<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zeral.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="EXPLAIN 简介 EXPLAIN 语句提供有关 MySQL 如何执行语句的信息，MySQL 解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。EXPLAIN 可以与 SELECT，DELETE，INSERT，REPLACE 和 UPDATE 语句一起使用。 在 EXPLAIN 的帮助下，您可以看到应该在表中添加索引的位置，以便通过使用索引查找行来使语句更快地执行。您还可">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL Explain 执行计划解释">
<meta property="og:url" content="https://www.zeral.cn/persistence/db/MySQL-Explain/index.html">
<meta property="og:site_name" content="Zeral&#39;s Blog">
<meta property="og:description" content="EXPLAIN 简介 EXPLAIN 语句提供有关 MySQL 如何执行语句的信息，MySQL 解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。EXPLAIN 可以与 SELECT，DELETE，INSERT，REPLACE 和 UPDATE 语句一起使用。 在 EXPLAIN 的帮助下，您可以看到应该在表中添加索引的位置，以便通过使用索引查找行来使语句更快地执行。您还可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zeral.cn/images/db/explain-left-deep.jpg">
<meta property="article:published_time" content="2020-05-18T07:51:00.000Z">
<meta property="article:modified_time" content="2021-05-19T06:22:52.458Z">
<meta property="article:author" content="Zeral">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="Explain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zeral.cn/images/db/explain-left-deep.jpg">

<link rel="canonical" href="https://www.zeral.cn/persistence/db/MySQL-Explain/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL Explain 执行计划解释 | Zeral's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zeral's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我思故我在</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zeral.cn/persistence/db/MySQL-Explain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/15558347?s=460&v=4">
      <meta itemprop="name" content="Zeral">
      <meta itemprop="description" content="Zeral, 全栈工程师一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeral's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL Explain 执行计划解释
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-18 15:51:00" itemprop="dateCreated datePublished" datetime="2020-05-18T15:51:00+08:00">2020-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-19 14:22:52" itemprop="dateModified" datetime="2021-05-19T14:22:52+08:00">2021-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categoriesv/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a>
                </span>
            </span>

          
            <span id="/persistence/db/MySQL-Explain/" class="post-meta-item leancloud_visitors" data-flag-title="MySQL Explain 执行计划解释" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="explain-简介"><a class="markdownIt-Anchor" href="#explain-简介"></a> EXPLAIN 简介</h2>
<p><code>EXPLAIN</code> 语句提供有关 MySQL 如何执行语句的信息，MySQL 解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。EXPLAIN 可以与 SELECT，DELETE，INSERT，REPLACE 和 UPDATE 语句一起使用。</p>
<p>在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 的帮助下，您可以看到应该在表中添加索引的位置，以便通过使用索引查找行来使语句更快地执行。您还可以使用 EXPLAIN 检查优化器是否以最佳顺序连接表。</p>
<blockquote>
<p>EXPLAIN 也可用于获取有关表中各列的信息。 EXPLAIN <em><strong>tbl_name</strong></em> 与 DESCRIBE <em><strong>tbl_name</strong></em> 和 SHOW COLUMNS FROM <em><strong>tbl_name</strong></em> 相同。</p>
</blockquote>
<span id="more"></span>
<p>以下示例中的表使用 MySQL <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">Sakila 示例数据库</a>。</p>
<p>EXPLAIN 的输出总是有相同的列。可变的是行数及内容。下表汇总这些列及它的简介，在接下来的小节中，我们将展示在 EXPLAIN 结果中每一列的意义。记住，输出中的行以 MySQL 实际执行的查询部分的顺序出现，而这个顺序不总是与其在原始 SQL 中的相一致。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Column</th>
<th style="text-align:left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id"><code>id</code></a></td>
<td style="text-align:left"><code>SELECT</code> 编号</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type"><code>select_type</code></a></td>
<td style="text-align:left"><code>SELECT</code> 类型</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table"><code>table</code></a></td>
<td style="text-align:left">该行的表名</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions"><code>partitions</code></a></td>
<td style="text-align:left">匹配的分区</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type"><code>type</code></a></td>
<td style="text-align:left">关联类型</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td>
<td style="text-align:left">可能用到的索引</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key"><code>key</code></a></td>
<td style="text-align:left">实际用到的索引</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len"><code>key_len</code></a></td>
<td style="text-align:left">实际用到索引的键长度</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref"><code>ref</code></a></td>
<td style="text-align:left">与索引进行比较的列名</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows"><code>rows</code></a></td>
<td style="text-align:left">估算要检查的行数</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered"><code>filtered</code></a></td>
<td style="text-align:left">按表条件过滤的行百分比</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra"><code>Extra</code></a></td>
<td style="text-align:left">附加信息</td>
</tr>
</tbody>
</table>
<h2 id="id-列"><a class="markdownIt-Anchor" href="#id-列"></a> id 列</h2>
<p>这一列总是包含一个编号，标识 SELECT 所属的行。如果在语句当中没有子査询或联合，那么只会有唯一的 SELECT，于是每一行在这个列中都将显示一个 1。否则，内层的 SELECT 语句一般会顺序编号，对应于其在原始语句中的位置。<br />
MYSQL 将 SELECT 査询分为简单和复杂类型，复杂类型可分成三大类：简单子査询、所谓的派生表(在 FROM 子句中的子査询)，以及 UNION 查询。下面是一个简单的子査询：</p>
<blockquote>
<p>id 的值代表 SELECT 在原 SQL 中的顺序，id 的顺序代表执行计划的顺序。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT (SELECT 1 FROM sakila.actor LIMIT 1) FROM sakila.film;</span></span><br><span class="line">+----+-------------+....</span><br><span class="line">| id | select_type |....</span><br><span class="line">+----+-------------+....</span><br><span class="line">|  1 | PRIMARY     |....</span><br><span class="line">|  2 | SUBQUERY    |....</span><br><span class="line">+----+-------------+....</span><br></pre></td></tr></table></figure>
<p>FROM 子句中的子査询和联合增加了 id 列的复杂性。下面是一个 FROM 子句中的基本子査询。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT film_id FROM (SELECT film_id from sakila.film LIMIT 10) as der;</span></span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">| id | select_type | table      |...</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; |...</span><br><span class="line">|  2 | DERIVED     | film       |...</span><br><span class="line">+----+-------------+------------+...</span><br></pre></td></tr></table></figure>
<p>如你所知，这个查询执行时有一个匿名临时表。 MySQL 内部通过别名（der）在外层查询中引用这个临时表，在更复杂的査询中可以看到 ref 列。</p>
<p>最后，下面是一个 UNION 查询：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT 1 UNION SELECT 1;</span></span><br><span class="line">+------+--------------+------------+...</span><br><span class="line">|  id  | select_type  | table      |...</span><br><span class="line">+------+--------------+------------+...</span><br><span class="line">|  1   | PRIMARY      | NULL       |...</span><br><span class="line">|  2   | UNION        | NULL       |...</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; |...</span><br><span class="line">+------+--------------+------------+...</span><br></pre></td></tr></table></figure>
<p>注意 UNION 结果输出中的额外行。 UNION 结果总是放在一个匿名临时表中，之后 MySQL 将结果读取到临时表外。临时表并不在原 SQL 中出现，因此它的 id 列是 NULL。与之前的例子相比（演示子査询的那个 FROM 子句中），从这个査询产生的临时表在结果中出现在最后一行，而不是第一行。</p>
<p>上面只是简单语句，但这三类语句的混合则会使输出变得非常复杂，后面我们会看到。</p>
<h2 id="select_type-列"><a class="markdownIt-Anchor" href="#select_type-列"></a> select_type 列</h2>
<p>这一列显示了对应行是简单还是复杂 SELECT（如果是后者，那么是三种复杂类型中的哪一种)。 可能的值如下：</p>
<h3 id="simple"><a class="markdownIt-Anchor" href="#simple"></a> <code>SIMPLE</code></h3>
<p>SIMPLE 值意味着查询不包括子査询和  UNION。</p>
<h3 id="primary"><a class="markdownIt-Anchor" href="#primary"></a> <code>PRIMARY</code></h3>
<p>如果査询有任何复杂的子部分，则最外层部分标记为 PRIMARY，其他部分标记如下。</p>
<h3 id="subquery"><a class="markdownIt-Anchor" href="#subquery"></a> <code>SUBQUERY</code></h3>
<p>包含在 SELECT 列表中的子査询中的 SELECT (换句话说，不在 FROM 子句中)标记为 SUBOUERY。</p>
<h3 id="derived"><a class="markdownIt-Anchor" href="#derived"></a> <code>DERIVED</code></h3>
<p>DERIVED 值用来表示包含在 FROM 子句的子査询中的 SELECT，MySQL 会递归执行并将结果放到一个临时表中。服务器内部称其“派生表”，因为该临时表是从子査询中派生来的。</p>
<h3 id="union"><a class="markdownIt-Anchor" href="#union"></a> <code>UNION</code></h3>
<p>在 UNION 中的第二个和随后的 SELECT 被标记为 UNION。</p>
<blockquote>
<p>UNION 和 UNION DISTINCT 同义，会删除重复行。UNION ALL 不会删除重复行。</p>
</blockquote>
<h3 id="union-result"><a class="markdownIt-Anchor" href="#union-result"></a> <code>UNION RESULT</code></h3>
<p>用来从 UNION 的匿名临时表检索结果的 SELECT 被标记为 UNION RESULT。</p>
<h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3>
<p>除了这些值，SUBQUERY 和 UNI0N 还可以被标记为 <code>DEPENDENT</code> 和 <code>UNCACHEABLE</code>。 DEPENDENT 意味着 SELECT 依赖于外层査询中发现的数据，UNCACHEABLE 意味着 SELECT 中的某些特性阻止结果被缓存于ー个 Item cache 中。（ Item cache 未被文档记载，它与査询缓存不是一回事，尽管它可以被一些相同类型的构件否定，例如 RAND() 函数。)</p>
<h2 id="table-列"><a class="markdownIt-Anchor" href="#table-列"></a> table 列</h2>
<p>这一列显示了对应行正在访问哪个表。在通常情况下，它相当明了：它就是那个表，或是该表的别名(如果 SQL 中定义了别名)。</p>
<p>可以在这一列中从上往下观察 MySQL 的关联优化器为査询选择的关联顺序。例如，可以看到在下面的査询中 MySQL 选择的关联顺序不同于语句中所指定的顺序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT film.film_id</span></span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor USING (actor_id);</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">| id | select_type | table      |...</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">|  1 | SIMPLE      | actor      |...</span><br><span class="line">|  1 | SIMPLE      | film_actor |...</span><br><span class="line">|  1 | SIMPLE      | film       |...</span><br><span class="line">+----+-------------+------------+...</span><br></pre></td></tr></table></figure>
<p>MySQL 的査询执行计划总是左侧深度优先树。如果把这个计划放倒，就能按顺序读出叶子节点，它们直接对应于 EXPLAIN 中的行。之前的査询计划看起来如图所示。</p>
<p><img src="../../../images/db/explain-left-deep.jpg" alt="left-deep" /></p>
<blockquote>
<p>在 SELECT 后加入指示 <code>STRAIGHT_JOIN</code> 会要求 Mysql 按指定顺序进行连接，但是这也会丧失自动优化的好处。</p>
</blockquote>
<h3 id="派生表和联合"><a class="markdownIt-Anchor" href="#派生表和联合"></a> 派生表和联合</h3>
<p>当 FROM 子句中有子査询或有 UNION 时，table 列会变得复杂得多。在这些场景下，确实没有一个“表”可以参考到，因为  MySQL 创建的匿名临时表仅在査询执行过程中存在。<br />
当在 FROM 子句中有子査询时，table 列是&lt;derived<em>N</em>&gt;的形式，其中 N 是子査询的 id。这总是“向前引用”一换言之，N 指向 EXPLAIN 输出中后面的一行。<br />
当有 UNION 时，UNION RESULT 的 table 列包含一个参与 UNION 的 id 列表。这总是“向后引用”，因为 UNION RESULT 出现在 UION 中所有参与行之后。如果在列表中有超过 20 个 id， table 列可能被截断以防止太长，此时不可能看到所有的值。幸运的是，仍然可以推测包括哪些行，因为你可以看到第一行的 id。在这一行和 UNION RESULT 之间出现的一切都会以某种方式被包含。</p>
<p>下面是一个无意义的査询，我们这里把它用作某种复杂 SELECT 类型的紧凑示例。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1   EXPLAIN</span><br><span class="line">2   SELECT actor_id,</span><br><span class="line">3          (SELECT 1 FROM sakila.film_actor WHERE film_actor.actor_id =</span><br><span class="line">4                                                 der_1.actor_id LIMIT 1)</span><br><span class="line">5   FROM (</span><br><span class="line">6       SELECT actor_id</span><br><span class="line">7       FROM sakila.actor LIMIT 5</span><br><span class="line">8   ) AS der_1</span><br><span class="line">9   UNION</span><br><span class="line">10  SELECT film_id,</span><br><span class="line">11         (SELECT @var1 FROM sakila.rental LIMIT 1)</span><br><span class="line">12  FROM (</span><br><span class="line">13      SELECT film_id,</span><br><span class="line">14             (SELECT 1 FROM sakila.store LIMIT 1)</span><br><span class="line">15      FROM sakila.film LIMIT 5</span><br><span class="line">16  ) AS der_2;</span><br></pre></td></tr></table></figure>
<p>下面是 EXPLAIN 的结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+------+----------------------+------------+...</span><br><span class="line">| id   | select_type          | table      |...</span><br><span class="line">+------+----------------------+------------+...</span><br><span class="line">|  1   | PRIMARY              | &lt;derived3&gt; |...</span><br><span class="line">|  3   | DERIVED              | actor      |...</span><br><span class="line">|  2   | DEPENDENT SUBQUERY   | film_actor |...</span><br><span class="line">|  4   | UNION                | &lt;derived6&gt; |...</span><br><span class="line">|  6   | DERIVED              | film       |...</span><br><span class="line">|  7   | SUBQUERY             | store      |...</span><br><span class="line">|  5   | UNCACHEABLE SUBQUERY | rental     |...</span><br><span class="line">| NULL | UNION RESULT         | &lt;union1,4&gt; |...</span><br><span class="line">+------+----------------------+------------+...</span><br></pre></td></tr></table></figure>
<h2 id="type-列"><a class="markdownIt-Anchor" href="#type-列"></a> type 列</h2>
<p>MySQL 用户手册上说这一列显示了“关联类型”，但我们认为更准确的说法是访问类型一一换言之就是 MySQL 决定如何查找表中的行。下面是最重要的访问方法，依次从最优到最差。</p>
<h3 id="null"><a class="markdownIt-Anchor" href="#null"></a> <code>NULL</code></h3>
<p>这种访问方式意味着 MySQL 能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。例如，从一个索引列里选取最小值可以通过单独查找索引来完成，不需要在执行时访问表。</p>
<h3 id="const-system"><a class="markdownIt-Anchor" href="#const-system"></a> <code>const, system</code></h3>
<p>当 MySQL 能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型。举例来说，如果你通过将某一行的主键放入 WHERE 子句里的方式来选取此行的主键，MySQL 就能把这个查询转换为一个常量。然后就可以高效地将表从联接执行中移除。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT * FROM sakila.film WHERE film_id = 1;</span>     </span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br><span class="line">| id | select_type | table | partitions | type  |...</span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br><span class="line">|  1 | SIMPLE      | film  | NULL       | const |...</span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br></pre></td></tr></table></figure>
<p><code>system</code>是 const 的特例，<strong>对应于系统表的数据过滤</strong>。</p>
<h3 id="eq_ref"><a class="markdownIt-Anchor" href="#eq_ref"></a> <code>eq_ref</code></h3>
<p>使用这种索引査找，MySQL 知道最多只返回一条符合条件的记录。这种访问方法可以在 MySQL 使用<strong>主键或者唯一性索引</strong>査找时看到，它会将它们与某个参考值做比较。MySQL 对于这类访问类型的优化做得非常好，因为它知道无须估计匹配行的范围或在找到匹配行后再继续査找。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN</span></span><br><span class="line">    -&gt; SELECT film.film_id</span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor USING (actor_id);</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br><span class="line">| id | select_type | table      | partitions | type   |...</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br><span class="line">|  1 | SIMPLE      | actor      | NULL       | index  |...</span><br><span class="line">|  1 | SIMPLE      | film_actor | NULL       | ref    |...</span><br><span class="line">|  1 | SIMPLE      | film       | NULL       | eq_ref |...</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br></pre></td></tr></table></figure>
<h3 id="ref"><a class="markdownIt-Anchor" href="#ref"></a> <code>ref</code></h3>
<p>这是一种索引访问(有时也叫做索引査找)，它返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，它是査找和扫描的混合体。此类索引访问只有当使用<strong>非唯一性索引或者唯一性索引的非唯一性前缀时</strong>オ会发生。把它叫做 ref 是因为索引要跟某个参考值相比较。这个参考值或者是一个常数，或者是来自多表査询前一个表里的结果值。</p>
<p>可以用于使用 = 或 &lt;=&gt; 运算符进行比较的索引列。</p>
<h3 id="ref_or_null"><a class="markdownIt-Anchor" href="#ref_or_null"></a> <code>ref_or_null</code></h3>
<p>这种连接类型类似于 ref，但是 MySQL 会额外搜索包含 NULL 值的行。此联接类型优化最常用于解析子查询。在以下示例中，MySQL 可以使用 ref_or_null 连接来处理 ref_table：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="operator">=</span> expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="range"><a class="markdownIt-Anchor" href="#range"></a> <code>range</code></h3>
<p>范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这比全索引扫描好一些，因为它用不着遍历全部索引。显而易见的范围扫描是带有 <code>BETWEEN</code> 或在 WHERE 子句里带有比较运算法（&lt;&gt;, &lt;=&gt;, &gt;, &gt;=, &lt;, &lt;=）的查询。当 MySQL 使用索引去査找一系列值时，例如 <code>IN()</code> 和 <code>OR</code> 列表，也会显示为范围扫描。<br />
然而，这两者其实是相当不同的访问类型，在性能上有重要的差异。</p>
<p>输出行中的 key 列表示使用了哪个索引。key_len 包含使用的最长的键部分。此类型的 ref 列为 NULL。</p>
<h3 id="index"><a class="markdownIt-Anchor" href="#index"></a> <code>index</code></h3>
<p>这个跟全表扫描一样，只是 MySQL 扫描表时按索引次序进行而不是行。它的主要优点是避免了排序；最大的缺点是要承担按索引次序读取整个表的开销。这通常意味着若是按随机次序访问行，开销将会非常大。<br />
如果在 Extra 列中看到 “Using index”，说明 MySQL 正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行。它比按索引次序全表扫描的开销要少很多。</p>
<h3 id="all"><a class="markdownIt-Anchor" href="#all"></a> <code>ALL</code></h3>
<p>这就是人们所称的全表扫描，通常意味着 MySQL 必须扫描整张表，从头到尾，去找到需要的行。(这里也有个例外，例如在査询里使用了 LIMIT，或者在 Extra 列中显示 “Using distinct/not exists”。)</p>
<h2 id="possible_keys-列"><a class="markdownIt-Anchor" href="#possible_keys-列"></a> possible_keys 列</h2>
<p>这一列显示了査询<strong>可以使用哪些索引</strong>，这是基于査询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早期创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。</p>
<h2 id="key-列"><a class="markdownIt-Anchor" href="#key-列"></a> key 列</h2>
<p>这一列显示了 MySQL <strong>决定采用哪个索引</strong>来优化对该表的访问。如果该索引没有出现在 possible_keys 列中，那么 MySQL 选用它是出于另外的原因一例如，它可能选择了个覆盖索引，哪怕没有 WHERE 子句。<br />
换句话说，possible keys 揭示了哪一个索引能有助于高效地行査找，而 key 显示的是优化采用哪一个索引可以最小化査询成本。下面就是一个例子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor \G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: idx_fk_film_id</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5462</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure>
<h2 id="key_len-列"><a class="markdownIt-Anchor" href="#key_len-列"></a> <code>key_len</code> 列</h2>
<p>该列显示了 MySQL 在索引里使用的字节数。如果 MySQL 正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列。要记住，MySQL5.5 及之前版本只能使用索引的最左前缀。举例来说，sakila.film_actor 的主键是两个 SMALLINT 列，并且每个 SMALLINT 列是两字节，那么索引中的每项是 4 字节。以下就是一个査询的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor WHERE actor_id=4;</span></span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br><span class="line">| id | select_type | table      | possible_keys          | key     | key_len |...</span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br><span class="line">|  1 | SIMPLE      | film_actor | PRIMARY,idx_fk_film_id | PRIMARY | 2       |...</span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br></pre></td></tr></table></figure>
<p>基于结果中的 key_len 列，可以推断出査询使用唯一的首列一 actor_id 列，来执行索引査找。当我们计算列的使用情况时，务必把字符列中的字符集也考虑进去。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE TABLE t</span></span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt;     a char(3) NOT NULL,</span><br><span class="line">    -&gt;     b int(11) NOT NULL,</span><br><span class="line">    -&gt;     c char(1) NOT NULL,</span><br><span class="line">    -&gt;     PRIMARY KEY (a, b, c)</span><br><span class="line">    -&gt; ) ENGINE = MYISAM</span><br><span class="line">    -&gt;   DEFAULT CHARSET = utf8;</span><br><span class="line">    </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO t(a, b, c)</span></span><br><span class="line">    -&gt; SELECT DISTINCT LEFT(TABLE_SCHEMA, 3), ORD(TABLE_NAME), LEFT(COLUMN_NAME, 1)</span><br><span class="line">    -&gt; FROM INFORMATION_SCHEMA.COLUMNS;</span><br><span class="line">    </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT a FROM t WHERE a = <span class="string">&#x27;sak&#x27;</span> AND b = 112;</span></span><br><span class="line">...+------+---------------+---------+---------+...</span><br><span class="line">...| type | possible_keys | key     | key_len |...</span><br><span class="line">...+------+---------------+---------+---------+...</span><br><span class="line">...| ref  | PRIMARY       | PRIMARY | 13      |...</span><br><span class="line">...+------+---------------+---------+---------+...</span><br></pre></td></tr></table></figure>
<p>这个査询中平均长度为 13 字节，即为 a 列和 b 列的总长度。a 列是 3 个字符，utf8 下每一个最多为 3 字节，而 b 列是一个 4 字节整型。则 key_len = 3*3 + 4；</p>
<p>key_len 列显示了在索引字段中可能的最大长度，而不是表中数据使用的实际字节数。<br />
在前面例子中 MySQL 总是显示 13 字节，即使 a 列恰巧只包含一个字符长度。换言之，key_len 通过査找表的定义而被计算出，而不是表中的数据。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td>char(n)：n 字节长度；varchar(n)：2 字节存储字符串长度</td>
<td>如果是 utf-8，则 n 字节变为 3n</td>
</tr>
<tr>
<td>数值类型</td>
<td>tinyint：1 字节；smallint：2 字节；int：4 字节；bigint：8 字节</td>
<td></td>
</tr>
<tr>
<td>时间类型</td>
<td>date：3 字节；timestamp：4 字节；datetime：8 字节</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ref-列"><a class="markdownIt-Anchor" href="#ref-列"></a> ref 列</h2>
<p>ref 列显示将哪些列或常量与 key 列中的列出的索引进行比较，以从表中选择行。下面是一个展示关联条件和别名组合的例子。注意，ref 列反映了在査询文本中 film 表是如何以 f 为别名的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN</span></span><br><span class="line">    -&gt; SELECT STRAIGHT_JOIN f.film_id</span><br><span class="line">    -&gt; FROM sakila.film AS f</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor AS fa</span><br><span class="line">    -&gt;              ON f.film_id = fa.film_id AND fa.actor_id = 1</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor AS a USING (actor_id);</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br><span class="line">...| table |...| key                | key_len | ref                    |...</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br><span class="line">...| f     |...| idx_fk_language_id | 1       | NULL                   |...</span><br><span class="line">...| fa    |...| PRIMARY            | 4       | const,sakila.f.film_id |...</span><br><span class="line">...| a     |...| PRIMARY            | 2       | const                  |...</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br></pre></td></tr></table></figure>
<h2 id="rows-列"><a class="markdownIt-Anchor" href="#rows-列"></a> rows 列</h2>
<p>rows 列表示 MySQL 认为执行查询必须检查的行数。这个数字是内嵌循环关联计划里的循环数目。也就是说它不是 MySQL 认为它最终要从表里读取出来的行数，而是 MySQL 为了找到符合査询的每一点上标谁的那些行而必须读取的行的平均数。（这个标准包括 SQL 里给定的条件，以及来自联接次序上前一个表的当前列。）</p>
<p>根据表的统计信息和索引的选用情况，这个估算可能很不精确。在有些版本里,它也反映不出 LIMIT 子句。举例来说，下面这个査询不会真的检査1000 行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select * from sakila.film <span class="built_in">limit</span> 1\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film</span><br><span class="line">            ...</span><br><span class="line">         rows: 1000</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure>
<p>通过把所有 rows 列的值相乘，可以粗略地估算出整个査询会检査的行数。例如，以下这个査询大约会检査 5400 行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN</span></span><br><span class="line">    -&gt; SELECT f.film_id</span><br><span class="line">    -&gt; FROM sakila.film AS f</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor AS fa USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor AS a USING (actor_id);</span><br><span class="line">...+------+...</span><br><span class="line">...| rows |...</span><br><span class="line">...+------+...</span><br><span class="line">...|  200 |...</span><br><span class="line">...|   27 |...</span><br><span class="line">...|    1 |...</span><br><span class="line">...+------+...</span><br></pre></td></tr></table></figure>
<p>要记住这个数字是 MySQL 认为它要检査的行数，而不是结果集里的行数。同时也要认识到有很多优化手段，例如关联缓冲区和缓存，无法影响到行数的显示。MySQL 可能不必真的读所有它估计到的行，它也不知道任何关于操作系统或硬件缓存的信息。</p>
<h2 id="partitions-filtered-列"><a class="markdownIt-Anchor" href="#partitions-filtered-列"></a> partitions、filtered 列</h2>
<p>partitions 表示所匹配的分区；</p>
<p>filtered 显示的是针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估算。最大值为100，这表示未对行进行过滤。值从 100 减小表示过滤量增加。rows 显示要检查的行的估计数，rows × filtered 显示与接下来的表连接的行数。例如，如果 rows 为1000，filtered 为 50.00（50％），则与下表连接的行数为1000×50％ = 500。</p>
<h2 id="extra-列"><a class="markdownIt-Anchor" href="#extra-列"></a> Extra 列</h2>
<p>这一列包含的是不适合在其他列显示的额外信息。 MySQL 用户手册里记录了大多数可以在这里出现的值。</p>
<p>常见的最重要的值如下：</p>
<h3 id="using-index"><a class="markdownIt-Anchor" href="#using-index"></a> ”<em>Using index</em>“</h3>
<p>此值表示 MySQL 将使用覆盖索引，以避免访问表。不要把覆盖索引和 index 访问类型弄混了。</p>
<p>表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表。</p>
<h3 id="using-where"><a class="markdownIt-Anchor" href="#using-where"></a> “<em>Using where</em>”</h3>
<p>这意味着 MySQL 服务器将在存储擎检索行后再进行过滤。许多 WHERE 条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带 WHERE 子句的査询都会显示 “Using where”。有时 “Using where” 的出现就是个暗示：査询可受益于不同的索引。</p>
<p>WHERE 子句用于限制要与下一个表匹配或发送给客户端的行。除非您特别打算从表中获取或检查<strong>所有行</strong>，否则，如果 Extra 值不是 Using where 并且表联接类型为 ALL 或 index，则查询中可能出现了问题。</p>
<h3 id="using-temporary"><a class="markdownIt-Anchor" href="#using-temporary"></a> “<em>Using temporary</em>”</h3>
<p>为了完成查询，MySQL 需要创建一个临时表来保存结果。如果查询包含以不同方式列出列的 <code>GROUP_BY</code> 和 <code>ORDER BY</code> 子句，通常会发生这种情况。</p>
<h3 id="using-filesort"><a class="markdownIt-Anchor" href="#using-filesort"></a> “<em>Using filesort</em>”</h3>
<p>这意味着 MySQL 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。 如果读取到的行数据于 sort_buffer_size 系统变量相比小，则在内存排序，相反内存不够或超过该变量，那么 MySQL 会先将数据分块，对每个独立的块使用 “快速排序” 进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。 EXPLAIN 不会告诉你 MySQL 将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。</p>
<h3 id="using-join-buffer"><a class="markdownIt-Anchor" href="#using-join-buffer"></a> “<em>Using join buffer</em>”</h3>
<p>Using join buffer 表示使用连接缓冲区的行提取匹配行。</p>
<p>内部细分可能包含：块级联循环算法（Block Nested-Loop），批量键访问算法（Batched Key Access），hash join。</p>
<h3 id="impossible-where"><a class="markdownIt-Anchor" href="#impossible-where"></a> “<em>Impossible where</em>”</h3>
<p>WHERE 子句始终为 false，无法选择任何行。</p>
<h3 id="select-tables-optimized-away"><a class="markdownIt-Anchor" href="#select-tables-optimized-away"></a> “<em>Select tables optimized away</em>”</h3>
<p>表示 SELECT 语句没有遍历表或者索引就返回数据了。</p>
<p>比如在优化阶段可以确定要读取的行（通过读取索引行），则在查询阶段无需读取任何表。如下面的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT MIN(film_id) FROM sakila.film;</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/ZeralZhang">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/Explain/" rel="tag"># Explain</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/java/Java-%E6%97%A5%E6%9C%9F%E7%B1%BB/" rel="prev" title="Java 日期类">
      <i class="fa fa-chevron-left"></i> Java 日期类
    </a></div>
      <div class="post-nav-item">
    <a href="/middleware/Elasticsearch%20%E5%85%A5%E9%97%A8/" rel="next" title="Elasticsearch 入门">
      Elasticsearch 入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#explain-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text"> EXPLAIN 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#id-%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text"> id 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select_type-%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text"> select_type 列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#simple"><span class="nav-number">3.1.</span> <span class="nav-text"> SIMPLE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#primary"><span class="nav-number">3.2.</span> <span class="nav-text"> PRIMARY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subquery"><span class="nav-number">3.3.</span> <span class="nav-text"> SUBQUERY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#derived"><span class="nav-number">3.4.</span> <span class="nav-text"> DERIVED</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union"><span class="nav-number">3.5.</span> <span class="nav-text"> UNION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union-result"><span class="nav-number">3.6.</span> <span class="nav-text"> UNION RESULT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">3.7.</span> <span class="nav-text"> 其它</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#table-%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text"> table 列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E8%A1%A8%E5%92%8C%E8%81%94%E5%90%88"><span class="nav-number">4.1.</span> <span class="nav-text"> 派生表和联合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text"> type 列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">5.1.</span> <span class="nav-text"> NULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-system"><span class="nav-number">5.2.</span> <span class="nav-text"> const, system</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eq_ref"><span class="nav-number">5.3.</span> <span class="nav-text"> eq_ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ref"><span class="nav-number">5.4.</span> <span class="nav-text"> ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ref_or_null"><span class="nav-number">5.5.</span> <span class="nav-text"> ref_or_null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#range"><span class="nav-number">5.6.</span> <span class="nav-text"> range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#index"><span class="nav-number">5.7.</span> <span class="nav-text"> index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#all"><span class="nav-number">5.8.</span> <span class="nav-text"> ALL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#possible_keys-%E5%88%97"><span class="nav-number">6.</span> <span class="nav-text"> possible_keys 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key-%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text"> key 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key_len-%E5%88%97"><span class="nav-number">8.</span> <span class="nav-text"> key_len 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-%E5%88%97"><span class="nav-number">9.</span> <span class="nav-text"> ref 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rows-%E5%88%97"><span class="nav-number">10.</span> <span class="nav-text"> rows 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#partitions-filtered-%E5%88%97"><span class="nav-number">11.</span> <span class="nav-text"> partitions、filtered 列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#extra-%E5%88%97"><span class="nav-number">12.</span> <span class="nav-text"> Extra 列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using-index"><span class="nav-number">12.1.</span> <span class="nav-text"> ”Using index“</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-where"><span class="nav-number">12.2.</span> <span class="nav-text"> “Using where”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-temporary"><span class="nav-number">12.3.</span> <span class="nav-text"> “Using temporary”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-filesort"><span class="nav-number">12.4.</span> <span class="nav-text"> “Using filesort”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-join-buffer"><span class="nav-number">12.5.</span> <span class="nav-text"> “Using join buffer”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#impossible-where"><span class="nav-number">12.6.</span> <span class="nav-text"> “Impossible where”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-tables-optimized-away"><span class="nav-number">12.7.</span> <span class="nav-text"> “Select tables optimized away”</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zeral"
      src="https://avatars3.githubusercontent.com/u/15558347?s=460&v=4">
  <p class="site-author-name" itemprop="name">Zeral</p>
  <div class="site-description" itemprop="description">Zeral, 全栈工程师一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zeral-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zeral-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="zeral:zeralzhang@gmail.com" title="E-Mail → zeral:zeralzhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ZeralZhang" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ZeralZhang" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeral</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"xscbbB5QhKlIenfLsvil037U-gzGzoHsz","app_key":"LLmCDfW8Pl0cKqCkjVJX6zL4","security":false,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b6f41cb44d3ba22c9361',
      clientSecret: '5867ad133bff941fada16af0e4bc81f939640f59',
      repo        : 'Zeral.github.io',
      owner       : 'Zeral-Zhang',
      admin       : ['Zeral-Zhang'],
      id          : '75f74beb00d2c12f15fe37b5dff7d8ad',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
