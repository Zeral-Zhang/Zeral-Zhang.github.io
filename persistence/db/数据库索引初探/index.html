<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zeral.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。 索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库索引初探">
<meta property="og:url" content="https://www.zeral.cn/persistence/db/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="Zeral&#39;s Blog">
<meta property="og:description" content="索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。 索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zeral.cn/images/db/b+tree_index.png">
<meta property="og:image" content="https://www.zeral.cn/images/db/tree_item.png">
<meta property="og:image" content="https://www.zeral.cn/images/db/clustered_index.png">
<meta property="og:image" content="https://www.zeral.cn/images/db/innodb_layout.png">
<meta property="og:image" content="https://www.zeral.cn/images/db/secondary_Indexes.png">
<meta property="article:published_time" content="2020-08-04T11:28:00.000Z">
<meta property="article:modified_time" content="2021-05-18T05:13:32.232Z">
<meta property="article:author" content="Zeral">
<meta property="article:tag" content="DB">
<meta property="article:tag" content="索引">
<meta property="article:tag" content="B+Tree">
<meta property="article:tag" content="B-Tree">
<meta property="article:tag" content="覆盖索引">
<meta property="article:tag" content="聚簇索引">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zeral.cn/images/db/b+tree_index.png">

<link rel="canonical" href="https://www.zeral.cn/persistence/db/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库索引初探 | Zeral's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zeral's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我思故我在</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zeral.cn/persistence/db/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/15558347?s=460&v=4">
      <meta itemprop="name" content="Zeral">
      <meta itemprop="description" content="Zeral, 全栈工程师一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeral's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库索引初探
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-04 19:28:00" itemprop="dateCreated datePublished" datetime="2020-08-04T19:28:00+08:00">2020-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-18 13:13:32" itemprop="dateModified" datetime="2021-05-18T13:13:32+08:00">2021-05-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categoriesv/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a>
                </span>
            </span>

          
            <span id="/persistence/db/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/" class="post-meta-item leancloud_visitors" data-flag-title="数据库索引初探" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。<br />
索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。</p>
<span id="more"></span>
<h1 id="索引的类型"><a class="markdownIt-Anchor" href="#索引的类型"></a> 索引的类型</h1>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。在 <code>MySQL</code> 中，案引是存储引擎层而不是服务器层实现的，所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<p>下面列举 <code>MySQL</code> 常见的索引类型，以及他们的优缺点。</p>
<h2 id="b-tree-索引"><a class="markdownIt-Anchor" href="#b-tree-索引"></a> B-Tree 索引</h2>
<p>当人们讨论索引的时候，如果没有特别指明类型，那多半说的是 B-Tree 索引，术语 <code>B-Tree</code> 并不特别指它的存储结构就是 <code>B-Tree</code>，<code>InnoDB</code> 使用的就是它的变种 <code>B+Tree</code>。</p>
<blockquote>
<p>B 树是二叉树的升级版，又叫平衡多路查找树，它的结点可以有很多子节点，二叉树最多只有 2 个子节点。</p>
<p>B+ 树是应文件系统所需而产生的一种 B 树的变形树，只有最底层的叶子节点保存数据，非叶子节点只保存索引，不保存实际的数据。</p>
<p>B+ 数中每个叶子节点都包含指向下一个叶子结点的顺序访问指针，方便叶子结点的范围遍历，节点的链接也方便了磁盘的顺序 IO。</p>
</blockquote>
<p><code>B-Tree</code> 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。下图展示了 <code>B-Tree</code> 索引的抽象表示，大致表示了 <code>InnoDB</code> 索引是如何工作的。</p>
<p><img src="../../../images/db/b+tree_index.png" alt="B+Tree 索引" /></p>
<p>B-Tree 索引能够加快访问数据的速度，因为存储引起不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根结点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。</p>
<p>叶子结点比较特别，他们的指针指向的是被索引的数据，而不是其它的节点页。下图绘制了一个节点和其对应的叶子节点，其实在根节点和叶子节点之间可能有很多层节点页，树的深度和表的大小直接相关。</p>
<p>**B-Tree 对索引列是顺序组织存储的，所以很适合范围查找数据。**例如，在一个基于文本域的索引树上，像“找出所有以 I 到 K 开头的名字”这样的查找效率会非常高。</p>
<p>假如有如下一张表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">    last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    dob <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender enum(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>表中的每一行数据，索引中包含了 last_name、first_name 和 dob 列中的值，下图展示了该索引是如何组织数据存储的。</p>
<p><img src="../../../images/db/tree_item.png" alt="索引树中的部分条目" /></p>
<p>请注意，**索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。**看一下最后两个条目，两个人的姓和名都一样，则根据他们的出生日期来排列顺序。</p>
<p>可以使用 B-Tree 索引的查询类型。 B-Tree 索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找，前面所述的索引对如下类型的查询有效。</p>
<p><em><strong>全值匹配</strong></em></p>
<p>全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen，出生于 1960-01-01 的人。</p>
<p><em><strong>匹配最左前缀</strong></em></p>
<p>前面提到的索引可用于查找所有姓为 Allen 的人，即只使用索引的第一列。</p>
<p><em><strong>匹配列前缀</strong></em></p>
<p>也可以只匹配某一列值的开头部分。例如前面提到的索引可用于查找所有以 J 开头的姓的人。这里也只使用索引的第一列。</p>
<p><em><strong>匹配范围值</strong></em></p>
<p>例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。</p>
<p><em><strong>精确匹配某一列并范围匹配另外一列</strong></em></p>
<p>前面提到的索引也可用于査找所有姓为 Allen，并且名字是字母 K 开头(比如 Kim、Karl 等)的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</p>
<p><em><strong>只访问索引的查询</strong></em></p>
<p>B-Tree 通常可以支持“只访问索引的査询”，即査询只需要访问索引，而无须访问数据行。后面我们将单独讨论这种“覆盖索引”的优化。</p>
<p>因为索引树中的节点是有序的，所以除了按值査找之外，索引还可以用于査询中的 <code>ORDER BY</code> 操作(按顺序査找)。一般来说，如果 <code>B-Tree</code> 可以按照某种方式査找到值，那么也可以按照这种方式用于排序。所以，如果 <code>ORDER BY</code> 子句满足前面列出的几种査询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于 B-Tree 索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始査找，则无法使用索引。例如上面例子中的索引无法用于査找名字为 Bill 的人，也无法査找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法査找姓氏以某个字母结尾的人。</li>
<li>不能跳过索引中的列。也就是说，前面所述的索无法用于査找姓为 Smith 并且在某个特定日期出生的人。如果不指定名 (first name)，则 MYSQL 只能使用索引的第一列。</li>
<li>如果査询中有某个列的范围査询，则其右边所有列都无法使用索引优化査找。例如有査询 <code>WHERE last name=' Smith' AND first name LIKE'1%' AND dob='1976 12-23'</code>，这个査询只能使用索引的前两列，因为这里 <code>LIKE</code> 是一个范围条件(但是服务器可以把其余列用于其他目的)。如果范围査询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。</li>
</ul>
<h3 id="为什么使用-b-tree-btree"><a class="markdownIt-Anchor" href="#为什么使用-b-tree-btree"></a> 为什么使用 B-Tree (B+Tree)</h3>
<p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析 B-/+Tree 作为索引的效率。</p>
<h4 id="局部性原理与磁盘预读"><a class="markdownIt-Anchor" href="#局部性原理与磁盘预读"></a> 局部性原理与磁盘预读</h4>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p><strong>当一个数据被用到时，其附近的数据也通常会马上被使用。</strong></p>
<p><strong>程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h4 id="b-tree-索引的性能分析"><a class="markdownIt-Anchor" href="#b-tree-索引的性能分析"></a> B-/+Tree 索引的性能分析</h4>
<p>从使用磁盘 I/O 次数评价索引结构的优劣性：根据 B-Tree 的定义，可知检索一次最多需要访问 h 个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，<strong>将一个结点的大小设为等于一个页面（默认 16 kb）</strong>，这样每个结点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。</p>
<p>**B-Tree 中一次检索最多需要 h-1 次 I/O（根结点常驻内存），渐进复杂度为 O(h)=O(log<sub>d</sub>N)。**一般实际应用中，出读 d 是非常大的数字，通常超过 100，因此 h 非常小。</p>
<p>综上所述，用 B-Tree 作为索引结构效率是非常高的。</p>
<p>而红黑树结构，h 明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的 I/O 渐进复杂度也为 O(h)，但是查找效率明显比 B-Tree 差得多。</p>
<h2 id="哈希索引"><a class="markdownIt-Anchor" href="#哈希索引"></a> 哈希索引</h2>
<p>哈希索引 (hash index) 基于哈希表实现，只有精确匹配索引所有列的査询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码 (hash code)，哈希码是个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>因为索自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引査找的速度非常快。然而，哈希索引也有它的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配査找，因为哈希索始终是使用索引列的全部内容来计算哈希值的。例如，在数据列 (A,B) 上建立哈希索引，如果査询只有数据列 A，则无法使用该索引。</li>
<li>哈希索引只支持等值比较査询，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>(注意 <code>&lt;&gt;</code> 和 <code>&lt;=&gt;</code> 是不同的操作，该操作是 NULL-safe equals)。也不支持任何范围査询，例如 <code>WHERE price&gt;100</code>。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。当出现哈希冲突的时候，存储引檠必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<p>InnoDB 引擎有一个特殊的功能叫做“<strong>自适应哈希索引 (adaptive hash index)</strong>”。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希査找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。</p>
<p>**创建自定义哈希索引。**如果我们即想使用 B-Tree 的优势，又想使用哈希索引增加速度，可以创建一个单独的列来存放数据的伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用 B-Tree 进行查找，但是它使用哈希值而不是键本身进行索引査找。你需要做的就是在査询的 WHERE 子句中手动指定使用哈希函数。</p>
<p>如果采用这种方式，不要使用 <code>SHA1()</code> 或 <code>MD5()</code> 这种哈希函数，因为他们计算出的哈希值会非常长，浪费空间。它们设计目标是最大程度消除冲突，如果我们的数据量不是特别大，可以使用 <code>CRC32()</code> 这样的函数或者自己编写哈希函数，最简单的就是取前面这种强哈希函数的一部分。CRC32() 返回的是 32 位的整数,当索引有 93000 条记录时出现冲突的概率是 1%。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONV(RIGH(MD5(<span class="string">&#x27;HTTP://www.mysql.com/&#x27;</span>),<span class="number">16</span>),<span class="number">16</span>,<span class="number">10</span>)<span class="keyword">AS</span> HASH64</span><br></pre></td></tr></table></figure>
<h2 id="空间数据索引r-tree"><a class="markdownIt-Anchor" href="#空间数据索引r-tree"></a> 空间数据索引（R-Tree）</h2>
<p><code>MYISAM</code> 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无须前缀査询。空间索引会从所有维度来索引数据。査询时，可以有效地使用任意维度来组合查询。必须使用 MYSQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。 MYSQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对 GIS 的解决方案做得比较好的是 Postgresql 的 POSTGIS。</p>
<h2 id="全文索引"><a class="markdownIt-Anchor" href="#全文索引"></a> 全文索引</h2>
<p>全文索引是一种特殊类型的索引，它査找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的 WHERE 条件匹配。<br />
在相同的列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突，全文索引适用于 MATCH AGAINST 操作,而不是普通的 WHERE 条件操作。</p>
<h1 id="索引的优点"><a class="markdownIt-Anchor" href="#索引的优点"></a> 索引的优点</h1>
<p>索引可以让服务器快速地定位到表的指定位置。但是这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。<br />
最常见的 <code>B-Tree</code> 索引，按照顺序存储数据，所以 MYSQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些査询只使用索引就能够完成全部査询。据此特性，总结下来索引有如下三个优点:</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
</ol>
<h1 id="高性能索引策略"><a class="markdownIt-Anchor" href="#高性能索引策略"></a> 高性能索引策略</h1>
<h2 id="独立的列"><a class="markdownIt-Anchor" href="#独立的列"></a> 独立的列</h2>
<p>我们通常会看到一些查询不当地使用索引，或者使得 MYSQL 无法使用已有的索引。如果查询中的列不是独立的，则 MYSQL 就不会使用索引。<strong>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</strong></p>
<h2 id="前缀索引和索引选择性"><a class="markdownIt-Anchor" href="#前缀索引和索引选择性"></a> 前缀索引和索引选择性</h2>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的<strong>模拟哈希索引</strong>。但有时候这样做还不够，还可以做些什么呢？</p>
<p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**索引的选择性是指，不重复的索引值（也称为基数, cardinality）和数据表的记录总数（#T）的比值,范围从 1/#T 到 1 之间。**索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MYSQL 在查找时过滤掉更多的行唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。<br />
一般情况下某个列前缀的选择性也是足够高的，足以满足査询性能。对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MYSQL 不允许索引这些列的完整长度。<br />
<strong>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长(以便节约空间)。</strong></p>
<blockquote>
<p>有时侯后缀索引(suffix index)也有用途(例如，找到某个域名的所有电子邮件地址)。 <strong>MYSQL 原生并不支持反向索引</strong>，但是可以把字符串反转后存储，并基于此建立前缀索引。</p>
</blockquote>
<h2 id="多列索引"><a class="markdownIt-Anchor" href="#多列索引"></a> 多列索引</h2>
<p><strong>在多个列上建立独立的单列索引大部分情况下并不能提高 MYSQL 的査询性能。</strong> <strong>MYSQL 5.0 和更新版本引入了一种叫“索引合并”(index merge)的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。更早版本的 MYSQL 只能使用其中某一个单列索引。</strong></p>
<h2 id="选择合适的索引列顺序"><a class="markdownIt-Anchor" href="#选择合适的索引列顺序"></a> 选择合适的索引列顺序</h2>
<p>**对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。**这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机 IO 和排序那么重要，考虑问题需要更全面(场景不同则选择不同，没有一个放之四海皆准的法则。这里只是说明,，这个经验法则可能没有你想象的重要)。</p>
<p>如果是从诸如 <code>pt-gery-digest</code> 这样的工具的报告中提取“最差”査询，那么再按上述办法选定的索引顺序往往是非常高效的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest --processlist h=192.168.10.11,u=root,p=root --interval=0.01 --output slowlog &gt; slowsql.log</span><br></pre></td></tr></table></figure>
<p><strong>尽可能将需要做范围査询的列放到索引的后面，以便优化器能使用尽可能多的索引列来进行最左匹配。</strong></p>
<h2 id="聚簇索引"><a class="markdownIt-Anchor" href="#聚簇索引"></a> 聚簇索引</h2>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，**但 <code>InnoDB</code> 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。**索引和数据存入同一个 .idb 文件中。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中，索引列包含的是整数值。</p>
<p><img src="../../../images/db/clustered_index.png" alt="Clustered index" /></p>
<p><strong>InnoDB 将通过主键聚集数椐</strong>，这也就是上图中的“被索引的列”就是主键列。</p>
<blockquote>
<p>默认情况下 Innodb 会使用定义的主键来作为聚簇索引，没有主键的话会使用所有列都不为空的第一个唯一索引，再没有的话会生成一个隐藏的基于行 ID 的聚簇索引，行 ID 就是插入顺序。</p>
</blockquote>
<p>聚集的数据有一些重要的优点：</p>
<ul>
<li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中査找要快。</li>
<li>使用覆盖索引扫描的査询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了 I/O 密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插人速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 <code>OPTIMIZE TABLE</code> 命令重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时侯。</li>
<li>**<u>二级索引(非聚簇索引)</u>**可能比想象的要更大，因为在二级索引中既包含了为其指定的列，索引的叶子节点还包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引査找，而不是一次。</li>
</ul>
<p>最后一点可能让人有些疑惑，为什么二级索引需要两次索引査找？答案在于二级索引中保存的“行指针”的实质。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</p>
<p><strong>这意味着通过二级索引査找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中査找到对应的行。这里做了重复的工作：两次 B-Tree 査找而不是一次。对于 InnoDB，自适应哈希索能够减少这样的重复工作。这就是所谓的“回表查询”。也就是说聚簇索引叶子结点存放主键和数据，非聚簇索引（其它索引）叶子结点存放的是引用行的主键列而非数据的指针。</strong></p>
<h3 id="innodb-数据分布"><a class="markdownIt-Anchor" href="#innodb-数据分布"></a> InnoDB 数据分布</h3>
<p>假设有如下表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout test (</span><br><span class="line">	col1 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col2 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(CO11),</span><br><span class="line">  KEY(CO12)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>假设该表的主键取值为 1~10000，按照随机顺序插入并使用 OPTIMIZE TABLE 命令做了优化。换句话说，数据在磁盘上的存储方式已经最优，但行的顺序是随机的。列 coL2 的值是从 1~100 之间随机赋值，所以有很多重复的值。</p>
<p>InnoDB 的数据分布。因为 InnoDB 支持聚簇索引，所以使用非常不同的方式存储同样的数据。 InnoDB 以如图所示的方式存储数据。</p>
<p><img src="../../../images/db/innodb_layout.png" alt="InnoDB layout" /></p>
<p>聚簇索引的每一个叶子节点都包含了主键值、事务 ID、用于事务和 MVCC 的回滚指针以及所有的剩余列 (在这个例子中是 coL2)。如果主键是一个列前缀索引, InnoDB 也会包含完整的主键列和剩下的其他列。</p>
<p>InnoDB 二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><strong>上图展示了 B-Tree 的聚簇索引的叶子节点结构</strong>，<strong>下图是非叶子节点</strong>，它包含了索引列和一个指向下级节点的指针（下一级节点可以是非叶子节点，也可以是叶子节点）。这对聚簇索引和二级索引都适用。</p>
<p><img src="../../../images/db/secondary_Indexes.png" alt="Secondary Indexes" /></p>
<h3 id="在-innodb-表中按主键顺序插入行"><a class="markdownIt-Anchor" href="#在-innodb-表中按主键顺序插入行"></a> 在 InnoDB 表中按主键顺序插入行</h3>
<p><strong>在 Mysql 中最简单的就是使用自增的主键列，这样可以保证行按顺序写入，对于根据主键做关联操作的性能也会更好。</strong></p>
<p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于 I/O 密集型的应用。例如，<strong><u>从性能的角度考虑，使用 UUID 来作为聚簇索引则会很糟糕：它使得聚簇索引的插人变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</u></strong></p>
<p>缺点如下：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机 I/O。</li>
<li>因为写入是乱序的，InnoDB 不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。</li>
</ul>
<h2 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引"></a> 覆盖索引</h2>
<p>索引确实是一种査找数据的高效方式，但是 MYSQL 也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含要査询的数据，那么还有什么必要再回表査询呢？<strong>如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称之为“覆盖索引”。</strong></p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果査询只需要扫描索引而无须回表，会带来多少好处：</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那 MYSQL 就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于 IO 密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中。</li>
<li>因为索引是按照列值顺序存储的(至少在单个页内是如此)，所以对于 I/O 密集型的范围査询会比随机从磁盘读取每一行数据的 I/O 要少得多。对于某些存储引擎，例如 <code>MyISAM</code> 和 <code>Percona Xtradb</code>，甚至可以通过 <code>OPTIMIZE</code> 命令使得索引完全顺序排列，这让简单的范围查询能使用完全顺序的索引访问。</li>
<li>一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。</li>
<li>由于 InnoDB 的聚簇索引，覆盖索引对 InnoDB 表特别有用。 InnoDB 的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖査询，则可以避免对主键索引的二次查询。</li>
</ul>
<p>不是所有类型的索引都可以成为覆盖索引。<strong>覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引副等都不存储索引列的值,所以 MySQL 只能使用 B-Tree 索引做覆盖索引。</strong></p>
<p>当发起一个**被索引覆盖的査询(也叫做索引覆盖査询)**时，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>“Using index”</code> 的信息。</p>
<p>对于部分需要查询不包含所有索引的字段时，我们可以通过**<u>延迟关联（deferred join</u>）**来利用覆盖索引的优势。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> products</span><br><span class="line">	  <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">JOIN</span> ( </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>	     <span class="keyword">SELECT</span> prod_id </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>       <span class="keyword">FROM</span> product </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>	     <span class="keyword">WHERE</span> actor <span class="operator">=</span> <span class="string">&#x27;SEAN_CARREY&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%APOLLO%&#x27;</span> </span><br><span class="line">	  <span class="operator">-</span><span class="operator">&gt;</span>     ) <span class="keyword">AS</span> t1 <span class="keyword">ON</span> ( t1.prod_id <span class="operator">=</span> products.prod_id );</span><br></pre></td></tr></table></figure>
<p>在 prod_id 和 actor 上我们设置了索引，在查询的一阶段 Mysql 可以使用覆盖索引，从子查询中先找到符合条件的 prod_id，然后根据 prod_id 值在外层查询匹配所有需要的列值。这样优化的效果取决于 WHERE 条件匹配的行数，匹配的行数越多且使用到索引越多越优化。</p>
<p>在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的査询。不过，可以更进一步优化 InnoDB。<strong>回想一下，InnoDB 的二级索引的叶子节点都包含了主键的值，这意味着 InnoDB 的二级索引可以有效地利用这些“额外”的主键列来覆盖査询。</strong><br />
例如， sakila.actor 使用 InnoDB 存储引擎，并在 last_name 字段有二级索引，虽然该索引的列不包括主键 actor_id，但也能够用于对 actor_id 做覆盖査询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id, last_name <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> last_name <span class="operator">=</span><span class="string">&#x27;HOPPER&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">           id: <span class="number">1</span> </span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">type</span>: SIMPLE </span><br><span class="line">        <span class="keyword">table</span>: actor </span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span> </span><br><span class="line">possible_keys: idx_actor_last_name</span><br><span class="line">          key: idx_actor_last_name</span><br><span class="line">          key_len: <span class="number">137</span> </span><br><span class="line">          <span class="keyword">ref</span>: const </span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">2</span> </span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">index</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面提到的很多限制都是由于存储引擎 API 设计所导致的。 <strong>MySQL 5.6 版本引入了 “索引条件推送(index condition pushdown)” 将过滤条件传到存储引擎层，可以减少传递到服务器层的数据量，这个优化默认开启。</strong></p>
</blockquote>
<h2 id="使用索引扫描来做排序"><a class="markdownIt-Anchor" href="#使用索引扫描来做排序"></a> 使用索引扫描来做排序</h2>
<p>MySQL 有两种方式可以生成有序的结果；通过排序操作，或者按索引顺序扫描，<strong>如果 <code>EXPLAIN</code> 出来的 <code>type</code> 列的值为 <code>“index”</code>，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）</strong>。</p>
<p><strong>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL 才能够使用索引来对结果做排序。如果査询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。</strong><br />
ORDER BY 子句和查找型査询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL 都需要执行排序操作，而无法利用索引排序。</p>
<p>有一种情况下 ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果 WHERE 子句或者 J0IN 子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>
<p>例如， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">Sakila 示例数据库的表</a> rental 在列 (rental_date, Inventory_id, customer_id) 上有名为 rental_date 的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>				 <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>			   <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
<p>MYSQL 可以使用 rental_date 索引为下面的査询做排序，从 EXPLAIN 中可以看到没有出现文件排序 (Using filesort) 操作；</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">				 type: ref </span><br><span class="line">possible keys: rental_date </span><br><span class="line">					key: rental_date </span><br><span class="line">				 rows: <span class="number">1</span> </span><br><span class="line">				Extra: Using where</span><br></pre></td></tr></table></figure>
<p>下面是一些不能使用索引做排序的查询：</p>
<ul>
<li>
<p>下面这个查询使用了两种不同的排序方向，但是索引列都是正序排序的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>, customer_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询的 ORDER BY 子句中引用了一个不在索引中的列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, staff_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询的 WHERE 和 ORDER BY 中的列无法组合成索引的最左前缀：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询在索引列的第一列上是范围条件，所以 MYSQL 无法使用索引的其余列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个査询在 inventory_id 列上有多个等于条件。对于排序来说，这也是一种范围查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">AND</span> inventory_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面这个例子理论上是可以使用索引进行关联排序的，但由于优化器在优化时将 file_actor 表当作关联的第二张表，所以实际上无法使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id, title <span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.film <span class="keyword">USING</span>(film_id ) <span class="keyword">ORDER</span> <span class="keyword">BY</span> actor_id;</span><br></pre></td></tr></table></figure>
<h2 id="冗余和重复索引"><a class="markdownIt-Anchor" href="#冗余和重复索引"></a> 冗余和重复索引</h2>
<p>MySQL 允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL 需要单独维护重复的索引，并且优化器在优化査询的时侯也需要逐个地进行考虑，这会影响性能。</p>
<p>冗余索引和重复索引有一些不同。如果创建了索引(A)，再创建索引(A,B)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当作索引(A)来使用(这种冗余只是对 B-Tree 索引来说的)。但是如果再创建索引(B,A)，则不是冗余索引，索引(B) 也不是，因为B不是索引(A,B)的最左前缀列。另外，其他不同类型的索引(例如哈希索引或者全文索引)也不会是 B-Tree 索引的冗余索引，无论覆盖的索引列是什么。</p>
<p>解决冗余索引和重复索引的方法很简单，删除这些索引就可以，但首先要做的是找出这样的索引。Percona Tookit 中的 <code>pt-duplicate-key-checker</code> 可以帮我们分析表结构找出冗余和重复的索引。</p>
<h2 id="未使用的索引"><a class="markdownIt-Anchor" href="#未使用的索引"></a> 未使用的索引</h2>
<p>这样的索引完全是累赘，建议考虑删除。</p>
<p>定位未使用的索引最简单有效的办法是在 Percona Server 或者 MariaDB 中先打开 User statistics 服务器变量，</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> userstat<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后让服务正常运行一段时间，再通过 INFOMATION_SCHEMA.INDEX_STATISTICS 就能查到每个索引的使用频率。</p>
<p>另外，还可以使用 Percona Toolkit 中的 <code>pt-index-usage</code>，该工具可以读取査询日志，并对日志中的每条査询进行 EXPLAIN 操作，然后打印出关于索引和查询的报告。这个工具不仅可以找出哪些索引是未使用的，还可以了解査询的执行计划一一例如在某些情况有些类似的査询的执行方式不一样，这可以帮助你定位到那些偶尔服务质量差的査询，优化它们以得到一致的性能表现。该工具也可以将结果写入到  MYSQL 的表中，方便查询结果。</p>
<h2 id="索引和锁"><a class="markdownIt-Anchor" href="#索引和锁"></a> 索引和锁</h2>
<p>索引可以让査询锁定更少的行。如果你的査询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然 InnoDB 的行锁效率很高，内存使用也很少，但是锁定行的时侯仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。但这只有当 InnoDB 在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在 InnoDB 检索到数据并返回给服务器层以后，MySQL 服务器才能应用 WHERE 子句。这时已经无法避免锁定行了：InnoDB 已经锁住了这些行，到适当的时候オ释放。在 MySQL5.1 和更新的版本中，InnoDB 可以在服务器端过滤掉行后就释放锁，但是在早期的 MYSQL 版本中, InnoDB 只有在事务提交后オ能释放锁。</p>
<p>通过下面的例子再次使用数据库 Sakila 很好地解释了这些情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id<span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| actor_id |</span><br><span class="line">+----------+</span><br><span class="line">|        2 |</span><br><span class="line">|        3 |</span><br><span class="line">|        4 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<p>这条査询仅仅会返回 2-4 之间的行，但是实际上获取了 1~4 之间的行的排他锁。InnoDB 会锁住第 1 行，这是因为 MySQL 为该查询选择的执行计划是索引范围扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br><span class="line">| id | select_type | table | type  | key     | Extra                    | </span><br><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br><span class="line">|  1 | SIMPLE      | actor | range | PRIMARY | Using where; Using index | </span><br><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br></pre></td></tr></table></figure>
<p>换句话说，底层存储引擎的操作是“从索引的开头开始获取满足条件 actor_id&lt;5 的记录”，服务器并没有告诉 InnoDB 可以过滤第 1 行的  WHERE 条件。注意到 EXPLAIN 的 Extra 列出现了“Using where”，这表示 MySQL 服务器将存储引擎返回行以后再应用 WHERE 过滤条件。</p>
<p>下面的第二个査询就能证明第 1 行确实已经被锁定，尽管第一个査询的结果中并没有这个第 1 行。保持第一个连接打开，然后开启第二个连接并执行如下査询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<p>这个查询将会挂起，直到第一个事务释放第 1 行的锁。</p>
<p>关于 InnoDB、索引和锁有一些很少有人知道的细节：InnoDB 在二级索引上使用共享(读)锁，但访问主键索引需要排他(写)锁。这消除了使用覆盖索引的可能性，并且使得 SELECT FOR UPDATE 比 L0CK IN SHARE MODE 或非锁定査询要慢很多。</p>
<h2 id="避免多个范围条件"><a class="markdownIt-Anchor" href="#避免多个范围条件"></a> 避免多个范围条件</h2>
<p>EXPLAIN 输出中 type 为 range 的代表范围查询，比如下面这种查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">&gt;</span> <span class="number">45</span>;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span><span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">				 id: <span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> type: SIMPLE </span><br><span class="line">			<span class="keyword">table</span>: actor </span><br><span class="line">			 type: <span class="keyword">range</span></span><br></pre></td></tr></table></figure>
<p>但是下面这条查询呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">99</span>);</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span><span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">				 id: <span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> type: SIMPLE </span><br><span class="line">			<span class="keyword">table</span>: actor </span><br><span class="line">			 type: <span class="keyword">range</span></span><br></pre></td></tr></table></figure>
<p>从 EXPLAIN 的结果是无法区分这两者的，但可以从值的范围和多个等于条件来得出不同。在我们看来，第二个查询就是多个等値条件查询。<br />
我们不是挑剔：这两种访问效率是不同的。对于范围条件查询，MySQL 无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询”则没有这个限制。</p>
<h2 id="更新索引统计信息"><a class="markdownIt-Anchor" href="#更新索引统计信息"></a> 更新索引统计信息</h2>
<p>可以使用 <code>SHOW INDEX FROM</code> 命令来査看索引的基数(Cardinality)。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW INDEX FROM sakila.actor;</span></span><br><span class="line">******************* 1.row *******************</span><br><span class="line">	  	 Table: actor </span><br><span class="line">  Non_unique: 0 </span><br><span class="line">    Key_name: PRIMARY </span><br><span class="line">Seq_in_index: 1 </span><br><span class="line"> Column_name: actor_id </span><br><span class="line">   Collation: A </span><br><span class="line"> Cardinality: 200 </span><br><span class="line">    Sub_part: NULL </span><br><span class="line">      Packed: NULL </span><br><span class="line">        Null:</span><br><span class="line">  Index_type: BTREE</span><br><span class="line">     Comment:</span><br></pre></td></tr></table></figure>
<p>这里需要特别提及的是索引列的<strong>基数(Cardinality)</strong>，<strong>其显示了存储引擎估算索引列有多少个不同的取值</strong>。引擎估算索引列有多少个不同的取值。在 MySQL5.0 和更新的版本中，还可以通过 <code>INFORMATION_SCHEMA.STATISTICS</code> 表很方便地査询到这些信息。</p>
<p>InnoDB 会在表首次打开，或者执行 <code>ANALYZE TABLE</code>，抑或表的大小发生非常大的变化(大小变化超过十六分之一或者新插入了 20 亿行都会触发)的时候计算索引的统计信息。</p>
<p>InnoDB 在打开某些 INFORMATION_SCHEMA 表，或者使用 SHOW TABLE STATUS 和 SHOW INDEX，抑或在 MYSQL 客户端开启自动补全功能的时侯都会触发索引统计信息的更新。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>在 MySQL 中，大多数情况下都会使用 B-Tree 索引。其他类型的索引大多只适用于特殊的目的。如果在合适的场景中使用索引，将大大提高査询的响应时间。本章将不再介绍更多这方面的内容了，最后值得总的回顾一下这些特性以及如何使用 B-Tree 索引。<br />
在选择索引和编写利用这些索引的査询时，有如下三个原则始终需要记住：</p>
<ol>
<li>单行访问是很慢的。特别是在机械硬盘存储中(SSD 的随机 I/O 要快很多，不过这点仍然成立)。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 IO 不需要多次磁盘寻道，所以比随机 I/O 要快很多(特别是对机械硬盘)。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且 GROUP BY 查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖査询是很快的。如果一个索引包含了査询需要的所有列，那么存储引擎就不需要再回表査找行。这避免了大量的单行访向，而上面的第 1 点已经写明单行访问是很慢的。</li>
</ol>
<p>**那如何判断一个系统创建的索引是合理的呢？**一般来说，我们建议按响应时间来对査询进行分析。找出那些消耗最长时间的査询或者那些给服务器带来最大压力的査询，然后检査这些査询的 schema、SQL 和索引结构，判断是否有査询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用随机 I/O 访问数据，或者是有太多回表査询那些不在索引中的列的操作。</p>
<p>如果仍然想找到那些索引不是很合适的査询并在它们成为问题前进行优化，则可以使用 <code>pt-query-digest</code> 的查询审査“review’”功能，分析其 EXPLAIN 出来的执行计划。</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/ZeralZhang">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/DB/" rel="tag"># DB</a>
              <a href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag"># 索引</a>
              <a href="/tags/B-Tree/" rel="tag"># B+Tree</a>
              <a href="/tags/B-Tree/" rel="tag"># B-Tree</a>
              <a href="/tags/%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95/" rel="tag"># 覆盖索引</a>
              <a href="/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/" rel="tag"># 聚簇索引</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/java/Java-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" rel="prev" title="Java 内存泄漏">
      <i class="fa fa-chevron-left"></i> Java 内存泄漏
    </a></div>
      <div class="post-nav-item">
    <a href="/concurrency/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" rel="next" title="Java 并发编程入门">
      Java 并发编程入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text"> 索引的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#b-tree-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.</span> <span class="nav-text"> B-Tree 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-b-tree-btree"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 为什么使用 B-Tree (B+Tree)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB"><span class="nav-number">1.1.1.1.</span> <span class="nav-text"> 局部性原理与磁盘预读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-tree-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">1.1.1.2.</span> <span class="nav-text"> B-&#x2F;+Tree 索引的性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.</span> <span class="nav-text"> 哈希索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95r-tree"><span class="nav-number">1.3.</span> <span class="nav-text"> 空间数据索引（R-Tree）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="nav-number">1.4.</span> <span class="nav-text"> 全文索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text"> 索引的优点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text"> 高性能索引策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97"><span class="nav-number">3.1.</span> <span class="nav-text"> 独立的列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text"> 前缀索引和索引选择性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.</span> <span class="nav-text"> 多列索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.4.</span> <span class="nav-text"> 选择合适的索引列顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.5.</span> <span class="nav-text"> 聚簇索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#innodb-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83"><span class="nav-number">3.5.1.</span> <span class="nav-text"> InnoDB 数据分布</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-innodb-%E8%A1%A8%E4%B8%AD%E6%8C%89%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E8%A1%8C"><span class="nav-number">3.5.2.</span> <span class="nav-text"> 在 InnoDB 表中按主键顺序插入行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">3.6.</span> <span class="nav-text"> 覆盖索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E6%9D%A5%E5%81%9A%E6%8E%92%E5%BA%8F"><span class="nav-number">3.7.</span> <span class="nav-text"> 使用索引扫描来做排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%97%E4%BD%99%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="nav-number">3.8.</span> <span class="nav-text"> 冗余和重复索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.9.</span> <span class="nav-text"> 未使用的索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E9%94%81"><span class="nav-number">3.10.</span> <span class="nav-text"> 索引和锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%A4%9A%E4%B8%AA%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.11.</span> <span class="nav-text"> 避免多个范围条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="nav-number">3.12.</span> <span class="nav-text"> 更新索引统计信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text"> 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zeral"
      src="https://avatars3.githubusercontent.com/u/15558347?s=460&v=4">
  <p class="site-author-name" itemprop="name">Zeral</p>
  <div class="site-description" itemprop="description">Zeral, 全栈工程师一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zeral-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zeral-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="zeral:zeralzhang@gmail.com" title="E-Mail → zeral:zeralzhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ZeralZhang" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ZeralZhang" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeral</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"xscbbB5QhKlIenfLsvil037U-gzGzoHsz","app_key":"LLmCDfW8Pl0cKqCkjVJX6zL4","security":false,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b6f41cb44d3ba22c9361',
      clientSecret: '5867ad133bff941fada16af0e4bc81f939640f59',
      repo        : 'Zeral.github.io',
      owner       : 'Zeral-Zhang',
      admin       : ['Zeral-Zhang'],
      id          : '9b448c3269372f16ec652c098b4ef01c',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
