<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zeral.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java 面试问题整理 [TOC]  Java 程序如何做到一次编写，到处运行 java 代码源文件经过 javac 编译期编译为 .class 文件，.class 文件不包含处理器本机代码，而是包含字节码 - JVM 的机器语言。启动器使用虚拟机运行程序。  由于 JVM 可在许多不同的操作系统上使用，因此相同的 .class 文件可以在不同系统上运行。  JDK 和 JRE 的区别 JRE(">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理">
<meta property="og:url" content="https://www.zeral.cn/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="Zeral&#39;s Blog">
<meta property="og:description" content="Java 面试问题整理 [TOC]  Java 程序如何做到一次编写，到处运行 java 代码源文件经过 javac 编译期编译为 .class 文件，.class 文件不包含处理器本机代码，而是包含字节码 - JVM 的机器语言。启动器使用虚拟机运行程序。  由于 JVM 可在许多不同的操作系统上使用，因此相同的 .class 文件可以在不同系统上运行。  JDK 和 JRE 的区别 JRE(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zeral.cn/images/java/getStarted-compiler.gif">
<meta property="og:image" content="https://www.zeral.cn/images/message/kafka/data-copying.gif">
<meta property="og:image" content="https://www.zeral.cn/images/message/kafka/zero-copying.gif">
<meta property="article:published_time" content="2018-11-08T10:32:55.000Z">
<meta property="article:modified_time" content="2021-06-04T13:16:38.120Z">
<meta property="article:author" content="Zeral">
<meta property="article:tag" content="Hibernate">
<meta property="article:tag" content="Java8">
<meta property="article:tag" content="Spring Security">
<meta property="article:tag" content="Spring Boot">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zeral.cn/images/java/getStarted-compiler.gif">

<link rel="canonical" href="https://www.zeral.cn/%E9%9D%A2%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试整理 | Zeral's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zeral's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">我思故我在</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zeral.cn/%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/15558347?s=460&v=4">
      <meta itemprop="name" content="Zeral">
      <meta itemprop="description" content="Zeral, 全栈工程师一枚。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeral's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-08 18:32:55" itemprop="dateCreated datePublished" datetime="2018-11-08T18:32:55+08:00">2018-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 21:16:38" itemprop="dateModified" datetime="2021-06-04T21:16:38+08:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categoriesv/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/%E9%9D%A2%E8%AF%95/" class="post-meta-item leancloud_visitors" data-flag-title="面试整理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="java-面试问题整理"><a class="markdownIt-Anchor" href="#java-面试问题整理"></a> Java 面试问题整理</h2>
<p>[TOC]</p>
<h4 id="java-程序如何做到一次编写到处运行"><a class="markdownIt-Anchor" href="#java-程序如何做到一次编写到处运行"></a> Java 程序如何做到一次编写，到处运行</h4>
<p>java 代码源文件经过 javac 编译期编译为 .class 文件，.class 文件不包含处理器本机代码，而是包含字节码 - JVM 的机器语言。启动器使用虚拟机运行程序。</p>
<p><img src="../images/java/getStarted-compiler.gif" alt="Figure showing MyProgram.java, compiler, MyProgram.class, Java VM, and My Program running on a computer." /></p>
<p>由于 JVM 可在许多不同的操作系统上使用，因此相同的 .class 文件可以在不同系统上运行。</p>
<h4 id="jdk-和-jre-的区别"><a class="markdownIt-Anchor" href="#jdk-和-jre-的区别"></a> JDK 和 JRE 的区别</h4>
<p>JRE(Java Runtime Environment)是 JVM 执行代码的基础。JDK 是 Java 程序开发所有特性的工具，包含JRE，编译，开发和调试工具。</p>
<h4 id="什么是按值传递什么是引用传递java-中是值传递还是引用传递"><a class="markdownIt-Anchor" href="#什么是按值传递什么是引用传递java-中是值传递还是引用传递"></a> 什么是按值传递，什么是引用传递，Java 中是值传递还是引用传递</h4>
<p>值传递：传递到方法中的形参值只是实参值的一个副本，对形参的修改不会影响之前的值；</p>
<p>引用传递：形参只是实参的别名。它指向真正的实参，对形参所做的任意修改都反映在实参中。</p>
<p>Java中都是值传递，基本类型值传递，对象类型是引用值传递，也就是说值的内容是对象的引用。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609">https://www.zhihu.com/question/31203609</a></p>
<h4 id="通过-new-创建-string-对象和字面量形式创建有什么区别"><a class="markdownIt-Anchor" href="#通过-new-创建-string-对象和字面量形式创建有什么区别"></a> 通过 new 创建 String 对象和字面量形式创建有什么区别</h4>
<p>当使用 new 创建 String 对象时它总是会在堆内存中创建一个新对象，使用字面量创建时则会优先返回字符串常量池已存在的对象引用，否则，会创建一个新对象，并放入字符串池以备后用。</p>
<p>java7 之前字符串池存在在永久代，很难被回收，导致 OOM；之后移到了堆内存；</p>
<p>除了字符串池，包装类使用包装类缓存来实现同样的效果，比如 Integer、Byte、Short、Long、Character 使用内部类维护对应的缓存。</p>
<h4 id="如何跳出多重循环"><a class="markdownIt-Anchor" href="#如何跳出多重循环"></a> 如何跳出多重循环</h4>
<p>通过对代码块加标签的形式为代码块命名，标签为任意有效的标识符后面加冒号，通过 <code>break 标签名;</code> 跳转到代码块所在结束范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">continueLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + (i * j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名代码块同样适用于 <code>continue</code> 的跳转，同 goto 不同，标签块只能在自身代码块闭合范围内跳转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BreakLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Pass &quot;</span> + i + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This will not print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Loops complete.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jdk-和-jre-的区别-2"><a class="markdownIt-Anchor" href="#jdk-和-jre-的区别-2"></a> JDK 和 JRE 的区别</h4>
<p>JRE(Java Runtime Environment)是 JVM 执行代码的基础。JDK 是 Java 程序开发所有特性的工具，包含 JRE，编译，执行 Java 应用。</p>
<h4 id="静态方法能否重写静态方法能否访问非静态内容"><a class="markdownIt-Anchor" href="#静态方法能否重写静态方法能否访问非静态内容"></a> 静态方法能否重写，静态方法能否访问非静态内容</h4>
<p>不能，虽然子类可以包含同名静态方法，但并不属于重写。重写相对于类实例而言，子类重写父类的方法实现不同的行为，方法重写是运行时多态的重要表现。1.8之前静态方法、变量存储在堆的永久代中，它们是class相关的数据，而不是实例，具体如何存储取决于JVM，不同JVM略有差异</p>
<h4 id="hashcode-和-equals-方法主要是做什么"><a class="markdownIt-Anchor" href="#hashcode-和-equals-方法主要是做什么"></a> hashCode 和 equals 方法主要是做什么</h4>
<p>equasl 去比较两个对象是否相等，重写后用来比较业务相等，重写 equals 必须重写 hashCode。</p>
<p>hashCode 方法不是用于提供对象的唯一标识符，而是将对象的状态(即成员字段的值)摘要为一个整数。此值主要由某些基于哈希的数据结构(例如 Map 和集合)使用，以有效地存储和检索对象。</p>
<p>hashCode 和 equals 的一些基本约定，比如：equals 相等，hashCode 一定要相等；重写了 hashCode 也要重写 equals；hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。equals 的对称、反射、传递等特性。</p>
<span id="more"></span>
<h4 id="arraylist-和-linkedlist-区别"><a class="markdownIt-Anchor" href="#arraylist-和-linkedlist-区别"></a> ArrayList 和 LinkedList 区别</h4>
<p>ArrayList 和 LinkedList 都实现了 List 接口，顺序为添加时的顺序，可以包含重复元素。</p>
<p><code>LinkedList</code> :</p>
<ol>
<li>除了实现 List 接口外，<code>LinkedList</code> 类还为在列表的开头及结尾 <code>get</code>、<code>remove</code> 和 <code>insert</code> 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</li>
<li>通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问，LinkedList 在随机访问相对比较慢，但是它的特性集较 ArrayList 更大。</li>
<li>由双向链表实现，其中的每个对象包含数据的同时包含指向链表的前后引用。</li>
</ol>
<p><code>ArrayList</code>:</p>
<ol>
<li>它长于随机访问元素，</li>
<li>在List的中间插入和移除元素时较慢。</li>
<li>ArrayList底层由数组支持。</li>
</ol>
<h4 id="jdbcjdbc-driver作用"><a class="markdownIt-Anchor" href="#jdbcjdbc-driver作用"></a> JDBC，JDBC Driver作用</h4>
<p>Java数据库连接（JDBC）是用于编程语言Java的应用程序编程接口（API），它定义了客户端如何访问数据库。它是一种基于Java的数据访问技术，用于Java数据库连接。</p>
<p>JDBC驱动程序提供JDBC API提供的抽象类的特定于供应商的实现。 每个驱动程序必须提供以下java.sql包类的实现：Connection，Statement，PreparedStatement，CallableStatement，ResultSet和Driver。</p>
<h4 id="drivermanager-statement-resultset-preparedstatement"><a class="markdownIt-Anchor" href="#drivermanager-statement-resultset-preparedstatement"></a> DriverManager、Statement、ResultSet、PreparedStatement</h4>
<p>DriverManager类是JDBC的管理层，作用于用户和驱动程序之间，跟踪可用的驱动程序，建立数据库和驱动程序之间的连接，记录驱动程序运行的一些信息。</p>
<p>Statement 对象用于将 SQL 语句发送到数据库中。</p>
<p>ResultSet 包含符合 SQL 语句中条件的所有行，通过一套 get 方法来获取当前行中不同列的数据。  使用 next 方法移动当前行。</p>
<h3 id="数据库连接池作用"><a class="markdownIt-Anchor" href="#数据库连接池作用"></a> 数据库连接池作用</h3>
<p>关于数据库连接的打开和关闭，与数据库的交互可能是昂贵的。 特别是，当数据库客户端数量增加时，此成本非常高并且消耗了大量资源。应用程序服务器在启动时获得数据库连接池并将其维护在池中。 连接请求由驻留在池中的连接提供。 在连接结束时，请求将返回到池中，并可用于满足将来的请求。</p>
<h3 id="对象的构建顺序"><a class="markdownIt-Anchor" href="#对象的构建顺序"></a> 对象的构建顺序</h3>
<p>初始化子类时，先初始化父类<br />
初始化父类的静态变量和静态代码块<br />
初始化子类的静态变量和静态代码块<br />
初始化父类的非静态变量，初始化父类的构造函数<br />
如果父类的构造函数中调用的方法被子类重写，那么调用的会是子类的方法<br />
初始化子类的非静态变量，初始化子类的构造函数</p>
<p>基类静态（按定义顺序）-&gt; 子类静态 -&gt; 基类非静态 -&gt; 基类构造 -&gt; 子类非静态 -&gt; 子类构造</p>
<h4 id="servlet-的生命周期"><a class="markdownIt-Anchor" href="#servlet-的生命周期"></a> Servlet 的生命周期：</h4>
<p>实例化 --&gt; 初始化 --&gt; 服务 --&gt; 销毁</p>
<ol>
<li>当 servlet 第一次被调用的时候，会触发 init 函数，该函数通过web.xml配置文件由web服务器自动实例化 servlet 装载到内存， init 函数只会被调用一次</li>
<li>然后去调用  servlet 的 service 函数，由 service 方法判断请求的方式，get、post或者其它，调用相应的方法</li>
<li>当 web 应用 reload 或者关闭 tomcat 或者 关机 都会去调用 destroy 函数，该函数就去销毁 servlet</li>
</ol>
<ul>
<li>
<h4 id="表单提交数据-get-请求和-post-请求的区别"><a class="markdownIt-Anchor" href="#表单提交数据-get-请求和-post-请求的区别"></a> 表单提交数据 get 请求和 post 请求的区别：</h4>
• 从安全性看 get &lt; post, get 提交的数据会在浏览器的地址栏显示<br />
• 从提交的内容的大小来看  get &lt; post get提交的数据不能大于 2K ，而 Post 从理论上不受限制， 但是实际的变成中建议不要大于 64K<br />
• 从请求响应速度看： get &gt; post , get 要求服务器立即处理请求，而 post 请求可能形成一个队列请求</li>
</ul>
<h2 id="java8-问题整理"><a class="markdownIt-Anchor" href="#java8-问题整理"></a> Java8 问题整理</h2>
<h4 id="java8-添加了哪些新特性"><a class="markdownIt-Anchor" href="#java8-添加了哪些新特性"></a> Java8 添加了哪些新特性</h4>
<p>Java8 添加了很多新特性。但最主要的是下面的内容：</p>
<ul>
<li><strong>Lambda 表达式</strong> - 一种新的语言特性，允许将操作视为对象</li>
<li><strong>方法引用</strong> - 允许直接使用方法的名称引用去定义 Lambda</li>
<li><strong>Optional</strong> - 用于表达可能存在的特殊包装类</li>
<li><strong>函数接口</strong> - 具有最多一个抽象方法的接口，可以使用 Lambda 表达式提供实现</li>
<li><strong>默认方法</strong> - 除了使用抽象方法，让我们能够在接口中添加完整的实现</li>
<li><strong>Nashorn，JavaScript 引擎</strong> - 一种基于 Java 的引擎，用于执行和评估 JavaScript 代码</li>
<li><strong>流（Stream）接口</strong> - 一个特殊的迭代器类，允许以函数方式处理对象集合</li>
<li><strong>CompletableFuture</strong> - 为复杂的异步编码提供了可行性</li>
<li><strong>Date 接口</strong> - 一个改进的，不可改变的 JodaTime 灵感的 Date API<br />
除了这些新功能外，还有很多在编译器和 JVM 级别下的功能增强。</li>
</ul>
<h4 id="什么是方法引用"><a class="markdownIt-Anchor" href="#什么是方法引用"></a> 什么是方法引用</h4>
<p>方法引用是一种 Java8 结构，它允许在不调用方法时引用方法。用于将方法视为 Lambda 表达式。它只能作为语法糖来减少一些 lambda 的冗长。比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>) -&gt; o.toString();</span><br></pre></td></tr></table></figure>
<p>可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object::toString();</span><br></pre></td></tr></table></figure>
<p>方法引用可以使用双冒号来分割类、对象名称、方法名。它有不同的变体，如构造函数引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>静态方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::valueOf;</span><br></pre></td></tr></table></figure>
<p>绑定实例方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str::toString;</span><br></pre></td></tr></table></figure>
<p>未绑定实例方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::toString;</span><br></pre></td></tr></table></figure>
<h4 id="什么是-optional我们怎么使用它"><a class="markdownIt-Anchor" href="#什么是-optional我们怎么使用它"></a> 什么是 Optional？我们怎么使用它？</h4>
<p>可选是 Java 8 中的一个新类，它封装了一个可选值，即是否存在的值。它是对象的包装器，您可以将其视为零或一个元素的容器。<br />
Optional 具有特殊的 Optional.empty() 值而不是被包裹的 null。因此，在许多情况下，可以使用它来代替可空值来消除 NullPointerException（NPE）。<br />
Optional 是一种返回类型的方法，以前会返回 null。这样的方法需要你编写样板代码来检查返回值，有时可能会忘记进行防御性检查。在 Java 8 中，Optional 返回类型明确要求您以不同方式处理 null 或非 null 包装值。<br />
例如，Stream.min() 方法计算值流中的最小值。但是如果流是空的呢？如果它不是 Optional，则该方法将返回 null 或抛出异常。<br />
但它返回一个 Optional 值，可能是 Optional.empty()（第二种情况）。这使我们可以轻松处理这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min1 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">  .min()</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">assertEquals(<span class="number">1</span>, min1);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> min2 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;)</span><br><span class="line">  .min()</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">assertEquals(<span class="number">0</span>, min2);</span><br></pre></td></tr></table></figure>
<p>Optional 不能用在实体的字段上，因为它没有实现 Serializable 接口。</p>
<h4 id="描述标准库中的一些函数接口"><a class="markdownIt-Anchor" href="#描述标准库中的一些函数接口"></a> 描述标准库中的一些函数接口</h4>
<p>java.util.function 包中有很多功能接口，更常见的包括但不限于：</p>
<ul>
<li><strong>Function</strong> - 它接受一个参数并返回结果 T -&gt; R</li>
<li><strong>Consumer</strong> - 它需要一个参数并且不返回接口（表示副作用）T -&gt; void</li>
<li><strong>Supplier</strong> - 它不需要参数并返回结果 () -&gt; R</li>
<li><strong>Predicate</strong> - 它需要一个参数并返回一个布尔值 T -&gt; boolean</li>
<li><strong>BiFunction</strong> - 它需要两个参数并返回一个结果 (T, U) -&gt; R</li>
<li><strong>BinaryOperator</strong> - 它类似于 BiFunction，接受两个参数并返回结果。两个参数和结果都是相同的类型 (T, T) -&gt; T</li>
<li><strong>UnaryOperator</strong> - 它类似于 Function，只接受一个参数并返回相同类型的结果 T -&gt; T</li>
</ul>
<h4 id="函数接口的作用"><a class="markdownIt-Anchor" href="#函数接口的作用"></a> 函数接口的作用</h4>
<p>函数接口为可以为 <strong>lambda 表达式</strong>和<strong>方法引用</strong>提供目标类型。</p>
<h4 id="什么是-default-方法我们可以用来做什么"><a class="markdownIt-Anchor" href="#什么是-default-方法我们可以用来做什么"></a> 什么是 default 方法，我们可以用来做什么</h4>
<p>default 方法是接口中具有实现的方法。<br />
我们可以使用默认方法向接口添加新功能，同时保持与已实现接口的类的向后兼容性：<br />
通常，当一个新的抽象方法被添加到接口时，所有实现类都将中断，直到它们实现新的抽象方法。在 Java 8 中，通过使用默认方法解决了这个问题。<br />
例如，Collection 接口没有 forEach 方法声明。因此，添加此类方法只会破坏整个集合 API。<br />
Java 8 引入了默认方法，以便 Collection 接口可以具有 forEach 方法的默认实现，而不需要实现此接口的类来实现相同的方法。</p>
<h4 id="什么是-lambda-表达式以及它用于什么"><a class="markdownIt-Anchor" href="#什么是-lambda-表达式以及它用于什么"></a> 什么是 Lambda 表达式以及它用于什么</h4>
<p>简单来说，lambda 表达式是一个可以<strong>作为对象引用和传递</strong>的函数。<br />
Lambda 表达式引入了 Java 中的函数式处理，并有助于编写紧凑且易于阅读的代码。<br />
因此，lambda 表达式是匿名类作为方法参数的自然替代品。它们的主要用途之一是定义函数接口的内联实现。</p>
<h2 id="spring-问题整理"><a class="markdownIt-Anchor" href="#spring-问题整理"></a> Spring 问题整理</h2>
<h4 id="使用-spring-有什么好处"><a class="markdownIt-Anchor" href="#使用-spring-有什么好处"></a> 使用 Spring 有什么好处</h4>
<h4 id="spring-ioc-容器"><a class="markdownIt-Anchor" href="#spring-ioc-容器"></a> Spring IOC 容器</h4>
<p>ApplicationContext 是 Spring IOC 的核心容器，它是 BeanFactory 的超集。BeanFactory 是 Spring 的核心接口，其实现类必须支持 Bean 的生命周期接口，初始化的顺序如下：</p>
<ul>
<li>
<p>BeanNameAware’s {@code setBeanName}</p>
</li>
<li>
<p>BeanClassLoaderAware’s {@code setBeanClassLoader}</p>
</li>
<li>
<p>BeanFactoryAware’s {@code setBeanFactory}</p>
</li>
<li>
<p>EnvironmentAware’s {@code setEnvironment}</p>
</li>
<li>
<p>EmbeddedValueResolverAware’s {@code setEmbeddedValueResolver}</p>
</li>
<li>
<p>ResourceLoaderAware’s {@code setResourceLoader}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ApplicationEventPublisherAware’s {@code setApplicationEventPublisher}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>MessageSourceAware’s {@code setMessageSource}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ApplicationContextAware’s {@code setApplicationContext}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ServletContextAware’s {@code setServletContext}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>{@code postProcessBeforeInitialization} methods of BeanPostProcessors</p>
</li>
<li>
<p>InitializingBean’s {@code afterPropertiesSet}</p>
</li>
<li>
<p>a custom init-method definition 自定义的 init 方法</p>
</li>
<li>
<p>{@code postProcessAfterInitialization} methods of BeanPostProcessors</p>
</li>
</ul>
<p>关闭bean工厂时，以下生命周期方法适用：<br />
 * {@ code postProcessBeforeDestruction} DestructionAwareBeanPostProcessors 的方法<br />
 * DisposableBean 的{@code destroy}<br />
 * 自定义销毁方法</p>
<h4 id="beanfactory-和-applicationcontext-区别"><a class="markdownIt-Anchor" href="#beanfactory-和-applicationcontext-区别"></a> <code>BeanFactory</code> 和 <code>ApplicationContext</code> 区别 ？</h4>
<p>主要体现在容器级别之间的区别以及对引导的影响。</p>
<p>除非有充分的理由，否则应使用 ApplicationContext，将 GenericApplicationContext 及其子类 AnnotationConfigApplicationContext 作为自定义引导的常见实现。这些是用于所有常见目的的 Spring 核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册 Bean 定义和带注解的类，以及（从5.0版本开始）注册功能性 Bean 定义。</p>
<p>因为 ApplicationContext 包含 BeanFactory 的所有功能，所以通常建议在 ApplicationContext 上使用，除非需要对 Bean 处理的完全控制。在 ApplicationContext（例如 GenericApplicationContext 实现）中，按照惯例（即， 按Bean 名称或 Bean 类型（尤其是后处理器））检测多种 Bean，而普通的 DefaultListableBeanFactory 不知道任何特殊的 Bean。</p>
<p>对于许多扩展的容器功能，例如注解处理和 AOP 代理，BeanPostProcessor 扩展点至关重要。 如果仅使用普通的 DefaultListableBeanFactory，则默认情况下不会检测到此类后处理器并将其激活。 这种情况可能会造成混乱。</p>
<p>下表列出了 BeanFactory 和 ApplicationContext 接口和实现所提供的功能。</p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left"><code>BeanFactory</code></th>
<th style="text-align:left"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Bean 实例化/编织</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">集成生命周期管理</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">自动 BeanPostProcessor 注册</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">自动 BeanFactoryPostProcessor 注册</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">方便的 MessageSource 访问（用于内部化）</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">内置的 ApplicationEvent 发布机制</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<h4 id="spring-bean-的作用范围"><a class="markdownIt-Anchor" href="#spring-bean-的作用范围"></a> Spring Bean 的作用范围</h4>
<ul>
<li>单例（<strong>默认</strong> 将单个bean定义范围限定为每个Spring IoC容器的单个对象实例。）</li>
<li>原型（将单个bean定义范围限定为任意数量的对象实例。）</li>
<li>request（将单个bean定义范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。）</li>
<li>session（将单个bean定义范围限定为HTTP会话的生命周期。）</li>
<li>application（将单个bean定义范围限定为ServletContext的生命周期。）</li>
<li>websocket（将单个bean定义范围限定为WebSocket的生命周期。）</li>
<li>线程 （3.0提供，但未配置）<br />
中间 request、session、application、websocket 只有在使用 Web 感知的 Spring ApplicationContext 实现（例如 <code>XmlWebApplicationContext</code> ）时，</li>
</ul>
<h4 id="spring-bean-的生命周期回调"><a class="markdownIt-Anchor" href="#spring-bean-的生命周期回调"></a> Spring Bean 的生命周期回调</h4>
<p>生命周期回调可以用在多个方面，比如 <code>JDBC</code> 的关闭，服务的启动和销毁。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;stop&quot;)</span></span><br><span class="line"><span class="meta">@Profile(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">h2TCPServer</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> H2ConfigurationHelper.createServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要与容器的bean生命周期管理进行交互，可以实现 Spring <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。容器为前者调用 <code>afterPropertiesSet()</code>，为后者调用<code>destroy()</code>，让bean在初始化和销毁bean时执行某些操作。</p>
<p>JSR-250 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean不会耦合到特定于Spring的接口。</p>
<p>如果您不想使用JSR-250注释但仍想删除耦合，请考虑使用<code>init-method</code> 和 <code>destroy-method</code> 对象定义元数据。<br />
要让注入Bean调用指定的构造方法，可以在注解 <code>@Bean</code> 中指定 <code>initMethod</code> 和 <code>destroyMethod</code> 的方法名。<br />
当这三种配置同时存在时，他们的执行顺序如下，销毁相同：</p>
<ol>
<li>使用 <code>@PostConstruct</code> 注释的方法</li>
<li>由 <code>InitializingBean</code> 回调接口定义的 <code>afterPropertiesSet()</code></li>
<li>自定义的 <code>initMethod</code> 方法</li>
</ol>
<h4 id="启动和停止应用回调"><a class="markdownIt-Anchor" href="#启动和停止应用回调"></a> 启动和停止应用回调</h4>
<p><code>Lifecycle</code> 接口为具有自己的生命周期要求的任何对象定义了基本方法（例如启动和停止某些后台进程）。<br />
当 <code>ApplicationContext</code> 接到开始或停止信号时（比如，运行时的停止/重启场景），他将级联调用上下文中的所有  <code>Lifecycle</code> 实现。具体调用会委托给 <code>LifecycleProcessor</code> 完成。<br />
默认的 Lifecycle 并没有细粒化控制自动启动，如果要对特定的 bean 自动启动，需要实现 <code>SmartLifecycle</code>。<br />
<code>DefaultLifecycleProcessor</code> 默认处理会在应用启动时检测自动启动的 Bean，并调用 start 方法。<br />
<code>depends-on</code>定义了显式的依赖，但是有时候我们只知道前后，并不确定具体依赖顺序。 <code>SmartLifecycle</code> 接口定义了另外一种方法 <code>getPhase()</code> 。<br />
启动时，phase 越小的对象最先启动；停止时，越大的越先停止。<br />
默认的 Lifecycle 的 phase 是 0，因此，负值表示这个对象比标准组件启动快。<br />
在非 web 项目中，可以通过在 JVM 中注册关闭钩子实现关闭回调，<code>registerShutdownHook()</code> 方法定义在 <code>ConfigurableApplicationContext</code> 接口中。</p>
<h4 id="元数据是什么spring-的配置元数据来自于哪"><a class="markdownIt-Anchor" href="#元数据是什么spring-的配置元数据来自于哪"></a> 元数据是什么，Spring 的配置元数据来自于哪</h4>
<p>元数据是描述其他数据的数据。 Meta 是一种前缀，在大多数信息技术中，用法意味着“基础定义或描述”。元数据总结了有关数据的基本信息，可以更轻松地查找和处理特定的数据实例。<br />
配置元数据来自于多个方面，包含但不局限于：</p>
<ul>
<li>注解配置</li>
<li>java 配置类</li>
<li>xml 配置文件</li>
</ul>
<h4 id="spring-是否支持运行时注册新-bean"><a class="markdownIt-Anchor" href="#spring-是否支持运行时注册新-bean"></a> Spring 是否支持运行时注册新 Bean</h4>
<p>在运行时注册新bean（并发实时访问工厂）不受官方支持，并且可能导致并发访问异常，bean容器中的不一致状态，或两者兼而有之。</p>
<h4 id="spring-是否支持添加用户自己注册的实例对象"><a class="markdownIt-Anchor" href="#spring-是否支持添加用户自己注册的实例对象"></a> Spring 是否支持添加用户自己注册的实例对象</h4>
<p>除了包含有关如何创建特定 bean 信息的 bean 定义之外， <code>ApplicationContext</code> 实现还允许注册在容器外部（由用户）创建的现有对象。这是通过 <code>getBeanFactory()</code> 方法访问 <code>ApplicationContext</code> 的 <code>BeanFactory</code> 来完成的，该方法返回 <code>BeanFactory</code> 的 <code>DefaultListableBeanFactory</code> 实现。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和 <code>registerBeanDefinition(..)</code> 方法支持此注册。</p>
<h4 id="spring-bean-命名约定"><a class="markdownIt-Anchor" href="#spring-bean-命名约定"></a> Spring Bean 命名约定</h4>
<p>bean 名称以小写字母开头，并从那里开始驼峰。此类名称的示例包括 accountManager，accountService，userDao，loginController 等。<br />
但是，在（不常见的）特殊情况下，当有多个字符并且第一个和第二个字符都是大写字母时，原始大小写将会保留。这些规则与 <code>java.beans.Introspector.decapitalize</code>（Spring 在此处使用）中定义的规则相同。</p>
<h4 id="实例化-bean-方式"><a class="markdownIt-Anchor" href="#实例化-bean-方式"></a> 实例化 Bean 方式</h4>
<ul>
<li>构造方法实例化（空的构造方法），或者注入依赖（代参构造）</li>
<li>静态工厂方法实例化</li>
<li>实例工厂方法实例化<br />
如果要为静态嵌套类配置 bean 定义，则必须使用嵌套类的二进制名称。</li>
</ul>
<p>例如，如果在 com.example 包中有一个名为 SomeThing 的类，并且此 SomeThing 类具有一个名为 OtherThing 的静态嵌套类，则 bean 定义上的 class 属性值将为com.example.SomeThing$OtherThing。</p>
<p>请注意，在名称中使用 <code>$</code> 字符可以将嵌套类名与外部类名分开。</p>
<h4 id="使用-xml-和注解配置-bean-区别"><a class="markdownIt-Anchor" href="#使用-xml-和注解配置-bean-区别"></a> 使用 xml 和注解配置 Bean 区别</h4>
<p>xml 通常将这些 bean 配置为顶级 <beans /> 元素内的 <bean /> 元素；<br />
使用 xml 配置 bean 时，我们需要指明 bean 的实现类类名，以便反射实例化注册到容器，就是上述描述的方法；</p>
<p><code>@Bean</code> 注解大多用在 <code>@Configuration</code> 配置类中；<br />
使用注解时，我们可以显式的去返回对象的实例来进行配置，实例时也可以传入其他实例方法来依赖Bean，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 bean 直接调用同一个类中的其他 @Bean 方法时，不得将@Configuration 类及其工厂方法标记为 final 或 private，因为它需要在运行时对每个这样的配置类进行 CGLIB 子类化。<br />
在 @Component 组件或者普通对象中直接调用其它 @Bean 方法也不可行，因为这是标准的Java方法调用，Spring不会通过 CGLIB 代理拦截调用。</strong></p>
<p>也可以加入其它注解来共同配置 Bean，比如：</p>
<ul>
<li><strong>@Profile</strong> – 允许选择性地根据配置包含某些bean</li>
<li><strong>@Scope</strong> – 更改 bean 的范围</li>
<li><strong>@Lazy</strong> – 仅在默认单例范围的情况下起作用</li>
<li><strong>@DependsOn</strong> – 在创建此 bean 之前强制创建特定的其他bean。</li>
<li><strong>@Primary</strong> – 是一种解决注入点级别歧义的机制，如果需要按类型匹配来注入Bean，但是符合类型的有多个。</li>
<li><strong>@Order</strong> – 设置优先级</li>
</ul>
<h4 id="已经有了-ref-引用依赖为什么需要-depend-on"><a class="markdownIt-Anchor" href="#已经有了-ref-引用依赖为什么需要-depend-on"></a> 已经有了 ref 引用依赖，为什么需要 Depend-on</h4>
<ul>
<li>可能 Bean 之间不是显式的依赖，但的确需要有初始化顺序</li>
<li>当多个 Bean 存在循环依赖关系时</li>
<li>或者仅仅想在一个 Bean 之前初始化另一个 Bean</li>
</ul>
<h4 id="依赖注入的两种方式"><a class="markdownIt-Anchor" href="#依赖注入的两种方式"></a> 依赖注入的两种方式</h4>
<ul>
<li>基于构造方法依赖注入（调用具有多个参数的构造方法)</li>
<li>基于 Setter 的依赖注入</li>
<li>混合使用<br />
由于您可以混合基于构造函数和基于 setter 的 DI ，因此将构造函数用于强制依赖项和 setter 方法或可选依赖项的配置方法是一个很好的经验法则。请注意，在 setter 方法上使用 <code>@Required</code> 注释可用于使属性成为必需的依赖项。<br />
Spring 团队通常提倡<strong>构造函数注入</strong>，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为null.此外，构造函数注入的组件总是以完全初始化的状态返回到客户端（调用）代码。作为旁注，大量的构造函数参数是一个糟糕的代码气味，暗示该类可能有太多的责任，应该重构以更好地解决关注点的正确分离。<br />
Setter 注入应主要仅用于可在类中指定合理默认值的可选依赖项。否则，必须在代码使用依赖项的任何位置执行非空检查。 setter 注入的一个好处是 setter 方法使该类的对象可以在以后重新配置或重新注入。因此，通过 JMX MBean 进行管理是二次注入的一个引人注目的用例。</li>
</ul>
<h4 id="spring-aop-的编织是在什么时候"><a class="markdownIt-Anchor" href="#spring-aop-的编织是在什么时候"></a> Spring AOP 的编织是在什么时候</h4>
<p>运行时，也就是说都是动态代理。 AspectJ 是在编译时。</p>
<h3 id="如何扩展-spring-容器"><a class="markdownIt-Anchor" href="#如何扩展-spring-容器"></a> 如何扩展 Spring 容器</h3>
<p>通常，我们不需要子类化 <code>ApplicationContext</code> 实现类。相反，可以通过插入特殊集成接口的实现来扩展 Spring IOC 容器。</p>
<ul>
<li>
<p>使用 <code>BeanPostProcessor</code> 来自定义 Beans</p>
<p>BeanPostProcessor 接口定义了回调方法，你可以去实现它以提供自己的（或覆盖容器的默认）实例化逻辑，依赖解析逻辑，等等。如果要在 Spring 容器完成实例化，配置和初始化 bean 之后实现某些自定义逻辑，则可以插入一个或多个 BeanPostProcessor 实现。</p>
<p>该工厂钩子允许自定义修改新 bean 实例，例如检查标记接口或用代理包装它们。 ApplicationContexts 可以在其 bean 定义中自动检测 BeanPostProcessor bean，并将它们应用于随后创建的任何 bean。</p>
<p>该接口默认包含两个默认方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法在任何 bean 初始化回调之前将此 BeanPostProcessor 应用于给定的新bean实例（如 InitializingBean 的 afterPropertiesSet 或自定义 init 方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br></pre></td></tr></table></figure>
<p>在任何 bean 初始化回调（如 InitializingBean 的 afterPropertiesSet 或自定义 init 方法）之后，将此 BeanPostProcessor 应用于给定的新 bean 实例。</p>
</li>
<li>
<p>使用 <code>BeanFactoryPostProcessor</code> 来自定义配置元数据</p>
<p>BeanFactoryPostProcessor 对 bean 的配置元数据进行操作。也就是说，Spring IOC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并允许在容器实例化除 BeanFactoryPostProcessor 实例之外的任何 bean 之前更改元数据。</p>
<p>比如：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"><code>PropertyPlaceholderConfigurer</code></a> 该配置器可以读取配置文件中的占位符，并从外部文件或环境变量等拿到相应的值替换占位符：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们可以在指定的外部文件中定义相应的属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">org.hsqldb.jdbcDriver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://production:9002</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>在配置文件找不到相应的属性时，默认也会从环境变量去寻找。你也可以自定寻找策略通过配置 <code>systemPropertiesMode</code> 。</p>
</li>
<li>
<p>使用 <code>FactoryBean</code> 自定义实例化逻辑</p>
<p>FactoryBean 接口是 Spring IOC 容器实例化逻辑的可插拔点。如果你有一个复杂的初始化代码，用 Java 表示比较好，而不是（可能）冗长的 XML，你可以创建自己的 FactoryBean，在该类中编写复杂的初始化，然后将自定义 FactoryBean 插入容器。</p>
</li>
</ul>
<h3 id="注解是否比-xml-配置-spring-更好"><a class="markdownIt-Anchor" href="#注解是否比-xml-配置-spring-更好"></a> 注解是否比 XML 配置 Spring 更好？</h3>
<p>每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，注解在其声明中提供了大量上下文，从而导致更短更简洁的配置。但是，XML 擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将配置靠近源，而另一些开发人员则认为注释类不再是 POJO，而且配置变得分散且难以控制。</p>
<p>无论选择如何，Spring 都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java">JavaConfig</a> 选项，Spring 允许以非侵入方式使用注释，而无需触及目标组件源代码。</p>
<p>在注入 XML 之前执行注解注入。因此，XML 配置会覆盖通过这两种方法连接的相同属性的注解。</p>
<h3 id="sprng-aop-代理机制"><a class="markdownIt-Anchor" href="#sprng-aop-代理机制"></a> Sprng AOP 代理机制？</h3>
<p>Spring AOP 使用 JDK 动态代理或 CGLIB 为给定目标对象创建代理。（只要有选择，JDK 动态代理就是首选）。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用 JDK 动态代理。目标类型实现的所有接口都是代理的。如果目标对象未实现任何接口，则会创建 CGLIB 代理。</p>
<p>这是因为 CGLIB 默认会继承目标对象，然后重写被代理方法，所以必须要求被代理类不为 final 类，代理方法也不能为 final 类型。代理类如果有接口，也会通过实现接口的方法代理。CGLIB 是第三方框架，基于 ASM 提供的字节码操作。</p>
<p>JDK 动态代理是通过实现目标对象接口来代理方法的，所以只能代理接口暴露出去的方法。它是纯 java 实现。</p>
<p>CGLIB 和 JDK 动态代理都是在代理运行时动态生成 class 文件达到动态代理的目的。</p>
<p>静态代理唯一的缺点就是我们需要对每一个方法编写我们的代理逻辑，造成了工作的繁琐和复杂。AspectJ 就是为了解决这个问题，在编译成 class 字节码的时候在方法周围加上业务逻辑。复杂的工作由特定的编译器帮我们做。所以会有 AOP 有切面(Aspect)、连接点(joinpoint)、通知(advice)、切入点(Pointcut)、目标对象(target)等概念来定义代理的逻辑。</p>
<h2 id="jpa-问题整理"><a class="markdownIt-Anchor" href="#jpa-问题整理"></a> JPA 问题整理</h2>
<h3 id="hql-和-jpql-区别"><a class="markdownIt-Anchor" href="#hql-和-jpql-区别"></a> HQL 和 JPQL 区别</h3>
<p>Hibernate Query Language（HQL）和 Java Persistence Query Language（JPQL）都是以对象模型为中心的查询语言，与 SQL 本质上类似。JPQL 是一个受 HQL 影响很大的子集。但是，JPQL 查询始终是有效的 HQL 查询，反之则不然。</p>
<p>HQL 和 JPQL 都是非类型安全的方法来执行查询操作。 Criteria 查询提供了一种类型安全的查询方法。</p>
<h2 id="spring-security-问题整理"><a class="markdownIt-Anchor" href="#spring-security-问题整理"></a> Spring-Security 问题整理</h2>
<h4 id="spring-security-如何实现认证和授权"><a class="markdownIt-Anchor" href="#spring-security-如何实现认证和授权"></a> Spring-Security 如何实现认证和授权</h4>
<h4 id="说一下-spring-security-几个重要的对象"><a class="markdownIt-Anchor" href="#说一下-spring-security-几个重要的对象"></a> 说一下 Spring-Security 几个重要的对象？</h4>
<ul>
<li><code>SecurityContextHolder</code>， 提供对 <code>SecurityContext</code> 的访问。</li>
<li><code>SecurityContext</code>，保存 <code>Authentication</code> 和可能的特定于请求的安全信息。</li>
<li><code>Authentication</code>，以 Spring Security 特定的方式表示认证主体（一般为用户信息） principal。</li>
<li><code>GrantedAuthority</code>，反映授予主体的应用程序范围的权限。</li>
<li><code>UserDetails</code>，提供从应用程序的 DAO 或其他安全数据源构建 Authentication 对象所需的信息。</li>
<li><code>UserDetailsService</code>，在基于字符串的用户名（或证书 ID 等）中传递时创建 UserDetails。</li>
</ul>
<h2 id="elasticsearch-问题整理"><a class="markdownIt-Anchor" href="#elasticsearch-问题整理"></a> Elasticsearch 问题整理</h2>
<h4 id="为什么选择使用-elasticsearch"><a class="markdownIt-Anchor" href="#为什么选择使用-elasticsearch"></a> 为什么选择使用 Elasticsearch</h4>
<h4 id="elatiscsearch-如何选择查询"><a class="markdownIt-Anchor" href="#elatiscsearch-如何选择查询"></a> Elatiscsearch 如何选择查询</h4>
<h4 id="elasticsearch-的索引和-mysql-索引优势在哪里"><a class="markdownIt-Anchor" href="#elasticsearch-的索引和-mysql-索引优势在哪里"></a> Elasticsearch 的索引和 Mysql 索引优势在哪里</h4>
<h4 id="如何实现类似-sql-的-like-查询"><a class="markdownIt-Anchor" href="#如何实现类似-sql-的-like-查询"></a> 如何实现类似 SQL 的 Like 查询</h4>
<h2 id="redis-问题整理"><a class="markdownIt-Anchor" href="#redis-问题整理"></a> Redis 问题整理</h2>
<h4 id="redis-的基本类型有哪些"><a class="markdownIt-Anchor" href="#redis-的基本类型有哪些"></a> Redis 的基本类型有哪些</h4>
<p>Redis 是一个开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。</p>
<h2 id="数据库-问题整理"><a class="markdownIt-Anchor" href="#数据库-问题整理"></a> 数据库 问题整理</h2>
<h4 id="mysql-底层如何存放数据"><a class="markdownIt-Anchor" href="#mysql-底层如何存放数据"></a> Mysql 底层如何存放数据</h4>
<h4 id="如何优化-sql"><a class="markdownIt-Anchor" href="#如何优化-sql"></a> 如何优化 SQL</h4>
<h2 id="kafka-问题整理"><a class="markdownIt-Anchor" href="#kafka-问题整理"></a> Kafka 问题整理</h2>
<h4 id="如何提高消息吞吐量"><a class="markdownIt-Anchor" href="#如何提高消息吞吐量"></a> 如何提高消息吞吐量</h4>
<h5 id="生产者"><a class="markdownIt-Anchor" href="#生产者"></a> 生产者</h5>
<ul>
<li>
<p>开启消息压缩</p>
<p><code>compression.type</code>：默认情况，消息不会被压缩。这个属性可以设置压缩算法：<code>gzip</code>, <code>snappy</code>, <code>lz4</code>, <code>zstd</code>。<code>zstd</code> 和 <code>gzip</code> 比较平衡。</p>
</li>
<li>
<p>等待更多的消息进入批次</p>
<p><code>linger.ms</code>：生产者在发送批次之前等待更多的消息加入批次的时间。增大这个值会增加延迟但可以提高吞吐量。</p>
</li>
<li>
<p>增大批次处理量</p>
<p><code>max.in.flight.requests.per.connection</code>：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
</li>
<li>
<p>分配合理的分区数和消费者个数</p>
</li>
</ul>
<h4 id="如何保证消息顺序"><a class="markdownIt-Anchor" href="#如何保证消息顺序"></a> 如何保证消息顺序</h4>
<p>Kafka 可以保证同一个分区里的消息是有序的。也就是说，如果生产者按照一定的顺序发送消息，broker 就会按照这个顺序把它们写入分区，消费者也会按照同样的顺序读取它们。</p>
<p><strong>使用单个分区能最大程度保证消息的顺序，或者消息使用相同的 key。还需注意下面的配置。</strong></p>
<h5 id="生产者-2"><a class="markdownIt-Anchor" href="#生产者-2"></a> 生产者</h5>
<p><code>retries</code>：生产者从服务器收到错误时的重试次数</p>
<p><code>max.in.flight.requests.per.connection</code>：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
<p>消息是否写入成功也是非常关键的，如果把 <code>retries</code> 设为非零整数，同时把 <code>max.in.flight.requests.per.connection</code> 设为比 1 大的数，那么第一批消息写入失败，而第二批写入成功，broker 重试第一个批次。此时第一个批次写入成功，那么两个批次的顺序就反了。</p>
<p>为了保证写入的顺序，不建议把 <code>retries</code> 设为 0。可以把 <code>max.in.flight.requests.per.connection</code> 设为 <strong>1</strong>，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker。不过这样的会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下。</p>
<h4 id="如何保证消息被消费-exactly-once"><a class="markdownIt-Anchor" href="#如何保证消息被消费-exactly-once"></a> 如何保证消息被消费 Exactly-Once</h4>
<p>由于各种故障，消息传递系统无法保证生产者和使用者应用程序之间的消息传递。根据客户端应用程序与此类系统交互的方式，可能会出现以下消息语义：</p>
<ul>
<li>如果消息传递系统永远不会复制消息，但可能会漏掉偶尔的消息，则我们称 <em><strong>最多一次 (at-most-once)</strong></em></li>
<li>如果它永远不会丢失一条消息，但可能会重复一条消息，则我们至少将其 <em><strong>至少一次 (at-least-once)</strong></em></li>
<li>如果它发送所有消息时总是不重复，那将是 <em><strong>恰好一次 (exactly-once)</strong></em></li>
</ul>
<p>要保证消息只发送一次，得保证生产者发送给服务器的消息只成功一次，消费者也只消费一次。Kafka 代理和客户端应用引入事物可确保进行一次准确的交付。</p>
<h5 id="生产者-3"><a class="markdownIt-Anchor" href="#生产者-3"></a> 生产者</h5>
<p><code>acks</code>：该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有影响。</p>
<ul>
<li><code>acks=0</code> 不需要确认</li>
<li><code>acks=1</code> 需要集群首领确认。首领确认纪录后失败，如果跟随者还没复制，则记录可能丢失。</li>
<li><code>acks=all</code> 集群首领及其追随者都确认后，才会收到成功响应。安全性更高，吞吐率下降。</li>
</ul>
<p><code>enable.idempotence</code>：当设置为 “true” 时，生产者将确保每个消息的仅有一个副本被写入流中。如果为 “false”，则生产者由于代理失败等原因而重试，可能会将重试消息的副本写入流中。 请注意，启用幂等性要求 <code>max.in.flight.requests.per.connection</code> 小于或等于 5，重试大于 0，<code>ack</code> 必须为 “<strong>all</strong>”。 如果用户未明确设置这些值，则将选择合适的值。 如果设置了不兼容的值，则将引发 ConfigException。</p>
<h6 id="幂等操作"><a class="markdownIt-Anchor" href="#幂等操作"></a> 幂等操作</h6>
<p>由于生产者出错重试会导致消息重复，所以为了生产者成功提交的消息恰好一次，可以使用幂等操作来保证。如果发生导致生产者重试的错误，则相同的消息（仍由生产者多次发送）将仅写入到代理上的 Kafka 日志一次。对于单个分区，幂等生产者发送消除了由于生产者或代理错误而产生重复消息的可能性。要启用此功能并为每个分区获取一次精确的语义（即没有重复，没有数据丢失和有序的语义），请将生产者配置为 <code>enable.idempotence = true</code>。</p>
<h6 id="事物"><a class="markdownIt-Anchor" href="#事物"></a> 事物</h6>
<p>生产者通过设定事物 Id (<code>transactional.id</code>)，然后开启事物。</p>
<h5 id="消费者"><a class="markdownIt-Anchor" href="#消费者"></a> 消费者</h5>
<h6 id="事物-2"><a class="markdownIt-Anchor" href="#事物-2"></a> 事物</h6>
<p><code>isolation.level</code>：控制如何读取事务写入的消息。如果设置为 <code>read_committed</code>，consumer.poll() 将仅返回已提交的事务性消息。如果设置为 <code>read_uncommitted</code>（<strong>默认</strong>），consumer.poll() 将返回所有消息，甚至是已中止的事务性消息。非事务性消息在两种方式下都返回。</p>
<h6 id="手动提交"><a class="markdownIt-Anchor" href="#手动提交"></a> 手动提交</h6>
<p><code>enable.auto.commit</code>：该属性决定是否自动提交偏移量，默认为 true。为了避免数据出现重复和丢失，可以通过手动提交的方式自行提交偏移量。</p>
<h4 id="是什么使-kafka-如此之快"><a class="markdownIt-Anchor" href="#是什么使-kafka-如此之快"></a> 是什么使 Kafka 如此之快</h4>
<h5 id="低延迟消息传递"><a class="markdownIt-Anchor" href="#低延迟消息传递"></a> 低延迟消息传递</h5>
<p>Kafka 通过顺序 IO 操作日志避免了长时间的磁盘寻道；</p>
<p>零复制原则，避免了内核上下文和应用上下文的文件读取和发送，直接在系统内核上下文中进行文件读取和发送，避免了上下文切换的时间消耗和内存占用。</p>
<p>传统数据复制方法</p>
<p><img src="../images/message/kafka/data-copying.gif" alt="Traditional data copying approach" /></p>
<p>零复制使用 <code>java.nio.channels.FileChannel.transferTo()</code></p>
<p><img src="../images/message/kafka/zero-copying.gif" alt="Data copy with transferTo()" /></p>
<h5 id="批处理数据和压缩"><a class="markdownIt-Anchor" href="#批处理数据和压缩"></a> 批处理数据和压缩</h5>
<p>高效压缩将同一批次的消息压缩在一起，并保持压缩在日志中，并且仅由使用者解压缩。支持的压缩算法：Zstd、Snappy、GZip 或 LZ4。</p>
<h5 id="水平扩展"><a class="markdownIt-Anchor" href="#水平扩展"></a> 水平扩展</h5>
<p>首先让我们了解什么是垂直扩展。可以说，对于传统的数据库服务器，当负载增加时，一种解决方法是添加更多资源，例如：CPU，RAM，SSD 等。这称为垂直扩展。它具有以下几个缺点：</p>
<ul>
<li>每个硬件都有局限性，不能无限地向上扩展。</li>
<li>如果机器出现故障怎么办？通常需要停机。</li>
</ul>
<p><strong>水平扩展</strong>通过添加更多机器来解决相同的问题。 Kafka 能够为单个主题提供数千个分区，并将其分布在数千台计算机中，这意味着 Kafka 可以处理巨大的负载。</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://twitter.com/ZeralZhang">
            <span class="icon">
              <i class="fab fa-twitter"></i>
            </span>

            <span class="label">Twitter</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/uploads/wechat-qcode.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Hibernate/" rel="tag"># Hibernate</a>
              <a href="/tags/Java8/" rel="tag"># Java8</a>
              <a href="/tags/Spring-Security/" rel="tag"># Spring Security</a>
              <a href="/tags/Spring-Boot/" rel="tag"># Spring Boot</a>
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/spring/Spring-Security-%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="prev" title="Spring Security 过滤器">
      <i class="fa fa-chevron-left"></i> Spring Security 过滤器
    </a></div>
      <div class="post-nav-item">
    <a href="/java/%E6%9B%BF%E4%BB%A3-Java-%E4%B8%AD%E7%B9%81%E7%90%90%E7%9A%84-If-%E8%AF%AD%E5%8F%A5/" rel="next" title="替代 Java 中繁琐的 If 语句">
      替代 Java 中繁琐的 If 语句 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text"> Java 面试问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E5%88%B0%E5%A4%84%E8%BF%90%E8%A1%8C"><span class="nav-number">1.0.1.</span> <span class="nav-text"> Java 程序如何做到一次编写，到处运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk-%E5%92%8C-jre-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.2.</span> <span class="nav-text"> JDK 和 JRE 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92java-%E4%B8%AD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">1.0.3.</span> <span class="nav-text"> 什么是按值传递，什么是引用传递，Java 中是值传递还是引用传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-new-%E5%88%9B%E5%BB%BA-string-%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%97%E9%9D%A2%E9%87%8F%E5%BD%A2%E5%BC%8F%E5%88%9B%E5%BB%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.4.</span> <span class="nav-text"> 通过 new 创建 String 对象和字面量形式创建有什么区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.0.5.</span> <span class="nav-text"> 如何跳出多重循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk-%E5%92%8C-jre-%E7%9A%84%E5%8C%BA%E5%88%AB-2"><span class="nav-number">1.0.6.</span> <span class="nav-text"> JDK 和 JRE 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E9%87%8D%E5%86%99%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%83%BD%E5%90%A6%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="nav-number">1.0.7.</span> <span class="nav-text"> 静态方法能否重写，静态方法能否访问非静态内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashcode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E4%B8%BB%E8%A6%81%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">1.0.8.</span> <span class="nav-text"> hashCode 和 equals 方法主要是做什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#arraylist-%E5%92%8C-linkedlist-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.9.</span> <span class="nav-text"> ArrayList 和 LinkedList 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdbcjdbc-driver%E4%BD%9C%E7%94%A8"><span class="nav-number">1.0.10.</span> <span class="nav-text"> JDBC，JDBC Driver作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drivermanager-statement-resultset-preparedstatement"><span class="nav-number">1.0.11.</span> <span class="nav-text"> DriverManager、Statement、ResultSet、PreparedStatement</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text"> 数据库连接池作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E5%BB%BA%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.2.</span> <span class="nav-text"> 对象的构建顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#servlet-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text"> Servlet 的生命周期：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE-get-%E8%AF%B7%E6%B1%82%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text"> 表单提交数据 get 请求和 post 请求的区别：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java8-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text"> Java8 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java8-%E6%B7%BB%E5%8A%A0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.0.1.</span> <span class="nav-text"> Java8 添加了哪些新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">2.0.2.</span> <span class="nav-text"> 什么是方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-optional%E6%88%91%E4%BB%AC%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="nav-number">2.0.3.</span> <span class="nav-text"> 什么是 Optional？我们怎么使用它？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.0.4.</span> <span class="nav-text"> 描述标准库中的一些函数接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.0.5.</span> <span class="nav-text"> 函数接口的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-default-%E6%96%B9%E6%B3%95%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">2.0.6.</span> <span class="nav-text"> 什么是 default 方法，我们可以用来做什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88"><span class="nav-number">2.0.7.</span> <span class="nav-text"> 什么是 Lambda 表达式以及它用于什么</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text"> Spring 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-spring-%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="nav-number">3.0.1.</span> <span class="nav-text"> 使用 Spring 有什么好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-ioc-%E5%AE%B9%E5%99%A8"><span class="nav-number">3.0.2.</span> <span class="nav-text"> Spring IOC 容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#beanfactory-%E5%92%8C-applicationcontext-%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.3.</span> <span class="nav-text"> BeanFactory 和 ApplicationContext 区别 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">3.0.4.</span> <span class="nav-text"> Spring Bean 的作用范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83"><span class="nav-number">3.0.5.</span> <span class="nav-text"> Spring Bean 的生命周期回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8%E5%9B%9E%E8%B0%83"><span class="nav-number">3.0.6.</span> <span class="nav-text"> 启动和停止应用回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88spring-%E7%9A%84%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE%E6%9D%A5%E8%87%AA%E4%BA%8E%E5%93%AA"><span class="nav-number">3.0.7.</span> <span class="nav-text"> 元数据是什么，Spring 的配置元数据来自于哪</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%B3%A8%E5%86%8C%E6%96%B0-bean"><span class="nav-number">3.0.8.</span> <span class="nav-text"> Spring 是否支持运行时注册新 Bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E8%87%AA%E5%B7%B1%E6%B3%A8%E5%86%8C%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.0.9.</span> <span class="nav-text"> Spring 是否支持添加用户自己注册的实例对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-bean-%E5%91%BD%E5%90%8D%E7%BA%A6%E5%AE%9A"><span class="nav-number">3.0.10.</span> <span class="nav-text"> Spring Bean 命名约定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-bean-%E6%96%B9%E5%BC%8F"><span class="nav-number">3.0.11.</span> <span class="nav-text"> 实例化 Bean 方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-xml-%E5%92%8C%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE-bean-%E5%8C%BA%E5%88%AB"><span class="nav-number">3.0.12.</span> <span class="nav-text"> 使用 xml 和注解配置 Bean 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86-ref-%E5%BC%95%E7%94%A8%E4%BE%9D%E8%B5%96%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-depend-on"><span class="nav-number">3.0.13.</span> <span class="nav-text"> 已经有了 ref 引用依赖，为什么需要 Depend-on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">3.0.14.</span> <span class="nav-text"> 依赖注入的两种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-aop-%E7%9A%84%E7%BC%96%E7%BB%87%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99"><span class="nav-number">3.0.15.</span> <span class="nav-text"> Spring AOP 的编织是在什么时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95-spring-%E5%AE%B9%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text"> 如何扩展 Spring 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%90%A6%E6%AF%94-xml-%E9%85%8D%E7%BD%AE-spring-%E6%9B%B4%E5%A5%BD"><span class="nav-number">3.2.</span> <span class="nav-text"> 注解是否比 XML 配置 Spring 更好？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sprng-aop-%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text"> Sprng AOP 代理机制？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jpa-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text"> JPA 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hql-%E5%92%8C-jpql-%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text"> HQL 和 JPQL 区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-security-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text"> Spring-Security 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-security-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83"><span class="nav-number">5.0.1.</span> <span class="nav-text"> Spring-Security 如何实现认证和授权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-spring-security-%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.0.2.</span> <span class="nav-text"> 说一下 Spring-Security 几个重要的对象？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#elasticsearch-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text"> Elasticsearch 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8-elasticsearch"><span class="nav-number">6.0.1.</span> <span class="nav-text"> 为什么选择使用 Elasticsearch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#elatiscsearch-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.0.2.</span> <span class="nav-text"> Elatiscsearch 如何选择查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#elasticsearch-%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C-mysql-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">6.0.3.</span> <span class="nav-text"> Elasticsearch 的索引和 Mysql 索引优势在哪里</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC-sql-%E7%9A%84-like-%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.0.4.</span> <span class="nav-text"> 如何实现类似 SQL 的 Like 查询</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text"> Redis 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">7.0.1.</span> <span class="nav-text"> Redis 的基本类型有哪些</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text"> 数据库 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql-%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">8.0.1.</span> <span class="nav-text"> Mysql 底层如何存放数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-sql"><span class="nav-number">8.0.2.</span> <span class="nav-text"> 如何优化 SQL</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka-%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text"> Kafka 问题整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%B6%88%E6%81%AF%E5%90%9E%E5%90%90%E9%87%8F"><span class="nav-number">9.0.1.</span> <span class="nav-text"> 如何提高消息吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="nav-number">9.0.1.1.</span> <span class="nav-text"> 生产者</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F"><span class="nav-number">9.0.2.</span> <span class="nav-text"> 如何保证消息顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-2"><span class="nav-number">9.0.2.1.</span> <span class="nav-text"> 生产者</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E8%A2%AB%E6%B6%88%E8%B4%B9-exactly-once"><span class="nav-number">9.0.3.</span> <span class="nav-text"> 如何保证消息被消费 Exactly-Once</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-3"><span class="nav-number">9.0.3.1.</span> <span class="nav-text"> 生产者</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E6%93%8D%E4%BD%9C"><span class="nav-number">9.0.3.1.1.</span> <span class="nav-text"> 幂等操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8B%E7%89%A9"><span class="nav-number">9.0.3.1.2.</span> <span class="nav-text"> 事物</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">9.0.3.2.</span> <span class="nav-text"> 消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%8B%E7%89%A9-2"><span class="nav-number">9.0.3.2.1.</span> <span class="nav-text"> 事物</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="nav-number">9.0.3.2.2.</span> <span class="nav-text"> 手动提交</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF-kafka-%E5%A6%82%E6%AD%A4%E4%B9%8B%E5%BF%AB"><span class="nav-number">9.0.4.</span> <span class="nav-text"> 是什么使 Kafka 如此之快</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8E%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="nav-number">9.0.4.1.</span> <span class="nav-text"> 低延迟消息传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%92%8C%E5%8E%8B%E7%BC%A9"><span class="nav-number">9.0.4.2.</span> <span class="nav-text"> 批处理数据和压缩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95"><span class="nav-number">9.0.4.3.</span> <span class="nav-text"> 水平扩展</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zeral"
      src="https://avatars3.githubusercontent.com/u/15558347?s=460&v=4">
  <p class="site-author-name" itemprop="name">Zeral</p>
  <div class="site-description" itemprop="description">Zeral, 全栈工程师一枚。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zeral-zhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zeral-zhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="zeral:zeralzhang@gmail.com" title="E-Mail → zeral:zeralzhang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ZeralZhang" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ZeralZhang" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeral</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              Counter('post', '/classes/Counter', { title, url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"xscbbB5QhKlIenfLsvil037U-gzGzoHsz","app_key":"LLmCDfW8Pl0cKqCkjVJX6zL4","security":false,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b6f41cb44d3ba22c9361',
      clientSecret: '5867ad133bff941fada16af0e4bc81f939640f59',
      repo        : 'Zeral.github.io',
      owner       : 'Zeral-Zhang',
      admin       : ['Zeral-Zhang'],
      id          : '9cb5808160c882cf490b05239ce5b445',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
