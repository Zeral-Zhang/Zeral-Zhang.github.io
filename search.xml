<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>开发常见问题整理</title>
    <url>/%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1>JPA</h1>
<ul>
<li><strong>parallelStream 调用 manyToMany 清除关联关系无效</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAuthorBooks</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    ids.add(<span class="number">1L</span>);</span><br><span class="line">    ids.add(<span class="number">2L</span>);</span><br><span class="line">    ids.parallelStream().forEach(<span class="built_in">this</span>::newTransaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newTransaction</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    authorRepository.findById(id).ifPresent(author -&gt; author.getBooks().clear());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用基于注解的 Spring 事物，Spring 中大量使用基于代理的模式来处理方法调用，如果被代理对象实现了接口则使用 <code>JDK 动态代理</code>，未实现接口则使用 <code>CGLIB 代理</code>，通过代理在方法调用时获取注解进行事物处理，实际在方法处理中会使用 AOP 切面编程来处理不同切入点的事件，具体的两个实现类为 <code>CglibAopProxy</code> 和 <code>JdkDynamicAopProxy</code>，切面的不同切入点 <code>advice</code> 又维护一系列的拦截方法 <code>MethodInterceptor</code>，通过方法调用时适合的拦截器会开始工作，比如我们这里的 <code>TransactionInterceptor</code> 会为方法调用包裹事物。</p>
<span id="more"></span>
<p>为什么并行流中的操作未其作用？原因在与并行流中的操作会使用 <code>Fork/Join</code> 被 <code>ForkJoinTask</code> 来执行，而该对象并没有受 Spring 代理的控制，所以在其中的方法调用并不会受注解的作用，即使我们声明了需要开启新事物。</p>
<p>更好的方法是使用手动事物：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clearAuthorBooks</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    ids.add(<span class="number">1L</span>);</span><br><span class="line">    ids.add(<span class="number">2L</span>);</span><br><span class="line">    ids.parallelStream().forEach(<span class="built_in">this</span>::newTransaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newTransaction</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">          authorRepository.findById(id).ifPresent(author -&gt; author.getBooks().clear());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Java11 集成 querydsl 报 javax.annotation.api not found</strong></li>
</ul>
<p>For those who are still fighting with the issue and when all proposed workarounds don’t work, here is what helped me (Java 11):</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// querydsl</span></span><br><span class="line">annotationProcessor     <span class="string">&#x27;com.querydsl:querydsl-apt:4.1.3:jpa&#x27;</span></span><br><span class="line">annotationProcessor     <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;</span> <span class="comment">// needed because the query dsl annotation processor doesn&#x27;t recognize javax.persistence.Entity</span></span><br><span class="line">compile                 <span class="string">&#x27;com.querydsl:querydsl-jpa:4.1.3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Taken from <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/50537096/annotationprocessor-and-dependencies">https://stackoverflow.com/questions/50537096/annotationprocessor-and-dependencies</a></p>
<p>This combination taken from <a target="_blank" rel="noopener" href="https://github.com/querydsl/querydsl/issues/2459#issuecomment-659892795">#2459 (comment)</a> also works:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">configure(querydslProjects) &#123;</span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&quot;io.spring.dependency-management&quot;</span></span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        compile(<span class="string">&quot;com.querydsl:querydsl-core&quot;</span>)</span><br><span class="line">        compile(<span class="string">&quot;com.querydsl:querydsl-jpa&quot;</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// I guess if you need another annotation processor just change jpa to whatever you want.</span></span><br><span class="line">        annotationProcessor(<span class="string">&quot;com.querydsl:querydsl-apt:$&#123;dependencyManagement.importedProperties[&#x27;querydsl.version&#x27;]&#125;:jpa&quot;</span>)</span><br><span class="line">        annotationProcessor(<span class="string">&quot;jakarta.persistence:jakarta.persistence-api&quot;</span>)</span><br><span class="line">        annotationProcessor(<span class="string">&quot;jakarta.annotation:jakarta.annotation-api&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1>Docker</h1>
<h1>Devops</h1>
<ul>
<li><strong>Jar 包加载 ClassPath 下的文件报找不到文件</strong></li>
</ul>
<blockquote>
<p>JAR 代表  <strong>Java ARchive - 归档</strong>，它是一种包文件格式，通常用于将许多 Java 类文件和关联的元数据和资源聚合到一个文件中以进行分发。JAR 文件是包含 Java 特定清单文件的存档文件。它们以 ZIP 格式构建，通常具有 .jar 文件扩展名。</p>
</blockquote>
<p>当我们使用 Spring 的 <code>ClassPathResource(&quot;files/filename&quot;)</code> 访问文件资源时，正常开发的情况下文件位于系统文件系统中，可以正常访问；当打成 JAR 包发布访问时，由于处在 JAR 特殊的 ZIP 包中，调用 <code>getFile</code> 将抛出错误，因为它不属于文件系统的文件。</p>
<p>虽然不能直接获取文件，但是还是可以通过类加载器访问到文件流或者 URL，<code>getInputStream()</code> 或 <code>getURL</code>。</p>
<h1>Java</h1>
<ul>
<li><strong>Collectors.toMap valueMapper 为 null 导致 NPE</strong></li>
</ul>
<p>Collectors.toMap 的 keyMapper 和 valueMapper 都不允许为 null，不管实际提供的 Map 实现是否支持 null。</p>
<p>它在内部使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-">Map.merge</a>，这是 JDK 的一个 <a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8148463">open bug</a>。</p>
<p>可以使用下面的写法收集流或者原始的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Boolean&gt; collect = list.stream()</span><br><span class="line">        .collect(HashMap::<span class="keyword">new</span>, (m,v) -&gt; m.put(v.getId(), v.getAnswer()), HashMap::putAll);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>面试整理</title>
    <url>/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Java-面试问题整理-2">Java 面试问题整理</h2>
<p>[TOC]</p>
<h4 id="Java-程序如何做到一次编写，到处运行-2">Java 程序如何做到一次编写，到处运行</h4>
<p>java 代码源文件经过 javac 编译期编译为 .class 文件，.class 文件不包含处理器本机代码，而是包含字节码 - JVM 的机器语言。启动器使用虚拟机运行程序。</p>
<p><img data-src="../images/java/getStarted-compiler.gif" alt="Figure showing MyProgram.java, compiler, MyProgram.class, Java VM, and My Program running on a computer."></p>
<p>由于 JVM 可在许多不同的操作系统上使用，因此相同的 .class 文件可以在不同系统上运行。</p>
<h4 id="JDK-和-JRE-的区别-2">JDK 和 JRE 的区别</h4>
<p>JRE(Java Runtime Environment) 是 JVM 执行代码的基础。JDK 是 Java 程序开发所有特性的工具，包含JRE，编译，开发和调试工具。</p>
<h4 id="JVM-内存结构-2">JVM 内存结构</h4>
<p><img data-src="../images/java/jvm/JVM_Internal_Architecture.png" alt="JVM_Internal_Architecture"></p>
<h4 id="什么是按值传递，什么是引用传递，Java-中是值传递还是引用传递-2">什么是按值传递，什么是引用传递，Java 中是值传递还是引用传递</h4>
<p>值传递：传递到方法中的形参值只是实参值的一个副本，对形参的修改不会影响之前的值；</p>
<p>引用传递：形参只是实参的别名。它指向真正的实参，对形参所做的任意修改都反映在实参中。</p>
<p>Java中都是值传递，基本类型值传递，对象类型是引用值传递，也就是说值的内容是对象的引用。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609">https://www.zhihu.com/question/31203609</a></p>
<span id="more"></span>
<h4 id="通过-new-创建-String-对象和字面量形式创建有什么区别-2">通过 new 创建 String 对象和字面量形式创建有什么区别</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量创建字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当使用 new 创建 String 对象时它总是会在堆内存中创建一个新对象，使用字面量创建时则会优先返回字符串常量池已存在的对象引用，否则，会创建一个新对象，并放入字符串池以备后用。</p>
<p>java7 之前字符串池存在在永久代，很难被回收，导致 OOM；之后移到了堆内存；</p>
<p>除了字符串池，包装类使用包装类缓存来实现同样的效果，比如 Integer、Byte、Short、Long、Character 使用内部类维护对应的缓存。</p>
<h4 id="如何跳出多重循环-2">如何跳出多重循环</h4>
<p>通过对代码块加标签的形式为代码块命名，标签为任意有效的标识符后面加冒号，通过 <code>break 标签名;</code> 跳转到代码块所在结束范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BreakLoop</span><span class="params">()</span> &#123;</span><br><span class="line">    outer:                                            <span class="comment">// 该代码块省略了花括号，也可以将代码包裹其中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Pass &quot;</span> + i + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This will not print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Loops complete.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名代码块同样适用于 <code>continue</code> 的跳转，同 goto 不同，标签块只能在自身代码块闭合范围内跳转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">continueLabel</span><span class="params">()</span> &#123;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + (i * j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态方法能否重写，静态方法能否访问非静态内容-2">静态方法能否重写，静态方法能否访问非静态内容</h4>
<p>不能，虽然子类可以包含同名静态方法，但并不属于重写。重写相对于类实例而言，子类重写父类的方法实现不同的行为，方法重写是运行时多态的重要表现。1.8 之前静态方法、变量存储在堆的永久代中，它们是 class 相关的数据，而不是实例，具体如何存储取决于 JVM，不同 JVM 略有差异</p>
<h4 id="范型能否接收原始类型或者原始类型数组-2">范型能否接收原始类型或者原始类型数组</h4>
<p>在 Java 中，泛型是通过使用“类型擦除”来实现向后兼容的。所有泛型类型都在运行时转换为 Object。所以原始类型不能作为范型的类型。</p>
<p>数组类型在 Java 中是引用类型，因为 Java 将数组看待为对象。所以原始类型的数组可以作为范型的类型。下面的写法是合法的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>[]&gt; test = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><img data-src="../images/java/reference-type.gif" alt="ReferenceType"></p>
<h4 id="hashCode-和-equals-方法主要是做什么-2">hashCode 和 equals 方法主要是做什么</h4>
<p>equasl 去比较两个对象是否相等，重写后用来比较业务相等，重写 equals 必须重写 hashCode。</p>
<p>hashCode 方法不是用于提供对象的唯一标识符，而是将对象的状态(即成员字段的值)摘要为一个整数。此值主要由某些基于哈希的数据结构(例如 Map 和集合)使用，以有效地存储和检索对象。</p>
<p>hashCode 和 equals 的一些基本约定，比如：equals 相等，hashCode 一定要相等；重写了 hashCode 也要重写 equals；hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。equals 的对称、反射、传递等特性。</p>
<h4 id="ArrayList-和-LinkedList-区别-2">ArrayList 和 LinkedList 区别</h4>
<p>ArrayList 和 LinkedList 都实现了 List 接口，顺序为添加时的顺序，可以包含重复元素。</p>
<p><code>LinkedList</code> :</p>
<ol>
<li>除了实现 List 接口外，<code>LinkedList</code> 类还为在列表的开头及结尾 <code>get</code>、<code>remove</code> 和 <code>insert</code> 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</li>
<li>通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问，LinkedList 在随机访问相对比较慢，但是它的特性集较 ArrayList 更大。</li>
<li>由双向链表实现，其中的每个对象包含数据的同时包含指向链表的前后引用。</li>
</ol>
<p><code>ArrayList</code>:</p>
<ol>
<li>它长于随机访问元素，</li>
<li>在List的中间插入和移除元素时较慢。</li>
<li>ArrayList底层由数组支持。</li>
</ol>
<h4 id="JDBC，JDBC-Driver作用-2">JDBC，JDBC Driver作用</h4>
<p>Java数据库连接（JDBC）是用于编程语言Java的应用程序编程接口（API），它定义了客户端如何访问数据库。它是一种基于Java的数据访问技术，用于Java数据库连接。</p>
<p>JDBC驱动程序提供JDBC API提供的抽象类的特定于供应商的实现。 每个驱动程序必须提供以下java.sql包类的实现：Connection，Statement，PreparedStatement，CallableStatement，ResultSet和Driver。</p>
<h4 id="DriverManager、Statement、ResultSet、PreparedStatement-2">DriverManager、Statement、ResultSet、PreparedStatement</h4>
<p>DriverManager 类是 JDBC 的管理层，作用于用户和驱动程序之间，跟踪可用的驱动程序，建立数据库和驱动程序之间的连接，记录驱动程序运行的一些信息。</p>
<p>Statement 对象用于将 SQL 语句发送到数据库中。</p>
<p>ResultSet 包含符合 SQL 语句中条件的所有行，通过一套 get 方法来获取当前行中不同列的数据。  使用 next 方法移动当前行。</p>
<h3 id="数据库连接池作用-2">数据库连接池作用</h3>
<p>关于数据库连接的打开和关闭，与数据库的交互可能是昂贵的。 特别是，当数据库客户端数量增加时，此成本非常高并且消耗了大量资源。应用程序服务器在启动时获得数据库连接池并将其维护在池中。 连接请求由驻留在池中的连接提供。 在连接结束时，请求将返回到池中，并可用于满足将来的请求。</p>
<h3 id="对象的构建顺序-2">对象的构建顺序</h3>
<p>初始化子类时，先初始化父类<br>
初始化父类的静态变量和静态代码块<br>
初始化子类的静态变量和静态代码块<br>
初始化父类的非静态变量，初始化父类的构造函数<br>
如果父类的构造函数中调用的方法被子类重写，那么调用的会是子类的方法<br>
初始化子类的非静态变量，初始化子类的构造函数</p>
<p>基类静态（按定义顺序）-&gt; 子类静态 -&gt; 基类非静态 -&gt; 基类构造 -&gt; 子类非静态 -&gt; 子类构造</p>
<h4 id="Servlet-的生命周期：-2">Servlet 的生命周期：</h4>
<p>实例化 --&gt; 初始化 --&gt; 服务 --&gt; 销毁</p>
<ol>
<li>当 servlet 第一次被调用的时候，会触发 init 函数，该函数通过web.xml配置文件由web服务器自动实例化 servlet 装载到内存， init 函数只会被调用一次</li>
<li>然后去调用  servlet 的 service 函数，由 service 方法判断请求的方式，get、post或者其它，调用相应的方法</li>
<li>当 web 应用 reload 或者关闭 tomcat 或者 关机 都会去调用 destroy 函数，该函数就去销毁 servlet</li>
</ol>
<ul>
<li>
<h4 id="表单提交数据-get-请求和-post-请求的区别：-2">表单提交数据 get 请求和 post 请求的区别：</h4>
• 从安全性看 get &lt; post, get 提交的数据会在浏览器的地址栏显示<br>
• 从提交的内容的大小来看  get &lt; post get提交的数据不能大于 2K ，而 Post 从理论上不受限制， 但是实际的变成中建议不要大于 64K<br>
• 从请求响应速度看： get &gt; post , get 要求服务器立即处理请求，而 post 请求可能形成一个队列请求</li>
</ul>
<h2 id="Java-并发问题整理-2">Java 并发问题整理</h2>
<h4 id="volatile-修饰符有什么作用-2">volatile 修饰符有什么作用</h4>
<h2 id="Java8-问题整理-2">Java8 问题整理</h2>
<h4 id="Java8-添加了哪些新特性-2">Java8 添加了哪些新特性</h4>
<p>Java8 添加了很多新特性。但最主要的是下面的内容：</p>
<ul>
<li><strong>Lambda 表达式</strong> - 一种新的语言特性，允许将操作视为对象</li>
<li><strong>方法引用</strong> - 允许直接使用方法的名称引用去定义 Lambda</li>
<li><strong>Optional</strong> - 用于表达可能存在的特殊包装类</li>
<li><strong>函数接口</strong> - 具有最多一个抽象方法的接口，可以使用 Lambda 表达式提供实现</li>
<li><strong>默认方法</strong> - 除了使用抽象方法，让我们能够在接口中添加完整的实现</li>
<li><strong>Nashorn，JavaScript 引擎</strong> - 一种基于 Java 的引擎，用于执行和评估 JavaScript 代码</li>
<li><strong>流（Stream）接口</strong> - 一个特殊的迭代器类，允许以函数方式处理对象集合</li>
<li><strong>CompletableFuture</strong> - 为复杂的异步编码提供了可行性</li>
<li><strong>Date 接口</strong> - 一个改进的，不可改变的 JodaTime 灵感的 Date API<br>
除了这些新功能外，还有很多在编译器和 JVM 级别下的功能增强。</li>
</ul>
<h4 id="什么是方法引用-2">什么是方法引用</h4>
<p>方法引用是一种 Java8 结构，它允许在不调用方法时引用方法。用于将方法视为 Lambda 表达式。它只能作为语法糖来减少一些 lambda 的冗长。比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>) -&gt; o.toString();</span><br></pre></td></tr></table></figure>
<p>可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object::toString();</span><br></pre></td></tr></table></figure>
<p>方法引用可以使用双冒号来分割类、对象名称、方法名。它有不同的变体，如构造函数引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>静态方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String::valueOf;</span><br></pre></td></tr></table></figure>
<p>绑定实例方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str::toString;</span><br></pre></td></tr></table></figure>
<p>未绑定实例方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String::toString;</span><br></pre></td></tr></table></figure>
<h4 id="什么是-Optional？我们怎么使用它？-2">什么是 Optional？我们怎么使用它？</h4>
<p>可选是 Java 8 中的一个新类，它封装了一个可选值，即是否存在的值。它是对象的包装器，您可以将其视为零或一个元素的容器。<br>
Optional 具有特殊的 Optional.empty() 值而不是被包裹的 null。因此，在许多情况下，可以使用它来代替可空值来消除 NullPointerException（NPE）。<br>
Optional 是一种返回类型的方法，以前会返回 null。这样的方法需要你编写样板代码来检查返回值，有时可能会忘记进行防御性检查。在 Java 8 中，Optional 返回类型明确要求您以不同方式处理 null 或非 null 包装值。<br>
例如，Stream.min() 方法计算值流中的最小值。但是如果流是空的呢？如果它不是 Optional，则该方法将返回 null 或抛出异常。<br>
但它返回一个 Optional 值，可能是 Optional.empty()（第二种情况）。这使我们可以轻松处理这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min1</span> <span class="operator">=</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">  .min()</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">assertEquals(<span class="number">1</span>, min1);</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="variable">min2</span> <span class="operator">=</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;)</span><br><span class="line">  .min()</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">assertEquals(<span class="number">0</span>, min2);</span><br></pre></td></tr></table></figure>
<p>Optional 不能用在实体的字段上，因为它没有实现 Serializable 接口。</p>
<h4 id="描述标准库中的一些函数接口-2">描述标准库中的一些函数接口</h4>
<p>java.util.function 包中有很多功能接口，更常见的包括但不限于：</p>
<ul>
<li><strong>Function</strong> - 它接受一个参数并返回结果 T -&gt; R</li>
<li><strong>Consumer</strong> - 它需要一个参数并且不返回接口（表示副作用）T -&gt; void</li>
<li><strong>Supplier</strong> - 它不需要参数并返回结果 () -&gt; R</li>
<li><strong>Predicate</strong> - 它需要一个参数并返回一个布尔值 T -&gt; boolean</li>
<li><strong>BiFunction</strong> - 它需要两个参数并返回一个结果 (T, U) -&gt; R</li>
<li><strong>BinaryOperator</strong> - 它类似于 BiFunction，接受两个参数并返回结果。两个参数和结果都是相同的类型 (T, T) -&gt; T</li>
<li><strong>UnaryOperator</strong> - 它类似于 Function，只接受一个参数并返回相同类型的结果 T -&gt; T</li>
</ul>
<h4 id="函数接口的作用-2">函数接口的作用</h4>
<p>函数接口为可以为 <strong>lambda 表达式</strong>和<strong>方法引用</strong>提供目标类型。</p>
<h4 id="什么是-default-方法，我们可以用来做什么-2">什么是 default 方法，我们可以用来做什么</h4>
<p>default 方法是接口中具有实现的方法。<br>
我们可以使用默认方法向接口添加新功能，同时保持与已实现接口的类的向后兼容性：<br>
通常，当一个新的抽象方法被添加到接口时，所有实现类都将中断，直到它们实现新的抽象方法。在 Java 8 中，通过使用默认方法解决了这个问题。<br>
例如，Collection 接口没有 forEach 方法声明。因此，添加此类方法只会破坏整个集合 API。<br>
Java 8 引入了默认方法，以便 Collection 接口可以具有 forEach 方法的默认实现，而不需要实现此接口的类来实现相同的方法。</p>
<h4 id="什么是-Lambda-表达式以及它用于什么-2">什么是 Lambda 表达式以及它用于什么</h4>
<p>简单来说，lambda 表达式是一个可以<strong>作为对象引用和传递</strong>的函数。<br>
Lambda 表达式引入了 Java 中的函数式处理，并有助于编写紧凑且易于阅读的代码。<br>
因此，lambda 表达式是匿名类作为方法参数的自然替代品。它们的主要用途之一是定义函数接口的内联实现。</p>
<h2 id="Spring-问题整理-2">Spring 问题整理</h2>
<h4 id="使用-Spring-有什么好处-2">使用 Spring 有什么好处</h4>
<h4 id="Spring-IOC-容器-2">Spring IOC 容器</h4>
<p>ApplicationContext 是 Spring IOC 的核心容器，它是 BeanFactory 的超集。BeanFactory 是 Spring 的核心接口，其实现类必须支持 Bean 的生命周期接口，初始化的顺序如下：</p>
<ul>
<li>
<p>BeanNameAware’s {@code setBeanName}</p>
</li>
<li>
<p>BeanClassLoaderAware’s {@code setBeanClassLoader}</p>
</li>
<li>
<p>BeanFactoryAware’s {@code setBeanFactory}</p>
</li>
<li>
<p>EnvironmentAware’s {@code setEnvironment}</p>
</li>
<li>
<p>EmbeddedValueResolverAware’s {@code setEmbeddedValueResolver}</p>
</li>
<li>
<p>ResourceLoaderAware’s {@code setResourceLoader}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ApplicationEventPublisherAware’s {@code setApplicationEventPublisher}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>MessageSourceAware’s {@code setMessageSource}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ApplicationContextAware’s {@code setApplicationContext}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ServletContextAware’s {@code setServletContext}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>{@code postProcessBeforeInitialization} methods of BeanPostProcessors</p>
</li>
<li>
<p>InitializingBean’s {@code afterPropertiesSet}</p>
</li>
<li>
<p>a custom init-method definition 自定义的 init 方法</p>
</li>
<li>
<p>{@code postProcessAfterInitialization} methods of BeanPostProcessors</p>
</li>
</ul>
<p>关闭bean工厂时，以下生命周期方法适用：<br>
 * {@ code postProcessBeforeDestruction} DestructionAwareBeanPostProcessors 的方法<br>
 * DisposableBean 的{@code destroy}<br>
 * 自定义销毁方法</p>
<h4 id="BeanFactory-和-ApplicationContext-区别-？-2"><code>BeanFactory</code> 和 <code>ApplicationContext</code> 区别 ？</h4>
<p>主要体现在容器级别之间的区别以及对引导的影响。</p>
<p>除非有充分的理由，否则应使用 ApplicationContext，将 GenericApplicationContext 及其子类 AnnotationConfigApplicationContext 作为自定义引导的常见实现。这些是用于所有常见目的的 Spring 核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册 Bean 定义和带注解的类，以及（从5.0版本开始）注册功能性 Bean 定义。</p>
<p>因为 ApplicationContext 包含 BeanFactory 的所有功能，所以通常建议在 ApplicationContext 上使用，除非需要对 Bean 处理的完全控制。在 ApplicationContext（例如 GenericApplicationContext 实现）中，按照惯例（即， 按Bean 名称或 Bean 类型（尤其是后处理器））检测多种 Bean，而普通的 DefaultListableBeanFactory 不知道任何特殊的 Bean。</p>
<p>对于许多扩展的容器功能，例如注解处理和 AOP 代理，BeanPostProcessor 扩展点至关重要。 如果仅使用普通的 DefaultListableBeanFactory，则默认情况下不会检测到此类后处理器并将其激活。 这种情况可能会造成混乱。</p>
<p>下表列出了 BeanFactory 和 ApplicationContext 接口和实现所提供的功能。</p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left"><code>BeanFactory</code></th>
<th style="text-align:left"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Bean 实例化/编织</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">集成生命周期管理</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">自动 BeanPostProcessor 注册</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">自动 BeanFactoryPostProcessor 注册</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">方便的 MessageSource 访问（用于内部化）</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">内置的 ApplicationEvent 发布机制</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<h4 id="Spring-Bean-的作用范围-2">Spring Bean 的作用范围</h4>
<ul>
<li>单例（<strong>默认</strong> 将单个bean定义范围限定为每个Spring IoC容器的单个对象实例。）</li>
<li>原型（将单个bean定义范围限定为任意数量的对象实例。）</li>
<li>request（将单个bean定义范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。）</li>
<li>session（将单个bean定义范围限定为HTTP会话的生命周期。）</li>
<li>application（将单个bean定义范围限定为ServletContext的生命周期。）</li>
<li>websocket（将单个bean定义范围限定为WebSocket的生命周期。）</li>
<li>线程 （3.0提供，但未配置）<br>
中间 request、session、application、websocket 只有在使用 Web 感知的 Spring ApplicationContext 实现（例如 <code>XmlWebApplicationContext</code> ）时，</li>
</ul>
<h4 id="Spring-Bean-的生命周期回调-2">Spring Bean 的生命周期回调</h4>
<p>生命周期回调可以用在多个方面，比如 <code>JDBC</code> 的关闭，服务的启动和销毁。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;stop&quot;)</span></span><br><span class="line"><span class="meta">@Profile(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">h2TCPServer</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> H2ConfigurationHelper.createServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要与容器的 bean 生命周期管理进行交互，可以实现 Spring <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。容器为前者调用 <code>afterPropertiesSet()</code>，为后者调用<code>destroy()</code>，让 bean 在初始化和销毁 bean 时执行某些操作。</p>
<p>JSR-250 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释通常被认为是在现代 Spring 应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的 bean 不会耦合到特定于 Spring 的接口。</p>
<p>如果您不想使用 JSR-250 注释但仍想删除耦合，请考虑使用<code>init-method</code> 和 <code>destroy-method</code> 对象定义元数据。<br>
要让注入Bean调用指定的构造方法，可以在注解 <code>@Bean</code> 中指定 <code>initMethod</code> 和 <code>destroyMethod</code> 的方法名。<br>
当这三种配置同时存在时，他们的执行顺序如下，销毁相同：</p>
<ol>
<li>使用 <code>@PostConstruct</code> 注释的方法</li>
<li>由 <code>InitializingBean</code> 回调接口定义的 <code>afterPropertiesSet()</code></li>
<li>自定义的 <code>initMethod</code> 方法<br>
当我们研究 Spring bean 的生命周期时，我们可以从对象实例化到它们的销毁等多个阶段来看。</li>
</ol>
<p>为了保持简单，<strong>我们将它们分组为创建和销毁阶段</strong>：<img data-src="../images/spring/spring-bean-lifecycle.png" alt="Spring Bean Lifecycle"></p>
<p>让我们更详细地解释这些阶段：</p>
<h5 id="Bean-创建阶段-2">Bean 创建阶段</h5>
<ul>
<li><strong>Instantiation - 实例化：</strong> Bean 的一切都是从这里开始的。Spring 实例化 bean 对象，就像我们手动创建 Java 对象实例一样。</li>
<li>**Populating Properties - 填充属性：**实例化对象后，Spring 扫描实现 <code>Aware</code> 接口的 bean，并开始设置相关属性。</li>
<li><strong>Pre-Initialization - 前置初始化：</strong> Spring 的 <code>BeanPostProcessors</code> 将在这个阶段开始工作。<code>postProcessBeforeInitialization()</code> 方法完成它们的工作。另外，带 <code>@PostConstruct</code> 注解的方法会在它们之后运行。</li>
<li><strong>AfterPropertiesSet - 填充属性后：</strong> Spring 执行实现了 <code>InitializingBean</code> 的 bean 的 <code>afterPropertiesSet()</code> 方法。</li>
<li><strong>Custom Initialization - 自定义初始化：</strong> Spring 会触发我们在 <code>@Bean</code>  注解的 <code>initMethod</code> 属性中定义的初始化方法。</li>
<li><strong>Post-Initialization - 初始化后：</strong> Spring 的 <code>BeanPostProcessors</code> 第二次运行了。此阶段触发 <code>postProcessAfterInitialization()</code> 方法。</li>
</ul>
<h5 id="Bean-销毁阶段-2">Bean 销毁阶段</h5>
<ul>
<li>**Pre-Destroy - 销毁前：**Spring 在这个阶段触发 <code>@PreDestroy</code> 注释的方法。</li>
<li><strong>Destroy - 销毁：</strong> Spring 执行实现了<code>DisposableBean</code> 的 <code>destroy()</code> 方法。</li>
<li><strong>Custom Destruction - 自定义解构:</strong> 我们可以在 <code>@Bean</code> 注解中用 <code>destroyMethod</code> 属性定义自定义销毁钩子，Spring 在最后阶段运行它们。</li>
</ul>
<h4 id="启动和停止应用回调-2">启动和停止应用回调</h4>
<p><code>Lifecycle</code> 接口为具有自己的生命周期要求的任何对象定义了基本方法（例如启动和停止某些后台进程）。<br>
当 <code>ApplicationContext</code> 接到开始或停止信号时（比如，运行时的停止/重启场景），他将级联调用上下文中的所有  <code>Lifecycle</code> 实现。具体调用会委托给 <code>LifecycleProcessor</code> 完成。<br>
默认的 Lifecycle 并没有细粒化控制自动启动，如果要对特定的 bean 自动启动，需要实现 <code>SmartLifecycle</code>。<br>
<code>DefaultLifecycleProcessor</code> 默认处理会在应用启动时检测自动启动的 Bean，并调用 start 方法。<br>
<code>depends-on</code>定义了显式的依赖，但是有时候我们只知道前后，并不确定具体依赖顺序。 <code>SmartLifecycle</code> 接口定义了另外一种方法 <code>getPhase()</code> 。<br>
启动时，phase 越小的对象最先启动；停止时，越大的越先停止。<br>
默认的 Lifecycle 的 phase 是 0，因此，负值表示这个对象比标准组件启动快。<br>
在非 web 项目中，可以通过在 JVM 中注册关闭钩子实现关闭回调，<code>registerShutdownHook()</code> 方法定义在 <code>ConfigurableApplicationContext</code> 接口中。</p>
<h4 id="元数据是什么，Spring-的配置元数据来自于哪-2">元数据是什么，Spring 的配置元数据来自于哪</h4>
<p>元数据是描述其他数据的数据。 Meta 是一种前缀，在大多数信息技术中，用法意味着“基础定义或描述”。元数据总结了有关数据的基本信息，可以更轻松地查找和处理特定的数据实例。<br>
配置元数据来自于多个方面，包含但不局限于：</p>
<ul>
<li>注解配置</li>
<li>java 配置类</li>
<li>xml 配置文件</li>
</ul>
<h4 id="Spring-是否支持运行时注册新-Bean-2">Spring 是否支持运行时注册新 Bean</h4>
<p>在运行时注册新bean（并发实时访问工厂）不受官方支持，并且可能导致并发访问异常，bean容器中的不一致状态，或两者兼而有之。</p>
<h4 id="Spring-是否支持添加用户自己注册的实例对象-2">Spring 是否支持添加用户自己注册的实例对象</h4>
<p>除了包含有关如何创建特定 bean 信息的 bean 定义之外， <code>ApplicationContext</code> 实现还允许注册在容器外部（由用户）创建的现有对象。这是通过 <code>getBeanFactory()</code> 方法访问 <code>ApplicationContext</code> 的 <code>BeanFactory</code> 来完成的，该方法返回 <code>BeanFactory</code> 的 <code>DefaultListableBeanFactory</code> 实现。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和 <code>registerBeanDefinition(..)</code> 方法支持此注册。</p>
<h4 id="Spring-Bean-命名约定-2">Spring Bean 命名约定</h4>
<p>bean 名称以小写字母开头，并从那里开始驼峰。此类名称的示例包括 accountManager，accountService，userDao，loginController 等。<br>
但是，在（不常见的）特殊情况下，当有多个字符并且第一个和第二个字符都是大写字母时，原始大小写将会保留。这些规则与 <code>java.beans.Introspector.decapitalize</code>（Spring 在此处使用）中定义的规则相同。</p>
<h4 id="实例化-Bean-方式-2">实例化 Bean 方式</h4>
<ul>
<li>构造方法实例化（空的构造方法），或者注入依赖（代参构造）</li>
<li>静态工厂方法实例化</li>
<li>实例工厂方法实例化<br>
如果要为静态嵌套类配置 bean 定义，则必须使用嵌套类的二进制名称。</li>
</ul>
<p>例如，如果在 com.example 包中有一个名为 SomeThing 的类，并且此 SomeThing 类具有一个名为 OtherThing 的静态嵌套类，则 bean 定义上的 class 属性值将为com.example.SomeThing$OtherThing。</p>
<p>请注意，在名称中使用 <code>$</code> 字符可以将嵌套类名与外部类名分开。</p>
<h4 id="使用-xml-和注解配置-Bean-区别-2">使用 xml 和注解配置 Bean 区别</h4>
<p>xml 通常将这些 bean 配置为顶级 <beans /> 元素内的 <bean /> 元素；<br>
使用 xml 配置 bean 时，我们需要指明 bean 的实现类类名，以便反射实例化注册到容器，就是上述描述的方法；</p>
<p><code>@Bean</code> 注解大多用在 <code>@Configuration</code> 配置类中；<br>
使用注解时，我们可以显式的去返回对象的实例来进行配置，实例时也可以传入其他实例方法来依赖Bean，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="keyword">public</span> Foo <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Foo</span>(bar());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="keyword">public</span> Bar <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 bean 直接调用同一个类中的其他 @Bean 方法时，不得将@Configuration 类及其工厂方法标记为 final 或 private，因为它需要在运行时对每个这样的配置类进行 CGLIB 子类化。<br>
在 @Component 组件或者普通对象中直接调用其它 @Bean 方法也不可行，因为这是标准的Java方法调用，Spring不会通过 CGLIB 代理拦截调用。</strong></p>
<p>也可以加入其它注解来共同配置 Bean，比如：</p>
<ul>
<li><strong>@Profile</strong> – 允许选择性地根据配置包含某些bean</li>
<li><strong>@Scope</strong> – 更改 bean 的范围</li>
<li><strong>@Lazy</strong> – 仅在默认单例范围的情况下起作用</li>
<li><strong>@DependsOn</strong> – 在创建此 bean 之前强制创建特定的其他bean。</li>
<li><strong>@Primary</strong> – 是一种解决注入点级别歧义的机制，如果需要按类型匹配来注入Bean，但是符合类型的有多个。</li>
<li><strong>@Order</strong> – 设置优先级</li>
</ul>
<h4 id="已经有了-ref-引用依赖，为什么需要-Depend-on-2">已经有了 ref 引用依赖，为什么需要 Depend-on</h4>
<ul>
<li>可能 Bean 之间不是显式的依赖，但的确需要有初始化顺序</li>
<li>当多个 Bean 存在循环依赖关系时</li>
<li>或者仅仅想在一个 Bean 之前初始化另一个 Bean</li>
</ul>
<h4 id="依赖注入的两种方式-2">依赖注入的两种方式</h4>
<ul>
<li>基于构造方法依赖注入（调用具有多个参数的构造方法)</li>
<li>基于 Setter 的依赖注入</li>
<li>混合使用<br>
由于您可以混合基于构造函数和基于 setter 的 DI ，因此将构造函数用于强制依赖项和 setter 方法或可选依赖项的配置方法是一个很好的经验法则。请注意，在 setter 方法上使用 <code>@Required</code> 注释可用于使属性成为必需的依赖项。<br>
Spring 团队通常提倡<strong>构造函数注入</strong>，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为null.此外，构造函数注入的组件总是以完全初始化的状态返回到客户端（调用）代码。作为旁注，大量的构造函数参数是一个糟糕的代码气味，暗示该类可能有太多的责任，应该重构以更好地解决关注点的正确分离。<br>
Setter 注入应主要仅用于可在类中指定合理默认值的可选依赖项。否则，必须在代码使用依赖项的任何位置执行非空检查。 setter 注入的一个好处是 setter 方法使该类的对象可以在以后重新配置或重新注入。因此，通过 JMX MBean 进行管理是二次注入的一个引人注目的用例。</li>
</ul>
<h4 id="Spring-AOP-的编织是在什么时候-2">Spring AOP 的编织是在什么时候</h4>
<p>运行时，也就是说都是动态代理。 AspectJ 是在编译时。</p>
<h3 id="如何扩展-Spring-容器-2">如何扩展 Spring 容器</h3>
<p>通常，我们不需要子类化 <code>ApplicationContext</code> 实现类。相反，可以通过插入特殊集成接口的实现来扩展 Spring IOC 容器。</p>
<ul>
<li>
<p>使用 <code>BeanPostProcessor</code> 来自定义 Beans</p>
<p>BeanPostProcessor 接口定义了回调方法，你可以去实现它以提供自己的（或覆盖容器的默认）实例化逻辑，依赖解析逻辑，等等。如果要在 Spring 容器完成实例化，配置和初始化 bean 之后实现某些自定义逻辑，则可以插入一个或多个 BeanPostProcessor 实现。</p>
<p>该工厂钩子允许自定义修改新 bean 实例，例如检查标记接口或用代理包装它们。 ApplicationContexts 可以在其 bean 定义中自动检测 BeanPostProcessor bean，并将它们应用于随后创建的任何 bean。</p>
<p>该接口默认包含两个默认方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span><br></pre></td></tr></table></figure>
<p>该方法在任何 bean 初始化回调之前将此 BeanPostProcessor 应用于给定的新bean实例（如 InitializingBean 的 afterPropertiesSet 或自定义 init 方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span><br></pre></td></tr></table></figure>
<p>在任何 bean 初始化回调（如 InitializingBean 的 afterPropertiesSet 或自定义 init 方法）之后，将此 BeanPostProcessor 应用于给定的新 bean 实例。</p>
</li>
<li>
<p>使用 <code>BeanFactoryPostProcessor</code> 来自定义配置元数据</p>
<p>BeanFactoryPostProcessor 对 bean 的配置元数据进行操作。也就是说，Spring IOC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并允许在容器实例化除 BeanFactoryPostProcessor 实例之外的任何 bean 之前更改元数据。</p>
<p>比如：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"><code>PropertyPlaceholderConfigurer</code></a> 该配置器可以读取配置文件中的占位符，并从外部文件或环境变量等拿到相应的值替换占位符：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们可以在指定的外部文件中定义相应的属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driverClassName</span>=<span class="string">org.hsqldb.jdbcDriver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://production:9002</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>在配置文件找不到相应的属性时，默认也会从环境变量去寻找。你也可以自定寻找策略通过配置 <code>systemPropertiesMode</code> 。</p>
</li>
<li>
<p>使用 <code>FactoryBean</code> 自定义实例化逻辑</p>
<p>FactoryBean 接口是 Spring IOC 容器实例化逻辑的可插拔点。如果你有一个复杂的初始化代码，用 Java 表示比较好，而不是（可能）冗长的 XML，你可以创建自己的 FactoryBean，在该类中编写复杂的初始化，然后将自定义 FactoryBean 插入容器。</p>
</li>
</ul>
<h3 id="注解是否比-XML-配置-Spring-更好？-2">注解是否比 XML 配置 Spring 更好？</h3>
<p>每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，注解在其声明中提供了大量上下文，从而导致更短更简洁的配置。但是，XML 擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将配置靠近源，而另一些开发人员则认为注释类不再是 POJO，而且配置变得分散且难以控制。</p>
<p>无论选择如何，Spring 都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java">JavaConfig</a> 选项，Spring 允许以非侵入方式使用注释，而无需触及目标组件源代码。</p>
<p>在注入 XML 之前执行注解注入。因此，XML 配置会覆盖通过这两种方法连接的相同属性的注解。</p>
<h3 id="Sprng-AOP-代理机制？-2">Sprng AOP 代理机制？</h3>
<p>Spring AOP 使用 JDK 动态代理或 CGLIB 为给定目标对象创建代理。（只要有选择，JDK 动态代理就是首选）。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用 JDK 动态代理。目标类型实现的所有接口都是代理的。如果目标对象未实现任何接口，则会创建 CGLIB 代理。</p>
<p>这是因为 CGLIB 默认会继承目标对象，然后重写被代理方法，所以必须要求被代理类不为 final 类，代理方法也不能为 final 类型。代理类如果有接口，也会通过实现接口的方法代理。CGLIB 是第三方框架，基于 ASM 提供的字节码操作。</p>
<p>JDK 动态代理是通过实现目标对象接口来代理方法的，所以只能代理接口暴露出去的方法。它是纯 java 实现。</p>
<p>CGLIB 和 JDK 动态代理都是在代理运行时动态生成 class 文件达到动态代理的目的。</p>
<p>静态代理唯一的缺点就是我们需要对每一个方法编写我们的代理逻辑，造成了工作的繁琐和复杂。AspectJ 就是为了解决这个问题，在编译成 class 字节码的时候在方法周围加上业务逻辑。复杂的工作由特定的编译器帮我们做。所以会有 AOP 有切面(Aspect)、连接点(joinpoint)、通知(advice)、切入点(Pointcut)、目标对象(target)等概念来定义代理的逻辑。</p>
<h2 id="JPA-问题整理-2">JPA 问题整理</h2>
<h3 id="HQL-和-JPQL-区别-2">HQL 和 JPQL 区别</h3>
<p>Hibernate Query Language（HQL）和 Java Persistence Query Language（JPQL）都是以对象模型为中心的查询语言，与 SQL 本质上类似。JPQL 是一个受 HQL 影响很大的子集。但是，JPQL 查询始终是有效的 HQL 查询，反之则不然。</p>
<p>HQL 和 JPQL 都是非类型安全的方法来执行查询操作。 Criteria 查询提供了一种类型安全的查询方法。</p>
<h2 id="Spring-Security-问题整理-2">Spring-Security 问题整理</h2>
<h4 id="Spring-Security-如何实现认证和授权-2">Spring-Security 如何实现认证和授权</h4>
<h4 id="说一下-Spring-Security-几个重要的对象？-2">说一下 Spring-Security 几个重要的对象？</h4>
<ul>
<li><code>SecurityContextHolder</code>， 提供对 <code>SecurityContext</code> 的访问。</li>
<li><code>SecurityContext</code>，保存 <code>Authentication</code> 和可能的特定于请求的安全信息。</li>
<li><code>Authentication</code>，以 Spring Security 特定的方式表示认证主体（一般为用户信息） principal。</li>
<li><code>GrantedAuthority</code>，反映授予主体的应用程序范围的权限。</li>
<li><code>UserDetails</code>，提供从应用程序的 DAO 或其他安全数据源构建 Authentication 对象所需的信息。</li>
<li><code>UserDetailsService</code>，在基于字符串的用户名（或证书 ID 等）中传递时创建 UserDetails。</li>
</ul>
<h2 id="Elasticsearch-问题整理-2">Elasticsearch 问题整理</h2>
<h4 id="为什么选择使用-Elasticsearch-2">为什么选择使用 Elasticsearch</h4>
<h4 id="Elatiscsearch-如何选择查询-2">Elatiscsearch 如何选择查询</h4>
<h4 id="Elasticsearch-的索引和-Mysql-索引优势在哪里-2">Elasticsearch 的索引和 Mysql 索引优势在哪里</h4>
<h4 id="如何实现类似-SQL-的-Like-查询-2">如何实现类似 SQL 的 Like 查询</h4>
<h2 id="Redis-问题整理-2">Redis 问题整理</h2>
<h4 id="Redis-的基本类型有哪些-2">Redis 的基本类型有哪些</h4>
<p>Redis 是一个开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。</p>
<h2 id="数据库-问题整理-2">数据库 问题整理</h2>
<h4 id="Mysql-底层如何存放数据-2">Mysql 底层如何存放数据</h4>
<h4 id="如何优化-SQL-2">如何优化 SQL</h4>
<h2 id="Kafka-问题整理-2">Kafka 问题整理</h2>
<h4 id="如何提高消息吞吐量-2">如何提高消息吞吐量</h4>
<h5 id="生产者-6">生产者</h5>
<ul>
<li>
<p>开启消息压缩</p>
<p><code>compression.type</code>：默认情况，消息不会被压缩。这个属性可以设置压缩算法：<code>gzip</code>, <code>snappy</code>, <code>lz4</code>, <code>zstd</code>。<code>zstd</code> 和 <code>gzip</code> 比较平衡。</p>
</li>
<li>
<p>等待更多的消息进入批次</p>
<p><code>linger.ms</code>：生产者在发送批次之前等待更多的消息加入批次的时间。增大这个值会增加延迟但可以提高吞吐量。</p>
</li>
<li>
<p>增大批次处理量</p>
<p><code>max.in.flight.requests.per.connection</code>：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
</li>
<li>
<p>分配合理的分区数和消费者个数</p>
</li>
</ul>
<h4 id="如何保证消息顺序-2">如何保证消息顺序</h4>
<p>Kafka 可以保证同一个分区里的消息是有序的。也就是说，如果生产者按照一定的顺序发送消息，broker 就会按照这个顺序把它们写入分区，消费者也会按照同样的顺序读取它们。</p>
<p><strong>使用单个分区能最大程度保证消息的顺序，或者消息使用相同的 key。还需注意下面的配置。</strong></p>
<h5 id="生产者-7">生产者</h5>
<p><code>retries</code>：生产者从服务器收到错误时的重试次数</p>
<p><code>max.in.flight.requests.per.connection</code>：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
<p>消息是否写入成功也是非常关键的，如果把 <code>retries</code> 设为非零整数，同时把 <code>max.in.flight.requests.per.connection</code> 设为比 1 大的数，那么第一批消息写入失败，而第二批写入成功，broker 重试第一个批次。此时第一个批次写入成功，那么两个批次的顺序就反了。</p>
<p>为了保证写入的顺序，不建议把 <code>retries</code> 设为 0。可以把 <code>max.in.flight.requests.per.connection</code> 设为 <strong>1</strong>，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker。不过这样的会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下。</p>
<h4 id="如何保证消息被消费-Exactly-Once-3">如何保证消息被消费 Exactly-Once</h4>
<p>由于各种故障，消息传递系统无法保证生产者和使用者应用程序之间的消息传递。根据客户端应用程序与此类系统交互的方式，可能会出现以下消息语义：</p>
<ul>
<li>如果消息传递系统永远不会复制消息，但可能会漏掉偶尔的消息，则我们称 <em><strong>最多一次 (at-most-once)</strong></em></li>
<li>如果它永远不会丢失一条消息，但可能会重复一条消息，则我们至少将其 <em><strong>至少一次 (at-least-once)</strong></em></li>
<li>如果它发送所有消息时总是不重复，那将是 <em><strong>恰好一次 (exactly-once)</strong></em></li>
</ul>
<p>要保证消息只发送一次，得保证生产者发送给服务器的消息只成功一次，消费者也只消费一次。Kafka 代理和客户端应用引入事物可确保进行一次准确的交付。</p>
<h5 id="生产者-8">生产者</h5>
<p><code>acks</code>：该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有影响。</p>
<ul>
<li><code>acks=0</code> 不需要确认</li>
<li><code>acks=1</code> 需要集群首领确认。首领确认纪录后失败，如果跟随者还没复制，则记录可能丢失。</li>
<li><code>acks=all</code> 集群首领及其追随者都确认后，才会收到成功响应。安全性更高，吞吐率下降。</li>
</ul>
<p><code>enable.idempotence</code>：当设置为 “true” 时，生产者将确保每个消息的仅有一个副本被写入流中。如果为 “false”，则生产者由于代理失败等原因而重试，可能会将重试消息的副本写入流中。 请注意，启用幂等性要求 <code>max.in.flight.requests.per.connection</code> 小于或等于 5，重试大于 0，<code>ack</code> 必须为 “<strong>all</strong>”。 如果用户未明确设置这些值，则将选择合适的值。 如果设置了不兼容的值，则将引发 ConfigException。</p>
<h6 id="幂等操作-2">幂等操作</h6>
<p>由于生产者出错重试会导致消息重复，所以为了生产者成功提交的消息恰好一次，可以使用幂等操作来保证。如果发生导致生产者重试的错误，则相同的消息（仍由生产者多次发送）将仅写入到代理上的 Kafka 日志一次。对于单个分区，幂等生产者发送消除了由于生产者或代理错误而产生重复消息的可能性。要启用此功能并为每个分区获取一次精确的语义（即没有重复，没有数据丢失和有序的语义），请将生产者配置为 <code>enable.idempotence = true</code>。</p>
<h6 id="事物-4">事物</h6>
<p>生产者通过设定事物 Id (<code>transactional.id</code>)，然后开启事物。</p>
<h5 id="消费者-3">消费者</h5>
<h6 id="事物-5">事物</h6>
<p><code>isolation.level</code>：控制如何读取事务写入的消息。如果设置为 <code>read_committed</code>，consumer.poll() 将仅返回已提交的事务性消息。如果设置为 <code>read_uncommitted</code>（<strong>默认</strong>），consumer.poll() 将返回所有消息，甚至是已中止的事务性消息。非事务性消息在两种方式下都返回。</p>
<h6 id="手动提交-3">手动提交</h6>
<p><code>enable.auto.commit</code>：该属性决定是否自动提交偏移量，默认为 true。为了避免数据出现重复和丢失，可以通过手动提交的方式自行提交偏移量。</p>
<h4 id="是什么使-Kafka-如此之快-3">是什么使 Kafka 如此之快</h4>
<h5 id="低延迟消息传递-3">低延迟消息传递</h5>
<p>Kafka 通过顺序 IO 操作日志避免了长时间的磁盘寻道；</p>
<p>零复制原则，避免了内核上下文和应用上下文的文件读取和发送，直接在系统内核上下文中进行文件读取和发送，避免了上下文切换的时间消耗和内存占用。</p>
<p>传统数据复制方法</p>
<p><img data-src="../images/middleware/kafka/data-copying.gif" alt="Traditional data copying approach"></p>
<p>零复制使用 <code>java.nio.channels.FileChannel.transferTo()</code></p>
<p><img data-src="../images/middleware/kafka/zero-copying.gif" alt="Data copy with transferTo()"></p>
<h5 id="批处理数据和压缩-3">批处理数据和压缩</h5>
<p>高效压缩将同一批次的消息压缩在一起，并保持压缩在日志中，并且仅由使用者解压缩。支持的压缩算法：Zstd、Snappy、GZip 或 LZ4。</p>
<h5 id="水平扩展-3">水平扩展</h5>
<p>首先让我们了解什么是垂直扩展。可以说，对于传统的数据库服务器，当负载增加时，一种解决方法是添加更多资源，例如：CPU，RAM，SSD 等。这称为垂直扩展。它具有以下几个缺点：</p>
<ul>
<li>每个硬件都有局限性，不能无限地向上扩展。</li>
<li>如果机器出现故障怎么办？通常需要停机。</li>
</ul>
<p><strong>水平扩展</strong>通过添加更多机器来解决相同的问题。 Kafka 能够为单个主题提供数千个分区，并将其分布在数千台计算机中，这意味着 Kafka 可以处理巨大的负载。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
        <tag>Hibernate</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程入门</title>
    <url>/concurrency/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>线程安全性</h1>
<p>要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变（Mutable）的状态的访问。</p>
<p>对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包含其他依赖对象的域。</p>
<p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：</p>
<ul>
<li>不在线程之间共享该状态变量</li>
<li>该状态变量修改为不可变的变量</li>
<li>在访问状态变量时使用同步</li>
</ul>
<span id="more"></span>
<h2 id="什么是线程安全性？"><strong>什么是线程安全性？</strong></h2>
<p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么称这个类是线程安全的。</p>
<p><strong>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</strong></p>
<p><strong>无状态对象一定是线程安全的。</strong></p>
<h2 id="活跃性与性能问题">活跃性与性能问题</h2>
<p>安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注于另一个目标，即“某件正确的事情最终会发生”。当某个操作无法继续执行下去时，就会发生活跃性问题。串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。</p>
<p>多线程中将遇到各种形式的活跃性问题，包括死锁、饥饿、以及活锁等。</p>
<p>与活跃性问题密切相关的是性能问题，活跃性意味着某件正确的事情最终会发生，但却不够好。因为我们通常希望正确的真情尽快发生。性能问题包括多个方面，例如服务时间过长、响应不灵敏、吞吐率过低、资源消耗过高、或者可伸缩性较低等。</p>
<h2 id="原子性"><strong>原子性</strong></h2>
<p>假定有两个操作 A 和 B，如果从执行 A 的线程来看，当另一个线程执行 B 时，要么将 B 全部执行完，要么完全不执行 B，那么 A 和 B 对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。</p>
<p>我们将“先检查后执行”以及“读取 — 修改 — 写入”等操作统称为符合操作。</p>
<h3 id="竞态条件">竞态条件</h3>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气。</p>
<h2 id="加锁机制">加锁机制</h2>
<p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<h3 id="内置锁">内置锁</h3>
<p>Java 提供内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态方法的 synchronized 方法以 Class 对象作为锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">  <span class="comment">// 访问或修改由锁保护的共享状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Java 对象都可以用作一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或者监视器锁（Monitor Lock）。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。</p>
<p>Java 的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。</p>
<h3 id="重入">重入</h3>
<p>由于**内置锁是可重入的，**因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。</p>
<p>重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为 1 。如果同一个线程再次获取这个锁时，计数值将递增，而当线程退出同步代码块时，计数器会相应递减。当计数值为 0 时，这个锁将被释放。</p>
<h3 id="用锁来保护状态">用锁来保护状态</h3>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们成状态变量是由这个锁保护的。</p>
<p>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。</p>
<p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。</p>
<h3 id="活跃性与性能">活跃性与性能</h3>
<p>当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络 I/O 或控制台 I/O），一定不要持有锁。</p>
<h1>对象的共享</h1>
<h2 id="可见性">可见性</h2>
<p>同步代码块和同步方法不仅可以确保以原子的方式执行操作，同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防治某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一个意想不到的调整，这种现象被称为“重排序（Reordering）”，在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p>
<h3 id="失效数据">失效数据</h3>
<p>在缺乏同步的程序中可能产生错误结果的一种情况：失效数据。</p>
<h3 id="非原子的-64-位操作">非原子的 64 位操作</h3>
<p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前的某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air-safety）。</p>
<p>最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量（double 和 long）。</p>
<p>Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量， JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。</p>
<h3 id="加锁及可见性">加锁及可见性</h3>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<h3 id="Volatile-变量">Volatile 变量</h3>
<p>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p>
<p><strong>加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。</strong></p>
<p>当且仅当满足以下所有条件时，才应该使用 volatile 变量：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其它状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
<h2 id="发布与逸出">发布与逸出</h2>
<p>“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出（Escape）。</p>
<ul>
<li>发布对象最简单的方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看到该对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knowSecrets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123; </span><br><span class="line">    knowSecrets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Secret&gt;();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发布对象还会发布其非私有字段引用的任何对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeStates</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span> ...&#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 getStates 方法发布对象，会导致任何对象都可以修改这个数组的内容。</p>
<ul>
<li>最后一种发布对象或其内部状态的机制就是发布一个内部的类实例。如 <code>ThisEscape</code> 所示，当 <code>ThisEscape</code> 发布 <code>EventListener</code> 时，也隐含地发布了 <code>ThisEscape</code> 实例本身，因为在这个内部类的实例中包含了对 <code>ThisEscape</code> 实例的隐含调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener( <span class="keyword">new</span> <span class="title class_">ThisEscape</span>.EventListener() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123; doSomething(e); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>安全的对象构造过程</strong></p>
<p>在 ThisEscape 中给出了逸出的一种特殊示例，即 this 引用在构造函数中逸出。当且仅当对象的构造函数返回时，对象才处于可预测和一致的状态。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造。</p>
<p>不要在构造函数中使 this 引用逸出。</p>
<p>如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SafeListener</span><span class="params">()</span> &#123;</span><br><span class="line">        listener = <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123; doSomething(e); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title function_">newInstance</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        <span class="type">SafeListener</span> <span class="variable">safe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeListener</span>();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程封闭">线程封闭</h2>
<p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（<code>Thread confinement</code>）。它是实现线程安全性的最简单方式之一。</p>
<p>线程封闭技术最常见的应用是 JDBC 的 <code>Connection</code> 对象。由于大多数请求都是由单个线程采用同步的方式来处理，并且在 Connection 对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将 Connection 对象封闭在线程中。</p>
<p>Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal 类，但程序员仍然需要确保封闭在线程中的对象不会从线程中逸出。</p>
<h3 id="栈封闭">栈封闭</h3>
<p>栈封闭是线程封闭的一种特例。在栈封闭中，只能通过变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中；它们位于执行线程的栈中，其他线程无法访问这个栈。</p>
<h3 id="ThreadLocal">ThreadLocal</h3>
<p>维持线程封闭性的一种更规范方法是使用 <code>ThreadLocal</code>，这个类能使线程中的某个值与线程关联起来。 <code>ThreadLocal</code> 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。</p>
<h3 id="不变性">不变性</h3>
<p>满足同步需求的另一种方法是使用不可变对象（Immutable Object）。如果某个对象在被创建后其状态就不能被修改，那么这个对象就被称为不可变对象。</p>
<p>不可变对象一定是线程安全的。</p>
<p>当满足以下条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是 final 类型（或最终 final）</li>
<li>对象是正确创建的（在对象的创建期间，this 引用没有逸出）</li>
</ul>
<p>保存在不可变对象中的程序状态仍然可以更新，即通过将一个保存新状态的实例来“替换”原有的不可变对象。</p>
<h3 id="Final-域">Final 域</h3>
<p>final 用于构造不可变性对象。final 类型的域是不能修改的。</p>
<blockquote>
<p>如果 final 引用的是对象，则指引用不可变，对象的堆数据可以被修改；在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，具体指类加载后准备阶段，如果没有 final，会先为<strong>类成员变量设置初始值-零值</strong>，编译器发现有 final 时类变量将被直接赋值。</p>
</blockquote>
<p>正如“除非需要更高的可见性，否则应该将所有的域都声明为私有域”是一个良好的编程习惯。“除非需要某个域是可变的，否则应将其声明为 final 域”也是一个良好的编程习惯。</p>
<h3 id="安全发布">安全发布</h3>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
<p>这种保证还将延伸到被正确创建对象中所有 final 类型的域。在没有额外同步的情况下，也可以安全地访问 final 类型的域。然而，如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。</p>
<p>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中</li>
<li>将对象的引用保存到某个正确构造对象的 final 类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>在线程安全容器内部的同步意味着，将对象放入到某个容器，例如 Vector 或 synchronizedList 时，将满足上述最后一条需求。</p>
<p>通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>静态初始化器由 JVM 在类的初始化阶段执行。由于在 JVM 内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<h4 id="事实不可变对象">事实不可变对象</h4>
<p>如果对象从技术来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。</p>
<p>在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
<p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p>
<ul>
<li><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li><strong>只读共享</strong>。在没有额外的同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需用进一步的同步。</li>
<li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Lock</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork/Join 框架入门</title>
    <url>/concurrency/ForkJoin-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>fork/join 框架在 Java 7 中呈现。它提供了一些工具，通过尝试使用所有可用的处理器内核来帮助加速并行处理 - 这是通过分而治之的方法实现的——分治算法。</p>
<p><strong>Java 8 的并行流背后使用的基础架构就是该框架。</strong></p>
<p>在实践中，这意味着框架首先“fork(分叉)”，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行，也就是任务分发。</p>
<p>之后，“join(并入)”部分开始，其中所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待直到执行每个子任务，也就是任务细分执行，并等待返回。</p>
<p>为了提供有效的并行执行，fork/join 框架使用一个名为 <code>ForkJoinPool</code> 的线程池，它管理 <code>ForkJoinWorkerThread</code> 类型的工作线程。</p>
<span id="more"></span>
<h2 id="ForkJoinPool">ForkJoinPool</h2>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ForkJoinPool.html">ForkJoinPool</a> 是框架的核心。它是 <code>ExecutorService</code> 的一个实现，它管理工作线程并为我们提供工具来获取有关线程池状态和性能的信息。</p>
<p>工作线程当时只能执行一个任务，但 ForkJoinPool 不会为每个子任务创建单独的线程。相反，池中的每个线程都有自己的双端队列（或deque），用于存储任务。</p>
<p>这种架构对于在<strong>工作窃取算法</strong>的帮助下平衡线程的工作负载至关重要。</p>
<h3 id="工作窃取算法-Work-stealing">工作窃取算法 (Work stealing)</h3>
<p><strong>简单地说 - 空闲线程试图从繁忙线程的双端队列中“窃取”工作。</strong></p>
<p>默认情况下，工作线程首先优先处理来自它们自己的队列（LIFO 或 FIFO，取决于模式）的任务。其次线程从另一个忙线程的双端队列尾部或全局入口队列中获取任务。</p>
<p>这种方法最大限度地减少了线程竞争任务的可能性。它还减少了线程必须寻找工作的次数，因为它首先在最大可用工作块上工作。</p>
<h3 id="ForkJoinPool-实例化">ForkJoinPool 实例化</h3>
<p>在 Java 8 中，访问 ForkJoinPool 实例的最方便方法是使用其静态方法 <code>commonPool()</code>。顾名思义，这将提供对公共池的引用，公共池是. 每个 ForkJoinTask 的默认线程池。</p>
<p>根据 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">Oracle 文档</a>，使用预定义的公共池可以减少资源消耗，因为这会阻止为每个任务创建单独的线程池。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">commonPool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br></pre></td></tr></table></figure>
<p>通过创建 ForkJoinPool 并将其分配给工具类 (PoolUtil) 的公共静态字段，可以在 Java 7 中实现相同的行为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br></pre></td></tr></table></figure>
<p>然后，可以很容易的访问：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> PoolUtil.forkJoinPool;</span><br></pre></td></tr></table></figure>
<p>使用 ForkJoinPool 的构造函数，可以创建具有特定级别的并行性，线程工厂和异常处理程序的自定义线程池。<strong>默认空构造</strong>使用当前可用的处理器核心 - <code>Runtime.getRuntime().availableProcessors()</code>。</p>
<h3 id="小心使用-commonPool">小心使用 commonPool</h3>
<p>很多时候，我们使用提供一些基于并行处理的功能的内置结构或框架。在大多数情况下，我们可以指定我们自己的线程池，它将在并行处理期间使用，但有时，我们不想指定我们自己的线程池，而只是使用当前库的默认值。每个库都有自己的方法来定义默认线程池。例如，Spring 框架在大多数情况下使用线程池，为每个任务创建一个新线程。</p>
<p><code>ForkJoinPool#commonPool()</code> 是一个静态线程池。JDK 中主要使用 commonPool 的两个主要功能为：<code>CompletableFuture</code> 和 <code>Parallel Streams</code>。这两个功能之间有一个小区别：使用 <code>CompletableFuture</code>，您可以指定自己的线程池并且不使用来自 <code>commonPool</code> 的线程，而在 <code>Parallel Streams</code> 的情况下则不能。</p>
<p>在决定是否使用 <code>commonPool</code> 的决策过程中要记住的关键是我们传递到线程池的任务的目的。一般来说，有两种类型的任务：计算和阻塞。</p>
<p>在计算任务的情况下，我们创建了一个绝对避免任何阻塞的任务，例如 I/O 操作（数据库调用、同步、线程睡眠等…）。您的任务在哪个线程上运行无关紧要，您可以让 CPU 保持忙碌并且不等待任何资源。这时候我们可以随意使用 commonPool 来执行工作。</p>
<p>但是，如果您打算使用 commonPool 来执行阻塞任务，那么您需要考虑一些后果。 如果您有三个以上的可用 CPU，那么您的 commonPool 会自动调整为两个线程，并且您可以通过将线程保持在阻塞状态来非常轻松地阻止同时使用 commonPool 的系统的任何其他部分的执行。<strong>根据经验，我们可以为阻塞任务创建自己的线程池，并使系统的其余部分保持分离和可预测</strong>。</p>
<p><strong>根本原因的有关 commonPool 的隐藏陷阱：即 commonPool 在计算时会使用多少线程。该值由 JVM 基于可用内核的数量自动计算。</strong></p>
<p>我们使用下面的代码进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CPU Core: &quot;</span> + Runtime.getRuntime().availableProcessors());</span><br><span class="line">        System.out.println(<span class="string">&quot;CommonPool Parallelism: &quot;</span> + ForkJoinPool.commonPool().getParallelism());</span><br><span class="line">        System.out.println(<span class="string">&quot;CommonPool Common Parallelism: &quot;</span> + ForkJoinPool.getCommonPoolParallelism());</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = IntStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">                .mapToObj(i -&gt; CompletableFuture.runAsync(CommonPoolTest::blockingOperation))</span><br><span class="line">                .collect(Collectors.toUnmodifiableList());</span><br><span class="line"></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(CompletableFuture[]::<span class="keyword">new</span>)).join();</span><br><span class="line">        System.out.println(<span class="string">&quot;Processed in &quot;</span> + Duration.ofNanos(System.nanoTime() - start).toSeconds() + <span class="string">&quot; sec&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blockingOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以注意到我们上面有一个非常简单的阻塞调用实现。执行 100 次 1 秒阻塞调用的迭代。让我们看看结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --cpus 4 -v $&#123;PWD&#125;:/app --workdir /app adoptopenjdk/openjdk11 java CommonPoolTest.java</span><br><span class="line">CPU Core: 4</span><br><span class="line">CommonPool Parallelism: 3</span><br><span class="line">CommonPool Common Parallelism: 3</span><br><span class="line">Processed in 34 sec</span><br></pre></td></tr></table></figure>
<p>我们为这次运行分配了 4 个 CPU，并在 34 秒内完成了这个程序。我们可以看到 JVM 自动发现它是在一个Docker 容器中执行的，并限制了 4 个CPU和 3 个专用线程来执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --cpus 2 -v $&#123;PWD&#125;:/app --workdir /app adoptopenjdk/openjdk11 java CommonPoolTest.java</span><br><span class="line">CPU Core: 2</span><br><span class="line">CommonPool Parallelism: 1</span><br><span class="line">CommonPool Common Parallelism: 1</span><br><span class="line">Processed in 1 sec</span><br></pre></td></tr></table></figure>
<p>在第二个例子中，我们只使用了 2 个 CPU，我们可以注意到 JVM 自动将并行度限制为 1。但是为什么只用了 1 秒？1 秒内到底发生了什么？！</p>
<p>您可以在 <code>commonPool</code> 中实现三种模式。</p>
<ul>
<li><em><strong>parallelism &gt; 2</strong></em> — JDK 为 <code>commonPool</code> 创建 (CPUs - 1) 个线程</li>
<li><em><strong>parallelism = 1</strong></em> — JDK 为每个提交的任务创建一个新线程</li>
<li><em><strong>parallelism = 0</strong></em> — 提交的任务在调用者自身的线程上执行</li>
</ul>
<p>parallelism 默认为 -1，则执行如下判断，也就是当前 CPUs - 1，单核 CPU 则为 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">    (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">    parallelism = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果要覆盖 JDK 的符合人机工程学的行为，还可以指定三个系统属性：</p>
<ul>
<li><strong>java.util.concurrent.ForkJoinPool.common.parallelism</strong></li>
<li><strong>java.util.concurrent.ForkJoinPool.common.threadFactory</strong></li>
<li><strong>java.util.concurrent.ForkJoinPool.common.exceptionHandler</strong></li>
</ul>
<h2 id="ForkJoinTask-V">ForkJoinTask<V></h2>
<p><img data-src="../../images/java/stream/fork-join-task.png" alt="ForkJoinTask"></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/ForkJoinTask.html">ForkJoinTask</a> 是 ForkJoinPool 中执行的任务的基本类型。在实践中，一般使用下列两个子类中的一个：</p>
<ul>
<li>void 任务的 <code>RecursiveAction</code></li>
<li>返回值的任务的 <code>RecursiveTask &lt;V&gt;</code>。</li>
</ul>
<p>它们都有一个抽象方法 <code>compute()</code>，该方法定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便拆分时，生成单个子任务结果的逻辑。该方法的实现类似于下面的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (任务足够小或不可分) &#123;</span><br><span class="line">    顺序计算该任务</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有确切的标准决定一个任务是否应该再拆分。递归的任务拆分过程如图所示：</p>
<p><img data-src="../../images/java/stream/fork-join.jpg" alt="fork join"></p>
<h3 id="RecursiveAction-–-例子">RecursiveAction – 例子</h3>
<p>为了演示框架的分支行为， 我们以将 String 递归地划分为指定长度的子串为例，使用 <code>createSubtask()</code> 方法创建基于这些子串的 CustomRecursiveTask 实例，在<strong>workload.length() 大于指定的长度阈值时，该 String 将被分割。</strong></p>
<p>因此，该方法返回 List <CustomRecursiveAction>。 使用 invokeAll() 方法将该集合提交给 ForkJoinPool 来执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRecursiveAction</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">workload</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> </span><br><span class="line">      Logger.getAnonymousLogger();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRecursiveAction</span><span class="params">(String workload)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.workload = workload;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workload.length() &gt; THRESHOLD) &#123;</span><br><span class="line">            ForkJoinTask.invokeAll(createSubtasks());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           processing(workload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> List&lt;CustomRecursiveAction&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CustomRecursiveAction&gt; subtasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">partOne</span> <span class="operator">=</span> workload.substring(<span class="number">0</span>, workload.length() / <span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">partTwo</span> <span class="operator">=</span> workload.substring(workload.length() / <span class="number">2</span>, workload.length());</span><br><span class="line"> </span><br><span class="line">        subtasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveAction</span>(partOne));</span><br><span class="line">        subtasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveAction</span>(partTwo));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> subtasks;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processing</span><span class="params">(String work)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> work.toUpperCase();</span><br><span class="line">        logger.info(<span class="string">&quot;This result - (&quot;</span> + result + <span class="string">&quot;) - was processed by &quot;</span></span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此模式可用于开发自己的 RecursiveAction 类。要执行此操作，请创建一个表示工作总量的对象，选择合适的阈值，定义分割工作的方法，并定义执行工作的方法。</p>
<h3 id="RecursiveTask-V">RecursiveTask<V></h3>
<p>对于返回值的任务，此处的逻辑类似，除了每个子任务的结果在一个结果中合并：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRecursiveTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomRecursiveTask</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> ForkJoinTask.invokeAll(createSubtasks())</span><br><span class="line">              .stream()</span><br><span class="line">              .mapToInt(ForkJoinTask::join)</span><br><span class="line">              .sum();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> processing(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Collection&lt;CustomRecursiveTask&gt; <span class="title function_">createSubtasks</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;CustomRecursiveTask&gt; dividedTasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveTask</span>(</span><br><span class="line">          Arrays.copyOfRange(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>)));</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> <span class="title class_">CustomRecursiveTask</span>(</span><br><span class="line">          Arrays.copyOfRange(arr, arr.length / <span class="number">2</span>, arr.length)));</span><br><span class="line">        <span class="keyword">return</span> dividedTasks;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">processing</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(arr)</span><br><span class="line">          .filter(a -&gt; a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">27</span>)</span><br><span class="line">          .map(a -&gt; a * <span class="number">10</span>)</span><br><span class="line">          .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，工作由存储在 CustomRecursiveTask 类的 arr 数组字段表示。createSubtask() 方法递归地将任务划分为较小的工作，直到每个部分小于阈值。然后，invokeAll() 方法将子任务提交给线程池 ForkJoinPool 并返回 Future 列表。</p>
<p>要触发执行，为每个子任务调用 join() 方法。</p>
<p>在这个例子中，这是使用 Java 8 的 Stream API  的 sum() 方法用于将子结果组合到最终结果中。</p>
<h2 id="将任务提交到-ForkJoinPool">将任务提交到 ForkJoinPool</h2>
<p>要将任务提交到线程池，只有很少的方法可以使用。 <code>submit()</code> 或 <code>execute()</code> 方法（它们的用例是相同的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">forkJoinPool.execute(customRecursiveTask);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> customRecursiveTask.join();</span><br></pre></td></tr></table></figure>
<p><code>invoke()</code> 方法分叉任务并等待结果，不需要任何手动加入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.invoke(customRecursiveTask);</span><br></pre></td></tr></table></figure>
<p><code>invokeAll()</code> 方法是将 ForkJoinTasks 集合提交给 ForkJoinPool 的最方便的方法。 它将任务作为参数（两个任务，var args 或集合），forks 它们按照生成它们的顺序返回 Future 对象的集合。</p>
<p>或者，您可以使用单独的 <code>fork()</code> 和 <code>join()</code> 方法。 fork() 方法将任务提交给池，但它不会触发它的执行。 join() 方法用于执行。在 RecursiveAction 的情况下，join() 只返回 null；对于 RecursiveTask <V>，它返回任务执行的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customRecursiveTaskFirst.fork();</span><br><span class="line">result = customRecursiveTaskLast.join();</span><br></pre></td></tr></table></figure>
<p>在我们的 RecursiveTask <V> 示例中，我们使用 invokeAll() 方法向池提交一系列子任务。使用 fork() 和 join() 可以完成相同的工作，但这会对结果的排序产生影响。</p>
<p>为避免混淆，使用 invokeAll() 方法向 ForkJoinPool 提交多个任务通常是个好主意。</p>
<h2 id="结论">结论</h2>
<p>使用 fork/join 框架可以加速处理大型任务，但要实现这一结果，应遵循一些指导原则：</p>
<ul>
<li><strong>使用尽可能少的线程池</strong> - 在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池</li>
<li><strong>请使用默认的公共线程池</strong> - 如果不需要特定调整</li>
<li><strong>使用合理的阈值</strong>将 ForkJoingTask 拆分为子任务</li>
<li><strong>避免在 ForkJoingTasks 中出现任何阻塞</strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Parallel Stream</tag>
        <tag>ForkJoinPool</tag>
        <tag>Fork/Join</tag>
        <tag>Work stealing</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap</title>
    <url>/data-structure/Java-HashMap-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1>基础</h1>
<p>我们先大概瞥一眼 JDK 1.7 之前的 HashMap 结构：</p>
<p><img data-src="../../images/java/hashmap/hashmap.jpg" alt="HashMap"></p>
<p>简而言之，<code>HashMap</code> 是由数组组成的一定数量的桶（<code>bucket</code>）。在进行存储时，使用 <code>key</code> 的 <code>hashcode()</code> 通过 <strong><code>hash</code> 函数</strong>计算得到  <code>hash</code> 值，然后通过 **<code>hash 值 % 数组长度</code>**来确定将 <code>Entry(key + value)</code> 放入数组的哪个桶里。</p>
<span id="more"></span>
<blockquote>
<p>为什么要用 <code>hashcode</code> 来确定位置？</p>
<p>为了高效的定位元素在数组中的位置，以及使放入的元素尽可能均匀的分布在数组中。</p>
<p>正确实现 hashcode() 方法返回的 hash 值可以达到散列分布的目的，同样的键也会返回相同的 hash 值，因此我们使用 hash 信息来确定元素在数组中的下标信息以达到快速访问。</p>
</blockquote>
<p>如果 hash 函数足够完美，将能实现数据的均匀分配，此时时间复杂度为 O(1)。但是开发者通常会编写较差的哈希函数，这将导致分布不均。</p>
<blockquote>
<p>散列函数也被用于对称、非对称加密算法、签名或摘要（Digest）算法中，比如：MD 加密、SHA 加密</p>
</blockquote>
<p><img data-src="../../images/java/hashmap/buckets.png" alt="Bad hashmap"></p>
<h2 id="Hash-碰撞及解决（Collision）">Hash 碰撞及解决（Collision）</h2>
<p>此时数组将会有很大一部分被浪费，而且含多不同的键将会产生相同的 hash 值**（hash 碰撞）**。</p>
<p><img data-src="../../images/java/hashmap/hash%20collision.png" alt="Hash function"></p>
<h3 id="负载因子与容量">负载因子与容量</h3>
<p>为了解决这个问题，一方面，我们可以增大哈希值的取值空间来减少冲突的可能性，比如使 hash 表大于所需的总数据量。期望只要有哈希表的 70 % 被占用就足够。存储元素的个数和哈希表桶的数量的比值就叫做<strong>负载因子（Load factor）</strong>。<br>
$$<br>
\begin{align*}<br>
Load \quad Factor = \frac{Total \quad number \quad of \quad items \quad stored} {Size \quad of \quad the \quad Buckets \quad array}<br>
\end{align*}<br>
$$</p>
<p>负载因子的值通常是可配置的，并在时间和空间成本之间进行权衡，下图是负载因子值调低调高时的影响。</p>
<p><img data-src="../../images/java/hashmap/tradeoff-time-space.png" alt="Tradeoff Time And Space"></p>
<p>Java 中 <code>HashMap</code> 的默认负载因子是 <code>0.75</code>，也就是说只要哈希表的 75 % 被占用就足够了。</p>
<p>容量（<code>Capacity</code>） 在 <code>Java HashMap</code> 中指桶的数量，也就是负载因子的被除数。</p>
<p><code>Java HashMap</code> 的默认初始容量为 <code>16</code>，即存储区数组在首次插入时被延迟初始化。</p>
<p>当插入的元素到达一定的阈值，HashMap 将会扩容来重新计算哈希，该阈值的计算公式为：<br>
$$<br>
Threshold = (Current Capacity) * (Load Factor)<br>
$$<br>
以 HashMap 的默认值计算，则为：<br>
$$<br>
Threshold = 16 * 0.75 = 12<br>
$$<br>
也就是说当插入第 13 个元素后会进行扩容为之前的两倍 <code>oldThreshold &lt;&lt; 1</code>，此时将发生重新哈希（<code>Rehashing</code>），由于重新哈希处理增加了存储桶的数量，因此降低了负载因子。</p>
<p><img data-src="../../images/java/hashmap/rehashing.gif" alt="Rehashing"></p>
<blockquote>
<p>为什么 HashMap 加载因子默认是 0.75？</p>
<p>这个跟一个统计学里很重要的原理——泊松分布有关。</p>
<p>泊松分布是统计学和概率学常见的离散概率分布，适用于描述单位时间内随机事件发生的次数的概率分布。</p>
<p><img data-src="../../images/java/hashmap/poisson-distribution.png" alt="Poisson distribution"><br>
等号的左边，P 表示概率，N 表示某种函数关系，t 表示时间，n 表示数量。等号的右边，λ 表示事件的频率。</p>
<p>在理想情况下，使用随机哈希码，在扩容阈值（加载因子）为 0.75 的情况下，节点出现在频率在 Hash 桶（表）中遵循参数平均为 0.5 的泊松分布。忽略方差，即 X = λt，P(λt = k)，其中 λt = 0.5的情况。</p>
<p>所以我们可以知道，其实常数 0.5 是作为参数代入泊松分布来计算的，而加载因子 0.75 是作为一个条件，当 HashMap 长度为length/size ≥ 0.75 时就扩容，在这个条件下，冲突后的拉链长度和概率结果为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br></pre></td></tr></table></figure>
<p>计算结果如上述的列表所示，当一个桶中的链表长度达到 8 个元素的时候，概率为 0.00000006，几乎是一个不可能事件。</p>
<p>选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择。</p>
</blockquote>
<h3 id="寻址">寻址</h3>
<p>另一方面，为了给冲突元素一个合适的位置存储，我们将解决方案从寻址方向上分为两个大类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">开放式寻址（Open Addressing）</th>
<th style="text-align:center">闭合式寻址（Closed Addressing）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通过在哈希表数组本身中搜索另一个空存储桶来处理冲突。</td>
<td style="text-align:center">键始终存储在散列到的桶中。在每个桶的基础上使用单独的数据结构来处理冲突。</td>
</tr>
<tr>
<td style="text-align:center">每个桶中最多存放一个键。</td>
<td style="text-align:center">每个桶存储任意键数。</td>
</tr>
<tr>
<td style="text-align:center">理论最大负载系数为1。</td>
<td style="text-align:center">没有理论上的最大负载系数。</td>
</tr>
<tr>
<td style="text-align:center">哈希表数组的大小必须始终至少与哈希表中键的数量一样大。</td>
<td style="text-align:center">性能随着负载系数的增长而降低。</td>
</tr>
</tbody>
</table>
<h4 id="开放式寻址相关技术">开放式寻址相关技术</h4>
<ul>
<li>线性探测（<code>Linear Probing</code>）</li>
<li>二次方探测（<code>Quadratic Probing</code>）</li>
<li>再哈希（<code>Double hashing</code>）</li>
<li>罗宾汉哈希（<code>Robin Hood hashing</code>）</li>
<li>等</li>
</ul>
<p>插入和查找扫描阵列的顺序在实现之间有所不同。下面介绍一些常用技术。 （所有索引均以数组长度为模。）</p>
<h5 id="线性探测">线性探测</h5>
<p>如果在存储区 i 中发生冲突，搜索序列将使用下列索引继续：</p>
<ul>
<li><em>i</em> + 1</li>
<li><em>i</em> + 2</li>
<li><em>i</em> + 3</li>
<li>…</li>
</ul>
<p>由于探测序列在内存中是线性的，因此该方法可实现良好的缓存性能。</p>
<h5 id="二次方探测">二次方探测</h5>
<p>通过二次方探测，从存储桶 i 开始的搜索序列如下：</p>
<ul>
<li><em>i</em> + 1<sup>2</sup></li>
<li><em>i</em> + 2<sup>2</sup></li>
<li><em>i</em> + 3<sup>2</sup></li>
<li>…</li>
</ul>
<h5 id="再哈希">再哈希</h5>
<p>使用二次哈希（另一个哈希函数）双重哈希，h 用于确定搜索序列中步骤的大小。如果 h<sub>2</sub>(key) = j，则从存储区 i 开始的搜索序列如下：</p>
<ul>
<li><em>i</em> + 1 × <em>j</em></li>
<li><em>i</em> + 2 × <em>j</em></li>
<li><em>i</em> + 3 × <em>j</em></li>
</ul>
<p>（如果 j 恰好等于数组长度的倍数，则使用 1 代替。）</p>
<p><img data-src="../../images/java/hashmap/open-addressing.png" alt="Comparison of Probing Techniques"></p>
<h4 id="闭合式寻址相关技术">闭合式寻址相关技术</h4>
<ul>
<li>使用链表单独存储 hash 相同的键值（拉链法）</li>
<li>使用动态数组单独存储 hash 相同的键值</li>
<li>使用自平衡二叉树</li>
</ul>
<p><strong>Java HashMap 是结合第一种和第三种的实现。</strong></p>
<p><img data-src="../../images/java/hashmap/hashmap-tree.png" alt="HashMap"></p>
<h1>HashMap</h1>
<p><img data-src="../../images/java/hashmap/hashmap-1.8.png" alt="HashMap JDK 1.8"></p>
<p>先总体了解下 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html"><code>HashMap</code></a> 作为集合类的特性：</p>
<ul>
<li>
<p>HashMap 的键值都不能存储基本类型</p>
<p>要存储基本类型提高性能，可以使用 <a target="_blank" rel="noopener" href="https://github.com/eclipse/eclipse-collections/blob/master/docs/guide.md#primitive-maps"><code>Eclipse Collection</code> 的原始类型集合类</a>。</p>
</li>
<li>
<p>支持一个 null 键和多个 null value</p>
</li>
<li>
<p>键必须唯一，重复的键值将被后面的值替代</p>
</li>
<li>
<p>使用哈希技术存储索引，所以不保证插入顺序</p>
</li>
<li>
<p>非线程安全，需自己保证同步</p>
<p>可以使用 <code>Collections.synchronizedMap(new HashMap(...));</code> 包裹，或使用 <code>HashTable</code>，<code>ConcurrentHashMap</code>，后者性能更高</p>
</li>
<li>
<p>快速失败机制</p>
<p>在 Java 非线程安全的集合类中，遍历集合中，对集合做额外的操作比如调用新增、删除会立即停止当前操作并抛出 <code>ConcurrentModificationException</code>，在 HashMap 中使用 <code>modCount</code> 记录修改次数，如果遍历中该记录和开始时不相同，则报错。</p>
<p>可以使用 <code>Iterator</code> 接口安全的移除元素，一般集合会实现安全的移除操作。但是多线程环境下得保证 <code>Iterator</code> 实现类的线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">20</span>, <span class="number">0.75f</span>);</span><br><span class="line"><span class="keyword">final</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().getKey().equals(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove(); <span class="comment">// ok!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java 8 removeIf</span></span><br><span class="line">hashMap.entrySet().removeIf(stringStringEntry -&gt; stringStringEntry.getKey().equals(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标记了 <strong>Serializeable</strong> 和 <strong>Cloneable</strong> 接口</p>
</li>
</ul>
<h2 id="数组桶">数组桶</h2>
<p>在代码中，桶数组用如下变量表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>这里需要注意几点：</p>
<ul>
<li>
<p>桶数组并没有在构造方法中初始化，而是在第一次使用时才会分配内存，比如 <code>put</code>、<code>compute</code>、<code>merge</code> 等。</p>
</li>
<li>
<p>当分配内存时，长度总是 2 的幂次方。</p>
<blockquote>
<p>为什么选择 2 的幂次方？</p>
<p>由于为了达到高效处理性能，很多操作都是通过位运算完成。比如其中的 <code>hash</code> 方法，计算桶索引等，后面会详细说明。</p>
</blockquote>
</li>
<li>
<p>如果初始化时传入的桶的容量 <code>capacity</code> 不是 2 的幂次方，将会使用<a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">该位运算算法</a>增加到最近的 2 次幂。</p>
</li>
</ul>
<h2 id="单链表">单链表</h2>
<p>每个桶内部由链表组成，在代码中为类 <code>Node&lt;K, V&gt;</code> 的实例，此类是 HashMap 类的静态内部类，并且实现 <code>Map.Entry&lt;K, V&gt;</code> 接口，此节点的表示形式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;			<span class="comment">// 使用 hash 定位桶</span></span><br><span class="line">        <span class="keyword">final</span> K key;				<span class="comment">// 节点存放的 key</span></span><br><span class="line">        V value;						<span class="comment">// 节点存放的 值</span></span><br><span class="line">        Node&lt;K,V&gt; next;     <span class="comment">// 指向链表的下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap-如何计算桶索引？">HashMap 如何计算桶索引？</h2>
<p>之前我们提到计算索引是使用哈希函数计算的 <code>hash</code> 值和桶数组长度求余，但是求余的效率并没有直接按位运算的高。同样我们需要借助一些<a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html#ModulusDivisionEasy">位运算的技巧</a>，这里 n 为桶数组的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = hash(key) &amp; (n-<span class="number">1</span>)  <span class="comment">// 相当于求 hash(key) % n，当 n 为 2 的次幂且不为 0 时成立</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 函数求 hash 值  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，为什么这里 hash 函数需要将高位数据移位到低位进行异或运算呢？这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</p>
<p>计算桶索引并不只是发生在 <code>put</code> 方法时，在调用 <code>get</code>、<code>contains</code>、<code>remove</code> 时都会调用 <code>hash</code> 方法重新计算 <code>hash</code> 值并在计算桶索引。</p>
<h2 id="为什么桶内不使用-ArrayList-或-LinkedList？">为什么桶内不使用 ArrayList 或 LinkedList？</h2>
<p>HashMap 内部使用单向链表来维护哈希冲突的元素，但为什么不用数组或双向链表，这其实是一个平衡后的考虑：</p>
<ul>
<li><code>ArrayList</code> 使用较少的空间，检索速度快，但是最坏的情况下插入和删除元素的时间复杂度可能为 <strong><code>O(n)</code></strong></li>
<li><code>LinkedList</code> 双向链表使用更多空间维护前后节点信息，但是插入或删除元素的时间复杂度为 <strong><code>O(1)</code></strong></li>
</ul>
<p>使用<strong>单向链表</strong>的好处在于，其既可以使空间相对较少，也能保证删除和插入的时间复杂度为 <code>O(1)</code>。但是如果链表过长，最坏的可能是所有元素都放入一个桶里，此时时间复杂度将变为 <code>O(n)</code>。为了优化这一点，<code>JDK 1.8</code> 使用了红黑树来优化链表过长的情况。</p>
<p>当桶数组的长度超过 <code>MIN_TREEIFY_CAPACITY</code> 且桶中的元素超过 <code>TREEIFY_THRESHOLD</code> 值时，链表转为红黑树。</p>
<p>当桶中元素减少至 <code>UNTREEIFY_THRESHOLD</code> 时，红黑树退回到链表。</p>
<h2 id="为什么桶内元素过长时用红黑树？">为什么桶内元素过长时用红黑树？</h2>
<p><img data-src="../../images/java/hashmap/red-black-tree.jpg" alt="Red Black Tree"></p>
<p>因为当大量哈希冲突的时候会导致节点链表越来越长从而降低 <code>HashMap</code> 性能。而红黑树为<strong>自平衡二叉搜索树</strong>，重新平衡并不完美，但保证在 <code>O(logN)</code> 时间内搜索，其中 <code>n</code> 是树的节点数。插入和删除操作，以及树的重排和重新着色，也在 <code>O(logN)</code> 时间内执行。 <strong>因此在数据量大的且桶中冲突较大的散列表中红黑树比单向链表更有优势。</strong></p>
<p>**本质上这是个安全问题。**因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个很长的链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端 CPU 大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p>
<p><strong>为什么选择红黑树而不是二叉树或绝对平衡二叉树呢？</strong><br>
首先，二叉树在极端情况下依然会形成链表。例如 1,2,3,4 的 <code>hashCode</code> 相同时，二叉树退化成链表；<br>
再是，绝对平衡就好像有强迫症一样把精力消耗在如何达到平衡上，因此造成不必要的性能开销；<br>
而红黑树它是一棵自平衡树但不是绝对平衡树，优点有以下：</p>
<ol>
<li>树属于折半查找，于较长的链表相比查询效率要高</li>
<li>自平衡树解决了二叉树的计算情况问题（二叉树退化成链表）</li>
<li>非绝对平衡树比绝对平衡树在增删节点时要高效一些</li>
</ol>
<p>因此红黑树是综合性能较强的树型数据结构。</p>
<h1>LinkedHashMap</h1>
<img data-src="../../images/data-structure/linked-hash-map-uml.png" alt="linked-hash-map-uml" style="zoom:50%;" />
<p>我们知道 HashMap 使用 <code>hash</code> 函数定位桶，桶内部使用单向链表存储冲突元素，不能保证插入的顺序。<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedHashMap.html"><code>LinkedHashMap</code></a> 继承了 HashMap，在原有的数据结构基础上，将所有桶内元素通过双向链表链接起来，该链表定义了迭代的顺序，默认是数据插入的顺序，也可以配置为访问顺序。转换为红黑树时也维护链表。</p>
<blockquote>
<p>如果将键重新插入映射中，则插入顺序不会受到影响。</p>
</blockquote>
<p><img data-src="../../images/data-structure/linked-hash-map.png" alt="LinkedHashMap"></p>
<p>该实现提供了顺序保证，但是并没有增加时间复杂度，和 HashMap 一样还是 <code>O(1)</code>。TreeMap 由于使用了红黑树来提供顺序保证，所以时间复杂度为 <code>O(logN)</code>。</p>
<h2 id="构建">构建</h2>
<h3 id="Insert-Order-LinkedHashMap">Insert Order LinkedHashMap</h3>
<p>我们可以使用其它 Map 来生成一个 LinkedHashMap 的拷贝，而不用管之前的实现。很适合一种以无序输入开始，最后保留该顺序的副本操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Map m)</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>(m);</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Access-Order-LinkedHashMap">Access Order LinkedHashMap</h3>
<p>还提供了一个特殊的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html#LinkedHashMap-int-float-boolean-">构造函数</a>来创建一个迭代顺序为上次访问顺序的 LinkedHashMap。访问顺序从最近最少访问到最近最多访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                     <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                     <span class="type">boolean</span> accessOrder)</span></span><br><span class="line">  </span><br><span class="line">构造一个具有指定初始容量、加载因子和排序模式的空 LinkedHashMap 实例。</span><br><span class="line">  </span><br><span class="line">参数:</span><br><span class="line">initialCapacity - 初始化桶容量</span><br><span class="line">loadFactor - 负载因子</span><br><span class="line">accessOrder - 排序模式 - <span class="literal">true</span> 为访问顺序 access-order, <span class="literal">false</span> 为插入顺序 insertion-order</span><br></pre></td></tr></table></figure>
<p>这种 Map <strong>非常适合构建 LRU (Least recently used) 缓存</strong>。而且提供了一个可重写移除旧元素的 protected 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该方法很容易构建一个首先丢弃最近最少使用的项目的 LRU 缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用特殊的构造方法，传入 true 为访问顺序，最近最多访问在前</span></span><br><span class="line">        <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">java</span>.util.LinkedHashMap&lt;Integer, Integer&gt; (capacity, <span class="number">0.75f</span>, <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义put后的移除规则，大于容量就删除eldest</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发性">并发性</h2>
<p>和 <code>HashMap</code> 一样，<code>LinkedHashMap</code> 的实现也不是同步的，<strong>非线程安全</strong>。因此，如果您打算从多个线程访问它，并且这些线程中至少有一个可能会在结构上改变它，那么必须从外部进行同步。最容易的实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m</span> <span class="operator">=</span> Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>());</span><br></pre></td></tr></table></figure>
<p>与 HashMap 的区别在于需要进行结构修改。在按<strong>访问顺序（access-ordered</strong>）链接的哈希映射中，仅调用 <em>get</em> API 时会导致结构修改。除此之外，还有诸如 <em>put</em> 和 <em>remove</em> 之类的操作。</p>
<h2 id="和-TreeMap-比较">和 TreeMap 比较</h2>
<p>以下是 TreeMap、HashMap 和 LinkedHashMap 之间的重要区别。</p>
<table>
<thead>
<tr>
<th>No.</th>
<th style="text-align:center"><strong>关键点</strong></th>
<th style="text-align:center">TreeMap</th>
<th style="text-align:center">HashMap</th>
<th style="text-align:center">LinkedHashMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">元素的顺序</td>
<td style="text-align:center">插入到 TreeMap 中的元素根据其键的自然顺序进行排序，或者通过在 Map 创建时提供的 <code>Comparator</code> 进行排序，具体取决于使用的构造函数。</td>
<td style="text-align:center">HashMap 不保证 Map 的顺序，也不保证顺序随时间保持不变。</td>
<td style="text-align:center">LinkedHashMap 默认遵循元素的插入顺序，并维护插入元素的顺序。</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">内部实现</td>
<td style="text-align:center">TreeMap 的内部实现不允许存储 null 键，但允许 null 值。</td>
<td style="text-align:center">HashMap 允许存储一个 null 键以及多个 null 值。</td>
<td style="text-align:center">LinkedHashmap 的内部实现与 HashMap 相似，因此允许存储一个 null 键和多个 null 值。</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">时间复杂度</td>
<td style="text-align:center">TreeMap 的 get、put 和 remove 操作的时间复杂度都是 O(logN)，比 HashMap 大。</td>
<td style="text-align:center">HashMap 在 get、put 和 remove 操作的情况下具有 O(1) 的复杂性。</td>
<td style="text-align:center">LinkedHashMap 具有与 HashMap 相同的复杂度，即 O(1)。</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">继承</td>
<td style="text-align:center">TreeMap 实现了 Collection 框架的 <code>SortedMap</code> 接口，它是 Map 的子代。TreeMap 内部实现了红黑树（一种自平衡二叉搜索树）。</td>
<td style="text-align:center">HashMap 实现了简单的 Map 接口，并在内部使用散列来存储和检索其元素。</td>
<td style="text-align:center">LinkedHashMap 扩展了 HashMap 并在内部像 HashMap 一样使用散列。</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">索引性能</td>
<td style="text-align:center">与 HashMap 和 LinkedHashMap 相比，TreeMap 维护其元素的顺序，因此性能指标较低，并且需要更多内存。</td>
<td style="text-align:center">HashMap 不维护其元素的任何插入顺序，因此与 TreeMap 相比更快，也不根据其值对其元素进行排序，因此也比 LinkedHashMap 更快。</td>
<td style="text-align:center">LinkedHashMap 比 TreeMap 快，但比 HashMap 慢。</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">比较</td>
<td style="text-align:center">TreeMap 中的元素通过使用 compareTo() 方法进行比较，其中也可以提供自定义实现。</td>
<td style="text-align:center">HashMap 使用 Object 类的 compare() 方法进行元素比较。</td>
<td style="text-align:center">LinkedHashMap 也使用 Object 类的 compare() 方法进行元素比较。</td>
</tr>
</tbody>
</table>
<h1>参考资料</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://programming.guide/hash-tables-open-vs-closed-addressing.html#:~:text=Also%20known%20as%20open%20hashing,the%20bucket%20it's%20hashed%20to.">hash-tables-open-vs-closed-addressing</a> 开放寻址和闭合寻址比较</li>
<li><a target="_blank" rel="noopener" href="https://programming.guide/hash-tables-open-addressing.html">hash-tables-open-addressing</a> 介绍开放式寻址</li>
<li><a target="_blank" rel="noopener" href="https://programming.guide/hash-tables.html">hash-tables</a> hash table 实现</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>LinkedHashMap</tag>
        <tag>Red–black tree</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>Map.merge()</title>
    <url>/data-structure/Map.merge()/</url>
    <content><![CDATA[<h1>Map.merge()</h1>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)">Map.merge()</a> 在键值范围中可能是功能最丰富的操作。而且还比较晦涩，很少使用。 merge() 可以解释如下：如果键值不存在（if absent），将新值放在给定键下；否则使用给定值更新现有键（UPSERT）。让我们从最基本的示例开始：计算唯一单词的出现次数。Java 8 之前的实现比较麻烦：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">prev</span> <span class="operator">=</span> map.get(word);</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        map.put(word, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(word, prev + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是，它可以工作，并且对于给定的输入会产生所需的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">words</span> <span class="operator">=</span> List.of(<span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Buzz&quot;</span>, <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Buzz&quot;</span>, <span class="string">&quot;Fizz&quot;</span>, <span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#123;Bar=<span class="number">1</span>, Fizz=<span class="number">2</span>, Foo=<span class="number">3</span>, Buzz=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>让我们尝试对其进行重构以避免条件逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    map.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">    map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>真好！ <code>putIfAbsent()</code> 必不可少，否则，代码将在首次出现以前未知的单词时中断。另外，我在 <code>map.put()</code> 中发现 <code>map.get(word)</code> 有点别扭。让我们也摆脱它！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    map.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">    map.computeIfPresent(word, (w, prev) -&gt; prev + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>仅当存在相关单词时，<code>computeIfPresent()</code> 才调用给定的转换，否则什么都不做。我们通过将键初始化为零来确保键存在，因此后面的增加转换始终有效。我们可以做得更好吗？通过减少额外的初始化，但是我不建议这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt;</span><br><span class="line">        map.compute(word, (w, prev) -&gt; prev != <span class="literal">null</span> ? prev + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>compute()</code> 与 <code>computeIfPresent()</code> 类似，但是无论给定键是否存在都被调用。如果键的值不存在，则 <code>prev</code> 参数为 <code>null</code>。将 if 判断隐藏在 lambda 中的三元表达式远非最佳。这是 <code>merge()</code> 运算符的亮点。在向您展示最终版本之前，让我们看一下 <code>Map.merge()</code> 的默认简化实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> V <span class="title function_">merge</span><span class="params">(K key, V value, BiFunction&lt;V, V, V&gt; remappingFunction)</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(key);</span><br><span class="line">    <span class="type">V</span> <span class="variable">newValue</span> <span class="operator">=</span> (oldValue == <span class="literal">null</span>) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span> (newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码段价值一千个字。 <code>merge()</code> 在两种情况下工作。如果给定的键不存在，它将变成 <code>put(key，value)</code>。但是，如果给定键已经具有某个值，那么我们的 <code>remappingFunction</code> 会合并（移除）旧的值和给定值。此功能可如下使用：</p>
<ul>
<li>使用新值覆盖旧值：<code>(old, new) -&gt; new</code></li>
<li>保留旧值：<code>(old, new) -&gt; old</code></li>
<li>以某种方式合并两者，例如：<code>(old, new) -&gt; old + new</code></li>
<li>甚至删除旧值：<code>(old, new) -&gt; null</code></li>
</ul>
<p>如您所见，merge() 非常通用。那么我们的问题使用 merge() 怎么做？非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt;</span><br><span class="line">        map.merge(word, <span class="number">1</span>, (prev, one) -&gt; prev + one)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>解释如下：如果单词不存在，该单词初始值为 1，否则将 1 添加到现有值。我将参数之一命名为 “one”，因为在我们的示例中，它始终是……1。遗憾的是 <code>remappingFunction</code> 需要两个参数，其中第二个是我们将要更新（新增或修改）的值。从技术上讲，我们已经知道此值，因此 <code>(word, 1, prev -&gt; prev + 1)</code> 将更容易理解。但是没有这样的 API。</p>
<p>好的，但是 merge() 真的有用吗？假设您有一个帐户操作（省略了构造函数，getter 和其他有用的属性）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String accNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及针对不同帐户的一系列操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">operations</span> <span class="operator">=</span> List.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1200&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;-4&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;8&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;800&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;-1500&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;2&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;-6.5&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;-600&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们想计算每个帐户的余额（总操作金额）。没有 <code>merge()</code>，这将很麻烦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">balances</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, BigDecimal&gt;();</span><br><span class="line"> </span><br><span class="line">operations.forEach(op -&gt; &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">key</span> <span class="operator">=</span> op.getAccNo();</span><br><span class="line">    balances.putIfAbsent(key, BigDecimal.ZERO);</span><br><span class="line">    balances.computeIfPresent(key, (accNo, prev) -&gt; prev.add(op.getAmount()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是在 merge() 的帮助下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">operations.forEach(op -&gt;</span><br><span class="line">        balances.merge(op.getAccNo(), op.getAmount(), </span><br><span class="line">                (soFar, amount) -&gt; soFar.add(amount))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">operations.forEach(op -&gt;</span><br><span class="line">        balances.merge(op.getAccNo(), op.getAmount(), BigDecimal::add)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我觉得这很可读。对于每个操作，将给定数量添加到给定编号。结果符合预期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">123</span>=<span class="number">9.5</span>, <span class="number">456</span>=-<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><code>ConcurrentHashMap</code></h2>
<p>当您意识到 ConcurrentHashMap 中正确实现了 Map.merge() 时，它会更加有用。这意味着我们可以原子地执行插入或更新操作。而且线程安全。</p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.nurkiewicz.com/2019/03/mapmerge-one-method-to-rule-them-all.html">原文链接</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟队列实现</title>
    <url>/data-structure/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="延迟队列定义"><strong>延迟队列定义</strong></h2>
<p>首先，队列这种数据结构相信大家都不陌生，它是一种先进先出的数据结构。普通队列中的元素是有序的，先进入队列中的元素会被优先取出进行消费；</p>
<p>延时队列相比于普通队列最大的区别就体现在其延时的属性上，普通队列的元素是先进先出，按入队顺序进行处理，而延时队列中的元素在入队时会指定一个延迟时间，表示其希望能够在经过该指定时间后处理。</p>
<h2 id="延时队列的应用">延时队列的应用</h2>
<p>延时队列在项目中的应用还是比较多的，尤其像电商类平台：</p>
<p>1、订单成功后，在30分钟内没有支付，自动取消订单</p>
<p>2、外卖平台发送订餐通知，下单成功后 60s 给用户推送短信。</p>
<p>3、如果订单一直处于某一个未完结状态时，及时处理关单，并退还库存</p>
<p>4、淘宝新建商户一个月内还没上传商品信息，将冻结商铺等</p>
<p>。。。。</p>
<p>上边的这些场景都可以应用延时队列解决。</p>
<span id="more"></span>
<h2 id="延时队列的实现">延时队列的实现</h2>
<h3 id="优先队列与二叉堆">优先队列与二叉堆</h3>
<p>**堆（heap）**是一种特殊的基于树的数据结构，它本质上是一个满足堆属性的几乎完整的树，通常使用数组来实现。</p>
<p><strong>堆</strong>是一种称为优先级队列的抽象数据类型的最高效率实现，实际上，优先级队列通常称为“堆”，无论它们如何实现。在堆中，最高（或最低）优先级的元素总是存储在根，也称为大顶堆（小顶堆）。但是，堆不是排序结构；它可以被认为是部分有序的。当需要重复删除具有最高（或最低）优先级的对象时，堆是一种有用的数据结构。</p>
<p>堆最常见的使用情况就是动态求极值，动态指我们会放入和移出，所以需要动态求极值。由于根节点就是极值，这样 O(1) 也可以取到极值，但是调整过程需要 O(logN)。</p>
<p>堆的常见实现是<strong>二叉堆</strong>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_heap">binary heap</a>），对应其树的表现形式为二叉树，下图为大顶堆（<strong>父节点的权值大于儿子的权值</strong>）：</p>
<img data-src="../../images/data-structure/max-heap.png" alt="Max-Heap-new" style="zoom: 50%;" />
<h3 id="Java-Timer-和-ScheduledThreadPoolExecutor">Java Timer 和  ScheduledThreadPoolExecutor</h3>
<h4 id="Timer">Timer</h4>
<p>Java Timer 可以实现延时任务，也可以实现周期性任务。Timer 内部使用优先队列存储任务，该优先队列使用二叉堆实现，并使用<strong>单个线程</strong>不断地拿优先队列的第一个任务的执行时间和当前时间做对比。如果时间到了先看看这个任务是不是周期性执行的任务，如果是则修改当前任务时间为下次执行的时间，如果不是周期性任务则将任务从优先队列中移除。最后执行任务。如果时间还未到则调用 <code>wait()</code> 等待。</p>
<p>文档建议使用 <code>java.util.concurrent</code> 包下 <code>ScheduledThreadPoolExecutor</code> 替代 <code>Timer</code>，原因在于：</p>
<p>该类是<strong>单线程执行</strong>，那么如果一个任务执行的时间过久则会影响下一个任务的执行时间(当然你任务的 run 要是异步执行也行)。</p>
<p>并且从代码可以看到<strong>对异常没有做什么处理</strong>，那么一个任务出错的时候会导致之后的任务都无法执行。</p>
<h4 id="ScheduledThreadPoolExecutor">ScheduledThreadPoolExecutor</h4>
<p><code>ScheduledThreadPoolExecutor</code> ，它是一个线程池，用于以给定的速率或延迟重复执行任务。 它实际上是 <code>Timer / TimerTask</code> 组合的更通用的替代品，因为它允许多个服务线程，接受各种时间单位，并且不需要子类化 TimerTask （只需实现 Runnable ）。 使用一个线程配置 ScheduledThreadPoolExecutor 其等效于 Timer 。</p>
<p>该类继承了 <code>ThreadPoolExecutor</code>，实现了 <code>ScheduledExecutorService</code>。可以定性操作就是正常线程池差不多了。区别就在于两点，一个是 <code>ScheduledFutureTask</code> ，一个是 <code>DelayedWorkQueue</code>。</p>
<p>其实 <code>DelayedWorkQueue</code> 就是优先队列，也是利用数组实现的二叉堆-小顶堆。而 <code>ScheduledFutureTask</code> 继承自 <code>FutureTask</code> 重写了 <code>run</code> 方法，实现了周期性任务的需求。</p>
<p>由于是线程池，可以多线程执行，可以传入 Callable 异常自己处理，或者被线程吞掉，不会影响其它线程。</p>
<h3 id="Java-DelayQueue-延时队列">Java DelayQueue 延时队列</h3>
<p><code>JDK</code> 中提供了一组实现延迟队列的 <code>API</code>，位于 <code>java.util.concurrent</code> 包下 <code>DelayQueue</code>。</p>
<p><code>DelayQueue</code> 是一个**线程安全的无界阻塞（<code>BlockingQueue</code>）**队列，内部封装了一个 <code>PriorityQueue</code>（优先队列），<code>PriorityQueue</code> 内部使用<code>完全二叉堆</code>来实现队列元素排序，我们在向 <code>DelayQueue</code> 队列中添加元素时，会给元素一个 <code>Delay</code>（延迟时间）作为排序条件，队列中最小的元素会优先放在队首。队列中的元素只有到了 <code>Delay</code> 时间才允许从队列中取出。放入的元素通过实现 <code>Delayed</code> 接口来提供延迟时间，并实现其 <code>Comparable</code> 来比较后期时间先后。</p>
<p><code>take</code> 方法检索并删除此队列的头，如有必要，阻塞直到延迟过期的元素在此队列上可用。</p>
<blockquote>
<p>有限时间的阻塞使用当前 leader 线程的等待来完成，该线程被设计用来等待队列头部的元素。使用 Leader-Follower 模式的这种变体用于最小化不必要的定时等待。 当一个线程成为领导者时，它只等待下一次延迟到期，而其他线程则无限期地等待。领导线程必须在从 take() 或 poll(…) 返回之前向某个其他线程发出信号，除非某个其他线程在此期间成为领导。</p>
</blockquote>
<p><code>poll</code> 检索并删除此队列的头部，如果此队列没有延迟过期的元素，则返回 null。</p>
<p>由于是无界队列，所以 <code>put</code>、<code>offset</code> 入队元素永远不会阻塞。</p>
<p>先简单实现一下看看效果，添加三个 <code>order</code> 入队 <code>DelayQueue</code>，分别设置订单在当前时间的 <code>5秒</code>、<code>10秒</code>、<code>15秒</code>后取消。</p>
<p><img data-src="../../images/data-structure/delay-queue.png" alt="DelayQueue"></p>
<h3 id="Redisson-RDelayedQueue">Redisson RDelayedQueue</h3>
<p>Redission 是 Redis 的 Java Client，为我们实现了很多易于使用的分布式集合类，这里就包括了延时队列，它允许以指定的延迟将每个元素传输到目标队列。实现其 <code>RDelayedQueue</code> 接口的类是 <code>RedissonDelayedQueue</code>，内部使用三个集合结构来实现：</p>
<ul>
<li>延时队列 List：数据入队的队列</li>
<li>目标队列 List：过期数据所在的队列</li>
<li>timeoutSet 过期时间 ZSet：分数值为 timeout 值，辅助判断元素是否过期</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RBlockingQueue&lt;String&gt; destinationQueue = client.getBlockingQueue(<span class="string">&quot;block_queue&quot;</span>);</span><br><span class="line">RDelayedQueue&lt;String&gt; delayedQueue = client.getDelayedQueue(destinationQueue);</span><br><span class="line"><span class="type">int</span> <span class="variable">memberCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= memberCount; i++) &#123;</span><br><span class="line">    <span class="comment">// 向延迟队列放入数据</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    delayedQueue.offer(time + <span class="string">&quot;---&quot;</span> + i, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">consumerCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (consumerCount != memberCount) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞队列有数据就返回，否则 wait</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">take</span> <span class="operator">=</span> destinationQueue.take();</span><br><span class="line">        consumerCount++;</span><br><span class="line">        System.out.println(<span class="string">&quot;take:&quot;</span> + take);</span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> Long.parseLong(take.split(<span class="string">&quot;---&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 消费可能产生的延迟</span></span><br><span class="line">        System.out.println(<span class="string">&quot;延迟时间:&quot;</span> + (System.currentTimeMillis() - time) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayedQueue.destroy();</span><br></pre></td></tr></table></figure>
<h4 id="Redis-ZSet">Redis ZSet</h4>
<p>Redis 有一个有序集合（Sorted Set）的数据结构 ZSet，ZSet 中每个成员都有一个对应 Score，ZSET 中的成员按 Score 和 ZSET 中成员的排序顺序进行排序和访问。</p>
<p><img data-src="../../images/middleware/redis/zset.svg" alt="ZSet"></p>
<p>那么我们可以通过以下这几个操作使用 Redis 的 ZSet 来实现一个延迟队列：</p>
<ol>
<li>入队操作：<code>ZADD KEY timestamp task</code>，我们将需要处理的任务，按其需要延迟处理时间作为 Score 加入到 ZSet 中。Redis 的 ZADD 的时间复杂度是 <code>O(logN)</code>，<code>N</code> 是 ZSet 中元素个数，因此我们能相对比较高效的进行入队操作。</li>
<li>起一个进程定时（比如每隔一秒）通过 <code>ZREANGEBYSCORE</code> 或 <code>ZRANGE</code> 方法查询 ZSet 中 Score 最小的元素，具体操作为：<code>ZRANGEBYSCORE KEY -inf +inf limit 0 1 WITHSCORES</code> 或 <code>ZRANGE KEY 0 0 WITHSCORES</code>。查询结果有两种情况：<br>
a. 查询出的分数小于等于当前时间戳，说明到这个任务需要执行的时间了，则去异步处理该任务，并移除该过期任务 <code>ZREM KEY task</code>；<br>
b. 查询出的分数大于当前时间戳，说明 ZSet 中所有的任务都还没有到需要执行的时间，则休眠一秒后继续查询；<br>
同样的，<code>ZRANGEBYSCORE</code> 操作的时间复杂度为 <code>O(logN + M)</code>，其中 <code>N</code> 为 ZSet 中元素个数，<code>M</code> 为查询的元素个数，因此我们定时查询操作也是比较高效的。</li>
</ol>
<p>Redis 的 ZSet 有序集合使用跳表这种数据结构来存储和管理有序数据。</p>
<h4 id="跳表（Skip-List）">跳表（Skip List）</h4>
<p>跳表是一种基于链表，并使用多层数组索引已达到近乎二分查找效率的<strong>有序</strong>数据结构，和二分查找一样，它使得包含 n 个元素的有序序列的查找和插入操作的平均时间复杂度都是 <code>O(logN)</code>。</p>
<p>我们知道，不借助额外空间的情况下，在链表中查找一个值，需要按照顺序一个个查找，时间复杂度为 O(N)，其中 N 为链表长度。但是链表对于插入、删除的时间复杂度只有 <code>O(1)</code>。数组和链表刚好相反，对于查找直接可以使用索引，在链表上使用数组索引就可以大大提高查询其性能，也是一种典型的用空间换时间的思想。</p>
<p><img data-src="../../images/data-structure/skip-list-add-element.gif" alt="skip-list-add-element"></p>
<h5 id="跳表与平衡树、哈希表的比较">跳表与平衡树、哈希表的比较</h5>
<ul>
<li>跳表和各种平衡树（如 AVL、红黑树等）的元素都是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个 key 的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li>
<li>在做范围查找的时候，平衡树比跳表操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整（再平衡），逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，跳表比平衡树更灵活一些。一般来说，平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，具体取决于参数 p 的大小，p 为有 (i+1) 层指针的概率。如果像 Redis 里的实现一样，取 p=1/4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li>查找单个 key，跳表和平衡树的时间复杂度都为 <code>O(logN)</code>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近 <code>O(1)</code>，性能更高一些。所以我们平常使用的各种 Map 或 dictionary 结构，大都是基于哈希表实现的。</li>
<li>从算法实现难度上来比较，跳表比平衡树要简单得多。</li>
</ul>
<h3 id="RabbitMQ-实现延迟队列">RabbitMQ 实现延迟队列</h3>
<p>RabbitMQ 本身并不直接提供对延迟队列的支持，我们依靠 RabbitMQ 的 <strong>TTL</strong> 以及<strong>死信队列</strong>功能，来实现延迟队列的效果。那就让我们首先来了解一下，RabbitMQ 的死信队列以及 TTL 功能。</p>
<h4 id="死信队列（Dead-Letter-Queue）"><strong>死信队列（Dead Letter Queue）</strong></h4>
<p>死信队列实际上是一种 RabbitMQ 的消息处理机制，当 RabbmitMQ 在生产和消费消息的时候，消息遇到如下的情况，就会变成“死信”：</p>
<ol>
<li>消息被拒绝<code>basic.reject/basic.nack</code> 并且不再重新投递 <code>requeue=false</code></li>
<li>消息超时未消费，也就是 TTL 过期了</li>
<li>消息队列到达最大长度</li>
</ol>
<p>消息一旦变成一条死信，便会被重新投递到死信交换机（Dead-Letter-Exchange），然后死信交换机根据绑定规则转发到对应的死信队列上，监听该队列就可以让消息被重新消费。</p>
<h4 id="消息生存时间（Time-To-Live）"><strong>消息生存时间（Time To Live）</strong></h4>
<p>TTL（Time-To-Live）是 RabbitMQ 的一种高级特性，表示了一条消息的最大生存时间，单位为毫秒。如果一条消息在 TTL 设置的时间内没有被消费，那么它就会变成一条死信，进入我们上面所说的死信队列。</p>
<p>有两种不同的方式可以设置消息的 TTL 属性，一种方式是直接在创建队列的时候设置整个队列的 TTL 过期时间，所有进入队列的消息，都被设置成了统一的过期时间，一旦消息过期，马上就会被丢弃，进入死信队列；</p>
<p>另一种方式是针对单条消息设置。不过需要注意的是，使用这种方式设置的 TTL，消息可能不会按时死亡，因为 RabbitMQ 只会检查第一个消息是否过期。比如这种情况，第一个消息设置了 20s 的 TTL，第二个消息设置了 10s 的 TTL，那么 RabbitMQ 会等到第一个消息过期之后，才会让第二个消息过期。</p>
<p>解决这个问题的方法也很简单，只需要安装 RabbitMQ 的一个插件即可：</p>
<p><strong><a href="https://link.zhihu.com/?target=https%3A//www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a></strong></p>
<p>安装好这个插件后，所有的消息就都能按照被设置的 TTL 过期了。</p>
<p><img data-src="../../images/middleware/rabbitmq/rabbitmq-delay-queue.png" alt="rabbitmq-delay-queue"></p>
<p><strong>延迟消费模式：</strong><br>
生产者发布消息到缓冲队列<code>buffer-queue</code>中，消息在<code>buffer-queue</code>中经过TTL时间成为死信后，会通过<code>buffer-queue</code>设置的死信交换机<code>dlx.exchange</code>重新路由出去。<code>worker-queue</code>为实际的工作队列，通过路由键<code>dlx.routing.key</code>与死信交换机<code>dlx.exchange</code>绑定，最终死信消息会重新路由到实际的工作队列<code>worker-queue</code>中，被消费处理。<br>
<strong>延迟重试模式：</strong><br>
生产者发布消息到实际的工作队列<code>buffer-queue</code>中，被消费者消费处理但是处理失败。消费者将处理失败的消息丢到缓冲队列<code>buffer-queue</code>，失败的消息在<code>buffer-queue</code>中经过TTL时间成为死信后，会通过<code>buffer-queue</code>设置的死信交换机<code>dlx.exchange</code>重新路由出去。<code>worker-queue</code>为实际的工作队列，通过路由键<code>dlx.routing.key</code>与死信交换机<code>dlx.exchange</code>绑定，处理失败的消息在<code>buffer-queue</code>中经过一段时间的延迟后，最终又路由回到<code>worker-queue</code>中，被再次消费处理，这就是延迟重试。</p>
<p>使用 RabbitMQ 来实现延迟队列，我们可以很好的利用一些 RabbitMQ 的特性，比如消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延迟队列不可用或者消息丢失。</p>
<h3 id="时间轮（Timer-Wheel）">时间轮（Timer Wheel）</h3>
<p>Timer Wheel 时间轮算法，是一种实现延迟队列的巧妙且高效的算法，被应用在 Netty，Zookeeper，Kafka 等各种框架中。</p>
<p><img data-src="../../images/data-structure/timer-wheel.jpg" alt="Timer Wheel"></p>
<p>如上图所示，时间轮是一个存储延迟消息的循环队列，其底层一般采用数组实现，可以高效循环遍历。这个循环队列中的每个元素对应一个桶（Bucket），桶中存放任务列表，这个列表一般是一个双向环形链表，链表中每一项都代表一个需要执行的延迟任务。双向链表的优点是，如果我们可以访问列表中的链接单元，它允许 O(1) 插入/删除列表项，比优先队列的 O(logN) 要快很多。</p>
<p>时间轮会有表盘指针，表示时间轮当前所指时间，随着时间推移，该指针会不断前进，并处理对应位置上的延迟任务列表。表盘有自己的刻度数，每个刻度数代表一定的过期时间，对于超出表盘时间的延迟任务，有两种实现方案，一种是像 Netty 的 <code>HashedWheelTimer</code> 在每个延迟任务中维护自己轮次，一种是像 Kafka <code>TimingWheel</code> 将表盘分层，就像我们手表的时分秒一样。</p>
<h4 id="Netty-HashedWheelTimer">Netty HashedWheelTimer</h4>
<p>我们以 Netty 的 <code>HashedWheelTimer</code> 为例，来说明时间轮中几个关键的概念。</p>
<h5 id="概念">概念</h5>
<p><strong>Tick Duration 刻度持续时间</strong></p>
<p>此计时器不会按时执行计划的任务  <code>TimerTask</code>，他只是一个“近似”的超时调度器。 <code>HashedWheelTimer</code> 会在每个刻度处中检查是否有任何任务落后于计划并执行它们。</p>
<p><strong>Ticks Per Wheel 每个轮盘的刻度数</strong></p>
<p><code>HashedWheelTimer</code> 维护着一个名为 “wheel” 的数据结构。简单地说，轮盘是一个 <code>TimerTasks</code> 的哈希表，其哈希函数是“任务的到期时间”。每个轮子的默认刻度数是 512。</p>
<p><strong>Round Duration 计时周期</strong></p>
<p>轮盘指针走完一圈耗时，roundDuration = ticksPerWheel ∗ tickDuration。当任务的延期时长 delay 超出计时周期时，任务放入对应桶中的同时保存剩余圈数：roundsRemaining = delay / roundDuration。</p>
<blockquote>
<p>不要创建太多 HashedWheelTimer 实例，由于该类在初始化时会创建一个工作线程（如果有传入线程池，则使用该线程池创建），所以最好在应用中共享该实例，以防止过多线程的浪费。</p>
</blockquote>
<h5 id="使用">使用</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1s 持续时间，5 个刻度</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedWheelTimer</span>(Executors.defaultThreadFactory(), <span class="number">1</span>, TimeUnit.SECONDS, <span class="number">5</span>);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;                  开始时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line"><span class="comment">// 定时任务</span></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order1 第&quot;</span> + (count) + <span class="string">&quot;次  5s 后执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        <span class="keyword">if</span> (count++ &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            timer.newTimeout(<span class="built_in">this</span>, <span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 结束时候再次注册</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">timer.newTimeout(task1, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order2 第&quot;</span> + (count) + <span class="string">&quot;次 10s 后执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count++ &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            timer.newTimeout(<span class="built_in">this</span>, <span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">// 结束时候再注册</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">timer.newTimeout(task2, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟任务</span></span><br><span class="line">timer.newTimeout(timeout -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;order3 15s 后执行一次时间  ：&quot;</span> + LocalDateTime.now());</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">latch.await();</span><br></pre></td></tr></table></figure>
<p>通过结束时再注册相同的延迟时间可以实现定时任务，从执行结果来看，也可以看到时间轮存在一定的误差，但是误差可以通过刻度数和精度来弥补。</p>
<h5 id="实现">实现</h5>
<p><img data-src="../../images/data-structure/hashed-wheel-timer.png" alt="baf4213d8966123c4ebbf9810646001e"></p>
<p>通过 <code>newTimeout</code> 将新的定时任务 <code>TimerTask</code> 包装为 <code>Timeout</code>，并根据传入的延期时间和轮盘的刻度数*刻度持续时间来计算该任务对应的轮次，添加到如上图所绘的 <code>timeouts</code> 的 <code>MPSC（Multiple Producer Single Consumer）</code>多生产者单消费者队列。</p>
<p><strong>单个的工作线程</strong>执行轮盘的轮询，通过工作线程的 sleep 休眠过了单个刻度的持续时间时，会将新添的定时任务的 timeouts 队列移入到相应的桶中，并执行该桶中到期的任务，也就是轮次为 0 的到期任务，其它轮次的定时任务相应减少轮次。由于单线程的原因，<strong>单个的任务执行超过刻度持续时间会影响该刻度桶中的其它任务执行</strong>。桶中的任务执行完后指针将移动到下一个刻度，然后重复该工作。</p>
<p>具体源码解析可查看：<a target="_blank" rel="noopener" href="https://www.javadoop.com/post/HashedWheelTimer">HashedWheelTimer 使用及源码分析</a>。</p>
<h5 id="小结一下">小结一下</h5>
<p>总体上看 Netty 的实现就是上文说的时间轮通过轮数的实现，完全一致。可以看出时间精度由 TickDuration 把控，并且工作线程的除了处理执行到时的任务还做了其他操作，因此任务不一定会被精准的执行。</p>
<p>而且任务的执行如果不是新起一个线程，或者将任务扔到线程池执行，那么耗时的任务会阻塞下个任务的执行。</p>
<p>并且会有很多无用的 tick 推进，例如 TickDuration 为1秒，此时就一个延迟 350 秒的任务，那就是有 349 次无用的操作。</p>
<p>但是从另一面来看，如果任务都执行很快(当然你也可以异步执行)，并且任务数很多，通过分批执行，并且增删任务的时间复杂度都是 O(1) 来说。时间轮还是比通过优先队列实现的延时任务来的合适些。</p>
<h4 id="Kafka-TimingWheel">Kafka TimingWheel</h4>
<p>Kafka 有一个被称为“请求炼狱（<code>request purgatory</code>）”的数据结构，炼狱会保留任何尚未满足其完成条件但也没出现错误的请求。问题是：我们如何满足高效跟踪集群中的数万个异步请求何时达成条件的任务？，比如下面列举的请求类型：</p>
<ul>
<li>不能认为带有 <code>acks=all</code> 的生产者请求已经完成，除非所有同步副本已经被确认。而且即使领导者 (leader) 出错，该请求也不能丢失。</li>
<li>消费者的 <code>min.bytes=1</code> 的抓取请求只能等到至少有一个新字节的数据时才会被响应，这样可以避免消费者忙于检查新数据的到达。</li>
</ul>
<p>这些请求只有在 (a) 条件满足时或者 (b) 超时出现时才能被认为已完成。</p>
<h5 id="旧的炼狱设计">旧的炼狱设计</h5>
<p>炼狱中的请求在满足条件时稍后完成，或者在超过请求的超时参数中指定的时间时强制完成（超时）。在旧的设计中，它使用 Java <code>DelayQueue</code> 来实现定时器。</p>
<p>当一个请求完成时，该请求不会立即从定时器或观察者列表中删除，而是会在条件检查期间被发现时才会删除。当删除没有跟上时，服务器可能会耗尽 JVM 堆并导致 <code>OutOfMemoryError</code>。</p>
<p>为了缓解这种情况，使用一个单独的线程，称为收割者线程，在当炼狱中的请求数量（挂起或已完成）超过配置的份额时，它会从炼狱中清除已完成的请求。清除操作会扫描定时器队列和所有观察者列表以查找已完成的请求并将其删除。</p>
<p>通过将此配置参数调低，服务器实际上可以避免内存问题。但是，如果服务器过于频繁地扫描所有列表，则必须付出显着的性能损失。</p>
<h5 id="新的炼狱设计">新的炼狱设计</h5>
<p>新设计的目标是允许立即删除已完成的请求并显着减轻由于昂贵的清除过程造成的负担。它需要在计时器和请求中交叉引用条目。此外，强烈希望有 O(1) 的插入/删除成本，因为每个请求/完成都会发生插入/删除操作。</p>
<p>为了满足这些要求，我们设计了一种基于<a target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~nahum/w6998/papers/ton97-timing-wheels.pdf">分层时间轮</a>的新炼狱实现。</p>
<h5 id="分层时间轮">分层时间轮</h5>
<p>一个简单的时间轮是存放着定时任务桶的循环队列。我们把 <code>u</code> 称为时间单位。一个大小为 <code>n</code> 的时间轮有 <code>n</code> 个桶，可以在 <code>n * u</code> 时间间隔内保存任务。每个桶都保存了属于相应时间范围内的定时任务。一开始，第一个桶保存 <code>[0, u)</code> 的任务，第二个桶保存 <code>[u, 2u)</code>, … 的任务，第 <code>n</code> 个桶保存 <code>[u * (n -1), u * n)]</code>。每过时间单位 <code>u</code> 的间隔，指针走了一格并移动到下一个存储桶，之前桶中的所有定时器任务到期，定时器立即运行过期的任务，清空的桶可用于下一轮倒计时。由于指针移动到新的用于倒计时开始的桶，因此，新的任务只会从该桶开始倒计时。所以如果当前桶的时间为 <code>t</code>，指针移动之后，它变成了 <code>[t + u * n, t + (n + 1) * u)</code> 的桶。时间轮的插入/删除（启动定时器/停止定时器）成本为 O(1)，而基于优先级队列的定时器，例如 <code>java.util.concurrent.DelayQueue</code> 和 <code>java.util.Timer</code>，插入/删除成本为 O(logN)。请注意，<code>DelayQueue</code> 或 <code>Timer</code> 都不支持随机删除。</p>
<p><img data-src="../../images/data-structure/timing-wheels.png" alt="Hierarchical timing wheels"></p>
<p>简单时间轮的一个主要缺点是它假设定时器的请求距离在当前时间 <code>n * u</code> 的时间间隔内。如果定时器请求超出此间隔，则为溢出，Netty 的单层时间轮是在每个定时任务中维护了轮次。分层时间轮用于处理此类溢出。它是一个分层组织的时间轮，将溢出委托给上层轮。最低级别具有最好的时间精度。当我们向上移动层次结构时，时间精度将变大。如果一个轮子在一级的精度是 u，刻度数是 n，那么在第二级的精度应该是 n*u，第三级 n2 * u，以此类推。在每一层，溢出都委托给更高一层的轮子。当较高级别的轮子 tick 推进时，它会将定时器任务重新插入较低级别。可以按需创建移出的轮层级数。当上层桶中的桶到期时，其中的所有任务都会递归地重新插入定时器。然后将任务移至更细粒度的轮子或者被执行。插入（start-timer）成本是 O(m)，其中 m 是轮盘的数量，与系统中的请求数量相比通常非常小，删除（stop-timer）成本仍然是 O(1)。</p>
<p><img data-src="../../images/data-structure/timing-wheels-2.png" alt="Doubly linked list for buckets in timing wheels"></p>
<h5 id="时间轮中桶的双向链表">时间轮中桶的双向链表</h5>
<p>在新设计中，我们对时间轮中的桶使用自己的双向链表实现。双向链表的优点是，如果我们可以访问列表中的链接单元，它允许 O(1) 插入/删除列表项。</p>
<p>当排队到定时器队列时，定时器任务实例在其自身中保存链接单元。当任务完成或取消时，将使用保存在任务本身中的链接单元更新列表。</p>
<h5 id="使用-DelayQueue-驱动时钟">使用 DelayQueue 驱动时钟</h5>
<p>一个简单的实现可以使用一个线程，它每单位时间唤醒一次并进行 tick 推进，并检查桶中是否有任何任务。炼狱单位时间为 1ms（u=1ms）。如果请求在最低级别的轮盘上比较稀疏，这可能是浪费的。这通常是因为大多数请求在插入到最低级别的轮盘之前在上层轮盘找到合适的位置。如果一个线程只在有一个非空的桶要到期时才唤醒，那就太好了。新的炼狱与旧实现类似，通过使用 <code>java.util.concurrent.DelayQueue</code> 来实现，但我们将<strong>非空任务桶</strong>而不是单个任务排入队列。这种设计具有性能优势。<code>DelayQueue</code> 中的项目数量受桶数量的限制，非空桶的数量通常远小于任务的数量，因此 DelayQueue 内部优先级队列的 offer/poll 操作次数会明显减少。</p>
<h5 id="小结一下-2">小结一下</h5>
<p>Kafka 用了多层次时间轮来实现，并且是按需创建时间轮，采用任务的绝对时间来判断延期，并且对于每个非空槽都会维护一个过期时间，利用 DelayQueue 来对每个非空槽的过期时间排序，来进行时间的推进，防止空推进的存在。</p>
<h2 id="总结">总结</h2>
<p>首先介绍了 Timer、DelayQueue 和 ScheduledThreadPool，它们都是基于优先队列实现的，O(logN) 的时间复杂度在任务数多的情况下频繁的入队出队对性能来说有损耗，而且 Java 的延迟任务都存放在 JVM 内存队列中，任务过多会导致 OOM，<strong>因此适合于任务数不多的情况</strong>。</p>
<p>Timer 是单线程的会有阻塞的风险，并且对异常没有做处理，一个任务出错 Timer 就挂了。而 ScheduledThreadPool 相比于 Timer 首先可以多线程来执行任务，并且线程池对异常做了处理，使得任务之间不会有影响。并且 Timer 和 ScheduledThreadPool 可以周期性执行任务。 而 DelayQueue 就是个具有优先级的阻塞队列。</p>
<p><strong>对比而言时间轮更适合任务数很大的延时场景，它的任务插入和删除时间复杂度都为O(1)</strong>。对于延迟超过时间轮所能表示的范围有两种处理方式，一是通过增加一个字段-轮数，Netty 就是这样实现的。二是多层次时间轮，Kakfa 是这样实现的。但是注意 Netty 的单线程任务阻塞影响其它任务的情况，而且相比而言 Netty 的实现会有空推进的问题，而 Kafka 采用 DelayQueue 以非空槽为单位，利用空间换时间的思想解决了空推进的问题。</p>
<p>基于 Redis 的实现可以利用 Redis 集群等部署，以及 Redis 高性能低内存等特点，使用在任务数很大延时场景。但 Redis 毕竟是基于内存的，虽然有数据持久化方案，<strong>但还是有数据丢失的可能性</strong>。</p>
<p>而 RabbitMQ 的实现方案，由于 RabbitMQ 本身的消息可靠发送、消息可靠投递、死信队列等特性，可以保障消息至少被消费一次以及未被正确处理的消息不会被丢弃，让消息的可靠性有了保障。</p>
<hr>
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c216a235f6a2">一口气说出 6种 延时队列的实现方案</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266156267">你真的知道怎么实现一个延迟队列吗 ？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&amp;mid=2657261425&amp;idx=1&amp;sn=d840079ea35875a8c8e02d9b3e44cf95&amp;scene=21#wechat_redirect">Redis 为什么用跳表而不用平衡树？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eae22e9ee9d8">RedissonDelayedQueue源码解读</a></li>
<li><a target="_blank" rel="noopener" href="https://biteeniu.github.io/rabbitmq/rabbitmq_delay_queue/">RabbitMQ实现延迟队列</a></li>
<li><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/HashedWheelTimer">HashedWheelTimer 使用及源码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.confluent.io/blog/apache-kafka-purgatory-hierarchical-timing-wheels/">Apache Kafka, Purgatory, and Hierarchical Timing Wheels</a></li>
<li><a target="_blank" rel="noopener" href="https://www.honeypps.com/mq/kafka-analysis-of-timing-wheel/">Kafka解惑之时间轮（TimingWheel）</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DelayQueue</tag>
        <tag>RDelayedQueue</tag>
        <tag>PriorityQueue</tag>
        <tag>Binary Heap</tag>
        <tag>Timer Wheel</tag>
        <tag>SkipList</tag>
        <tag>Redission</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2 使用指南</title>
    <url>/devops/PM2-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>P（rocess）M（anager）2 Runtime 是具有内置 Load Balancer 的 Node.js 应用程序的项目进程管理器。它允许永久保持应用程序的在线，无需停机即可重新加载它们，并可以完成常见的 Devops 任务。</p>
<h2 id="安装使用">安装使用</h2>
<p>使用 npm 安装全局指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i pm2 -g</span><br></pre></td></tr></table></figure>
<p>系统启动或重启时自动启动/禁用自启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pm2 startup/unstartup</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>启动应用，指定名称，设置集群 Node 数量，检测文件变化时自动重启，忽略检测文件，指定脚本参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pm2 start npm -i max --name=<span class="string">&quot;doc-manager&quot;</span> --watch --ignore-watch=<span class="string">&quot;node_modules&quot;</span> -- run start</span><br></pre></td></tr></table></figure>
<h2 id="进程管理">进程管理</h2>
<ul>
<li>
<p>查看进程列表：<code>pm2 list</code></p>
</li>
<li>
<p>启动进程：<code>pm2 start</code></p>
</li>
<li>
<p>停止进程：<code>pm2 stop</code></p>
</li>
<li>
<p>删除进程：<code>pm2 delete</code></p>
</li>
<li>
<p>重启进程：<code>pm2 restart</code></p>
<ul>
<li>修改环境变量，重启更新配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ NODE_ENV=production pm2 restart app --update-env</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重新加载进程：<code>pm2 reload</code></p>
</li>
<li>
<p>查看日志：<code>pm2 logs</code>  — error 只输出错误 —lines n 输出最后的多少行</p>
<ul>
<li>清空日志：<code>pm2 flush</code></li>
</ul>
</li>
<li>
<p>查看当前进程环境变量：<code>pm2 env &lt;pm_id&gt;</code></p>
</li>
<li>
<p>查看监控：<code>pm2 monitor</code></p>
</li>
<li>
<p>保存当前列表到硬盘：<code>pm2 save</code></p>
</li>
<li>
<p>恢复上一次保存的列表：<code>pm2 resurrect</code></p>
</li>
</ul>
<h3 id="集群模式">集群模式</h3>
<p><img data-src="../images/devops/cluster-mode.png" alt="scale across all cpu's available"></p>
<p>内置的负载均衡器提供联网的 Node.js 应用程序（http(s)/ tcp / udp服务器），可以在所有可用的 CPU 上进行扩展，无需任何代码修改。</p>
<p>要启用集群模式，只需传递 -i <number-instances> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>
<p>max 代表 cpu 最大可用数，也可以使用负数来移除 Node 服务数量。</p>
<h2 id="静态文件服务">静态文件服务</h2>
<p>pm2 也可以作为静态文件的服务来使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 serve &lt;path&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>默认使用当前文件夹和 8080 端口。</p>
<blockquote>
<p>pm2 也可以使用配置文件的形式；通过 SSH使用自动化代理部署，具体请查看官方文档；</p>
</blockquote>
<p>命令行的所有指令可以在这查看：<a target="_blank" rel="noopener" href="https://pm2.io/doc/en/runtime/reference/pm2-cli/">CLI</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>PM2</tag>
        <tag>Nuxt</tag>
        <tag>Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>NGINX root 和 alias</title>
    <url>/devops/nginx-root-%E5%92%8C-alias/</url>
    <content><![CDATA[<p>在配置 NGINX 文件映射时发现 root 并没有按照期待映射，找解决方法，建议换作 alias 映射目录，不解，查下文档，理解区别。</p>
<h2 id="root">root</h2>
<p>root 指令用于指定搜索文件的根目录。NGINX 将请求 URI 附加到 <code>root</code> 指定的路径。该指令可以放置在 <code>http</code>，<code>server</code> 或 <code>location</code> 上下文中的任何级别上。</p>
<span id="more"></span>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /www/data;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /images/ &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.(mp3|mp4)</span> &#123;</span><br><span class="line">        <span class="attribute">root</span> /www/media;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /static/ &#123;</span><br><span class="line">        <span class="attribute">root</span> /www/media;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们请求以 <code>/images/</code> 匹配的 URI 时，NGINX 会在 <code>/www/data/images/</code> 目录下查找相应的文件，但是如果 URI 以 .mp3 或 .mp4 扩展名结尾，那么 NGINX 会在 <code>/www/media/</code> 目录中搜索文件，因为它是在匹配的 location 块中定义的。</p>
<p>如果请求以斜线结尾，NGINX 将其视为对目录的请求，并尝试在目录中查找索引文件。<code>index</code> 指令用于定义索引文件的名称（默认值为 index.html）。继续这个例子，如果请求的 URI 是<code>/images/some/path/</code>，NGINX 查找文件 <code>/www/data/images/some/path/index.html</code>（如果它存在）。如果不存在，NGINX 默认返回 HTTP 代码 404（未找到）。</p>
<p>location 中的 root 用于指定该路有的相对 root 资源目录，比如上面的 <code>/static/</code> 请求会在 <code>/www/media/static/</code> 下寻找匹配文件。</p>
<h2 id="alias">alias</h2>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="section">location</span> / &#123;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="section">location</span> /i/ &#123;</span><br><span class="line">      <span class="attribute">alias</span> /data/images/;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们请求<code>/i/top.gif</code>时，将会查找<code>/data/images/top.gif</code>该文件。<br>
地址中可以包含变量，具体查看文档。</p>
<p>当 location 匹配指令值的最后一部分时：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /images/ &#123;</span><br><span class="line">    <span class="attribute">alias</span> /data/w3/images/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好使用 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html#root">root</a> 指令替代:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /images/ &#123;</span><br><span class="line">    <span class="attribute">root</span> /data/w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结：">总结：</h2>
<ul>
<li><code>root</code> UIR 映射 URI + location Path</li>
<li><code>alias</code> URI 映射 location</li>
</ul>
<p>如果请求后缀和文件夹名称相同，建议使用 <code>root</code>。</p>
]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2 使用指南</title>
    <url>/devops/WSL2-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1>适用于 Windows 10 的子系统 Linux 安装指南</h1>
<h2 id="启用-Windows-子系统-Linux">启用 Windows 子系统 Linux</h2>
<p>在 Windows 上安装任何 Linux 发行版之前，您必须首先启用“<strong>Windows Subsystem for Linux</strong>/<strong>适用于Linux的Windows子系统</strong>”可选功能。</p>
<p><img data-src="../../images/devops/wsl-enable.jpeg" alt="wsl-enable"></p>
<p>或者以管理员身份打开 PowerShell 并运行：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows-Subsystem-Linux</span> /all /norestart</span><br></pre></td></tr></table></figure>
<h2 id="启用虚拟机功能">启用虚拟机功能</h2>
<p>安装 WSL 2 之前，必须启用“<strong>Virtual Machine Platform</strong>/<strong>虚拟机平台</strong>”可选功能。 计算机需要<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed">虚拟化功能</a>才能使用此功能。</p>
<p>以管理员身份打开 PowerShell 并运行：</p>
<p>PowerShell复制</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>
<p><strong>重新启动</strong> 计算机，以完成 WSL 安装并更新到 WSL 2。</p>
<span id="more"></span>
<h2 id="下载-Linux-内核更新包">下载 Linux 内核更新包</h2>
<ol>
<li>
<p>下载最新包：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></li>
</ul>
<blockquote>
<p>备注</p>
<p>如果使用的是 ARM64 计算机，请下载 <a target="_blank" rel="noopener" href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi">ARM64 包</a>。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：<code>systeminfo | find &quot;System Type&quot;</code>。 <strong>警告：</strong> 在非英语 Windows 版本中，你可能需要修改搜索文本，例如在德语中为 <code>systeminfo | find &quot;Systemtyp&quot;</code>。</p>
</blockquote>
</li>
<li>
<p>运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）</p>
</li>
</ol>
<p>安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。 （如果希望将新的 Linux 安装设置为 WSL 1，请跳过此步骤。）</p>
<h2 id="将-WSL-2-设置为默认版本">将 WSL 2 设置为默认版本</h2>
<p>打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：</p>
<p>PowerShell 复制</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="安装所选的-Linux-分发版">安装所选的 Linux 分发版</h2>
<ol>
<li>
<p>打开 <a target="_blank" rel="noopener" href="https://aka.ms/wslstore">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</p>
<p><img data-src="https://docs.microsoft.com/zh-cn/windows/wsl/media/store.png" alt="Microsoft Store 中的 Linux 分发版的视图"></p>
<p>单击以下链接会打开每个分发版的 Microsoft Store 页面：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9N9TNGVNDL3Q">Ubuntu 18.04 LTS</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9n6svws3rx71">Ubuntu 20.04 LTS</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9NJFZK00FGKV">openSUSE Leap 15.1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9MZ3D1TRP8T1">SUSE Linux Enterprise Server 12 SP5</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9PN498VPMF3Z">SUSE Linux Enterprise Server 15 SP1</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9PKR34TNCV07">Kali Linux</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9MSVKQC78PK6">Debian GNU/Linux</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9n6gdm4k2hnc">Fedora Remix for WSL</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9NV1GV1PXZ6P">Pengwin</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9N8LP0X93VCP">Pengwin Enterprise</a></li>
<li><a target="_blank" rel="noopener" href="https://www.microsoft.com/store/apps/9p804crf0395">Alpine WSL</a></li>
</ul>
</li>
<li>
<p>在分发版的页面中，选择“获取”。</p>
<p><img data-src="https://docs.microsoft.com/zh-cn/windows/wsl/media/ubuntustore.png" alt="Microsoft Store 中的 Linux 分发版"></p>
</li>
</ol>
<p>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。 未来的所有启动时间应不到一秒。</p>
<p>然后，需要<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/user-support">为新的 Linux 分发版创建用户帐户和密码</a>。</p>
<p><img data-src="https://docs.microsoft.com/zh-cn/windows/wsl/media/ubuntuinstall.png" alt="Windows 控制台中的 Ubuntu 解包"></p>
<p><strong>祝贺你！现已成功安装并设置了与 Windows 操作系统完全集成的 Linux 分发！</strong></p>
<h1>配置 WSL2 Linux</h1>
<h2 id="配置-SSH-或-FTP">配置 SSH 或 FTP</h2>
<h3 id="OpenSSH-介绍">OpenSSH 介绍</h3>
<p>OpenSSH 是一个强大的工具集合，用于远程控制联网计算机和在联网计算机之间传输数据。您还将了解一些可能使用 OpenSSH 服务器应用程序进行的配置设置以及如何在您的 Ubuntu 系统上更改它们。</p>
<p>OpenSSH 是安全外壳 (SSH) 协议系列工具的免费可用版本，用于远程控制计算机或在计算机之间传输文件。用于完成这些功能的传统工具，例如 telnet 或 rcp，是不安全的，并且在使用时以明文形式传输用户密码。OpenSSH 提供了一个服务器守护进程和客户端工具来促进安全、加密的远程控制和文件传输操作，有效地替代了传统工具。</p>
<p>OpenSSH 服务器组件 <code>sshd - ssh daemon</code> 持续侦听来自任何客户端工具的客户端连接。当发生连接请求时，sshd 会根据客户端工具连接的类型设置正确的连接。例如，如果远程计算机与 ssh 客户端应用程序连接，则 OpenSSH 服务器在身份验证后建立远程控制会话。如果远程用户使用 scp 连接到 OpenSSH 服务器，则 OpenSSH 服务器守护程序会在身份验证后在服务器和客户端之间启动文件的安全副本。OpenSSH 可以使用多种身份验证方法，包括普通密码、公钥和 Kerberos 票证。</p>
<h3 id="安装">安装</h3>
<p>OpenSSH 客户端和服务器应用程序的安装很简单。要在 Ubuntu 系统上安装 OpenSSH 客户端应用程序，请在终端提示符下使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-client</span><br></pre></td></tr></table></figure>
<p>要安装 OpenSSH 服务器应用程序和相关支持文件，请在终端提示符下使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service ssh start</span><br></pre></td></tr></table></figure>
<h3 id="配置-SSH">配置 SSH</h3>
<p>您可以通过编辑文件来配置 OpenSSH 服务器应用程序 sshd 的默认行为<code>/etc/ssh/sshd_config</code>。有关此文件中使用的配置指令的信息，您可以使用在终端提示符下发出的以下命令查看相应的手册页：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man sshd_config</span><br></pre></td></tr></table></figure>
<p>sshd 配置文件中有许多指令控制诸如通信设置和身份验证模式等内容。以下是可以通过编辑<code>/etc/ssh/sshd_config</code>文件更改的配置指令示例。</p>
<blockquote>
<p><strong>Tip</strong></p>
<p>在编辑配置文件之前，您应该制作原始文件的副本并保护它不被写入，以便您将原始设置作为参考并在必要时重新使用。</p>
<p><code>/etc/ssh/sshd_config</code>使用以下命令复制文件并防止写入，在终端提示符下发出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/ssh/sshd_config /etc/ssh/sshd_config.original</span><br><span class="line">sudo <span class="built_in">chmod</span> a-w /etc/ssh/sshd_config.original</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此外，由于丢失 ssh 服务器可能意味着无法访问服务器，请在更改配置后和重新启动服务器之前检查配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sshd -t -f /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>以下是您可以更改的配置指令<em>示例</em>：</p>
<ul>
<li>要将 OpenSSH 设置为侦听 TCP 端口 2222 而不是默认的 TCP 端口 22，请将 Port 指令更改为：</li>
</ul>
<blockquote>
<p>Port 2222</p>
</blockquote>
<ul>
<li>要让您的 OpenSSH 服务器将<code>/etc/issue.net</code>文件内容显示为登录前横幅，只需在<code>/etc/ssh/sshd_config</code>文件中添加或修改以下行：</li>
</ul>
<blockquote>
<p>Banner /etc/issue.net</p>
</blockquote>
<ul>
<li>要将监听地址设为所有，修改配置：</li>
</ul>
<blockquote>
<p>ListenAddress 0.0.0.0</p>
</blockquote>
<ul>
<li>如果想使用 SSH 密钥而不是密码进行身份验证，您还可以将 <code>PasswordAuthentication</code> 设置为 “no”。如果您知道自己在做什么并且不知道如何使用 ssh 密钥，请将其设置为 “yes” 使用密码登录。</li>
</ul>
<blockquote>
<p>PasswordAuthentication yes</p>
</blockquote>
<ul>
<li>要将 root 用户配置为允许使用密码登录，默认的配置为 <code>prohibit-password</code> 禁止密码登录。</li>
</ul>
<blockquote>
<p>PermitRootLogin yes</p>
</blockquote>
<p>对<code>/etc/ssh/sshd_config</code>文件进行更改后，保存文件，然后在终端提示符下使用以下命令重新启动 sshd 服务器应用程序以使更改生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong></p>
<p>sshd 的许多其他配置指令可用于更改服务器应用程序的行为以满足您的需要。但是，请注意，如果您访问服务器的唯一方法是 ssh，并且您在通过该<code>/etc/ssh/sshd_config</code>文件配置 sshd 时出错，您可能会发现在重新启动服务器时您被锁定在服务器之外。此外，如果提供了不正确的配置指令，sshd 服务器可能会拒绝启动，因此在远程服务器上编辑此文件时要格外小心。</p>
</blockquote>
<h3 id="配置-FTP">配置 FTP</h3>
<p>sftp 是一个文件传输程序，类似于 ftp，它通过加密的 ssh 传输执行所有操作。它还可能使用 ssh 的许多功能，例如公钥认证和压缩。</p>
<p>OpenSSH 本身实现了 SFTP 客户端和服务，通过配置 <code>/etc/ssh/sshd_config</code> 来启用内置的 SFTP。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注释掉这行，使用内置的 internal-sftp</span></span><br><span class="line"><span class="comment">#Subsystem      sftp    /usr/libexec/openssh/sftp-server</span></span><br><span class="line"><span class="attr">Subsystem</span> <span class="string">sftp internal-sftp</span></span><br></pre></td></tr></table></figure>
<p>如果需要为 sftp 单独设置用户组及配置，请参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/binarylei/p/9201975.html">SFTP 安装与配置</a></p>
<h3 id="SSH-Keys">SSH Keys</h3>
<p>SSH 允许在不需要密码的情况下在两台主机之间进行身份验证。 SSH 密钥认证使用<em>私钥</em>和<em>公钥</em>。</p>
<p>如果本机没有密钥，要生成密钥，请从终端提示输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>这将使用 <em>RSA 算法</em>生成密钥。在撰写本文时，生成的密钥将有 3072 位。您可以使用该 <code>-b</code> 选项修改位数。例如，要生成 4096 位的密钥，您可以执行以下操作：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span>-keygen -t rsa -b <span class="number">4096</span></span><br></pre></td></tr></table></figure>
<p>在此过程中，系统将提示您输入密码。当提示创建密钥时，只需<em>按 Enter</em>键即可。</p>
<p>默认情况下，<em>公钥</em>保存到文件中<code>~/.ssh/id_rsa.pub</code>，同时<code>~/.ssh/id_rsa</code>是<em>私钥</em>。现在将<code>id_rsa.pub</code>文件复制到远程主机并通过输入将其附加到远程服务器的<code>~/.ssh/authorized_keys</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-copy-id username@remotehost</span><br></pre></td></tr></table></figure>
<p>最后，仔细检查<code>authorized_keys</code>文件的权限，只有经过身份验证的用户才有读写权限。如果权限不正确，请通过以下方式更改它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>您现在应该能够通过 SSH 连接到主机而不会被提示输入密码。</p>
<h2 id="配置-WSL2-外部远程访问">配置 WSL2 外部远程访问</h2>
<p>如果需要从外部访问 WSL2 中的服务，则需要将 WSL2 中的端口转发到 windows 监听，并开启相应端口的防火墙设置。</p>
<h3 id="获取-WSL2-IP">获取 WSL2 IP</h3>
<p>要进行转发，需要先获取 WSL2 的 IP 地址，可以在 windows 下使用 powershell 执行获取：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl hostname <span class="literal">-I</span></span><br></pre></td></tr></table></figure>
<h3 id="配置端口转发">配置端口转发</h3>
<p>使用<strong>管理员权限</strong>的 powershell 执行 22 SSH/SFTP 端口转发，并设置监听任意 IP 访问：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">0.0</span>.<span class="number">0.0</span> listenport=<span class="number">22</span> connectaddress=<span class="number">172.23</span>.<span class="number">129.80</span> connectport=<span class="number">22</span></span><br></pre></td></tr></table></figure>
<h3 id="打开端口入站防火墙">打开端口入站防火墙</h3>
<p>接下来，在相同的<strong>管理员权限</strong>命令行下，打开入站防火墙端口。您可以从高级防火墙设置中执行此操作，但您可以再次使用 netsh 更轻松！</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=”Open Port <span class="number">22</span> <span class="keyword">for</span> WSL2” <span class="built_in">dir</span>=<span class="keyword">in</span> action=allow protocol=TCP localport=<span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>如果您担心，可以像这样列出所有 portproxy 规则：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy show v4tov4</span><br></pre></td></tr></table></figure>
<p>如果需要，您可以将它们全部删除：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">netsh int portproxy reset all</span><br></pre></td></tr></table></figure>
<h3 id="使用脚本自动化设置">使用脚本自动化设置</h3>
<p>由于 WSL2 重启或者 Windows 重启会导致其 IP 发生变化，使用自动化脚本完成更加方便。</p>
<p>脚本详见：<a target="_blank" rel="noopener" href="https://gist.github.com/daehahn/497fa04c0156b1a762c70ff3f9f7edae?WT.mc_id=-blog-scottha">WSL 2 TCP NETWORK FORWARDING</a></p>
<p>使用 Windows <strong>Task Scheduler</strong>/<strong>任务计划程序</strong>设置最高权限，设置启动或者登录自动触发脚本。</p>
<p><img data-src="../../images/devops/wsl-schedule-task.png" alt="wsl2 schedule task"></p>
<p>使用 <code>powershell</code> 执行该 psl 脚本：</p>
<p><img data-src="../../images/devops/wsl-schedule-task-trigger.png" alt="image-20210802180358093"></p>
<h1>配置 Linux</h1>
<h2 id="配置-Shell-为-Zsh">配置 Shell 为 Zsh</h2>
<h3 id="安装-2">安装</h3>
<p>具体参考：<a target="_blank" rel="noopener" href="https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH">Installing ZSH</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install zsh</span><br></pre></td></tr></table></figure>
<p>Oh My Zsh 使你的命令行更加酷炫和便捷，也可以更便捷的管理 Zsh 配置，安装 Oh My Zsh：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>如果出现：Failed to connect to <a target="_blank" rel="noopener" href="http://raw.githubusercontent.com">raw.githubusercontent.com</a> port 443: Connection refused，则代表你的 DNS 可能被污染，使用 VPN 或是配置 <code>/etc/hosts</code> 指明 ip 映射：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">199.232.68.133</span> <span class="string">raw.githubusercontent.com</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-Oh-My-Zsh">配置 Oh My Zsh</h3>
<p>默认的配置文件位于：<em>~/.zshrc</em>，你可以配置主题、插件、alias、PATH 等等，具体参考：<a target="_blank" rel="noopener" href="https://github.com/ohmyzsh/ohmyzsh/wiki">https://github.com/ohmyzsh/ohmyzsh/wiki</a></p>
<hr>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">适用于 Linux 的 Windows 子系统安装指南 (Windows 10)</a></p>
<p><a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/service-openssh">OpenSSH Server</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>WSL2</tag>
        <tag>OpenSSH</tag>
        <tag>SFTP</tag>
        <tag>SSH</tag>
        <tag>Zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Docker 的网络</title>
    <url>/devops/%E5%85%B3%E4%BA%8E-Docker-%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="Docker-容器网络"><code>Docker</code> 容器网络</h2>
<p><code>Docker</code> 从容器中提取了基础的主机连接网络。 这样做为应用程序提供了一定程度的运行时环境不可知性，并允许基础结构管理器调整实现以适合操作环境。 连接到 <code>Docker</code> 网络的容器将获得一个唯一的 IP 地址，该 IP 地址可以为连接到同一 <code>Docker</code> 网络的其他容器进行路由。</p>
<p>但这种方法的主要问题是，在容器内运行的任何软件都没有简洁的方法来确定依赖的宿主机的 IP 地址，这阻止了容器将其服务端点通告给容器网络外部的其他服务。</p>
<p><code>Docker</code> 还将网络视为第一类实体。 这意味着它们具有自己的生命周期，并且不受任何其他对象的约束。 您可以使用 <code>docker network</code> 子命令直接定义和管理它们。</p>
<span id="more"></span>
<p>运行 docker network ls 会将打印所有网络表格信息到终端。 结果应如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">63d93214524b        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">6eeb489baff0        host                host                <span class="built_in">local</span></span><br><span class="line">3254d02034ed        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>Docker</code> 包括三个网络，每个网络由不同的驱动程序提供。 名为 <code>bridge</code> 的网络是默认网络，由网桥驱动程序提供。 桥驱动程序为同一机器上运行的所有容器提供容器间连接。<code>host</code> 网络由 <code>host</code> 驱动程序提供，该驱动程序指示 <code>Docker</code> 不要为连接的容器创建任何特殊的网络命名空间或资源。 主机网络上的容器与主机的网络堆栈交互，就像非容器进程一样。最后，<code>none</code> 网络使用 <code>null</code> 驱动程序。 连接到无网络的容器自身外部将没有任何网络连接。</p>
<p>网络的范围可以采用三个值：<code>local</code>，<code>global</code> 或 <code>swarm</code>。这表明是将网络限制在网络所在的计算机上（<code>local</code>），还是在集群的每个节点上创建网络，而不是在它们之间路由（<code>global</code>），还是无缝地跨接参与 <code>Docker</code> 群的所有主机（多主机） 或整个群集）。 如您所见，所有默认网络都具有 <code>local</code> 范围，并且将无法直接与路由在不同计算机上运行的容器之间通信。</p>
<p>默认 <code>bridge</code> 网络保持与旧 <code>Docker</code> 的兼容性，并且无法利用现代 <code>Docker</code> 功能（包括服务发现或负载平衡），处于同一网络环境下的 <code>docker</code> 容器，可以通过 <code>hostname</code> 互相发现，默认容器的 hostname 和容器名相同，可以只用 <code>--hostname</code> 指定容器主机名。</p>
<h2 id="超越-bridge-网络">超越 <code>bridge</code> 网络</h2>
<p>默认情况下，桥接网络已经可以满足你的需求。桥接网络非常适合单服务部署，例如运行内容管理系统或博客的 <code>LAMP</code> 或大多数本地开发任务。但如果你正在运行旨在容忍机器故障的多服务器环境，则需要能够在不同机器上的容器之间无缝路由流量，桥接网络做不到。</p>
<p><code>Docker</code> 提供了一些开箱即用的选项来处理这种用例。 最佳选择取决于构建网络的环境，如果在 <code>Linux</code> 主机上使用 <code>Docker</code> 并且可以控制主机网络，则可以使用 <code>macvlan</code> 或 <code>ipvlan</code> 网络驱动程序提供的底层网络。 底层网络为每个容器创建第一类的网络地址。 这些身份可从连接主机的同一网络中发现和路由。 机器上运行的每个容器看起来就像网络上的一个独立节点。</p>
<p>如果您正在运行 <code>Mac</code> 的 <code>Docker</code> 或 <code>Windows</code> 的 <code>Docker</code> 或在托管云环境中运行，那么这些选项将不起作用。 此外，底层网络配置取决于主机网络，因此定义很少可移植。 最受欢迎的多主机容器网络选项是 <code>overlay</code> 网络。</p>
<p><code>overlay</code> 网络驱动程序在启用了 <code>swarm</code> 模式的 <code>Docker</code> 引擎上可用。 <code>overlay</code> 网络的结构与桥接网络相似，但是逻辑网桥组件可感知多主机，并且可以在集群中每个节点路由容器间连接。</p>
<p>就像在桥接网络上一样，<code>overlay</code> 网络上的容器也不能从集群外部直接路由。 但是容器间的通信很简单，并且网络定义基本上独立于主机网络环境。</p>
<p>在某些情况下，您会有一些特殊的网络要求，但底层网络或 <code>overlay</code> 网络无法满足这些要求。 也许您需要能够调整主机网络配置，或者确保容器在完全网络隔离的情况下运行。 在这种情况下，您应该使用一种特殊的容器网络。</p>
<h2 id="特殊容器网络：host-和-none">特殊容器网络：<code>host</code> 和 <code>none</code></h2>
<p><code>host</code> 和 <code>none</code>。 这些并不是真正的网络。 相反，它们是具有特殊含义的网络附件类型。</p>
<p>在 <code>docker run</code> 命令上指定 <code>--network host</code> 选项时，您正在告诉 <code>Docker</code> 创建一个没有任何特殊网络适配器或网络名称空间的新容器。 无论结果容器中运行的是哪种软件，对主机网络的访问程度都将与容器外部运行的软件相同。 由于没有网络名称空间，因此所有用于调整网络堆栈的内核工具都可用于修改（只要修改过程可以这样做）。</p>
<p>在 <code>host</code> 网络上运行对于系统服务或其他基础结构组件很有用。 但这在多租户环境中不合适，因此不应将其用于第三方容器。 因此，您通常不希望将容器连接到网络。 本着构建最低特权系统的精神，应尽可能使用 <code>none</code> 网络。</p>
<p>在 <code>none</code> 网络上创建容器会指示 <code>Docker</code> 不要为新容器设置任何已连接的虚拟以太网适配器。 它将具有自己的网络名称空间，因此将被隔离，但是如果没有跨越名称空间边界连接的适配器，它将无法使用网络在容器外部进行通信。 以这种方式配置的容器仍将具有自己的回环接口，因此多进程容器仍可以使用与本地主机的连接进行进程间通信。</p>
<p>桥接网络使用网络地址转换（<code>NAT</code>）来使所有出站容器通信以及桥接网络外部的目的地看起来像是来自主机本身。 这意味着您在容器中运行的服务软件与世界其他地区以及大多数客户和客户所在的网络部分是隔离的。</p>
<h2 id="使用-NodePort-发布处理入站流量">使用 <code>NodePort</code> 发布处理入站流量</h2>
<p><code>Docker</code> 容器网络都是关于容器之间的简单连接和路由的。 将那些容器中运行的服务与外部网络客户端连接起来需要额外的步骤。 由于容器网络通过网络地址转换连接到更广泛的网络，因此您必须专门告诉 <code>Docker</code> 如何从外部网络接口转发流量。 您需要在主机接口上指定 <code>TCP</code> 或 <code>UDP</code> 端口以及目标容器和容器端口，类似于通过家庭网络上的 <code>NAT</code> 屏障转发流量。</p>
<p><code>NodePort 发布</code> 是我们在这里用来匹配 <code>Docker</code> 和其他生态系统项目的术语。 节点部分是对主机的推断，通常是较大机器集群中的节点。</p>
<p>端口发布配置是在容器创建时提供的，以后不能更改。 <code>docker run</code> 和 <code>docker create</code> 命令提供 <code>-p</code> 或 <code>--publish list</code> 选项。 与其他选项一样，<code>-p</code> 选项采用以冒号分隔的字符串参数。 该参数指定主机接口，要转发的主机上的端口，目标端口和端口协议。 以下所有参数均等效：</p>
<ul>
<li><code>0.0.0.0:8080:8080/tcp</code></li>
<li><code>8080:8080/tcp</code></li>
<li><code>8080:8080</code></li>
</ul>
<p>直接使用 <code>port</code> 时未指定主机端口号，会随机从主机端口中分配一个端口号，可以使用 <code>docker port 容器名</code>来查看具体分配端口号，或 <code>docker ps</code> 也可以看到端口映射情况，不过 <code>docker port</code> 可以使用容器端口号缩小查找范围：<code>docker port 容器名 容器端口号</code>。</p>
<h2 id="总结-2">总结</h2>
<p>网络是一个广泛的主题，需要几本书才能正确覆盖。 这里主要解释了 <code>Docker</code> 提供的的单主机的网络实施：</p>
<ul>
<li><code>Docker</code> 网络是第一等公民，可以像容器，卷和镜像一样被创建，索引和删除。</li>
<li>桥接网络是一种特殊的网络，它允许使用内置的容器名称解析来直接进行容器间网络通信。</li>
<li><code>Docker</code> 默认提供另外两个特殊网络：<code>host</code> 和 <code>none</code>。</li>
<li>使用 <code>none</code> 驱动程序创建的网络会将容器与网络隔离。</li>
<li><code>host</code> 网络上的容器将具有对主机上网络设施和接口的完全访问权限。</li>
<li>使用 <code>NodePort</code> 发布将网络流量转发到主机端口与目标容器端口。</li>
<li><code>Docker</code> 网桥网络不提供任何网络防火墙或访问控制功能。</li>
<li>可以为每个容器自定义网络名称解析堆栈。 可以自定义 <code>DNS</code> 服务器，搜索域和静态主机。</li>
<li>网络管理可以使用第三方工具和 <code>Docker none</code> 网络进行外部化。</li>
</ul>
]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>JSR 94 Rule Engine API【翻译】</title>
    <url>/java/JSR-94-Rule-Engine-API/</url>
    <content><![CDATA[<blockquote>
<p>文章节选部分并翻译自：<a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/javase/javarule.html">Getting Started With the Java Rule Engine API (JSR 94): Toward Rule-Based Applications</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.jcp.org/en/jsr/detail?id=94">Java 规则引擎 API (JSR 94)</a> 规范是通过 <a target="_blank" rel="noopener" href="http://www.jcp.org/">Java Community Process (JCP)</a> 项目开发的，它通过提供一个简单的 API 来访问来自 Java 平台标准版的规则引擎，从而为规则引擎定义了 Java 运行时 API（ Java SE）或 Java Platform Enterprise Edition（Java EE）Java 技术客户端。本文概述了 JSR 94，并讨论了如何将业务规则技术融入 Java 技术应用程序中。示例代码展示了开发基于规则的应用程序所涉及的工作。</p>
<h2 id="引言">引言</h2>
<p>许多业务应用程序必须应对市场经济的动态变化。例如，用于保险和银行业的应用程序必须能够适应在设计过程中没有人能够预测或计划的不可避免的市场变化。一个解决方案是拥有一个规则引擎，它根本上是一组工具，使业务分析师和开发人员能够根据组织的数据构建决策逻辑。规则引擎应用最终用户定义的规则和操作，而不会影响应用程序的运行方式。该应用程序是为处理单独设计的规则而构建的。</p>
<p>规则引擎的示例包括 Drools、Fair Isaac Blaze Advisor、ILOG JRules 和 Jess，仅举几例。然而，缺乏标准可能是阻止企业使用基于规则的应用程序的主要因素。大多数规则引擎都有专有的 API，这使得它们很难与应用程序集成。如果不再支持某个规则引擎，而业务决定采用其他规则引擎，则需要重写大部分应用程序代码。JSR 94 尝试标准化 Java 技术的规则引擎实现。前面提到的四个规则引擎都支持 JSR 94。</p>
<p>JSR 94 为规则管理和规则运行时 API 提供了指南，但它没有定义用于定义规则和操作的语言的指南。正在努力标准化通用规则语言，包括 <a target="_blank" rel="noopener" href="http://www.ruleml.org/">规则标记语言 (RuleML)</a>。</p>
<span id="more"></span>
<h2 id="Rule-Engine">Rule Engine</h2>
<p><strong>规则引擎的基本思想是将业务或应用程序逻辑外部化。</strong> 规则引擎可以被视为一个复杂的 <em>if-then</em> 语句解释器。<em>if-then</em> 语句是规则。规则由条件和动作两部分组成：当条件满足时，动作被执行。<em>if</em> 部分包含条件（例如金额 &gt;=$100），<em>then</em> 部分包含操作（例如优惠折扣 5%）。规则引擎的输入是称为规则执行集和数据对象的规则集合。输出由输入决定，可能包括经过修改的原始输入数据对象、新数据对象和可能的副作用（例如向客户发送电子邮件）。</p>
<p>规则引擎应该用于具有高度动态业务逻辑的应用程序以及允许最终用户编写业务规则的应用程序。规则引擎是高效决策的绝佳工具，因为它可以快速、可靠和重复地根据数以千计的事实做出决策。</p>
<p>规则引擎允许对于在开发周期外的人制定的规则能够快速响应，快速部署。</p>
<h3 id="术语">术语</h3>
<ul>
<li>
<p><strong>规则 - Rule</strong>：<em>一组条件（condition），然后是一组动作（action）</em>。它代表了系统的逻辑。规则主要以 <em>if-then</em> 形式表示。它主要包含<strong>条件</strong>和<strong>动作</strong>两部分。规则有时也被称为<strong>作业（production）</strong>。</p>
<blockquote>
<p><strong>Rule = Condition + Action</strong></p>
</blockquote>
<p>条件也称为<strong>事实（fact）或前因（antecedents）或模式（pattern）</strong>。动作也被称为<strong>结果（consequent）</strong>。</p>
<p>规则在以下原则上工作：</p>
<ul>
<li>它们是相互独立的</li>
<li>很容易变更（修改、移除、增加）</li>
<li>每个规则控制最小数量的所需信息，原子性</li>
<li>可以允许不同背景的人协作</li>
</ul>
</li>
<li>
<p><strong>人类专家</strong>：相应业务领域的专家。这个人以规则的形式提供<strong>知识（Knowledge）</strong>。</p>
<p>规则形式的知识：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Rule</span> <span class="number">1</span>: 一个人是否有资格获得住房贷款？</span><br><span class="line"><span class="attribute">if</span>:</span><br><span class="line">   <span class="attribute">1</span>. 他的月薪超过 <span class="number">7</span>K。</span><br><span class="line">   <span class="attribute">2</span>. 他的征信评分超过 <span class="number">80</span>。</span><br><span class="line"><span class="attribute">then</span>:</span><br><span class="line">   <span class="attribute">1</span>. 获批房屋贷款。 </span><br><span class="line">   <span class="attribute">2</span>. 获批房屋贷款总额的 <span class="number">30</span>%。</span><br><span class="line"><span class="attribute">Rule</span> <span class="number">2</span>: 一个人是否有资格获得住房贷款？</span><br><span class="line"><span class="attribute">if</span>:</span><br><span class="line">   <span class="attribute">1</span>. 他的月薪超过 <span class="number">15</span>K。</span><br><span class="line">   <span class="attribute">2</span>. 他的征信评分超过 <span class="number">70</span>。</span><br><span class="line"><span class="attribute">then</span>:</span><br><span class="line">   <span class="attribute">1</span>. 获批房屋贷款。</span><br><span class="line">   <span class="attribute">2</span>. 获批房屋贷款总额的 <span class="number">60</span>%。   </span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>专家系统 - Expert System</strong>：它是一个使用人类专家的知识来解决问题并给出解决方案的程序。它也被称为基于规则的系统或者作业系统。</p>
<p><img data-src="../../images/java/rule-engine/expert-system-program.jpeg" alt="Expert System Program"></p>
</li>
<li>
<p><strong>推理引擎 - Inference Engine</strong>：它是专家系统的大脑，管理专家系统内部的大量规则和事实。它的工作是挑选规则并应用数据并生成解决方案。我们将详细讨论它。</p>
</li>
</ul>
<p>规则引擎，也是一个专家系统程序，它对数据运行规则，如果有任何条件匹配，则执行相应的动作。</p>
<p><img data-src="../../images/java/rule-engine/rule-based-system.png" alt="Rule Based System"></p>
<p>在上图中，表明我们以规则（if-then 形式）的形式收集知识并将它们放置在任意的存储系统中，如文件或数据库。现在推理引擎根据需求选择规则并在输入数据或查询上运行它们。如果任何模式/条件匹配，则它执行相应的操作并返回结果或解决方案。</p>
<h3 id="推理引擎">推理引擎</h3>
<p>推理引擎是专家系统的核心组成部分，它将逻辑规则应用于知识库，从已知事实中推断出新信息。推理引擎通常以两种模式运行，它们是：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Forward_chaining">正向推理 - Forward chaining</a></p>
<p>数据驱动，其基本思想是：从问题已有的事实（初始证据）出发，正向使用规则，当规则的条件部分与已有的事实匹配时，就把该规则作为可用规则放入候选规则队列中，然后通过冲突消解，在候选队列中选择一条规则作为启用规则进行推理，并将其结论放入数据库中，作为下一步推理时的证据。如此重复这个过程，直到再无可用规则可被选用或者求得了所要求的解为止。</p>
</li>
</ul>
<p>例如：假如我们想根据给定的规则和数据知道名字为 Fritz 宠物的肤色。</p>
<p>Rules：</p>
<figure class="highlight tp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. if <span class="keyword">X</span> 呱呱叫 and <span class="keyword">X</span> 吃苍蝇 - then <span class="keyword">X</span> 是一只青蛙</span><br><span class="line"><span class="number">2</span>. if <span class="keyword">X</span> 啁啾叫 - then <span class="keyword">X</span> 是金丝雀</span><br><span class="line"><span class="number">3</span>. if <span class="keyword">X</span> 是一只青蛙 - then <span class="keyword">X</span> 是绿色的</span><br><span class="line"><span class="number">4</span>. if <span class="keyword">X</span> 是金丝雀 - then <span class="keyword">X</span> 是黄色的</span><br></pre></td></tr></table></figure>
<p>Data:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> Fritz 呱呱叫</span><br><span class="line"><span class="bullet">2.</span> Fritz 吃苍蝇</span><br></pre></td></tr></table></figure>
<p>根据给定的规则和数据我们可以提取到以下信息：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Fritz</span> 是青蛙。</span><br><span class="line">Fritz 是绿色的。</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Backward_chaining">反向推理 - Backward chaing</a></p>
<p>目标驱动，它是首先提出某个假设，然后寻找支持该假设的证据，若所需的证据都能找到，说明原假设是正确的；若无论如何都找不到所需要的证据，则说明原假设不成立，此时需要另做新的假设。</p>
</li>
</ul>
<p>还有一类称为 <em><strong>双向推理 - Hybrid chaining</strong></em>，它是正向和反向推理的组合。</p>
<p>推理引擎的程序分三个阶段工作，以对给定数据执行规则。</p>
<p><img data-src="../../images/java/rule-engine/inference-engine.png" alt="Inference Engine"></p>
<p><strong>阶段 1 — 匹配 Match</strong>：在此阶段，推理引擎将事实和数据与规则集进行匹配。这个过程称为模式匹配。</p>
<p>我们可以用于模式匹配的算法有：</p>
<ul>
<li>Linear</li>
<li>Rete</li>
<li>Treat</li>
<li>Leaps</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.jboss.org/drools/release/7.27.0.Final/drools-docs/html_single/index.html">Drools</a> 是规则引擎的实现之一，使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rete_algorithm">Rete 算法</a>变种 <a target="_blank" rel="noopener" href="https://docs.jboss.org/drools/release/latestFinal/drools-docs/html_single/index.html#phreak-algorithm-con_decision-engine">Phreak 算法</a> 进行模式匹配。它是模式匹配的最佳算法之一。</p>
<p><em>第一阶段的输出是一个冲突集（Conflict Set）</em>。冲突集意味着，对于相同的事实或条件，可能满足不止一个规则。所以它返回冲突规则集。</p>
<p><strong>阶段 2 — 解决 Resolve</strong>：在此阶段，推理引擎管理冲突规则的顺序。它解决了冲突并给出了选定的规则。为了解决冲突，它可以使用以下任何算法。</p>
<ul>
<li>Lex</li>
<li>Recency</li>
<li>MEA</li>
<li>Refactor</li>
<li>Priority wise</li>
</ul>
<p><img data-src="../../images/java/rule-engine/resolve-conflict.png" alt="Resolve Conflict"></p>
<p><strong>阶段 3 — 执行 Execute</strong>：在此阶段，推理引擎仅对给定数据运行所选规则的动作，并将输出/结果返回给客户端。</p>
<h2 id="使用规则引擎的时间、地点和原因">使用规则引擎的时间、地点和原因</h2>
<p>规则引擎在应用程序中用于替换和管理一些业务逻辑。它们最适用于业务逻辑过于动态而无法在源代码级别进行管理的应用程序——也就是说，业务策略的更改需要立即反映在应用程序中。保险（例如保险评级）、金融服务（贷款、欺诈检测、索赔路由和管理）、政府（申请流程和税收计算）、电信客户服务和计费（需要的长途电话促销）等领域的应用集成到计费系统中）、电子商务（个性化用户体验）等都可以从使用规则引擎中受益匪浅。</p>
<p>基于规则的应用程序通过传入要执行的规则集来与规则引擎进行通信。然后，应用程序可以检查结果并将其显示给最终用户或执行进一步处理。规则引擎根据规则所需的输入以及从先前规则的评估中获得的结果来确定何时评估每个规则。您不需要指定规则的顺序或依赖关系。</p>
<p>例如，在 Java EE 企业应用程序中，规则可以适合如下应用程序：</p>
<ul>
<li>在应用层管理动态业务逻辑和任务流</li>
<li>在表现层自定义页面流程和工作流程，以及根据会话状态构建自定义页面</li>
</ul>
<p>为您的应用程序采用基于规则的方法具有以下优势：</p>
<ul>
<li>代表策略的规则很容易传达和理解。</li>
<li>规则比传统的编程语言保持更高级别的独立性。</li>
<li>规则将知识与其实现逻辑分开。</li>
<li>无需更改源代码即可更改规则；因此，无需重新编译应用程序的代码。</li>
</ul>
<p>然而，这些好处并非没有代价。与任何工具一样，将规则引擎集成到您的应用程序中的决定应基于成本与收益。成本包括学习曲线以及在应用程序和规则引擎之间构建接口所涉及的工作。此外，不同的规则引擎使用不同的格式和语法来定义规则。因此，如果组织决定从一种规则引擎转移到另一种规则引擎，业务分析师和开发人员必须学习和了解另一种工具的操作。</p>
<h2 id="JSR-94">JSR 94</h2>
<p>JSR 94 定义了一个简单的 API，用于从 Java SE 或 Java EE 客户端访问规则引擎。它提供 API</p>
<ul>
<li>注册和注销规则</li>
<li>解析规则</li>
<li>检查规则元数据</li>
<li>执行规则</li>
<li>检索结果</li>
<li>过滤结果</li>
</ul>
<p>请注意，JSR 94 <em>未</em>对以下内容进行标准化：</p>
<ul>
<li>规则引擎本身</li>
<li>规则的执行流程</li>
<li>用于描述规则的语言</li>
<li>Java EE 技术的部署机制</li>
</ul>
<p>换句话说，它没有标准化规则执行的语义。</p>
<h2 id="JSR-94-架构">JSR 94 架构</h2>
<p>API 定义在两个主要包中：</p>
<ul>
<li><strong>规则管理员 API</strong>：这个 API 在 <code>javax.rules.admin</code> 包中定义 ，提供可用于加载规则和关联动作来作为执行集的类。一个 <em>rule execution set - 规则执行集</em>是规则的集合。规则可以从外部资源加载，例如 URI、一个 <code>InpuTStream</code>、一个 XML <code>Element</code>、一个二元抽象语法树或一个 <code>Reader</code> 。它还提供了注册和取消注册规则执行集的方法。此包还可用于定义对执行集的权限以提供访问授权。</li>
<li><strong>运行时客户端 API</strong>：此 API 在 <code>javax.rules</code> 包中定义 ，提供客户端使用的类来运行规则并获取结果。只能访问使用规则管理器 API 注册的规则。此 API 使客户端能够获取规则会话并在该会话中执行规则。</li>
</ul>
<p>JSR 94 专家组决定使用两个单独的包来加强以下区别：(1) 执行管理员 API 先前加载并注册到运行时环境中的规则执行集和 (2) 动态加载和执行外部资源（只能通过使用规则管理员 API 来执行）。此外，分离允许对用户群进行更细粒度的控制，允许一些用户执行规则但不能管理它们。</p>
<h3 id="规则管理员-API"><strong>规则管理员 API</strong></h3>
<p>此 API 使用 <code>RuleServiceProvider</code> 该类获取 <code>RuleAdministrator</code> 接口的实例，该实例提供注册和取消注册执行集的方法。管理员 API 的高级功能如下：</p>
<ul>
<li>它通过 <code>RuleServiceProvider</code> 类获取接口 <code>RuleAdministrator</code> 的实例</li>
<li>它从外部可序列化或不可序列化的资源创建一个 <code>RuleExecutionSet</code>，包括
<ul>
<li><code>org.w3c.dom.Element</code> 用于从 XML 子文档中读取</li>
<li><code>java.io.InputStream</code> 用于从二进制流中读取</li>
<li><code>java.lang.Object</code> 用于从特定于供应商的抽象语法树中读取</li>
<li><code>java.io.Reader</code> 用于从字符流中读取</li>
<li><code>java.lang.String</code> 用于从 URI 中读取</li>
</ul>
</li>
<li>它根据 URI 注册 <code>RuleExecutionSet</code> 对象以供 <code>RuleRuntime</code> 使用。</li>
<li>它根据 URI 取消注册 <code>RuleExecutionSet</code> 对象，因此不再可以从 <code>RuleRuntime</code> 访问它。</li>
<li>它通过从 <code>RuleExecutionSet</code> 检索 <code>Rule</code> 对象列表来查询规则执行集的结构元数据。</li>
<li>它在规则执行集和规则上设置和获取应用程序或供应商特定的属性。</li>
</ul>
<h3 id="运行时客户端-API"><strong>运行时客户端 API</strong></h3>
<p>此 API 以类似于 Java 数据库连接 (JDBC) 软件的方式提供对规则引擎 API 的供应商实现的访问。供应商通过 <code>RuleServiceProvider</code> 类向客户公开他们的规则引擎实现。此类提供对运行时和管理 API 的访问。供应商提供唯一标识实现的规则服务提供程序 URL。所有规则服务提供者都应该注册一个 <code>RuleServiceProviderManager </code> 对象，以便客户端可以访问。</p>
<p>这个 API 的核心是 <code>RuleRuntime</code> 接口，它提供了允许客户端创建 <code>RuleSession</code> 用于运行规则的方法。<code>RuleSession</code> 是客户端和规则引擎之间的运行时连接；它与单个规则执行集相关联，可能会消耗规则引擎资源，但当客户端不再需要规则会话时，必须明确释放规则会话。因此，规则会话做了两件事：</p>
<ul>
<li>它提供了一种机制来访问向规则服务提供者注册的所有规则执行集的列表。</li>
<li>它定义了客户端希望建立的会话类型：有状态或无状态。
<ul>
<li><code>statelessRuleSession</code> 无状态规则会话提供了高性能和简单的 API，该 API 执行具有输入对象列表的规则执行集。无状态规则会话方法是幂等的。</li>
<li><code>statefulRuleSession</code> 有状态规则会话允许客户端与规则执行集合进行长时间的交互。输入对象可以逐步添加到会话中，输出对象也可以被重复查询。</li>
</ul>
</li>
</ul>
<p>Runtime Client API 的高级功能如下：</p>
<ul>
<li>它通过 <code>RuleServiceManager</code> 类获取规则引擎供应商的规则服务提供者的实例 。</li>
<li>它通过 <code>RuleServiceProvider</code> 类获取接口 <code>RuleRuntime</code> 的实例 。</li>
<li>它通过 <code>RuleRuntime</code> 创建一个 <code>RuleSession</code>。</li>
<li>它获取已注册 URI 的 <code>java.util.List</code>。</li>
<li>它与获取的 <code>RuleSession</code> 交互。</li>
<li>它通过 <code>RuleExecutionSetMetadata</code> 接口检索 <code>RuleSession</code> 的元数据。</li>
<li>它提供了一个 <code>ObjectFilter</code> 接口来过滤执行 <code>RuleExecutionSet</code> 的结果。</li>
<li>它使用 <code>Handle</code> 实例来访问添加到 <code>statefulRuleSession</code> 的对象。</li>
</ul>
<h2 id="参考实现">参考实现</h2>
<p>Drools 是一个业务规则管理系统，具有基于正向推理和反向推理的规则引擎，允许快速可靠地评估业务规则和复杂事件处理。规则引擎也是创建专家系统的基本构件，在人工智能中，专家系统是模拟人类专家决策能力的计算机系统。</p>
<p>Drools 支持多种类型资产，您可以使用这些资产为决策服务定义业务决策规则。每个决策创作资产都有不同的优势，您可能更喜欢使用一种资产或多种资产的组合，具体取决于您的目标和需求。</p>
<p>这些资产类型包括：决策模型和符号 (DMN) 模型、引导决策表、电子表格决策表、引导规则、引导规则模版、DRL 规则、预测模型标记语言 (PMML) 模型。</p>
<p>一个简单的 DRL 规则文件结构如下，它由条件和动作组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rule <span class="string">&quot;name&quot;</span> </span><br><span class="line"></span><br><span class="line">when     </span><br><span class="line">  (Conditions) - also called Left Hand Side of the <span class="title function_">Rule</span> <span class="params">(LHS)</span> </span><br><span class="line">then     </span><br><span class="line">  (Actions/Consequence) - also called Right Hand Side of the <span class="title function_">Rule</span> <span class="params">(RHS)</span> </span><br><span class="line">end </span><br></pre></td></tr></table></figure>
<h3 id="Drools-engine">Drools engine</h3>
<p>Drools 引擎的基本功能是将传入的数据或事实与规则的条件进行匹配，并确定是否以及如何执行规则。</p>
<p>Drools 引擎使用以下基本组件运行：</p>
<ul>
<li><strong>Rules</strong>：规则，您定义的业务规则或 DMN 决策。所有规则必须至少包含触发规则的条件和规则规定的动作。</li>
<li><strong>Facts</strong>：事实，在 Drools 引擎中输入或更改的数据，Drools 引擎与规则条件匹配以执行适用的规则。</li>
<li><strong>Production memory</strong>：作业内存，Rules 存储在 Drools 引擎中的位置。</li>
<li><strong>Working memory</strong>：工作内存，Facts 存储在 Drools 引擎中的位置。</li>
<li><strong>Agenda</strong>：议程，激活的规则被注册和排序（如果适用）以准备执行的位置。</li>
</ul>
<p>当业务用户或自动化系统在 Drools 中添加或更新与规则相关的信息时，该信息以一个或多个事实的形式插入到 Drools 引擎的工作内存中。Drools 引擎将这些事实与存储在作业内存中的规则条件进行匹配，以确定符合条件的规则执行。 （这种将事实与规则匹配的过程通常称为<em>模式匹配 - pattern matching</em>。）当满足规则条件时，Drools 引擎在议程中激活并注册规则，然后 Drools 引擎对优先或冲突的规则进行排序以准备执行。</p>
<p>下图说明了 Drools 引擎的这些基本组件：</p>
<p><img data-src="../../images/java/rule-engine/rule-engine-inkscape_enterprise.png" alt="rule-engine-inkscape_enterprise"></p>
<p>Drools 规则引擎会将规则转换成执行树，每个规则条件都被拆分为小块，在树结构中连接并重用。每当数据被传送到规则引擎，它将在此类似的树中进行评估并最终到达动作节点，这些规则将会标记为该数据特定的执行规则集。</p>
<p><img data-src="../../images/java/rule-engine/rules-execution-trees.png" alt="Rules Execution Trees"></p>
<p>同样的 Drools 中的会话也分为有状态和无状态：</p>
<ul>
<li>Stateless Session 无状态会话，无状态会话是<strong>不使用推理</strong>来随时间对事实进行迭代更改的会话。在无状态会话中，来自先前会话调用（先前会话状态）的数据在会话调用之间被丢弃，而在有状态会话中，该数据被保留。无状态会话的行为类似于函数，因为它产生的结果由 KIE 基础的内容和传递到会话以在特定时间点执行的数据确定。</li>
<li>Stateful Session 有状态会话，它<strong>使用推理</strong>随着时间的推移对事实进行迭代更改。在有状态的会话中，来自会话的先前调用（先前的会话状态）的数据在会话调用之间保留，而在无状态会话中，该数据被丢弃。有状态会话会保留之前输入的 Facts 的 Working memory 和当前输入的 Facts 来做联合评判、推理。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Rule Engine</tag>
        <tag>JSR 94</tag>
        <tag>Drools</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式共识算法</title>
    <url>/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1>历史</h1>
<p>在早些的文献中，共识（consensus）也叫做协商（agreement）。</p>
<p>本文按照最有意义的顺序进行讨论，而不是按照发表的顺序。</p>
<p>我所知道的共识问题的第一个实例是在 Lamport 的 <a target="_blank" rel="noopener" href="http://research.microsoft.com/users/lamport/pubs/time-clocks.pdf">“Time, Clocks and the Ordering of Events in a Distributed System” (1978)</a> 中，尽管它没有明确声明为共识或协商问题。在本文中，Lamport 讨论了消息如何在处理器之间以有限的时间传播，并与爱因斯坦的狭义相对论进行了类比。并给出了一个完整的分析，包括时空图等等。问题在于，在分布式系统中，您无法判断事件 A 是否发生在事件 B 之前，除非 A 以某种方式导致了 B。每个观察者都可以看到事件以不同的顺序发生，除了相互导致的事件，即在分布式系统中事件只有部分有序。Lamport 定义了“<code>happens before</code>”的关系和运算符，并继续提供一种算法，该算法提供分布式系统中事件的总排序，以便每个进程以与其他进程相同的顺序查看事件。</p>
<span id="more"></span>
<p>Lamport 还引入了 <strong><code>分布式状态机</code></strong> 的概念：在相同状态下启动一组确定性状态机，然后确保它们以相同的顺序处理相同的消息。每台机器现在都是其他机器的复制品。关键问题是让每个副本都同意下一个要处理的消息是什么：共识问题。这就是创建事件总排序的算法所做的，它为消息传递提供了一个约定的排序。但是，该系统不具有容错能力。如果一个进程失败，其他进程就必须等待它恢复。</p>
<p>大约与该文章同时，Gray 在 <a target="_blank" rel="noopener" href="http://research.microsoft.com/~Gray/papers/DBOS.pdf">“Notes on Database Operating Systems” (1979)</a> 中描述了 <strong><code>2PC</code></strong>。不幸的是，如果 TM（Transaction Manager）在错误的时间发生故障，2PC 会阻塞。Skeen 在 <a target="_blank" rel="noopener" href="http://www.cs.cornell.edu/courses/cs614/2004sp/papers/Ske81.pdf">“NonBlocking Commit Protocols” (1981)</a> 中表明，对于分布式事务，您需要一个 3 段式提交算法来避免与 2PC 相关的阻塞问题<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，<strong><code>3PC</code></strong>。</p>
<p>Fischer、Lynch 和 Paterson 在 <a target="_blank" rel="noopener" href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf">“Impossibility of Distributed Consensus with One Faulty Process” (1985)</a> 中表明，在即使只有一个错误进程的异步系统中分布式共识也是不可能的，这也被称为著名的“<strong><code>FLP</code></strong>”结论。到了这个时候，“共识”是让一堆处理器同意一个值的问题的名称。在一个<u>完全异步</u>的系统中（处理器以任意速度运行，消息在处理器之间传输需要任意长的时间），有一个完美的网络（所有消息都被传递，消息按顺序到达并且不能复制）即使只有一个错误的进程（甚至只是一个故障停止），也不存在一个可以解决一致性问题的确定性共识算法 。问题的核心是在这种理论场景下您无法区分已停止的进程和运行非常缓慢的进程之间的区别，这使得在异步系统中处理故障几乎是不可能的。这种不可能的结果来自于最坏情况的调度场景，在实践中不太可能发生，除非在对抗的情况下，如网络中的智能拒绝服务攻击者。在大多数正常情况下，进程调度有一定程度的自然随机性。这篇论文也很重要，因为它展示了如何证明某事是不可能的：证明所有解决问题的算法都必须具有某种性质，然后证明这种性质是不可能的，即反证法。</p>
<p>在这个阶段，人们意识到分布式算法有两个特性：<strong>安全性</strong>（<code>Safety</code>）和<strong>活性</strong>（<code>Liveness</code>）。专业的资料一般翻译为<strong>协定性</strong>（<code>Safety</code>）和<strong>终止性</strong>（<code>Liveness</code>），协议性意味着所有的坏事都不会发生，而终止性意味着好事终会发生。2PC 是一种异步共识算法，所有进程必须就事务的提交或中止达成一致。2PC 是安全的：没有错误数据被写入数据库，但它的活跃性不是很好：如果 TM 在错误的点失败，系统将阻塞。</p>
<p>同样到了这个阶段，人们认为分布式系统是同步的（进程以已知的速率运行，消息在已知的时间范围内传递）或异步的（进程以未知的任意速率运行，并且消息可能需要无限的时间来传递）。异步情况比同步情况更普遍：适用于异步系统的算法也适用于同步系统，但反之则不然。您可以将同步系统视为异步系统的一个特例，它恰好对传递消息所需的时间有限制。</p>
<p>在 FLP 之前，有 <strong><code>拜占庭将军问题</code></strong> <a target="_blank" rel="noopener" href="http://research.microsoft.com/users/lamport/pubs/byz.pdf">“The Byzantine Generals Problem” (1982)</a> 论文。在这种形式的共识问题中，进程可以撒谎，并且它们可以积极地试图欺骗其他进程。这个问题看起来比 FLP 结果更难，但它确实有同步情况的解决方案（尽管在写拜占庭将军论文时异步和同步系统之间的区别并不明确）。该解决方案在交换消息的数量上和所需的消息轮数方面代价高昂。问题最初来自航空航天工业：如果传感器在飞机上提供错误信息会发生什么（显然系统可以被视为同步）。</p>
<p>1986 年，对共识感兴趣的分布式系统人员和交易人员聚集在一起。当时最好的共识算法是拜占庭将军，但这对于事物来说太昂贵了。Jim Gray 写了一份会议记录：<a target="_blank" rel="noopener" href="http://research.microsoft.com/~Gray/papers/TandemTR88.6_ComparisonOfByzantineAgreementAndTwoPhaseCommit.pdf">“A Comparison of the Byzantine Agreement Problem and the Transaction Commit Problem.” (1987) </a>。</p>
<p>该论文在介绍中包含此内容：“在会议之前，人们普遍认为分布式系统面临的事务提交问题是学术界研究的拜占庭将军问题的退化形式。也许这次会议最有用的结果是表明这两个问题几乎没有共同之处。”</p>
<p>最终，<strong><code>分布式事务</code><strong>将被视为共识的一种版本，称为</strong><code>统一共识</code></strong>（参见<a target="_blank" rel="noopener" href="http://infoscience.epfl.ch/getfile.py?recid=88273&amp;mode=best">&quot;Uniform consensus is harder than consensus&quot; (2000)</a>）。有了统一的共识，所有进程都必须就一个值达成一致，即使是错误的进程——只有当所有 RM<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 都准备好提交时，事务才应该提交。大多数形式的共识只关注让非错误流程达成一致。统一共识比普遍共识更难。</p>
<p>最终，Lamport 提出了 <strong><code>Paxos 共识算法</code></strong>，在 <a target="_blank" rel="noopener" href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf">“The Part-Time Parliament” (submitted in 1990, published 1998)</a> 中有所描述。不幸的是，用希腊城邦作为比喻反而使得描述更为晦涩，人们发现这篇论文很难理解，这篇论文一直被忽略，直到 Butler Lampson 在 <a target="_blank" rel="noopener" href="http://research.microsoft.com/lampson/58-Consensus/Acrobat.pdf">“How to Build a Highly Availability System using Consensus” (1996)</a> 中讨论了这个问题。该文很好地介绍了构建容错系统和 Paxos。后来，Lamport 重新出版 <a target="_blank" rel="noopener" href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf">&quot;Paxos Made Simple (2001)</a>。Paxos 的内核是给定一个固定数量的进程，它们中的大多数必须至少有一个共同的进程。例如，给定三个进程 A、B 和 C，可能的多数是：AB、AC 或 BC。如果在有多数票（例如 AB）时作出决定，那么在未来的任何时候，当另一个多数可用时，至少有一个进程可以记住前一个多数决定的内容。如果多数是 AB，则两个进程都会记住，如果存在 AC，则 A 会记住，如果存在 BC，则 B 会记住。</p>
<p>Paxos 可以容忍丢失的消息、延迟的消息、重复的消息和无序传递的消息。如果有一个领导者有足够的时间可以与大多数进程对话两次<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，它们将达成共识。任何进程，包括领导者，都可能失败并重新启动；实际上所有进程都可能同时失败，算法仍然是安全的。一次也可以有多个领导者。</p>
<p>Paxos 是一种异步算法；没有明确的超时。然而，它只有在系统以同步方式运行时才达成共识，即消息在有限的时间段内传递；否则是安全的。根据 <code>FLP</code>，有一种特殊情况是 Paxos 不会达成共识，但这种理论设想在实践中相对容易避免<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。</p>
<p>将系统明确划分为同步和异步的区别过于宽泛，而 Dwork、Lynch 和 Stockmeyer 在 <a target="_blank" rel="noopener" href="http://theory.lcs.mit.edu/tds/papers/Lynch/jacm88.pdf">“Consensus in the presence of partial synchrony” (1988) </a> 中定义了 <strong><code>部分同步系统</code></strong>。部分同步系统有两种版本：一种是进程以已知范围内的速度运行，消息在有限时间内传递，但实际值事先未知；在另一个版本中，进程的速度范围和消息传递的上限是先验已知的，但它们只会在未来某个未知时间开始保持。部分同步模型是比同步或异步模型更好的现实世界模型；大多数情况下，网络以可预测的方式运行，但偶尔会出问题。</p>
<p>Lamport 和 Gray 在  <a target="_blank" rel="noopener" href="http://research.microsoft.com/research/pubs/view.aspx?tr_id=701">“Consensus on Transaction Commit” (2005)</a> 中继续将 Paxos 应用于分布式事务提交问题。他们使用 Paxos 有效地复制了 2PC 的 TM，并为事物中涉及的每个 RM 使用了一个 Paxos 实例来同意该 RM 是否可以提交该事物。从表面上看，每个 RM 使用一个 Paxos 实例看起来很昂贵，但事实证明并非如此。对于无故障情况，<strong><code>Paxos Commit</code></strong> 将分两个阶段完成，即它具有与 2PC 相同的消息延迟，但交换了更多消息。根据 Skeen 结果，仅当存在故障时才需要第三阶段。给定 2n+1 个 TM 副本，Paxos Commit 将完成最多 n 个错误副本。Paxos Commit 并没有直接使用 Paxos 来解决事务提交问题，即它不是用来解决统一共识的，而是用来使系统容错的。</p>
<p>任何因为 2PC 阻塞而不应使用分布式事务的论点都是无效的，如果将 2PC 中的 TM 做出 committed/aborted 决策这一步替换为一轮 Paxos，就能解决 2PC 的容错问题。但此时 TM 仍然需要先得知所有 RM 都 prepared，至少需要一轮消息延时。而本文提出的 Paxos Commit 算法则消除了这次延时。</p>
<p>最近有一些关于 <strong><code>CAP</code></strong> 猜想的讨论：<strong>一致性</strong>（<code>Consistency</code>）, <strong>可用性</strong>（<code>Availability</code>）和 <strong>分区容忍性</strong>（<code>Partition</code>）。该猜想断言，在分布式系统中不能同时拥有这三个系统：一致的系统、可能有错误的进程以及能够处理网络分区的系统。</p>
<p>我们可以通过将一致性与共识等同起来来看 CAP。对于异步系统，我们无法就一个错误的进程达成共识，FLP，因此我们无法同时兼得异步系统的一致性和可用性！</p>
<p>现在以一个具有三个节点的 Paxos 系统为例：A、B 和 C。如果两个节点都在工作，我们就可以达成共识，即我们可以满足一致性和可用性。现在如果 C 被分区并且 C 被查询，它无法响应，因为它无法与其他节点通信；它不知道自己是否已分区，或者其他两个节点是否已关闭，或者网络是否非常慢。其他两个节点可以继续，因为它们可以相互交谈并且形成多数。所以对于 CAP 猜想，Paxos 不满足分区容忍性，因为 C 无法响应查询。然而，我们可以设计我们的方法来解决这个问题。如果我们在一个数据中心内，我们可以使用两个独立的网络（Paxos 不介意消息是否重复）。如果我们在互联网上，那么我们可以让我们的客户端查询所有节点 A、B 和 C，如果 C 被分区，则客户端可以查询 A 或 B，除非它以类似于 C 的方式分区。</p>
<p>对于同步网络，如果 C 被分区，如果它在固定时间段内没有收到消息，它可以知道它被分区，从而可以向客户端声明自己。</p>
<p><code>Paxos</code>、<code>Paxos Commit</code> 和 <code>HTTP/REST</code> 结合起来构建了一个高可用的网格计算协同分配系统，详细信息可以在这里找到  <a target="_blank" rel="noopener" href="https://www.cct.lsu.edu/research/cyber-advancement/harc"><code>HARC - The Highly-Available Resource Co-allocator </code></a>，这篇论文中还有更多的参考资料：<a target="_blank" rel="noopener" href="http://www.allhands.org.uk/2006/proceedings/papers/624.pdf">“Co-Allocation, Fault Tolerance and Grid Computing” (2006)</a>。</p>
<h1>Paxos</h1>
<p><code>Paxos</code> 算法 —— <code>Paxos</code> 是由 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Leslie_Lamport">Leslie Lamport</a> 提出的一种基于消息传递且具有高度容错特性的分布式系统的共识算法。</p>
<p>现已是当今分布式系统最重要的理论基础，如果没有 <code>Paxos</code>，那后续的 <code>Raft</code>、<code>ZAB</code> 等算法，<code>ZooKeeper</code>、<code>Etcd</code> 这些分布式协调框架、<code>Hadoop</code>、<code>Consul</code> 这些在此基础上的各类分布式应用都很可能会延后好几年面世。</p>
<h2 id="共识算法">共识算法</h2>
<p>假设有一个由多个进程组成的集合，集合里的每个进程都可以提议（可能不同的）值。共识算法保证在被提议的这些值中只有一个值能够被选定。一旦一个值被选定，则所有进程都需要能够获知（learn）这个被选定的值。共识算法的安全性要求做到：</p>
<ul>
<li>只有被提议的值才可以被选定，</li>
<li>只能有一个值能被选定，</li>
<li>只有一个值真的已经“确定”被选定，其他进程才能获知这个值已被选定</li>
</ul>
<p><strong>我们不会尝试去明确精准的活性要求</strong>。无论如何，算法的目标是要保证被提议的值中有某个值能够被选定，并且一旦一个值被选定了，其他进程最终能够获知这个被选定的值。</p>
<p>我们让三类代理（agent）来执行这个共识算法中的三个角色：<strong>提议者</strong>（<code>proposers</code>）、<strong>接受者</strong>（<code>acceptors</code>）以及<strong>学习者</strong>（<code>learners</code>）。在实际实现中，一个独立的进程可以充当不止一个代理，但是从代理到进程之间的映射关系不是我们这里关注的重点。</p>
<p>设想代理之间可以通过发送消息的方式相互通信。我们使用传统的异步（模型），而不是拜占庭问题模型，也就是说：</p>
<ul>
<li>代理以任意速度运行，可能因停止而失效（指不能正常工作），也可能重启。由于所有代理都有可能在一个值被选定之后失效再接着重启，除非失效或者重启的代理能够记住一些关键信息，否则没有任何解决方案。</li>
<li>消息发送的长度可以是任意的，消息也可以重复或者丢失，但消息不会被篡改。</li>
</ul>
<h2 id="算法描述">算法描述</h2>
<p>使用 Paxos 算法的分布式系统里的，所有的节点都是平等的，它们都可以承担以上某一种或者多种的角色，不过为了便于确保有明确的多数派，决策节点的数量应该被设定为奇数个，且在系统初始化时，网络中每个节点都知道整个网络所有决策节点的数量、地址等信息。</p>
<p>将提议者和接受者的行为都放在一起，我们可以看到这个算法的操作可以分为以下两个阶段：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">阶段 <span class="number">1</span>：</span><br><span class="line">（a）提议者选择一个提案编号 <span class="built_in">n</span>，向“大多数”接受者发送一个带有编号 <span class="built_in">n</span> 的 prepare 请求；</span><br><span class="line">（b）如果接受者收到一个编号为 <span class="built_in">n</span> 的 prepare 请求，且 <span class="built_in">n</span> 比它已经响应过的任何一个 prepare 请求的编号都大，则它会向这个请求回复响应，内容包括：一个不再接受任何编号小于 <span class="built_in">n</span> 的提案的承诺，以及它已经接受过的最大编号的提案（假如有的话）。</span><br><span class="line"></span><br><span class="line">阶段 <span class="number">2</span>：</span><br><span class="line">（a）如果提议者从“大多数”接受者收到了对它前面发出的 prepare 请求的响应，它就会接着给那每一个接受者发送一个针对编号为 <span class="built_in">n</span> 且值为 v 的提案的 accept 请求，而 v 就是它所收到的响应中最大编号的提案的值，或者是它在所有响应都表明没有接受过任何提案的前提下自由选择的值 v；</span><br><span class="line">（b）如果接受者收到了一个针对编号为 <span class="built_in">n</span> 的提案的 accept 请求，它就会接受这个请求，除非它之前已经响应过编号大于 <span class="built_in">n</span> 的 request 请求。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“提案”始终意味着：一个提案编号加上一个提案的值。</p>
</blockquote>
<p>整个过程的时序图如图所示。</p>
<p><img data-src="../../images/distributed/paxos.svg" alt="paxos"></p>
<h2 id="工作实例">工作实例</h2>
<p>假设一个分布式系统有五个节点，分别命名为 S<sub>1</sub>、S<sub>2</sub>、S<sub>3</sub>、S<sub>4</sub>、S<sub>5</sub>，这个例子中只讨论正常通信的场景，不涉及网络分区。全部节点都同时扮演着提案节点和决策节点的身份。此时，有两个并发的请求分别希望将同一个值分别设定为 X（由 S1作为提案节点提出）和 Y（由 S5作为提案节点提出），以 P 代表准备阶段，以 A 代表批准阶段，这时候可能发生以下情况：</p>
<ul>
<li>
<p>情况一：譬如，S<sub>1</sub> 选定的提案 ID 是 3.1（全局唯一 ID 加上节点编号），先取得了多数派决策节点的承诺 Promise 应答和批准 Accepted 应答，此时 S<sub>5</sub> 选定提案 ID 是 4.5，发起 Prepare 请求，收到的多数派应答中至少会包含 1 个此前应答过  S<sub>1</sub> 的决策节点，假设是 S<sub>3</sub>，那么 S<sub>3</sub> 提供的 Promise 中必将包含 S<sub>1</sub> 已设定好的值 X，S<sub>5</sub> 就必须无条件地用 X 代替 Y 作为自己提案的值，由此整个系统对“取值为 X”这个事实达成一致，如图所示。</p>
<p><img data-src="../../images/distributed/paxos1.145e2dd6.png" alt="img"></p>
</li>
<li>
<p>情况二：事实上，对于情况一，X 被选定为最终值是必然结果，但从上图中可以看出，X 被选定为最终值并不是必定需要多数派的共同批准，只取决于 S<sub>5</sub> 提案时 Promise 应答中是否已包含了批准过 X 的决策节点，譬如下图所示，S<sub>5</sub> 发起提案的 Prepare 请求时，X 并未获得多数派批准，但由于 S<sub>3</sub> 已经批准的关系，最终共识的结果仍然是 X。</p>
<p><img data-src="../../images/distributed/paxos2.59e89ab0.png" alt="img"></p>
</li>
<li>
<p>情况三：当然，另外一种可能的结果是 S<sub>5</sub> 提案时 Promise 应答中并未包含批准过 X 的决策节点，譬如应答 S<sub>5</sub></p>
<p>提案时，节点 S<sub>1</sub> 已经批准了 X，节点 S<sub>2</sub>、S<sub>3</sub>未批准但返回了 Promise 应答，此时 S<sub>5</sub> 以更大的提案 ID 获得了 S<sub>3</sub>、S<sub>4</sub>、S<sub>5</sub> 的 Promise，这三个节点均未批准过任何值，那么 S<sub>3</sub>将不会再接收来自 S<sub>1</sub> 的 Accept 请求，因为它的提案 ID 已经不是最大的了，这三个节点将批准 Y 的取值，整个系统最终会对“取值为 Y”达成一致，如图所示。</p>
<p><img data-src="../../images/distributed/paxos3.c646204c.png" alt="img"></p>
</li>
<li>
<p>情况四：从情况三可以推导出另一种极端的情况，如果两个提案节点交替使用更大的提案 ID 使得准备阶段成功，但是批准阶段失败的话，这个过程理论上可以无限持续下去，形成活锁（Live Lock），如图所示。在算法实现中会引入随机超时时间来避免活锁的产生。</p>
<p><img data-src="../../images/distributed/paxos4.33b9f31e.png" alt="img"></p>
</li>
</ul>
<p>虽然 Paxos 是以复杂著称的算法，但以上介绍都是基于 Basic Paxos、以正常流程（未出现网络分区等异常）、通俗方式讲解的 Paxos 算法，并未涉及严谨的逻辑和数学原理，也未讨论 Paxos 的推导证明过程，对于普通的不从事算法研究的技术人员来说，理解起来应该也不算太困难。</p>
<p>Basic Paxos 的价值在于开拓了分布式共识算法的发展思路，但它因有如下缺陷，一般不会直接用于实践：<strong>Basic Paxos 只能对单个值形成决议，并且决议的形成至少需要两次网络请求和应答（准备和批准阶段各一次），高并发情况下将产生较大的网络开销，极端情况下甚至可能形成活锁</strong>。总之，Basic Paxos 是一种很学术化但对工业化并不友好的算法，现在几乎只用来做理论研究。实际的应用都是基于 Multi Paxos 和 Fast Paxos 算法的，接下来我们将会了解 Multi Paxos 与一些它的理论等价的算法（如 Raft、ZAB 等算法）。</p>
<h1>Multi Paxos</h1>
<p>上一节的最后，笔者举例介绍了 Basic Paxos 的活锁问题，两个提案节点互不相让地争相提出自己的提案，抢占同一个值的修改权限，导致整个系统在持续性地“反复横跳”，外部看起来就像被锁住了一样。此外，笔者还讲述过一个观点，分布式共识的复杂性，主要来源于网络的不可靠与请求的可并发两大因素，活锁问题与许多 Basic Paxos 异常场景中所遭遇的麻烦，都可以看作是源于任何一个提案节点都能够完全平等地、与其他节点并发地提出提案而带来的复杂问题。为此，Lamport 专门设计（“专门设计”的意思是在 Paxos 的论文中 Lamport 随意提了几句可以这么做）了一种 Paxos 的改进版本“Multi Paxos”算法，希望能够找到一种两全其美的办法，既不破坏 Paxos 中“众节点平等”的原则，又能在提案节点中实现主次之分，限制每个节点都有不受控的提案权利，这两个目标听起来似乎是矛盾的，但现实世界中的选举就很符合这种在平等节点中挑选意见领袖的情景。</p>
<p>Multi Paxos 对 Basic Paxos 的核心改进是增加了“选主”的过程，提案节点会通过定时轮询（心跳），确定当前网络中的所有节点里是否存在有一个主提案节点，一旦没有发现主节点存在，节点就会在心跳超时后使用 Basic Paxos 中定义的准备、批准的两轮网络交互过程，向所有其他节点广播自己希望竞选主节点的请求，希望整个分布式系统对“由我作为主节点”这件事情协商达成一致共识，如果得到了决策节点中多数派的批准，便宣告竞选成功。当选主完成之后，除非主节点失联之后发起重新竞选，否则从此往后，就只有主节点本身才能够提出提案。此时，无论哪个提案节点接收到客户端的操作请求，都会将请求转发给主节点来完成提案，而主节点提案的时候，也就无需再次经过准备过程，因为可以视作是经过选举时的那一次准备之后，后续的提案都是对相同提案 ID 的一连串的批准过程。也可以通俗理解为选主过后，就不会再有其他节点与它竞争，相当于是处于无并发的环境当中进行的有序操作，所以此时系统中要对某个值达成一致，只需要进行一次批准的交互即可，如图所示。</p>
<p><img data-src="../../images/distributed/multi_paxos.svg" alt="multi_paxos"></p>
<p>可能有人注意到这时候的二元组 (id, value) 已经变成了三元组 (id, i, value)，这是因为需要给主节点增加一个“任期编号”，这个编号必须是严格单调递增的，以应付主节点陷入网络分区后重新恢复，但另外一部分节点仍然有多数派，且已经完成了重新选主的情况（<strong>脑裂</strong>），此时必须以任期编号大的主节点为准。当节点有了选主机制的支持，在整体来看，就可以进一步简化节点角色，不去区分提案、决策和记录节点了，统统以“节点”来代替，节点只有主（<code>Leader</code>）和从（<code>Follower</code>）的区别，此时协商共识的时序图如图所示。</p>
<p><img data-src="../../images/distributed/raft.svg" alt="multi_paxos"></p>
<p>在这个理解的基础上，我们换一个角度来重新思考“分布式系统中如何对某个值达成一致”这个问题，可以把该问题划分做三个子问题来考虑，可以证明（具体证明就不列在这里了，感兴趣的读者可参考结尾给出的论文）当以下三个问题同时被解决时，即等价于达成共识：</p>
<ul>
<li><strong>如何选主</strong>（<code>Leader Election</code>）。</li>
<li><strong>如何把数据复制到各个节点上</strong>（<code>Log Replication</code>）。</li>
<li><strong>如何保证过程是安全的</strong>（<code>Safety</code>）。</li>
</ul>
<p>选主问题尽管还涉及许多工程上的细节，譬如心跳、随机超时、并行竞选，等等，但要只论原理的话，如果你已经理解了 Paxos 算法的操作步骤，相信对选主并不会有什么疑惑，因为这本质上仅仅是分布式系统对“谁来当主节点”这件事情的达成的共识而已，我们在前一节已经花了数千字来讲述分布式系统该如何对一件事情达成共识，这里就不重复赘述了，下面直接来解决数据（Paxos 中的提案、Raft 中的日志）在网络各节点间的复制问题。</p>
<p>在正常情况下，当客户端向主节点发起一个操作请求，譬如提出“将某个值设置为 X”，此时主节点将 X 写入自己的变更日志，但先不提交，接着把变更 X 的信息在下一次心跳包中广播给所有的从节点，并要求从节点回复确认收到的消息，从节点收到信息后，将操作写入自己的变更日志，然后给主节点发送确认签收的消息，主节点收到过半数的签收消息后，提交自己的变更、应答客户端并且给从节点广播可以提交的消息，从节点收到提交消息后提交自己的变更，数据在节点间的复制宣告完成。</p>
<p>在异常情况下，网络出现了分区，部分节点失联，但只要仍能正常工作的节点的数量能够满足多数派（过半数）的要求，分布式系统就仍然可以正常工作，这时候数据复制过程如下：</p>
<ul>
<li>假设有 S1、S2、S3、S4、S5 五个节点，S1是主节点，由于网络故障，导致 S1、S2 和 S3、S4、S5 之间彼此无法通信，形成网络分区。</li>
<li>一段时间后，S3、S4、S5 三个节点中的某一个（譬如是 S3）最先达到心跳超时的阈值，获知当前分区中已经不存在主节点了，它向所有节点发出自己要竞选的广播，并收到了 S4、S5 节点的批准响应，加上自己一共三票，即得到了多数派的批准，竞选成功，此时系统中同时存在 S1和 S3 两个主节点，但由于网络分区，它们不会知道对方的存在。</li>
<li>这种情况下，客户端发起操作请求：
<ul>
<li>如果客户端连接到了 S1、S2 之一，都将由 S1 处理，但由于操作只能获得最多两个节点的响应，不构成多数派的批准，所以任何变更都无法成功提交。</li>
<li>如果客户端连接到了 S3、S4、S5 之一，都将由 S3 处理，此时操作可以获得最多三个节点的响应，构成多数派的批准，是有效的，变更可以被提交，即系统可以继续提供服务。</li>
<li>事实上，以上两种“如果”情景很少机会能够并存。网络分区是由于软、硬件或者网络故障而导致的，内部网络出现了分区，但两个分区仍然能分别与外部网络的客户端正常通信的情况甚为少见。更多的场景是算法能容忍网络里下线了一部分节点，按照这个例子来说，如果下线了两个节点，系统正常工作，下线了三个节点，那剩余的两个节点也不可能继续提供服务了。</li>
</ul>
</li>
<li>假设现在故障恢复，分区解除，五个节点可以重新通信了：
<ul>
<li>S1 和 S3 都向所有节点发送心跳包，从各自的心跳中可以得知两个主节点里 S3 的任期编号更大，它是最新的，此时五个节点均只承认 S3 是唯一的主节点。</li>
<li>S1、S2 回滚它们所有未被提交的变更。</li>
<li>S1、S2 从主节点发送的心跳包中获得它们失联期间发生的所有变更，将变更提交写入本地磁盘。</li>
<li>此时分布式系统各节点的状态达成最终一致。</li>
</ul>
</li>
</ul>
<p>下面我们来看第三个问题：“如何保证过程是安全的”，不知你是否感觉到这个问题与前两点的存在一点差异？选主、数据复制都是很具体的行为，但是“安全”就很模糊，什么算是安全或者不安全？</p>
<p>在分布式理论中，<code>Safety</code> 和 <code>Liveness </code> 两种属性是有预定义的术语，在专业的资料中一般翻译成“协定性”和“终止性”，这两个概念也是由 Lamport 最先提出，当时给出的定义是：</p>
<ul>
<li>协定性（Safety）：所有的坏事都不会发生（something “bad” will never happen）。</li>
<li>终止性（Liveness）：所有的好事都终将发生，但不知道是啥时候（something “good” will must happen, but we don’t know when）。</li>
</ul>
<p>这种就算解释了你也看不明白的定义，是不是很符合 Lamport 老爷子一贯的写作风格？（笔者无奈地摊手苦笑）。我们不去纠结严谨的定义，仍通过举例来说明它们的具体含义。譬如以选主问题为例，Safety 保证了选主的结果一定是有且只有唯一的一个主节点，不可能同时出现两个主节点；而 Liveness 则要保证选主过程是一定可以在某个时刻能够结束的。由前面对活锁的介绍可以得知，在 Liveness 这个属性上选主问题是存在理论上的瑕疵的，可能会由于活锁而导致一直无法选出明确的主节点，所以 Raft 论文中只写了对 Safety 的保证，但由于工程实现上的处理，现实中是几乎不可能会出现终止性的问题。</p>
<p>最后，以上这种把共识问题分解为 “<code>Leader Election</code>”、“<code>Log Replication</code>” 和 “<code>Safety</code>” 三个问题来思考、解决的解题思路，即 “<strong><code>Raft 算法</code></strong>”，这篇以《<a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">一种可以让人理解的共识算法</a>》（In Search of an Understandable Consensus Algorithm）为题的论文提出了 Raft 算法，并获得了 USENIX ATC 2014 大会的 Best Paper，后来更是成为 <code>Etcd</code>、<code>LogCabin</code>、<code>Consul</code> 等重要分布式程序的实现基础，<code>ZooKeeper</code> 的 <code>ZAB</code> 算法与 <code>Raft</code> 的思路也非常类似，这些算法都被认为是 Multi Paxos 的等价派生实现。</p>
<h1>复制状态机（Replicated state machines）</h1>
<p>一致性算法是在[<a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">复制状态机</a>]的背景下产生的。 在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器宕机，也可以继续运行。</p>
<p>复制状态机用于解决分布式系统中的各种容错问题。 例如，具有单个 leader 的大规模系统，如 GFS，HDFS 和 RAMCloud ，通常使用单独的复制状态机来进行 leader 选举和存储 leader 崩溃后重新选举需要的配置信息。Chubby 和 ZooKeeper 都是复制状态机。</p>
<p>复制状态机通常使用复制日志实现，如图1所示。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行日志中的命令。 每个日志中命令都相同并且顺序也一样，因此每个状态机处理相同的命令序列。 这样就能得到相同的状态和相同的输出序列。</p>
<p><img data-src="../../images/distributed/raft-state-machine.png" alt="img"></p>
<p>一致性算法的工作就是保证复制日志的一致性。 每台服务器上的一致性模块接收来自客户端的命令，并将它们添加到其日志中。 它与其他服务器上的一致性模块通信，以确保每个日志最终以相同的顺序包含相同的命令，即使有一些服务器失败。 一旦命令被正确复制，每个服务器上的状态机按日志顺序处理它们，并将输出返回给客户端。 这样就形成了高可用的复制状态机。</p>
<p>实际系统中的一致性算法通常具有以下属性：</p>
<ul>
<li>它们确保在所有非拜占庭条件下（包括网络延迟，分区和数据包丢失，重复和乱序）的安全性（不会返回不正确的结果）。</li>
<li>只要任何大多数（过半）服务器都可以运行，并且可以相互通信和与客户通信，一致性算法就可用。 因此，五台服务器的典型集群可以容忍任何两台服务器的故障。 假设服务器突然宕机; 它们可以稍后从状态恢复并重新加入群集。</li>
<li>它们不依赖于时序来确保日志的一致性：错误的时钟和极端消息延迟可能在最坏的情况下导致可用性问题。</li>
<li>在通常情况下，只要集群的大部分（过半服务器）已经响应了单轮远程过程调用，命令就可以完成; 少数（一半以下）慢服务器不需要影响整个系统性能。</li>
</ul>
<h1>Raft</h1>
<p>Raft 算法内容节选自：<a target="_blank" rel="noopener" href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a></p>
<p>该算法的关键特性图：</p>
<p><img data-src="../../images/distributed/raft-key-properties.png" alt="Raft Key Properties"></p>
<p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这样的系统可以容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：<strong>主节点</strong> - <code>Leader</code>、<strong>从节点</strong> - <code>Follower</code> 或者<strong>候选节点</strong> - <code>Candidate</code> 。</p>
<p>在正常情况下，集群中只有一个 leader 并且其他的节点全部都是 follower 。</p>
<p><code>Follower</code> 都是被动的：他们不会发送任何请求，只是简单的响应来自 leader 和 candidate 的请求。</p>
<p><code>Leader</code> 处理所有的客户端请求（如果一个客户端和 follower 通信，follower 会将请求重定向给 leader）。</p>
<p>第三种状态，<code>Candidate</code> ，是用来选举一个新的 leader。下图展示了这些状态和他们之间的转换关系；这些转换关系在接下来会进行讨论。</p>
<p><img data-src="../../images/distributed/raft-state-transform.png" alt="Raft State Transform"></p>
<p>Raft 把时间分割成任意长度的<strong>任期</strong>（<code>term</code>），如下图所示。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。Raft 保证了在任意一个任期内，最多只有一个 leader 。</p>
<p><img data-src="../../images/distributed/raft-term.png" alt="Raft Term"></p>
<p>不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。任期在 Raft 算法中充当<strong>逻辑时钟</strong>的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</p>
<p>Raft 算法中服务器节点之间使用 <code>RPC</code> 进行通信，并且基本的一致性算法只需要两种类型的 RPC。请求投票（<code>RequestVote</code>） RPC 由 candidate 在选举期间发起，追加条目（<code>AppendEntries</code>）RPC 由 leader 发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPC 来获得最佳的性能。</p>
<h2 id="Leader-选举">Leader 选举</h2>
<p>Raft 使用一种<strong>心跳机制</strong>来触发 leader 选举。当服务器程序启动时，他们都是 follower 。<strong>一个服务器节点只要能从 leader 或 candidate 处接收到有效的 RPC 就一直保持 follower 状态</strong>。Leader 周期性地向所有 follower 发送心跳（不包含日志条目的 <code>AppendEntries</code> RPC）来维持自己的地位。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它就假设系统中没有可用的 leader ，然后开始进行选举以选出新的 leader。</p>
<p>要开始一次选举过程，<strong>follower 先增加自己的当前任期号并且转换到 candidate 状态</strong>。然后投票给自己并且并行地向集群中的其他服务器节点发送 <code>RequestVote</code> RPC（让其他服务器节点投票给它）。Candidate 会一直保持当前状态直到以下三件事情之一发生：(a) 它自己赢得了这次的选举（收到过半的投票），(b) 其他的服务器节点成为 leader ，© 一段时间之后没有任何获胜者。这些结果会在下面的章节里分别讨论。</p>
<p><strong>当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader</strong> 。对于同一个任期，每个服务器节点只会投给一个 candidate ，按照先来先服务（first-come-first-served）的原则（注意：安全性一节在投票上增加了额外的限制）。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举（关键特性图中的选举安全性）。一旦 candidate 赢得选举，就立即成为 leader 。然后它会向其他的服务器节点发送心跳消息来确定自己的地位并阻止新的选举。</p>
<p>在等待投票期间，candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 <code>AppendEntries</code> RPC 。如果这个 leader 的任期号（包含在 RPC 中）不小于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</p>
<p>第三种可能的结果是 candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个 Candidate 都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。</p>
<p>Raft 算法使用<strong>随机选举超时时间</strong>的方法来确保很少发生选票瓜分的情况，就算发生也能很快地解决。为了阻止选票一开始就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后该服务器赢得选举并在其他服务器超时之前发送心跳。同样的机制被用来解决选票被瓜分的情况。<strong>每个 candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后一直等待直到选举超时；这样减小了在新的选举中再次发生选票瓜分情况的可能性</strong>。</p>
<p>选举的例子可以很好地展示可理解性是如何指导我们选择设计方案的。起初我们打算使用一种等级系统（ranking system）：每一个 candidate 都被赋予一个唯一的等级（rank），等级用来在竞争的 candidate 之间进行选择。如果一个 candidate 发现另一个 candidate 拥有更高的等级，它就会回到 follower 状态，这样高等级的 candidate 能够更加容易地赢得下一次选举。但是我们发现这种方法在可用性方面会有一下小问题。我们对该算法进行了多次调整，但是每次调整之后都会有新的小问题。最终我们认为<strong>随机重试</strong>的方法更加显然且易于理解。</p>
<h2 id="日志复制">日志复制</h2>
<p>Leader 一旦被选举出来，就开始为客户端请求提供服务。客户端的每一个请求都包含一条将被复制状态机执行的指令。Leader 把该指令作为一个新的条目追加到日志中去，然后并行的发起 <code>AppendEntries</code> RPC 给其他的服务器，让它们复制该条目。当该条目被安全地复制（下面会介绍），leader 会应用该条目到它的状态机中（状态机执行该指令）然后把执行的结果返回给客户端。如果 follower 崩溃或者运行缓慢，或者网络丢包， Leader 会不断地重试 <code>AppendEntries</code> RPC（即使已经回复了客户端）直到所有的 follower 最终都存储了所有的日志条目。</p>
<p>日志以下图展示的方式组织。每个日志条目存储一条状态机指令和 leader 收到该指令时的任期号。任期号用来检测多个日志副本之间的不一致情况，同时也用来保证关键特性图中的某些性质。每个日志条目都有一个整数索引值来表明它在日志中的位置。</p>
<p><img data-src="../../images/distributed/raft-log.png" alt="Raft Log"></p>
<p>Leader 决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为**<em>已提交</em>（<em>Committed</em>）**的。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。<strong>一旦创建该日志条目的 leader 将它复制到过半的服务器上，该日志条目就为已提交（例如在上图中的条目 7）</strong>。同时，leader 日志中该日志条目之前的所有日志条目也都会被提交，包括由其他 leader 创建的条目。<strong>Leader 追踪将会被提交的日志条目的最大索引，未来的所有 <code>AppendEntries</code> RPC 都会包含该索引，这样其他的服务器才能最终知道哪些日志条目需要被提交</strong>。<strong>Follower 一旦知道某个日志条目已经被提交就会将该日志条目应用到自己的本地状态机中（按照日志的顺序）。</strong></p>
<p>我们设计了 Raft 的日志机制来维持不同服务器之间日志高层次的一致性。这么做不仅简化了系统的行为也使得系统行为更加可预测，同时该机制也是保证安全性的重要组成部分。Raft 维护着以下特性，这些同时也构成了关键特性图中的 <code>Log Matching Property</code>（日志匹配特性） ：</p>
<ul>
<li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>
<li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。</li>
</ul>
<p>Leader 在特定的任期号内的一个日志索引处最多创建一个日志条目，同时日志条目在日志中的位置也从来不会改变。该点保证了上面的第一条特性。第二个特性是由 <code>AppendEntries</code> RPC 执行一个简单的一致性检查所保证的。在发送 <code>AppendEntries</code> RPC 的时候，leader 会将前一个日志条目的索引位置和任期号包含在里面。如果 follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，每当 <code>AppendEntries</code> RPC 返回成功时，leader 就知道 follower 的日志一定和自己相同（从第一个日志条目到最新条目）。</p>
<p>正常操作期间，leader 和 follower 的日志保持一致，所以 <code>AppendEntries</code> RPC 的一致性检查从来不会失败。然而，leader 崩溃的情况会使日志处于不一致的状态（老的 leader 可能还没有完全复制它日志里的所有条目）。这种不一致会在一系列的 leader 和 follower 崩溃的情况下加剧。下图展示了在什么情况下 follower 的日志可能和新的 leader 的日志不同。Follower 可能缺少一些在新 leader 中有的日志条目，也可能拥有一些新 leader 没有的日志条目，或者同时发生。缺失或多出日志条目的情况可能会涉及到多个任期。</p>
<p><img data-src="../../images/distributed/raft-node-failed.png" alt="Raft Node Failed"></p>
<blockquote>
<p>当一个 leader 成功当选时（最上面那条日志），follower 可能是（a-f）中的任何情况。每一个盒子表示一个日志条目；里面的数字表示任期号。Follower 可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能这样发生，f 对应的服务器在任期 2 的时候是 leader ，追加了一些日志条目到自己的日志中，一条都还没提交（commit）就崩溃了；该服务器很快重启，在任期 3 重新被选为 leader，又追加了一些日志条目到自己的日志中；在这些任期 2 和任期 3 中的日志都还没被提交之前，该服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>
</blockquote>
<p>在 Raft 算法中，leader 通过强制 follower 复制它的日志来解决不一致的问题。这意味着 follower 中跟 leader 冲突的日志条目会被 leader 的日志条目覆盖。安全性一节会证明通过增加一个限制可以保证安全性。</p>
<p>要使得 follower 的日志跟自己一致，leader 必须找到两者达成一致的最大的日志条目（索引最大），删除 follower 日志中从那个点之后的所有日志条目，并且将自己从那个点之后的所有日志条目发送给 follower 。所有的这些操作都发生在对 <code>AppendEntries</code> RPCs 中一致性检查的回复中。Leader 针对每一个 follower 都维护了一个 nextIndex ，表示 leader 要发送给 follower 的下一个日志条目的索引。当选出一个新 leader 时，该 leader 将所有 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（上图中的 11）。如果 follower 的日志和 leader 的不一致，那么下一次 <code>AppendEntries</code> RPC 中的一致性检查就会失败。在被 follower 拒绝之后，leaer 就会减小 nextIndex 值并重试 <code>AppendEntries</code> RPC 。最终 nextIndex 会在某个位置使得 leader 和 follower 的日志达成一致。此时，<code>AppendEntries</code> RPC 就会成功，将 follower 中跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（如果有需要追加的日志条目的话）。一旦 <code>AppendEntries</code> RPC 成功，follower 的日志就和 leader 一致，并且在该任期接下来的时间里保持一致。</p>
<blockquote>
<p>如果想要的话，该协议可以被优化来减少被拒绝的 <code>AppendEntries</code> RPC 的个数。例如，当拒绝一个 <code>AppendEntries</code> RPC 的请求的时候，follower 可以包含冲突条目的任期号和自己存储的那个任期的第一个 index 。借助这些信息，leader 可以跳过那个任期内所有冲突的日志条目来减小 nextIndex；这样就变成每个有冲突日志条目的任期需要一个 <code>AppendEntries</code> RPC 而不是每个条目一次。在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p>
</blockquote>
<p>通过这种机制，leader 在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。Leader 只需要进行正常的操作，然后日志就能在回复 <code>AppendEntries</code> 一致性检查失败的时候自动趋于一致。Leader 从来不会覆盖或者删除自己的日志条目（关键特性图 的 Leader Append-Only 属性）。</p>
<p>这样的日志复制机制展示了一致性特性：只要过半的服务器能正常运行，Raft 就能够接受，复制并应用新的日志条目；在正常情况下，新的日志条目可以在一个 RPC 来回中被复制给集群中的过半机器；并且单个运行慢的 follower 不会影响整体的性能。</p>
<h2 id="安全性">安全性</h2>
<p>前面的章节里描述了 Raft 算法是如何进行 leader 选举和日志复制的。然而，到目前为止描述的机制并不能充分地保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个 follower 可能会进入不可用状态，在此期间，leader 可能提交了若干的日志条目，然后这个 follower 可能会被选举为 leader 并且用新的日志条目覆盖这些日志条目；结果，不同的状态机可能会执行不同的指令序列。</p>
<p>这节通过对 leader 选举增加一个限制来完善 Raft 算法。这一限制保证了对于给定的任意任期号， leader 都包含了之前各个任期所有被提交的日志条目（图 3 中的 Leader Completeness 性质）。有了这一 leader 选举的限制，我们也使得提交规则更加清晰。最后，我们展示了对于 Leader Completeness 性质的简要证明并且说明该性质是如何领导复制状态机执行正确的行为的。</p>
<h3 id="选举限制">选举限制</h3>
<p>在任何基于 leader 的一致性算法中，leader 最终都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，一开始并没有包含所有已经提交的日志条目的服务器也可能被选为 leader 。这种算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的 leader ，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证新 leader 在当选时就包含了之前所有任期号中已经提交的日志条目，不需要再传送这些日志条目给新 leader 。这意味着日志条目的传送是单向的，只从 leader 到 follower，并且 leader 从不会覆盖本地日志中已经存在的条目。</p>
<p>Raft 使用投票的方式来阻止 candidate 赢得选举<strong>除非该 candidate 包含了所有已经提交的日志条目</strong>。 Candidate 为了赢得选举必须与集群中的过半节点通信，这意味着至少其中一个服务器节点包含了所有已提交的日志条目。如果 candidate 的日志至少和过半的服务器节点一样新（接下来会精确地定义“新”），那么他一定包含了所有已经提交的日志条目。<code>RequestVote</code> RPC 执行了这样的限制： RPC 中包含了 candidate 的日志信息，如果投票者自己的日志比 candidate 的还新，它会拒绝掉该投票请求。</p>
<p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。如果两份日志最后条目的任期号不同，那么任期号大的日志更新。如果两份日志最后条目的任期号相同，那么日志较长的那个更新。</p>
<h3 id="提交之前任期内的日志条目">提交之前任期内的日志条目</h3>
<p>如同日志复制节描述的那样，一旦当前任期内的某个日志条目已经存储到过半的服务器节点上，leader 就知道该日志条目已经被提交了。如果某个 leader 在提交某个日志条目之前崩溃了，以后的 leader 会试图完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到过半的服务器节点上，leader 也无法立即断定该日志条目已经被提交了。下图展示了一种情况，一个已经被存储到过半节点上的老日志条目，仍然有可能会被未来的 leader 覆盖掉。</p>
<p><img data-src="https://willzhuang.github.io/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/8.png" alt="img"></p>
<blockquote>
<p>如图的时间序列展示了为什么 leader 无法判断老的任期号内的日志是否已经被提交。在 (a) 中，S1 是 leader ，部分地复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 中通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 ©，S5 又崩溃了；S1 重新启动，选举成功，继续复制日志。此时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。但是，在崩溃之前，如果 S1 在自己的任期里复制了日志条目到大多数机器上，如 (e) 中，然后这个条目就会被提交（S5 就不可能选举成功）。 在这种情况下，之前的所有日志也被提交了。</p>
</blockquote>
<p>为了消除图中描述的问题，Raft 永远不会通过计算副本数目的方式来提交<strong>之前任期内</strong>的日志条目。只有 leader <strong>当前任期内</strong>的日志条目才通过计算副本数目的方式来提交；一旦当前任期的某个日志条目以这种方式被提交，那么由于日志匹配特性，之前的所有日志条目也都会被间接地提交。在某些情况下， Leader 可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经存储到所有服务器上），但是 Raft 为了简化问题使用了一种更加保守的方法。</p>
<p>Raft 会在提交规则上增加额外的复杂性是因为当 leader 复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的一致性算法中，如果一个新的 leader 要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 的做法使得更加容易推导出（reason about）日志条目，因为他们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft 中的新 leader 只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p>
<h1>引用及参考</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://betathoughts.blogspot.com/2007/06/brief-history-of-consensus-2pc-and.html">A brief history of Consensus, 2PC and Transaction Commit.</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/#fn:8">《Paxos Made Simple》中文翻译：Paxos 如此简单</a></li>
<li><a target="_blank" rel="noopener" href="https://fuzhe1989.github.io/2021/03/16/consensus-on-transaction-commit/">[笔记] Consensus on Transaction Commit</a></li>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/consensus/paxos.html">Paxos</a></li>
<li><a target="_blank" rel="noopener" href="https://willzhuang.github.io/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/">Raft论文翻译</a></li>
<li><a target="_blank" rel="noopener" href="https://raft.github.io/">The Raft Consensus Algorithm</a></li>
<li><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">The Secret Lives of Data</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>一旦宕机的不是其中某个参与者，而是协调者的话，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>分布式系统中处理事务的进程称为 Resource Manager（RM）。每个 RM 可以自行决定事务中与自己有关的部分要 commit 还是 abort，而整个事务想要 commit 则必须所有参与的 RM 都同意 commit。整个 transaction commit 的关键就在于所有 RM 要对事务是 commit 还是 abort 达成共识。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>两次为两阶段，一阶段发出提案，二阶段对特案中的值进行批准达成共识。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>如果两个提案节点交替使用更大的提案 ID 使得准备阶段成功，但是批准阶段失败的话，这个过程理论上可以无限持续下去，形成活锁（Live Lock），详见：<a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/consensus/paxos.html">Paxos</a>。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Distributed</category>
      </categories>
      <tags>
        <tag>Lock</tag>
        <tag>Concurrent</tag>
        <tag>Paxos</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Agent</title>
    <url>/java/Java-Agent/</url>
    <content><![CDATA[<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html">Java Instrumentation API</a>，提供允许 Java 编程语言代理人（Agent）Instrument 在 JVM 上运行的程序的服务。</p>
<blockquote>
<p>Agent：代理，以下文章中的所述代理都是指 Java Agent。</p>
<p>Instrumentation/Instrument：直译仪器，在计算机术语中也有植入、插桩、编排、性能测量的意思。</p>
</blockquote>
<p>Instrument 设计的目的是将字节码添加到方法中，收集工具使用的数据。出于这个目的，因为更改纯粹是附加的，因此这些工具不会修改应用程序状态或行为。此类良性工具的示例包括监控代理、分析器、覆盖分析器和事件记录器。</p>
<p>由于这种检测机制提供了修改现有已编译 Java 类的字节码或添加字节码的能力，所以我们也可以用来动态修改运行的程序代码。</p>
<span id="more"></span>
<blockquote>
<p>注意：开发人员/管理员负责验证他们部署的 Java 代理的内容和结构的可信度，因为它们能够任意转换来自其他 JAR 文件的字节码。由于这是在包含字节码的 Jars 被验证为可信之后发生的，因此 Java 代理的可信度将确定整个程序的可信度。</p>
</blockquote>
<h1>启动 Java Agent</h1>
<p>代理通常部署为 JAR 文件。 JAR 文件清单（<code>MANIFEST.MF</code>）中的属性指定将加载以启动代理的代理类。可以通过多种方式启动代理：</p>
<ul>
<li>对于支持命令行接口的实现，可以通过在命令行上指定一个选项来启动代理。</li>
<li>也支持在 VM 启动一段时间后启动代理的机制的实现。例如，实现可以提供一种机制，允许工具附加到正在运行的应用程序，并初始化加载工具代理到正在运行的应用程序中。</li>
<li>代理也可以与应用程序一起打包在一个可执行的 JAR 文件中。</li>
</ul>
<p>下面描述了 <strong>Java 11</strong> 中这些启动代理的方式：</p>
<h2 id="通过命令行接口启动代理">通过命令行接口启动代理</h2>
<p>如果实现提供了从命令行接口启动代理的方法，则可以通过向命令行添加以下选项来启动代理，这种实现一般称为<strong>静态加载</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:&lt;jarpath&gt;[=&lt;options&gt;]</span><br></pre></td></tr></table></figure>
<p>其中 <jarpath> 是代理 JAR 文件的路径，<options> 是代理选项。</p>
<p>代理 JAR 文件的清单必须在其主清单中包含属性 <code>Premain-Class</code>。该属性的值是代理类的名称。代理类必须实现一个与主应用程序入口点原则相似的 <code>public static premain</code> 方法。在 Java 虚拟机 (JVM) 初始化之后，将调用 <code>premain</code> 方法，然后才是真正的应用程序 <code>main</code> 方法。 <code>premain</code> 方法必须返回才能继续启动。</p>
<p><code>premain</code> 方法具有两个可能的签名之一。 JVM 首先尝试在代理类上调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br></pre></td></tr></table></figure>
<p>如果代理类未实现此方法，则 JVM 将尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure>
<p>代理类可能还有一个 <code>agentmain</code> 方法，用于在 VM 启动后启动代理时使用（见下文）。当使用命令行选项启动代理时，不会调用 <code>agentmain</code> 方法。</p>
<p>每个代理都通过 <code>agentArgs</code> 参数传递其代理选项。代理选项作为单个字符串传递，任何额外的解析都应该由代理本身执行。</p>
<p>如果无法启动代理（例如，无法加载代理类，或者代理类没有合适的 <code>premain</code> 方法），<strong>JVM 将中止</strong>。如果 <code>premain</code> 方法抛出未捕获的异常，JVM 将中止。</p>
<p><code>-javaagent</code> 选项可以在同一命令行上多次使用，从而启动多个代理。<code>premain</code> 方法将按照代理在命令行上指定的顺序调用。多个代理可能使用相同的 <jarpath>。</p>
<p>代理 <code>premain</code> 方法可以做什么没有建模限制。应用程序 <code>main</code> 可以做的任何事情，包括创建线程，在 <code>premain</code> 中都是合法的。</p>
<h2 id="在-VM-启动后启动代理">在 VM 启动后启动代理</h2>
<p>实现也可以提供一种机制来在 VM 启动后的某个时间启动代理，一般称为<strong>动态加载</strong>。关于如何启动的细节是特定于实现的，但通常应用程序已经启动并且它的 <code>main</code> 方法已经被调用。</p>
<p>我们可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/module-summary.html">Java Attach API</a> 来将代理附加到应用程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VirtualMachine</span> <span class="variable">jvm</span> <span class="operator">=</span> VirtualMachine.attach(jvmPid);</span><br><span class="line">jvm.loadAgent(agentFile.getAbsolutePath());</span><br><span class="line">jvm.detach();</span><br></pre></td></tr></table></figure>
<p>如果实现支持在 VM 启动后启动代理，则以下适用：</p>
<ul>
<li>代理 JAR 的清单必须在其清单中包含属性 <code>Agent-Class</code>。该属性的值是代理类的名称。</li>
<li>代理类必须实现 <code>public static agentmain</code> 方法。</li>
</ul>
<p>agentmain 方法具有两种可能的签名之一。 JVM 首先尝试在代理类上调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br></pre></td></tr></table></figure>
<p>如果代理类未实现此方法，则 JVM 将尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure>
<p>当使用命令行选项启动代理时，代理类也可能有一个 <code>premain</code> 方法。在 VM 启动后启动代理时，不会调用 <code>premain</code> 方法。</p>
<p>代理通过 <code>agentArgs</code> 参数传递其代理选项。代理选项作为单个字符串传递，任何额外的解析都应该由代理本身执行。</p>
<p><code>agentmain</code> 方法应该执行启动代理所需的任何必要初始化。启动完成后，该方法应返回。如果无法启动代理（例如，因为无法加载代理类，或者因为代理类没有符合的 <code>agentmain</code> 方法），<strong>JVM 不会中止</strong>。如果 <code>agentmain</code> 方法抛出未捕获的异常，它将被忽略（但可能会被 JVM 记录以进行故障排除）。</p>
<h2 id="在可执行-JAR-文件中包含代理">在可执行 JAR 文件中包含代理</h2>
<p>JAR 文件规范定义了打包为可执行 JAR 文件的独立应用程序的清单属性。</p>
<p>如果实现支持将应用程序作为可执行 JAR 启动的机制，则主清单可能包含 <code>Launcher-Agent-Class</code> 属性，以指定要在调用应用程序主方法之前启动的代理的类名。 Java 虚拟机尝试在代理类上调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span><br></pre></td></tr></table></figure>
<p>如果代理类未实现此方法，则 JVM 将尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">agentmain</span><span class="params">(String agentArgs)</span></span><br></pre></td></tr></table></figure>
<p><code>agentmain</code> 方法应该执行启动代理和返回所需的任何必要初始化。如果无法启动代理，例如无法加载代理类，代理类没有定义符合规范的 <code>agentmain</code> 方法，或者 <code>agentmain</code> 方法抛出未捕获的异常或错误，<strong>JVM 将中止</strong>。</p>
<h2 id="加载代理类和代理类可用的模块-类">加载代理类和代理类可用的模块/类</h2>
<blockquote>
<p>这里的模块是指 Java 11 的模块化系统的模块。</p>
</blockquote>
<p>从代理 JAR 文件加载的类由<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#getSystemClassLoader()">系统类加载器</a>加载，并且是系统类加载器的<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#getUnnamedModule()">未命名模块</a>的成员。系统类加载器通常也定义包含应用程序 <code>main</code> 方法的类。</p>
<p>代理类可见的类是系统类加载器可见的类，至少包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html#boot()">引导层</a>模块导出的包中的类。引导层是否包含所有平台模块将取决于初始模块或应用程序的启动方式。</li>
<li>可以由系统类加载器（通常是类路径）定义为未命名模块成员的类。</li>
<li>代理安排由引导类加载器定义的任何类，作为其未命名模块的成员。</li>
</ul>
<p>如果代理类需要链接到不在引导层中的平台（或其他）模块中的类，那么应用程序可能需要在启动确保这些模块在引导层中。例如，在 JDK 实现中，<code>--add-modules</code> 命令行选项可用于将模块添加到要在启动时解析的根模块集中。</p>
<p>支持安排由引导类加载器加载的代理类（通过 <code>appendToBootstrapClassLoaderSearch</code> 或下面指定的 <code>Boot-Class-Path</code> 属性），必须只链接到定义到引导类加载器的类。不能保证所有平台类都可以由引导类加载器定义。</p>
<p>如果配置了自定义系统类加载器（通过 <code>getSystemClassLoader</code> 方法中指定的系统属性 <code>java.system.class.loader</code>），则它必须定义 <code>appendToSystemClassLoaderSearch</code> 中指定的 <code>appendToClassPathForInstrumentation</code> 方法。 换句话说，自定义系统类加载器必须支持将代理 JAR 文件添加到系统类加载器搜索的机制。</p>
<h2 id="清单属性-Manifest-Attributes">清单属性(Manifest Attributes)</h2>
<p>为代理 JAR 文件定义了以下清单属性：</p>
<ul>
<li>
<p><code>Premain-Class</code></p>
<p>在 JVM 启动时指定代理时，此属性指定代理类。也就是说，包含 <code>premain</code> 方法的类。在 JVM 启动时指定代理时，此属性是必需的。如果该属性不存在，JVM 将中止。注意：这是一个类名，而不是文件名或路径。</p>
</li>
<li>
<p><code>Agent-Class</code></p>
<p>如果实现支持在 VM 启动后某个时间启动代理的机制，则该属性指定代理类。即包含 <code>agentmain</code> 方法的类。如果此属性不存在，代理将不会启动。注意：这是一个类名，而不是文件名或路径。</p>
</li>
<li>
<p><code>Launcher-Agent-Class</code></p>
<p>如果实现支持将应用程序作为可执行 JAR 启动的机制，则主清单可能包含此属性，以指定要在调用应用程序主方法之前启动的代理的类名。</p>
</li>
<li>
<p><code>Boot-Class-Path</code></p>
<p>引导类加载器要搜索的路径列表。路径代表目录或库（在许多平台上通常称为 JAR 或 zip 库）。在定位类的平台特定机制失败后，引导类加载器会搜索这些路径。按照列出的顺序搜索路径。列表中的路径由一个或多个空格分隔。路径采用分层 URI 的路径组件的语法。如果路径以斜杠字符 (‘/’) 开头，则该路径是绝对路径，否则它是相对路径。根据代理 JAR 文件的绝对路径解析相对路径。格式错误和不存在的路径将被忽略。在 VM 启动后某个时间启动代理时，不代表 JAR 文件的路径将被忽略。该属性是可选的。</p>
</li>
<li>
<p><code>Can-Redefine-Classes</code></p>
<p>布尔值（true 或 false，大小写无关）。是否能够重新定义此代理所需的类。 true 以外的值被认为是 false。该属性是可选的，默认为 false。</p>
</li>
<li>
<p><code>Can-Retransform-Classes</code></p>
<p>布尔值（true 或 false，大小写无关）。是否能够重新转换此代理所需的类。 true 以外的值被认为是 false。该属性是可选的，默认为 false。</p>
</li>
<li>
<p><code>Can-Set-Native-Method-Prefix</code></p>
<p>布尔值（true 或 false，大小写无关）。是否能够设置此代理所需的本机方法前缀。 true 以外的值被认为是 false。该属性是可选的，默认为 false。</p>
</li>
</ul>
<p>代理 JAR 文件可能在清单中同时具有 <code>Premain-Class</code> 和 <code>Agent-Class</code> 属性。当使用 <code>-javaagent</code> 选项在命令行上启动代理时，<code>Premain-Class</code> 属性指定代理类的名称，而 <code>Agent-Class</code> 属性将被忽略。同样，如果代理在 VM 启动后的某个时间启动，则 <code>Agent-Class</code> 属性指定代理类的名称（忽略 <code>Premain-Class</code> 属性的值）。</p>
<h1>修改代码</h1>
<p>要修改已有类的代码，我们主要是通过传入的 <code>Instrumentation</code> 实例注册 <code>ClassFileTransformer</code> 转换器来实现。在转换器实现内我们通过类名和类加载器共同来判断是否是我们需要修改的类，然后去修改字节码，可以使用一些类库轻松实现字节码的修改。如果我们注册的是具有重新转换能力的转换器，则可以使用 <code>retransformClasses</code> 立即修改转换类，否则会在类定义、加载或重新定义时调用。</p>
<blockquote>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<p>也就是说要比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p>
<p>这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象的所属关系判定等情况。</p>
</blockquote>
<h2 id="Instrumentation">Instrumentation</h2>
<p>在上面列出的方法签名的参数中，不管是静态加载的 <code>premain</code> 还是动态加载的 <code>agentmain</code>，都传递了一个 <code>Instrumentation</code> 实例给我们。一旦我们的代理获得了 <code>Instrumentation</code> 实例，就可以随时调用该实例上的方法。</p>
<p>该实例主要包含以下方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer)">addTransformer</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a> transformer)</td>
<td>注册提供的转换器。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer,boolean)">addTransformer</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a> transformer, boolean canRetransform)</td>
<td>注册提供的转换器，当 canRetransform 为 true 时，代表该转换器具有重新转换能力。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#removeTransformer(java.lang.instrument.ClassFileTransformer)">removeTransformer</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a> transformer)</td>
<td>取消注册提供的转换器。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getAllLoadedClasses()">getAllLoadedClasses</a></strong>()</td>
<td>返回 JVM 当前加载的所有类的数组。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)">getInitiatedClasses</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html">ClassLoader</a> loader)</td>
<td>返回 loader 启动加载器所有类的数组。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isModifiableClass(java.lang.Class)">isModifiableClass</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html">Class</a>&lt;?&gt; theClass)</td>
<td>测试一个类是否可以通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformation</a> 或 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefinition</a> 来修改。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()">isRetransformClassesSupported</a></strong>()</td>
<td>返回当前 JVM 配置是否支持类的重新转换。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformClasses</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html">Class</a>&lt;?&gt;… classes)</td>
<td>重新转换提供的类集合。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()">isRedefineClassesSupported</a></strong>()</td>
<td>返回当前 JVM 配置是否支持重新定义类。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefineClasses</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassDefinition.html">ClassDefinition</a>… definitions)</td>
<td>使用给定的类文件重新定义提供的类集合。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isModifiableModule(java.lang.Module)">isModifiableModule</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Module.html">Module</a> module)</td>
<td>测试是否可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)">redefineModule</a> 修改模块。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)"><strong>redefineModule</strong></a>(…)</td>
<td>重新定义模块以扩展它读取的模块集、它导出或打开的包集或其使用或提供的服务。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getObjectSize(java.lang.Object)">getObjectSize</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">Object</a> objectToSize)</td>
<td>返回指定对象消耗的存储量的特定于实现的近似值。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)">appendToBootstrapClassLoaderSearch</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/jar/JarFile.html">JarFile</a> jarfile)</td>
<td>指定一个 JAR 文件，其中包含要由引导程序类加载器定义的检测类。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#appendToSystemClassLoaderSearch(java.util.jar.JarFile)">appendToSystemClassLoaderSearch</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/jar/JarFile.html">JarFile</a> jarfile)</td>
<td>指定一个 JAR 文件，其中包含要由系统类加载器定义的检测类。</td>
</tr>
</tbody>
</table>
<h2 id="ClassFileTransformer">ClassFileTransformer</h2>
<p>如果我们要转换一个类，则可以通过注册一个自定义的 <code>ClassFileTransformer</code> 来实现，Java 虚拟机会在<em><strong>加载</strong></em>、<em><strong>重新定义</strong></em>或<em><strong>重新转换类</strong></em>时调用该实例的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html#transform(java.lang.Module,java.lang.ClassLoader,java.lang.String,java.lang.Class,java.security.ProtectionDomain,byte%5B%5D)"><code>transform</code></a> 方法。转换器是在 Java 虚拟机<em><strong>定义类之前</strong></em>被调用。</p>
<p><code>ClassFileTransformer</code> 可以实现为具有重新转换能力的转换器，通过在注册时将 <code>canRetransform</code> 参数传入为 <code>true</code> 告诉注册器自己有重新转换的能力。</p>
<p>一旦使用 <code>addTransformer</code> 注册了转换器，将在每个新的类定义时和每个类重新定义时调用转换器。在每个类重新转换时，也将调用具有重新转换能力的转换器。对新类定义的请求是使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#defineClass(byte%5B%5D,int,int)"><code>ClassLoader.defineClass</code></a> 或其原生等效方法进行的。类重新定义的请求是使用  <code>Instrumentation.redefineClasses</code> 或其原生等效方法进行的。类重新转换的请求是使用 <code>Instrumentation.retransformClasses</code> 或其原生等效方法进行的。在处理请求期间，<strong>转换器是在类的文件字节被验证和应用之前调用</strong>。当有多个转换器时，转换操作是通过转换器调用链组成的。也就是说，一次调用返回的字节数组成为下一次调用的输入（通过 <code>classfileBuffer</code> 参数）。</p>
<p>转换器将按以下顺序生效：</p>
<ul>
<li>没有再转换能力的转换器</li>
<li>没有再转换能力的原生转换器</li>
<li>有再转换能力的转换器</li>
<li>有再转换能力的原生转换器</li>
</ul>
<p>对于再转换，不调用没有再转换能力的转换器，而是重用前一次转换的结果。其他情况，该转换方式始终被调用。在这些所有分组中，转换器都是按照注册的顺序被调用。本机转换器由 Java 虚拟机工具接口（<code>JVMTI</code>）中的 <code>ClassFileLoadHook</code> 事件提供）。</p>
<p>传给第一个转换器的输入（<code>classfileBuffer</code> 参数）是：</p>
<ul>
<li>对于新的类定义，传递其 <code>ClassLoader.defineClass</code> 的字节</li>
<li>对于类重新定义，是 <code>Instrumentation.redefineClasses</code> 时传入的参数 <code>ClassDefinition</code> 实例的 <code>getDefinitionClassFile()</code> 返回结果</li>
<li>对于类重新转换，传递的是新类定义的字节。或者，如果是重新定义，则是最后一次重新定义的字节。</li>
</ul>
<p>如果实现方法确定不需要转换，则应返回 <code>null</code>。否则，它应该创建一个新的 byte[] 数组，将输入的 <code>classfileBuffer</code> 连同所有所需的转换复制到其中，并返回新数组。不得修改输入的 <code>classfileBuffer</code>。</p>
<p>在重新转换和重新定义的情况下，转换器必须支持重新定义语义：如果转换器在初始定义期间更改的类后来被重新转换或重新定义，则转换器必须确保第二个类输出类文件是第一个输出类文件的合法重新定义。</p>
<p>如果转换器抛出异常（它没有捕获），后续转换器仍将被调用，并且仍将尝试加载、重新定义或重新转换。因此，抛出异常与返回 null 具有相同的效果。为了防止在转换器代码中生成未经检查的异常时出现意外行为，转换器可以捕获 <code>Throwable</code>。如果转换器认为 <code>classFileBuffer</code> 不代表有效格式化的类文件，它应该抛出一个 <code>IllegalClassFormatException</code>；虽然这与返回 null 具有相同的效果。它有助于记录或调试格式损坏。</p>
<h2 id="字节码操作库">字节码操作库</h2>
<p>字节码的操作库有的偏重性能，有的偏重更友好的 API 操作，下面介绍几种常见的字节码操作库：</p>
<h3 id="Byte-Buddy"><a target="_blank" rel="noopener" href="http://bytebuddy.net/">Byte Buddy</a></h3>
<p>Byte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。</p>
<p>Byte Buddy 是一个相当新的库，但提供了 CGLIB 或 Javassist 提供的任何功能等等。Byte Buddy 可以完全定制到字节码级别，并带有一个富有表现力的领域特定语言（DSL），在操作字节码时，它可能是最安全、最合理的选择，而且代码可读性很高。</p>
<p>Byte Buddy 也提供了一个方便的 API 来定义 Java 代理（agent），比如下面这个统计代码时间的 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerAgent</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String arguments, </span></span><br><span class="line"><span class="params">                             Instrumentation instrumentation)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AgentBuilder</span>.Default()</span><br><span class="line">      .type(ElementMatchers.nameEndsWith(<span class="string">&quot;Timed&quot;</span>))</span><br><span class="line">      .transform((builder, type, classLoader, <span class="keyword">module</span>) -&gt; </span><br><span class="line">          builder.method(ElementMatchers.any())</span><br><span class="line">                 .intercept(MethodDelegation.to(TimingInterceptor.class))</span><br><span class="line">      ).installOn(instrumentation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimingInterceptor</span> &#123;</span><br><span class="line">  <span class="meta">@RuntimeType</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">intercept</span><span class="params">(<span class="meta">@Origin</span> Method method, </span></span><br><span class="line"><span class="params">                                 <span class="meta">@SuperCall</span> Callable&lt;?&gt; callable)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callable.call();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(method + <span class="string">&quot; took &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Javassist"><a target="_blank" rel="noopener" href="http://jboss-javassist.github.io/javassist/">Javassist</a></h3>
<p>它是 Java 中用于编辑字节码的类库；它使 Java 程序能够在运行时定义一个新类，并在 JVM 加载类文件时修改它。与其他类似的字节码编辑器不同，Javassist 提供了两个级别的 API：源代码级和字节码级。如果用户使用源代码级 API，他们可以在不了解 Java 字节码规范的情况下编辑类文件。</p>
<h3 id="CGLIB"><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a></h3>
<p>CGLIB 速度非常快，这是它仍然存在的主要原因之一。</p>
<p>一般来说，允许在运行时重写类的库必须避免在重写相应的类之前加载任何类型。 因此，它们不能使用 Java 反射 API 来加载反射中使用的任何类型，所以他们必须通过 IO（这是一个性能破坏者）读取类文件。 这使得 Javassist 或 Proxetta 比 Cglib 慢得多，CGLIB 只是通过反射 API 读取方法并覆盖它们。</p>
<h3 id="ASM"><a target="_blank" rel="noopener" href="http://asm.ow2.org/">ASM</a></h3>
<p>CGLIB、Byte Buddy 和几乎所有其他库都建立在 ASM 之上，ASM 本身在非常低的级别上操作字节码。这对大多数人来说是个障碍，因为您必须了解字节码和一点点 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/specs/">JVMS</a> 才能正确使用它。</p>
<p>但是掌握 ASM 无疑是非常有趣的。 但是请注意，虽然有一个很棒的 <a target="_blank" rel="noopener" href="http://download.forge.objectweb.org/asm/asm4-guide.pdf">ASM 4 指南</a>，但在 API 的某些部分中，javadoc 文档可能非常简洁，ASM 正在改进它的文档。</p>
<p>它紧跟 JVM 版本以支持新功能。</p>
<h1>Java Agent 和 JVM Native Agent</h1>
<p>虽然两者都以几乎相同的方式加载到 <code>JVM</code> 中（使用特殊的 <code>JVM</code> 启动参数），但它们的构建方式几乎完全不同。</p>
<p>native agent 一般使用 <code>-agentlib</code> 或 <code>-agentpath</code> 命令行参数指定，Java agent 静态加载是通过 <code>-javaagent</code> 指定。</p>
<p>Java Agent 底层也是通过 JVMTI 接口来驱动的。</p>
<h2 id="Native-Agents">Native Agents</h2>
<p>Native 代理是完全不同的野兽。如果您认为 Java 代理可以让您做很酷的事情，那么请抓紧时间，因为本地代理在完全不同的层面上运行。本机代理不是用 Java 编写的，而是主要用 C++ 编写的，并且不受普通 Java 代码运行的规则和限制的约束。不仅如此，它们还提供了一组极其强大的功能，称为 JVM 工具接口 (JVMTI)。</p>
<h3 id="它能做什么">它能做什么</h3>
<p>jvmti.h 公开的这组 API 使 JVM 动态加载的 C++ 库能够获得对 JVM 实时工作的极高级别的可见性。这跨越了广泛的领域，包括 GC、locking、代码操作、同步、线程管理、编译调试等等。JVMTI 旨在使 JVM 尽可能透明，同时仍保持设计灵活性，以允许 JVM 供应商提供不同的底层实现。这组 API 非常广泛，包含数百个关于 JVM 的回调和函数。您可以使用这些来做 Java 代理无法做的非常强大的事情，例如编写自己的调试器，或者构建低级、实时错误分析工具，比如 JRebel 和 JProfiler 等。</p>
<p>JRebel 通过 JVMTI 构建一种在运行时提供类的平滑热交换而无需重新启动 JVM 的技术。</p>
<p>JProfiler 通过 JVMTI 修改目标框架的代码以注入收集性能指标的新代码。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Instrumentation</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/java/Java-NIO/</url>
    <content><![CDATA[<p>从 1.4 版本开始，Java 提供了另一套 I/O 系统，称为 NIO(New I/O 的缩写)。NIO 支持面向缓冲区的、基于通道的 I/O 操作。随着 JDK7 的发布，Java 对 NIO 系统进行了极大扩展，增强了对文件处理和文件系统特性的支持。缘于 NIO 文件类提供的功能，NIO 预期会成为文件处理中越来越重要的部分。</p>
<p>NIO 包含下面几个核心的组件：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>还有基于文件的几个核心组件：</p>
<ul>
<li>Path</li>
<li>FileSystem</li>
</ul>
<p>下面我们就以核心组件展开来说。</p>
<span id="more"></span>
<h1>Channels and Buffers</h1>
<p>标准的 I/O 编程接口是面向字节流和字符流的。而 NIO 是面向通道（Channel）和缓冲区（Buffer）的，数据总是从通道中读到 buffer 缓冲区内，或者从 buffer 写入到通道中。</p>
<p><img data-src="../../images/java/nio/overview-channels-buffers.png" alt="overview-channels-buffers"></p>
<h2 id="Channel">Channel</h2>
<p>I/O 操作的纽带。<br>
通道表示与实体的开放连接，例如硬件设备、文件、网络套接字或能够执行一个或多个不同 I/O 操作（例如读取或写入）的程序组件。<br>
通道要么打开要么关闭。 通道在创建时打开，一旦关闭，它便保持关闭状态。</p>
<p>有很多的 Channel 类型。下面列举了主要的几种：</p>
<ul>
<li>FileChannel - 用于读取、写入、映射和操作文件的通道。</li>
<li>DatagramChannel - 可以通过 Selector 复用的面向报文的套接字通道。</li>
<li>SocketChannel - 可以通过 Selector 复用的面向流的连接套接字通道。</li>
<li>ServerSocketChannel - 可以通过 Selector 复用的面向流的侦听套接字通道。</li>
</ul>
<p>Java NIO Channel 通道和流非常相似，主要有以下几点区别：</p>
<ul>
<li>通道即可以读也可以写，流一般来说是单向的（只能读或者写）。</li>
<li>通道可以异步读写。</li>
<li>通道总是基于缓冲区 Buffer 来读写。</li>
</ul>
<p>在 Java NIO 中如果一个 Channel 是 FileChannel 类型的，那么他可以直接把数据传输到另一个 Channel。逐个特性得益于 FileChannel 包含的 <code>transferTo</code> 和 <code>transferFrom</code> 两个方法。</p>
<ul>
<li>
<p><code>FileChannel.transferFrom</code> 方法把数据从通道源传输到 FileChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">fromFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fromChannel</span> <span class="operator">=</span> fromFile.getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">toFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">toChannel</span> <span class="operator">=</span> toFile.getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> fromChannel.size();</span><br><span class="line"> </span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>
<p>transferFrom 的参数 position 和 count 表示目标文件的写入位置和最多写入的数据量。如果通道源的数据小于 count 那么就传实际有的数据量。<br>
另外，有些 SocketChannel 的实现在传输时只会传输哪些处于就绪状态的数据，即使 SocketChannel 后续会有更多可用数据。因此，这个传输过程可能不会传输整个的数据。</p>
</li>
<li>
<p><code>FileChannel.transferTo</code> 方法把 FileChannel 数据传输到另一个 channel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">fromFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fromChannel</span> <span class="operator">=</span> fromFile.getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">toFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">toChannel</span> <span class="operator">=</span> toFile.getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="type">long</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> fromChannel.size();</span><br><span class="line"> </span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<p>这段代码和之前介绍 transferFrom 时的代码非常相似，区别只在于调用方法的是哪个 FileChannel.</p>
<p>SocketChannel 的问题也存在与 transferTo 的实现可能只在发送的 buffer 填充满后才发送，并结束。</p>
</li>
</ul>
<h3 id="Scatter-Gather-IO">Scatter/Gather IO</h3>
<p>Java NIO 发布时内置了对分散（Scatter）/ 聚集（Gather）IO 的支持。Scatter / Gather 是通过单个通道向多个 Buffer 读写数据的两个概念。</p>
<p>Scattering Read 指的是从通道读取的操作能把数据写入多个 Buffer，也就是 Scatter 代表了数据从一个 Channel 到多个 Buffer 的过程。</p>
<p>Scatter / Gather 在有些场景下会非常有用，比如需要处理多份分开传输的数据。举例来说，假设一个消息包含了 Header 和 Body，我们可能会把 Header 和 Body 保存在不同独立 Buffer 中，这种分开处理 Header 与 Body 的做法会使开发更简明。</p>
<p>Java 提供了 java.nio.channels.ScatteringByteChannel 接口，以支持 Scattering 和 java.nio.channels.GatheringByteChannel 接口来支持 Gathering。</p>
<h4 id="Scattering-Read">Scattering Read</h4>
<p>“Scattering Read” 是把数据从单个 Channel 写入到多个 Buffer，下面是示意图：</p>
<p><img data-src="../../images/java/nio/scatter.png" alt="scatter.png"></p>
<p>用代码来表示的话如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128);</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">ByteBuffer </span><span class="keyword">body </span>  = <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword"></span> </span><br><span class="line"><span class="keyword">ByteBuffer[] </span><span class="keyword">bufferArray </span>= &#123; header, <span class="keyword">body </span>&#125;;</span><br><span class="line"> </span><br><span class="line">channel.read(<span class="keyword">bufferArray);</span></span><br></pre></td></tr></table></figure>
<p>观察代码可以发现，我们把多个 buffer 写在了一个数组中，然后把数组传递给 channel.read() 方法。read() 方法内部会负责把数据按顺序写进传入的 buffer 数组内。一个 buffer 写满后，接着写到下一个 buffer 中。</p>
<p>实际上，Scattering Read 内部必须写满一个 buffer 后才会向后移动到下一个 buffer，因此这并不适合消息大小会动态改变的部分，也就是说，如果你有一个 header 和 body，并且 header 有一个固定的大小（比如 128 字节），这种情形下可以正常工作。</p>
<h4 id="Gathering-Write">Gathering Write</h4>
<p>“Gathering Write” 把多个 Buffer 的数据写入到同一个 Channel 中，下面是示意图：</p>
<p><img data-src="../../images/java/nio/gather.png" alt="gather"></p>
<p>用代码表示的话如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span>   <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// write data into buffers</span></span><br><span class="line"> </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"> </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>
<h2 id="Buffer">Buffer</h2>
<p>缓冲区是特定原始类型数据的容器，本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。</p>
<p>下面是核心的 Buffer 实现类的列表：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 Buffer 涵盖了可以通过 I/O 操作的基础类型：byte，short，int，long，float，double 以及 characters。NIO 实际上还包含一种 MappedBytesBuffer，一般用于和内存映射的文件。</p>
<h3 id="容量，位置，上限">容量，位置，上限</h3>
<p>一个Buffer有三个属性是必须掌握的，分别是：</p>
<ul>
<li>capacity - 容量</li>
<li>position - 位置</li>
<li>limit - 限制</li>
</ul>
<p>position 和 limit 的具体含义取决于当前 buffer 的模式。capacity 在两种模式下都表示容量。</p>
<p>下面有张示例图，描诉了不同模式下 position 和 limit 的含义：</p>
<p><img data-src="../../images/java/nio/buffers-modes.png" alt="buffers-modes"></p>
<h4 id="容量（Capacity）">容量（Capacity）</h4>
<p>作为一块内存，buffer 有一个固定的大小，叫做 capacity 容量。也就是最多只能写入容量值得字节，整形等数据。一旦 buffer 写满了就需要清空已读数据以便下次继续写入新的数据。</p>
<h4 id="位置（Position）">位置（Position）</h4>
<p>当写入数据到 Buffer 的时候需要中一个确定的位置开始，默认初始化时这个位置 position 为 0，一旦写入了数据比如一个字节，整形数据，那么 position 的值就会指向数据之后的一个单元，position 最大可以到 capacity。</p>
<p>当从 Buffer 读取数据时，也需要从一个确定的位置开始。buffer 从写入模式变为读取模式时，position 会归零，每次读取后，position 向后移动。</p>
<h4 id="上限（Limit）">上限（Limit）</h4>
<p>在写模式，limit 的含义是我们所能写入的最大数据量。它等同于 buffer 的容量。</p>
<p>一旦切换到读模式，limit 则代表我们所能读取的最大数据量，他的值等同于写模式下 position 的位置。</p>
<p>数据读取的上限时 buffer 中已有的数据，也就是 limit 的位置（原 position 所指的位置）。</p>
<h3 id="标记和重置">标记和重置</h3>
<p>缓冲区的标记是在调用 <code>reset</code> 方法时将其位置重置到的索引。 标记并不总是被定义，但当它被定义时，它永远不会是负数，也永远不会大于位置。 如果定义了标记，则在将位置或限制调整为小于标记的值时将丢弃该标记。 如果未定义标记，则调用 reset 方法会导致抛出 <code>InvalidMarkException</code> 。</p>
<h3 id="不变量">不变量</h3>
<p>以下不变量适用于标记、位置、限制和容量值：<br>
<strong>0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量</strong><br>
新创建的缓冲区始终具有零位置和未定义的标记。 初始限制可能为零，也可能是某个其他值，具体取决于缓冲区的类型及其构造方式。 新分配的缓冲区的每个元素都初始化为零。</p>
<h3 id="清除，翻转和倒带">清除，翻转和倒带</h3>
<p>利用 Buffer 读写数据，通常遵循四个步骤：</p>
<ul>
<li>把数据写入 Buffer；</li>
<li>调用 <code>buffer.flip()</code>；</li>
<li>从 Buffer 中读取数据；</li>
<li>调用 <code>buffer.clear()</code> 或者 <code>buffer.compact()</code></li>
</ul>
<p>当写入数据到 buffer 中时，buffer 会记录已经写入的数据大小。当需要读数据时，通过 <code>flip()</code> 方法把 buffer 从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。</p>
<p>当读取完数据后，需要清空 buffer，以满足后续写入操作。清空 buffer 有两种方式：调用 <code>clear()</code> 或 <code>compact()</code> 方法。<code>clear</code> 会清空整个 buffer，<code>compact</code> 则只清空已读取的数据，未被读取的数据会被移动到 buffer 的开始位置，写入位置则近跟着未读数据之后。</p>
<p>如果想重复读取已写入的数据，可以使用 <code>rewind()</code> 将 position 置为 0。</p>
<h1>选择器（Selector）</h1>
<p><code>SelectableChannel</code> 对象的多路复用器。</p>
<p>选择器允许单线程操作多个通道。如果你的程序中有大量的链接，同时每个链接的 I/O 带宽不高的话，这个特性将会非常有帮助。比如聊天服务器。 下面是一个单线程中 Selector 维护 3 个 Channel 的示意图：</p>
<p><img data-src="../../images/java/nio/overview-selectors.png" alt="overview-selectors"></p>
<p>要使用 Selector 的话，我们必须把 Channel 注册到 Selector 上，然后就可以调用 Selector 的 <code>select()</code> 方法。这个方法会进入阻塞，直到有一个 Channel 的状态符合条件。当方法返回时，线程就可以处理事件，比如：连接事件，数据到达事件等。</p>
<h2 id="创建-Selector">创建 Selector</h2>
<p>创建一个 Selector 可以通过 Selector.open() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>
<h2 id="注册-Channel-到-Selector-上">注册 Channel 到 Selector 上</h2>
<p>为了通过 Selector 来使用 Channel，我们必须先把 Channel 注册到 Selector 上，这个操作可以使用 SelectableChannel.register() 完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>Channel 必须处于非阻塞模式才能与 Selector 一起使用。这意味着您不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 无法切换到非阻塞模式。不过，套接字通道可以正常工作。</p>
<p>注意 register() 方法的第二个参数。这是一个“关注集合（interest set）”，代表我们关注的 Channel 状态，有四种基础类型可供监听 。</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>一个 channel 触发了一个事件也可视作该事件处于就绪状态。因此当 channel 与 server 连接成功后，那么就是“连接就绪”状态。server socket channel 接收请求连接时处于“可连接就绪”状态。channel 有数据可读时处于“读就绪”状态。channel 可以进行数据写入时处于“写就绪”状态。</p>
<p>这四个事件由四个 SelectionKey 常量表示：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果您对多个事件感兴趣，可以使用 OR 将常量放在一起，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;    </span><br></pre></td></tr></table></figure>
<h2 id="SelectionKey">SelectionKey</h2>
<p>正如您在上一节中看到的，当您使用 Selector 注册 Channel 时， register() 方法返回一个 <code>SelectionKey</code> 对象。这个 <code>SelectionKey</code> 对象包含一些有趣的属性：</p>
<ul>
<li>关注集合 The interest set</li>
<li>就绪集合 The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>附加对象 An attached object (optional)</li>
</ul>
<p>这 5 个属性都代表什么含义呢？下面会一一介绍。</p>
<h3 id="Interest-Set">Interest Set</h3>
<p>这个“关注集合”实际上就是我们希望处理的事件的集合，它的值就是注册时传入的参数，我们可以用按为与运算把每个事件取出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">interestSet</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line"> </span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInAccept</span>  <span class="operator">=</span> interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInConnect</span> <span class="operator">=</span> interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInRead</span>    <span class="operator">=</span> interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isInterestedInWrite</span>   <span class="operator">=</span> interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<h3 id="Ready-Set">Ready Set</h3>
<p>&quot;就绪集合&quot;中的值是当前 channel 处于就绪的值，一般来说在调用了 select 方法后都会需要用到就绪状态，select 会在后面介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readySet</span> <span class="operator">=</span> selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>从“就绪集合”中取值的操作类似于“关注集合”的操作，当然还有更简单的方法，SelectionKey 提供了一系列返回值为 boolean 的的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<h3 id="Channel-Selector">Channel + Selector</h3>
<p>从 SelectionKey 操作 Channel 和 Selector 非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Channel</span>  <span class="variable">channel</span>  <span class="operator">=</span> selectionKey.channel();</span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> selectionKey.selector();</span><br></pre></td></tr></table></figure>
<h3 id="Attaching-Objects">Attaching Objects</h3>
<p>我们可以给一个 SelectionKey 附加一个 Object，这样做一方面可以方便我们识别某个特定的 channel，同时也增加了 channel 相关的附加信息。例如，可以把用于 channel 的 buffer 附加到 SelectionKey 上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"> </span><br><span class="line"><span class="type">Object</span> <span class="variable">attachedObj</span> <span class="operator">=</span> selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>附加对象的操作也可以在 register 的时候就执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h2 id="从-Selector-中选择-Channel">从 Selector 中选择 Channel</h2>
<p>一旦我们向 Selector 注册了一个或多个 channel 后，就可以调用 <code>select</code> 来获取 channel。<code>select</code> 方法会返回所有处于<strong>就绪状态</strong>的 channel。 select 方法具体如下：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select() 方法在返回 channel 之前处于阻塞状态。 select(long timeout) 和 select 做的事一样，不过他的阻塞有一个超时限制。</p>
<p>selectNow() 不会阻塞，根据当前状态立刻返回合适的 channel。</p>
<p>select() 方法的返回值是一个 int 整形，代表有多少 channel 处于就绪了。也就是自上一次 select 后有多少 channel 进入就绪。举例来说，假设第一次调用 select 时正好有一个 channel 就绪，那么返回值是 1，并且没有 对这个 channel 做任何处理，接着再次调用 select，此时恰好又有一个新的 channel 就绪，那么返回值还是 1，现在我们一共有两个 channel 处于就绪，但是在每次调用 select 时只有一个 channel 是就绪的。</p>
<h3 id="selectedKeys">selectedKeys()</h3>
<p>在调用 select 并返回了有 channel 就绪之后，可以通过选中的 key 集合来获取 channel，这个操作通过调用 selectedKeys() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>还记得在 register 时的操作吧，我们 register 后的返回值就是 SelectionKey 实例，也就是我们现在通过 selectedKeys() 方法所返回的 SelectionKey。</p>
<p>可以通过如下方法遍历这些 SelectionKey：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selected<span class="constructor">Keys()</span>;</span><br><span class="line"> </span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator<span class="literal">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(keyIterator.has<span class="constructor">Next()</span>) &#123;</span><br><span class="line"> </span><br><span class="line">    SelectionKey key = keyIterator.next<span class="literal">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(key.is<span class="constructor">Acceptable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.is<span class="constructor">Connectable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.is<span class="constructor">Readable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.is<span class="constructor">Writable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    keyIterator.remove<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述循环会迭代 key 集合，针对每个 key 我们单独判断他是处于何种就绪状态。</p>
<p>注意 keyIterater.remove() 方法的调用，Selector 本身并不会移除 SelectionKey 对象，这个操作需要我们手动执行。当下次 channel 处于就绪时，Selector 任然会把这些 key 再次加入进来。</p>
<p>SelectionKey.channel 返回的 channel 实例需要强转为我们实际使用的具体的 channel 类型，例如 ServerSocketChannel 或 SocketChannel.</p>
<h2 id="wakeUp">wakeUp()</h2>
<p>由于调用 select 而被阻塞的线程，可以通过调用 Selector.wakeup() 来唤醒即便此时已然没有 channel 处于就绪状态。具体操作是，使用另一个线程调用该 Selector 的 Selector.wakeup()，被阻塞与 select 方法的线程就会立刻返回。</p>
<p>如果另一个线程调用了 wakeup()，而 select() 中当前没有线程被阻塞，那么下一个调用 select() 的线程将立即“唤醒”。</p>
<h2 id="close">close()</h2>
<p>当操作 Selector 完毕后，需要调用 close 方法。close 的调用会关闭 Selector 并使相关的 SelectionKey 都无效。channel 本身并未关闭。</p>
<p>由于 Selector 实现了 Closable，所以可以使用 try-with-resources 来在方法退出时自动关闭。</p>
<h2 id="完整的-Selector-案例">完整的 Selector 案例</h2>
<p>这有一个完整的案例，首先打开一个 Selector，然后注册 channel，并持续监视选择器以了解四个事件（接受、连接、读取、写入）的“准备情况”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"> </span><br><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"> </span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>管道（Pipe）</h1>
<p>一个 Java NIO 的管道是两个线程间单向传输数据的连接。一个管道（Pipe）有一个 Source Channel 源管道和一个 Sink Channel 下游管道。我们把数据写到 Sink Channel 中，这些数据可以同过 Source Channel 再读取出来。</p>
<p>下面是一个管道的示意图：</p>
<p><img data-src="../../images/java/nio/pipe-internals.png" alt="pipe-internals"></p>
<h1>路径（Path）</h1>
<p>Path 在 Java 7 新增。相关接口位于 <code>java.nio.file</code> 包下。</p>
<p>一个 Path 实例代表一个文件系统内的路径。Path 可以指向文件也可以指向目录。可以是相对路径也可以是绝对路径。绝对路径包含了从根目录到该文件（目录）的完整路径。相对路径是从一个路径（基准路径）指向另一个目录或文件的路径。完整路径实际上等同于相对路径加上基准路径。</p>
<h1>文件系统（FileSystem）</h1>
<p>您可以通过打包在 java.nio.file 中的 <code>FileSystem</code> 和 <code>FileSystems</code> 类轻松访问文件系统。 事实上，可以通过 SPI 服务提供商的形式注册 <code>FileSystemProvider</code>，使用 <code>FileSystems</code> 定义的 <code>newFileSystem()</code> 方法，甚至可以获得一个新的文件系统。<br>
<code>FileStore</code> 类封装了文件存储系统。</p>
<h2 id="Files">Files</h2>
<p>Java NIO 中的 Files 类（java.nio.file.Files）提供了多种操作文件系统中文件、目录等文件相关类型的静态方法，在大多数情况下，此处定义的方法将委派给关联的文件系统提供程序以执行文件操作。</p>
<p>例如，它具有允许您打开或创建具有指定路径的文件的方法。 也可以获取有关路径下文件的信息，例如它是可执行的，隐藏还是只读，或者获取文件的属性，比如最后修改时间等。或者判断该路径文件是否符号链接（软链接），创建软链接，获取软链接的目标等。</p>
<p>Files 还提供让您复制或移动文件的方法，以及遍历文件夹树的 <code>walk</code> 和 <code>walkFileTree</code> 方法，walkFileTree 支持使用 <code>FileVisitor</code> 的精确遍历文件和文件夹。</p>
<p>Files 还包括这四种方法：<code>list()</code>，<code>walk()</code>，<code>lines()</code>，以及 <code>find()</code>，都返回 <code>Stream</code> 对象。 这些方法有助于将 NIO 与 Stream API 集成。从 JDK 11 开始，Files 还包括方法 <code>readString()</code> 和 <code>writeString()</code>，其返回包含文件中的字符串或写入<code>CharSequence</code>（例如 String）到文件。</p>
<h2 id="监视服务（WatchService）">监视服务（WatchService）</h2>
<p>监视已注册对象的变化和事件。</p>
<p>例如，文件管理器可以使用监视服务来监视目录的更改，以便在创建或删除文件时更新文件列表的显示。</p>
<p>从文件系统监视事件的实现旨在直接映射到可用的本地文件事件通知工具，或者在本地工具不可用时使用原始机制，例如轮询。</p>
<h1>异步 IO (Asynchronous I/O)</h1>
<p>NIO 提供多路复用 I/O，以便于创建高度可扩展的服务器。 客户端代码注册套接字通道到 <code>Selector</code> 以便通道准备开始 I/O 时通知它。</p>
<p>NIO 也提供异步 I/O，允许客户端代码启动 I/O 操作，然后在操作完成时通知客户端。 类似于多路复用 I/O，异步 I/O 也通常用于促进创建高度可扩展的服务器。</p>
<p><code>java.nio.channels.AsynchronousChannel</code> 接口描述了异步通道，它支持异步 I/O 操作（读取，写入等）。</p>
<p>一种形式是调用方法然后立即返回 <code>Future</code>，它代表异步计算的结果，我们可以通过 <code>isDone</code> 来判断是否完成，<code>get</code> 等待完成并获取结果，或者调用 <code>cancel</code> 指示取消此任务执行。</p>
<p>另一种是在异步完成或失败时，调用我们传入的 <code>CompletionHandler</code> 的 <code>completed</code> 或 <code>failed</code> 回掉方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存泄漏</title>
    <url>/java/Java-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1>1. 引言</h1>
<p><code>Java</code> 的核心优势之一是借助 <code>JVM</code> 内置的垃圾收集器（或简称 <code>GC</code>）的自动内存管理。GC 隐式地负责分配和释放内存，因此能够处理大多数内存泄漏问题。</p>
<p>尽管 GC 有效地处理了很大一部分内存，但它不能保证针对内存泄漏的万无一失的解决方案。 GC 非常聪明，但并非完美无缺。即使在有责任心的开发人员的应用程序中，内存泄漏仍然可能存在。</p>
<p>在某些情况下，应用程序会生成大量多余的对象，从而耗尽关键的内存资源，有时会导致整个应用程序的故障。</p>
<p>内存泄漏是 <code>Java</code> 中的真正问题。在本教程中，<strong>我们将看到导致内存泄漏的潜在原因是什么，如何在运行时识别它们，以及如何在应用程序中对其进行处理。</strong></p>
<span id="more"></span>
<p><img data-src="../../images/java/jvm/gc-mark-sweep.gif" alt="Mark &amp; sweep GC"></p>
<h1>2. 什么是内存泄漏</h1>
<p>内存泄漏指<strong>当堆中存在不再使用的对象，但是垃圾回收器无法将其从内存中删除的情况</strong>，因此不必要地对其进行了维护。</p>
<p>内存泄漏很严重，因为它会<strong>阻塞内存资源并随着时间的推移降低系统性能</strong>。如果不加以处理，该应用程序最终将耗尽其资源，最终以致命的 <code>java.lang.OutOfMemoryError</code> 终止。</p>
<p>堆内存中有两种不同类型的对象-已引用和未引用。引用对象是那些在应用程序中仍具有活动引用的对象，而未引用的对象则没有任何活动引用。</p>
<p>垃圾收集器会定期删除未引用的对象，但是它永远不会收集仍在引用的对象。这是可能发生内存泄漏的地方：</p>
<p><img data-src="../../images/java/jvm/memory_Leak_In_Java.png" alt="Memory Leak"></p>
<p><strong>Symptoms of a Memory Leak</strong></p>
<ul>
<li>当应用程序长时间连续运行时，性能严重下降</li>
<li>应用程序中的 <code>OutOfMemoryError</code> 堆错误</li>
<li>自发和奇怪的应用程序崩溃</li>
<li>该应用程序偶尔会用完连接对象</li>
</ul>
<p>让我们仔细看看其中一些场景以及如何处理它们。</p>
<h1>3. Java 中的内存泄漏类型</h1>
<p>在任何应用程序中，由于多种原因都会发生内存泄漏。在本节中，我们将讨论最常见的那些。</p>
<h2 id="3-1-静态字段的内存泄漏">3.1 静态字段的内存泄漏</h2>
<p>可能导致潜在内存泄漏的第一种情况是大量使用静态变量。</p>
<p>在 Java 中，静态字段的寿命通常与正在运行的应用程序的整个寿命匹配（除非 ClassLoader 符合垃圾收集的条件）。</p>
<p>让我们创建一个填充静态列表的简单 Java 程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">StaticTest</span>().populateList();</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果我们在程序执行过程中分析堆内存，那么我们将看到在调试点 1 和 2 之间，按预期，堆内存增加了。</p>
<p>但是，当我们在调试点 3 保留 populateList() 方法时，堆内存尚未被垃圾回收，正如我们在此 VisualVM 响应中看到的那样：</p>
<p><img data-src="../../images/java/jvm/memory-with-static.png" alt="Memory with static"></p>
<p>但是，在上面的程序的第 2 行中，如果我们仅删除关键字 static，那么它将对内存使用量带来巨大的变化，此 Visual VM 响应显示：</p>
<p><img data-src="../../images/java/jvm/memory-without-static.png" alt="Memory without static"></p>
<p>调试点之前的第一部分几乎与我们在静态情况下获得的结果相同。但是这一次我们离开 populateList() 方法之后，<strong>列表的所有内存都被垃圾回收了，因为我们没有对其的任何引用。</strong></p>
<p>因此，我们需要非常注意静态变量的使用。如果将集合或大型对象声明为静态，那么它们会在应用程序的整个生命周期中保留在内存中，从而阻塞了本来可以在其他地方使用的重要内存。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>尽量减少使用静态变量</li>
<li>使用单例时，依赖于延迟加载对象而不是急于加载的实现</li>
</ul>
<h2 id="3-2-未关闭资源">3.2 未关闭资源</h2>
<p>每当我们建立新连接或打开流时，JVM 就会为这些资源分配内存。一些示例包括数据库连接，输入流和会话对象。</p>
<p>忘记关闭这些资源可能会阻塞内存，从而使它们无法进入 GC。甚至在发生异常的情况下也会发生这种情况，该异常会阻止程序执行到达处理关闭这些资源的代码语句。</p>
<p>在任何一种情况下，资源留下的开放连接都会消耗内存，如果我们不处理它们，它们可能会降低性能，甚至可能导致 <code>OutOfMemoryError</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = OutOfMemoryError.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenURL_whenUnclosedStream_thenOutOfMemory</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, URISyntaxException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">URLConnection</span> <span class="variable">conn</span> </span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://norvig.com/big.txt&quot;</span>).openConnection();</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(conn.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (br.readLine() != <span class="literal">null</span>) &#123;</span><br><span class="line">        str += br.readLine();</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看从 URL 加载大文件时应用程序的内存情况：</p>
<p><img data-src="../../images/java/jvm/unclosed-streams-memory-leak.png" alt="Java unclosed streams memory leak"></p>
<p>如我们所见，堆使用率随着时间逐渐增加 – 这是由于不关闭流而导致的内存泄漏的直接影响。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>始终使用 <code>finally</code> 块关闭资源</li>
<li>关闭资源的代码（即使在 <code>finally</code> 块中）本身也不应该有任何异常</li>
<li>使用 <code>Java 7+</code> 时，我们可以利用 <code>try-with-resources</code> 块</li>
</ul>
<h2 id="3-3-equals-和-hashcode-实现不当">3.3 <em>equals</em> 和 <em>hashcode()</em> 实现不当</h2>
<p>在定义新类时，一个非常普遍的疏忽是没有为 <code>equals()</code> 和 <code>hashCode()</code> 方法编写适当的重写方法。</p>
<p><code>HashSet</code> 和 <code>HashMap</code> 在许多操作中使用这些方法，如果未正确覆盖它们，则它们可能成为潜在内存泄漏问题的根源。</p>
<p>让我们以一个简单的 <code>Person</code> 类为例，并将其用作 <code>HashMap</code> 中的键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们将重复的 <code>Person</code> 对象插入使用此键的 <code>Map</code> 中。</p>
<p>请记住，<code>Map</code> 不能包含重复的键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenMap_whenEqualsAndHashCodeNotOverridden_thenMemoryLeak</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jon&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertFalse(map.size() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 <code>Person</code> 作为键。由于 <code>Map</code> 不允许使用重复的键，因此，作为键插入的大量重复的 <code>Person</code> 对象不应增加内存。</p>
<p>但是，由于我们尚未定义适当的 <code>equals()</code> 方法，因此重复的对象堆积并增加了内存，这就是为什么我们在内存中看到多个对象的原因。为此，<code>VisualVM</code> 中的堆内存如下所示：</p>
<p><img data-src="../../images/java/jvm/before_implementing_equals_and_hashcode.png" alt="Before implementing equals and hashcode"></p>
<p>但是，如果我们正确地重写了<code>equals()</code> 和 <code>hashCode()</code> 方法，则此 <code>Map</code> 中将仅存在一个 <code>Person</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> person.name.equals(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + name.hashCode();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>正确覆盖 <code>equals()</code> 和 <code>hashCode()</code> 之后，同一程序的堆内存如下所示：</p>
<p><img data-src="../../images/java/jvm/afterimplementing_equals_and_hashcode.png" alt="After implementing equals and hashcode"></p>
<p><strong>如果不重写这些方法，则发生内存泄漏的可能性非常高</strong>，因为 <code>Hibernate</code> 无法比较对象，并会使用重复的对象填充其缓存。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>根据经验，定义新实体时，请始终覆盖 <code>equals()</code> 和 <code>hashCode()</code> 方法</li>
<li>不仅要覆盖，而且还必须以最佳方式覆盖这些方法</li>
</ul>
<h2 id="3-4-使用非静态内部类">3.4 使用非静态内部类</h2>
<p>这是在非静态内部类（匿名类）的情况下发生的。为了进行初始化，这些内部类始终需要封闭类的实例。</p>
<p>默认情况下，每个非静态内部类都有对其包含类的隐式引用。如果我们在应用程序中使用此内部类的对象，<strong>则即使在包含类的对象超出范围后，也不会对其进行垃圾回收。</strong></p>
<p>考虑一个类其中包含对大量笨重对象的引用，并且具有一个非静态内部类。现在，当我们创建内部类的对象时，内存模型如下所示：</p>
<p><img data-src="../../images/java/jvm/inner_Classes_That_Reference_Outer_Classes.png" alt="Inner Classes That Reference Outer Classes"></p>
<p>但是，如果仅将内部类声明为静态，则相同的内存模型如下所示：</p>
<p><img data-src="../../images/java/jvm/static_Classes_That_Reference_Outer_Classes.png" alt="Static Classes That Reference Outer Classes"></p>
<p>发生这种情况是因为内部类对象隐式持有对外部类对象的引用，从而使其成为垃圾回收的无效候选对象。对于匿名类，也会发生同样的情况。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>如果内部类不需要访问包含的类成员，请考虑将其转换为静态类</li>
</ul>
<h2 id="3-5-通过-finalize-方法">3.5 通过 <em>finalize()</em> 方法</h2>
<p>使用终结器是潜在的内存泄漏问题的另一个来源。每当覆盖类的 <code>finalize()</code> 方法时，<strong>该类的对象不会立即被垃圾收集</strong>。取而代之的是， <code>GC</code> 将它们排入队列以进行最终确定，这将在以后的某个时间点进行。</p>
<p>另外，如果用 <code>finalize()</code> 方法编写的代码不是很优化，并且终结器队列无法跟上 <code>Java</code> 垃圾收集器的速度，那么迟早，我们的应用程序注定会遇到 <code>OutOfMemoryError</code>。</p>
<p>为了说明这一点，让我们考虑一下我们有一个覆盖了 <code>finalize()</code> 方法的类，并且该方法需要一点时间来执行。</p>
<p><img data-src="../../images/java/jvm/finalize_method_overridden.png" alt="finalize method overridden"></p>
<p>但是，如果只删除覆盖的 <code>finalize()</code> 方法，则同一程序将给出以下响应：</p>
<p><img data-src="../../images/java/jvm/finalize_method_not_overridden.png" alt="finalize method not overridden"></p>
<p><strong>如何预防？</strong></p>
<ul>
<li>我们应该始终避免使用终结器</li>
</ul>
<h2 id="3-6-字符串常量池">3.6 字符串常量池</h2>
<p>在 <code>Java 7</code> 之前，<code>JVM</code> 将 <strong><code>Java</code> 字符串池放置在永久代 <code>PermGen</code> 空间中，该空间的大小是固定的 - 无法在运行时扩展，并且不适合进行垃圾回收。</strong></p>
<p>默认的字面量创建方法和 String 的 <code>intern</code> 方法会在字符串常量池保留字符串。</p>
<p>在 <code>PermGen</code>（而不是堆 <code>Heap</code>）中保留 <code>String</code> 的风险是，如果我们保留过多的 <code>String</code>，我们可能会从 <code>JVM</code> 中获得 <code>OutOfMemory</code> 错误。</p>
<p>从 <code>Java 7</code> 开始，<code>Java</code> 字符串池**存储在 <code>Heap</code> 空间中，该空间由 <code>JVM</code> 进行垃圾回收。**这种方法的优点是减少了 <code>OutOfMemory</code> 错误的风险，因为未引用的字符串将从池中删除，从而释放内存。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>
<p>解决此问题的最简单方法是升级到最新的 Java 版本</p>
</li>
<li>
<p>或者要在 6 之前使用大量字符串或长字符串，请增加 <code>PermGen</code> 空间的大小，以避免任何潜在的 <code>OutOfMemoryErrors</code>：</p>
<p><code>-XX:MaxPermSize=512m</code></p>
</li>
</ul>
<h2 id="3-7-使用-ThreadLocal">3.7 使用 <em>ThreadLocal</em></h2>
<p><em><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a></em> 是一种使我们能够将状态隔离到特定线程，从而使我们能够实现线程安全的结构。</p>
<p>使用此构造时，<strong>每个线程将保留对其 <em>ThreadLocal</em> 变量副本的隐式引用，并将维护自己的副本，只要线程是活动的。</strong></p>
<p><img data-src="../../images/java/jvm/thread-local.png" alt="ThreadLocal"></p>
<blockquote>
<p>实线代表强引用，虚线代表弱引用（<code>WeakReference</code>）</p>
<p>JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在 java 中，用 <code>java.lang.ref.WeakReference</code> 类来表示。可以在缓存中使用弱引用。</p>
</blockquote>
<p>尽管有其优点，但使用 <em><code>ThreadLocal</code></em> 变量还是有争议的，因为如果使用不当，它们会导致内存泄漏。</p>
<p><strong><em>ThreadLocal</em> 导致内存泄漏</strong></p>
<p>一旦持有线程不再存活，就应该对 <em>ThreadLocals</em> 进行垃圾回收。但是，将 <em>ThreadLocals</em> 与现代应用程序服务器一起使用时会出现问题。</p>
<p>现代应用程序服务器使用线程池来处理请求，而不是创建新请求（例如，对于 <code>Apache Tomcat</code> 为 <a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-7.0-doc/config/executor.html"><code>Executor</code></a>）。此外，他们还使用单独的类加载器。</p>
<p>由于应用程序服务器中的<a target="_blank" rel="noopener" href="https://www.baeldung.com/thread-pool-java-and-guava">线程池</a>使用线程重用的概念，因此它们永远不会被垃圾回收 - 而是被重用以满足另一个请求。</p>
<p>现在，如果任何类创建了一个 <code>ThreadLocal</code> 变量，但未明确删除它，那么即使在 Web 应用程序停止后，该对象的副本也将与工作线程一起保留，从而阻止垃圾回收该对象。</p>
<p>从上图中可以看出，<code>ThreadLocalMap</code> 使用 <code>ThreadLocal</code> 的弱引用作为 <code>key</code>，如果一个 <code>ThreadLocal</code> 不存在外部<strong>强引用</strong>时，<code>Key(ThreadLocal)</code> 势必会被 <code>GC</code> 回收，这样就会导致 <code>ThreadLocalMap</code> 中 <code>key</code> 为 <code>null</code>， 而 <code>value</code> 还存在着强引用，只有 <code>thead</code> 线程退出以后，<code>value</code> 的强引用链条才会断掉。</p>
<p>但如果当前线程再迟迟不结束的话，这些 <code>key</code> 为 <code>null</code> 的 <code>Entry</code> 的 <code>value</code> 就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>永远无法回收，造成内存泄漏。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>
<p>在不再使用 <em>ThreadLocal</em> 时清理是一个好习惯 - <em>ThreadLocal</em> 提供了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#remove()"><em>remove()</em></a> 方法，该方法将删除此变量的当前线程值</p>
</li>
<li>
<p><strong>不要使用 <code>ThreadLocal.set(null)</code> 来清除值</strong> - 实际上并不会清除值，而是查找与当前线程关联的 <code>Map</code> 并将键值对分别设置为当前线程和 <code>null</code></p>
</li>
<li>
<p>最好将 <em>ThreadLocal</em> 视为需要在 <em>finally</em> 块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(System.nanoTime());</span><br><span class="line">    <span class="comment">//... further processing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-8-过期引用">3.8 过期引用</h2>
<p>虽然绝大多数情况下我们在编写代码时不必考虑内存的回收，但是一旦我们自身管理了这些内存，垃圾回收可能就无法正常工作。让我们先来看一下一个简单的 Stack 类的实现，看看能不能找出内存泄漏的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> &#123;</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它的问题在哪里？如果堆栈增大然后缩小，弹出的对象被外部程序引用，那么即使使用该堆栈的程序没有引用该对象，从堆栈弹出的对象也不会被垃圾回收。 这是因为虽然弹出了对象的引用，但是堆栈自身还保留对这些对象的<strong>过时引用 （obsolete reference）</strong>。<strong>所以垃圾回收器永远不会回收这部分对象。</strong></p>
<p>垃圾收集语言中的内存泄漏（更适当地称为<strong>无意的对象保留 unintentional object retentions</strong>）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p>
<p>此类问题的<strong>解决方法</strong>很简单：一旦引用过时，则将其清空。 就我们的 <code>Stack</code> 类而言，对某个项目的引用在从堆栈中弹出后便会过时。 正确的 <code>pop</code> 方法版本如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>; <span class="comment">// 消除过期对象引用</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>清空好处</strong>：如果它们以后又被错误地引用，程序立即抛出 <code>NullPointerException</code> 异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。<br>
<strong>清空对象引用应该是例外而不是规范</strong>，不是所有的对象结束引用都需要手动清空，GC 自身能很好的做到，<strong>除非我们自身管理了内存时，才需要警惕。</strong></p>
<p>在 <code>JDK</code> 中，已经有现成的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html"><code>Stack</code></a> 类供我们使用，来看看它是怎么实现 <code>pop</code> 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="type">int</span>     <span class="variable">len</span> <span class="operator">=</span> size();</span><br><span class="line"></span><br><span class="line">        obj = peek(); <span class="comment">//这个方法将栈顶的元素取出来，但并不会把栈顶元素弹出</span></span><br><span class="line">        removeElementAt(len - <span class="number">1</span>); <span class="comment">//这是 Stack 父类的方法,将栈顶元素弹出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">removeElementAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                     elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> elementCount - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount--;</span><br><span class="line">        <span class="comment">// 可以看到，jdk 的实现就是显式地把引用清空，以此告诉 GC 将过期引用回收</span></span><br><span class="line">        elementData[elementCount] = <span class="literal">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何预防？</strong></p>
<ul>
<li>如果我们自身管理了对象的内存，<strong>首先应该尽可能的将变量定义在狭窄的范围内</strong></li>
<li>消除过时引用的最佳方法是让包含引用的变量超出范围</li>
<li>如果我们清楚知道该对象已经不再使用，可以手动清空对象使 GC 清楚可以被回收</li>
</ul>
<h2 id="3-9-未正确使用缓存">3.9 未正确使用缓存</h2>
<p>一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 <code>WeakHashMap</code> 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，<code>WeakHashMap</code> 才有用。这点和 <code>ThreadLocal</code> 很像。</p>
<p>更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程（也许是 <code>ScheduledThreadPoolExecutor</code>）或将新的项添加到缓存时顺便清理。<code>LinkedHashMap</code> 类使用它的 <code>removeEldestEntry</code> 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 <code>java.lang.ref</code>。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>使用成熟的缓存实现类</li>
<li>如果简单实用，可以使用 <code>WeakHashMap</code> 或者定期清理缓存或设置过期时间等策略</li>
</ul>
<h2 id="3-10-监听器和其它回调">3.10 监听器和其它回调</h2>
<p>如果你实现了一个API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（<code>weak references</code>），例如，仅将它们保存在 <code>WeakHashMap</code>的键（<code>key</code>）中。</p>
<p>比如 JDK 中虚拟机状态监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VMState</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VirtualMachineImpl vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listeners</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;WeakReference&lt;VMListener&gt;&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WeakReference&lt;VMListener&gt;&gt;();</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何预防？</strong></p>
<ul>
<li>自身管理对象内存时，要正确实现对象的管理操作</li>
<li>使用弱引用以便不使用时让 <code>GC</code> 回收</li>
</ul>
<h1>4. 处理内存泄漏的其他策略</h1>
<p>尽管在处理内存泄漏时没有一种万能的解决方案，但是有一些方法可以使这些泄漏最小化。</p>
<h2 id="4-1-启用分析">4.1 启用分析</h2>
<p>Java Profiler 是监视和诊断通过应用程序的内存泄漏的工具。他们分析了我们应用程序内部发生的事情 - 例如，内存分配方式。</p>
<p><strong>使用分析器，我们可以比较不同的方法并找到可以最佳利用资源的领域。</strong></p>
<p>在之前的例子中，我们一直使用 <code>Java VisualVM</code>。还有其它不同类型的 <code>Profiler</code>，例如 <code>Mission Control</code>，<code>JProfiler</code>，<code>YourKit</code> 和 <code>Netbeans Profiler</code> 等。</p>
<h2 id="4-2-详细垃圾回收">4.2 详细垃圾回收</h2>
<p>通过启用详细的垃圾收集，我们可以跟踪 <code>GC</code> 的详细信息。为此，我们需要将以下内容添加到我们的 <code>JVM</code> 配置中：</p>
<p><code>-verbose:gc</code></p>
<p>通过添加此参数，我们可以看到 <code>GC</code> 内部发生的情况的详细信息：</p>
<p><img data-src="../../images/java/jvm/verbose-garbage-collection.jpg" alt="verbose garbage collection"></p>
<h2 id="4-3-使用引用对象避免内存泄漏">4.3 使用引用对象避免内存泄漏</h2>
<p>我们还可以诉诸于 <code>java.lang.ref</code> 包内置的 Java 引用对象来处理内存泄漏。使用 <code>java.lang.ref</code> 包，而不是直接引用对象，通过使用对对象的特殊引用，使它们易于垃圾回收。</p>
<p>在引入引用类之前，只有强引用可用。例如，下面的代码行展示了一个强引用 <code>obj</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>obj 引用存储在堆中的对象。只要 obj 引用存在，垃圾收集器就永远不会释放用于保存该对象的存储。一个对象可以被多种引用类型引用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">对应类</th>
<th style="text-align:center">特征</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center"></td>
<td style="text-align:center">强引用的对象被引用时不会被 GC 回收</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">SoftReference</td>
<td style="text-align:center">如果物理内存充足则不会被 GC 回收，如果物理内存不充足则会被 GC 回收。</td>
<td><strong>实现内存敏感型数据缓存</strong></td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">WeakReference</td>
<td style="text-align:center">一旦被 GC 扫描到则会被回收</td>
<td><strong>用于实现规范化的映射</strong>。如果映射仅包含特定值的一个实例，则称为规范化。比如 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/WeakHashMap.html"><em><code>WeakHashMap</code></em></a></strong>；<br /><strong>解决 Lapsed Listener 问题</strong>，上面所述监听器回调问题</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">PhantomReference</td>
<td style="text-align:center">不会影响对象的生命周期，形同于无，任何时候都可能被 GC 回收</td>
<td>**确定何时从内存中删除对象，**这有助于安排对内存敏感的任务。例如，我们可以等待一个大对象被删除再加载另一个对象。<br />**避免使用 <em>finalize</em> 方法，并改进 finalization 过程</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">FinalReference</td>
<td style="text-align:center">用于收尾机制(finalization)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="4-4-基准测试">4.4 基准测试</h2>
<p>我们可以通过执行基准测试来衡量和分析 Java 代码的性能。这样，我们可以比较替代方法执行相同任务的性能。这可以帮助我们选择更好的方法，并且可以帮助我们节省内存。</p>
<h2 id="4-5-代码评测">4.5 代码评测</h2>
<p>最后，我们通过最经典的，古老的方式来进行简单的代码演练。</p>
<p>在某些情况下，即使是这种简单的方法也可以帮助消除一些常见的内存泄漏问题。</p>
<h1>5. 结论</h1>
<p>内存泄漏很难解决，要找到它们需要对 Java 语言进行复杂的掌握和命令。在处理内存泄漏时，没有一种千篇一律的解决方案，因为泄漏可能通过各种多样的事件发生。</p>
<p>但是，如果我们采用最佳实践并定期执行严格的代码演练和分析，则可以最大程度地减少应用程序中内存泄漏的风险。</p>
<p>与往常一样，可以在 <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-perf">GitHub</a> 上获得用于生成本教程中描述的 VisualVM 响应的代码段。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Memory Leak</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 代理 入门</title>
    <url>/java/Java-%E4%BB%A3%E7%90%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="什么是代理">什么是代理</h2>
<p>代理是一种设计模式。当我们想要添加或修改现有类的某些功能时，我们创建并使用代理对象。通常，代理对象具有与原始代理对象相同的方法，并且在 Java 代理类中通常扩展原始类。代理的主要目的是控制对目标对象的访问，而不是增强目标对象的功能。</p>
<p>这样，代理类可以通过方便的方式实现许多功能：</p>
<ul>
<li>方法开始和结束时日志</li>
<li>访问控制，过滤恶意请求</li>
<li>本地执行远程服务</li>
<li>缓存请求结果</li>
<li>对参数执行额外检查</li>
<li>模拟原始类的行为</li>
<li>实现对昂贵资源的懒加载</li>
<li>智能引用，可在没有客户端使用某个重量级对象时立即销毁该对象</li>
<li>etc…</li>
</ul>
<p>在实际应用中，代理类不直接实现功能。遵循单一责任原则，代理类仅执行代理，并且实际行为在处理程序中实现。</p>
<p>与静态代理相比，动态代理需要在运行时进行 Java 反射的字节码生成。使用动态方法，无需创建代理类，这可以带来更多便利。</p>
<span id="more"></span>
<h2 id="静态代理类">静态代理类</h2>
<p>由程序创建或特定工具自动生成源代码，在程序运行前，代理类的.class文件就已经存在。</p>
<p>通过将目标类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的。</p>
<h3 id="缺点">缺点</h3>
<ul>
<li>冗余。定义的静态代理类非常特定于一个实现，这意味着对于每个实现，代理都需要明确定义，这是重复的工作。</li>
<li>受限。单个代理类无法实现对多个不同类的方法调用的代理。</li>
<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>
</ul>
<h2 id="动态代理类">动态代理类</h2>
<p>动态代理类（下面简称为代理类）是一个在运行时实现指定接口列表的类，这样就可以通过其中一个接口实例类上的方法调用编码并通过统一接口分配给另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需预生成代理类，例如使用编译时工具。动态代理类的实例上的方法调用被分派到实例的调用处理程序中的单个方法 - <code>invoke</code>。</p>
<p>动态代理类对于需要在呈现接口 API 的对象上提供类型安全反射调度调用的应用程序或库非常有用。例如应用程序可以使用动态代理类来创建实现多个任意事件侦听器接口的对象，通过扩展 <code>java.util.EventListener</code> 的接口，以统一的方式处理不同类型的各种事件，例如将所有此类事件记录到文件中。</p>
<h3 id="动态代理类-API">动态代理类 API</h3>
<p>动态代理类（下面简称为代理类）是一个实现在运行时创建指定的接口列表的类的<strong>类（Class）</strong>。</p>
<p>代理接口就是由代理类实现的接口。</p>
<p>代理实例是代理类的实例。</p>
<h4 id="创建代理类">创建代理类</h4>
<p>使用类 <code>java.lang.reflect.Proxy</code> 的静态方法来创建代理类及其实例。</p>
<p>在给定类加载器和接口数组的情况下，<code>Proxy.getProxyClass</code> 方法返回代理类的 java.lang.Class 对象。代理类将在指定的类加载器中定义，并将实现所有提供的接口。如果已经在类加载器中定义了相同的接口排列的代理类，将返回现有的代理类；否则，将动态生成这些接口的代理类，并在类加载器中定义。</p>
<p>可以传递给 <code>Proxy.getProxyClass</code> 的参数有几个限制：</p>
<ul>
<li><code>interfaces</code> 数组中的所有 <code>Class</code> 对象都必须表示接口，而不是类或基本类型。</li>
<li><code>interfaces</code> 数组中的任何两个元素都不能引用相同的 <code>Class</code> 对象。</li>
<li>所有接口类型必须通过指定的类加载器按名称可见。换句话说，对于类加载器 cl 和每个接口 i，以下表达式必须为 true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(i.getName(), <span class="literal">false</span>, cl) == i</span><br></pre></td></tr></table></figure>
<ul>
<li>所有非公共接口必须位于同一个包中；否则，代理类无法实现所有接口，无论它在哪个包中定义。</li>
<li>对于具有相同签名的指定接口的任何成员方法集：
<ul>
<li>如果任何方法的返回类型是基本类型或 void，则所有方法必须具有相同的返回类型。</li>
<li>否则，其中一个方法必须具有可分配给其余方法的所有返回类型的返回类型。</li>
</ul>
</li>
<li>生成的代理类不得超过虚拟机对类强加的任何限制。例如，VM 可以将类可以实现的接口数量限制为 65535；在这种情况下，<code>interfaces</code> 数组的大小不得超过 65535。</li>
</ul>
<p>如果违反任何这些限制，<code>Proxy.getProxyClass</code> 将抛出 <code>IllegalArgumentException</code>。如果接口数组参数或其任何元素为空，则将抛出 <code>NullPointerException</code>。</p>
<p>请注意，指定代理接口的顺序很重要：对具有相同接口组合但顺序不同的代理类的两个请求将导致两个不同的代理类。代理类通过其代理接口的顺序来区分，以便在两个或更多代理接口共享具有相同名称和参数签名的方法的情况下提供确定性方法调用编码;</p>
<p>因此，每次使用相同的类加载器和接口列表调用 <code>Proxy.getProxyClass</code> 时，不需要生成新的代理类，动态代理类 API 的实现应保留生成的代理类的缓存，缓存的键由其相应的加载器和接口列表定义。实现缓存时应注意不要引用类加载器，接口和代理类，以防止类加载器及其所有类在适当时被垃圾收集。</p>
<h5 id="代理类属性">代理类属性</h5>
<p>代理类具有以下属性：</p>
<ul>
<li>代理类是公共的，最终的，而不是抽象的。</li>
<li>代理类的非限定名称是未指定的。但是，以字符串 <code>“$Proxy”</code> 开头的类名空间是为代理类保留的。</li>
<li>代理类 extend <code>java.lang.reflect.Proxy</code>。</li>
<li>代理类以相同的顺序实现其创建时指定的接口。</li>
<li>由于代理类实现了在创建时指定的所有接口，因此在其 Class 对象上调用 <code>getInterfaces</code> 将返回一个包含相同接口列表的数组（按照创建时指定的顺序）。在其 Class 对象上调用 <code>getMethods</code> 将返回包含这些接口中所有方法的 <code>Method</code> 对象数组，并且调用 <code>getMethod</code> 将按预期在代理接口中查找方法。</li>
<li>如果 <code>Proxy.isProxyClass</code> 方法传递了一个代理类 -（由 <code>Proxy.getProxyClass</code> 返回的类或 <code>Proxy.newProxyInstance</code> 返回的对象的类），则返回 true，否则返回 false。</li>
<li>代理类的 <code>java.security.ProtectionDomain</code> 与引导类加载器加载的系统类相同，例如 java.lang.Object，因为代理类的代码是由受信任的系统代码生成的。通常会授予此保护域 <code>java.security.AllPermission</code>。</li>
</ul>
<h4 id="创建代理实例">创建代理实例</h4>
<p>每个代理类都有一个公共构造函数，它接受一个参数，即 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/InvocationHandler.html"><code>InvocationHandler</code></a> 接口的实现。</p>
<p>每个代理实例都有一个关联的 <code>InvocationHandler</code> 对象，该对象就是通过构造方法传递进来的。不必非要使用反射 API 来访问公共构造函数，也可以通过调用 <code>Proxy.newProxyInstance</code> 方法创建代理实例。 <code>Proxy.newProxyInstance</code> 因与 <code>Proxy.getProxyClass</code> 相同的原因抛出 <code>IllegalArgumentException</code>（比如接口数量不能超过 65535）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(...);</span><br><span class="line"><span class="comment">// 创建代理类</span></span><br><span class="line">Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);</span><br><span class="line"><span class="comment">// 使用代理类创建代理实例</span></span><br><span class="line"><span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) proxyClass.getConstructor(InvocationHandler.class).newInstance(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用静态方法直接创建代理实例</span></span><br><span class="line"><span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;Foo.class&#125;, handler);</span><br></pre></td></tr></table></figure>
<h5 id="代理实例属性">代理实例属性</h5>
<p>代理实例有以下属性：</p>
<ul>
<li>给定代理实例 proxy 和其代理类 Foo 实现的接口之一，以下表达式将返回 true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy <span class="keyword">instanceof</span> Foo</span><br></pre></td></tr></table></figure>
<p>并且以下转换操作将成功（而不是抛出 ClassCastException）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(Foo) proxy</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>静态 <code>Proxy.getInvocationHandler</code> 方法传递代理实例并返回与之关联的 <code>InvocationHandler</code>。如果传递给 <code>Proxy.getInvocationHandler</code> 的对象不是代理实例，则将抛出 <code>IllegalArgumentException</code>。</p>
</li>
<li>
<p>代理实例上的接口方法调用将被编码并调度到 <code>InvocationHandler</code> 的调用方法，如下所述。</p>
<p>代理实例本身将作为 <code>invoke</code> 的第一个参数传递，它是 Object 类型。</p>
<p>传递给 <code>invoke</code> 的第二个参数是 <code>java.lang.reflect.Method</code> 实例，该实例对应于在代理实例上调用的接口方法。<code>Method</code> 对象的声明类将是声明方法的接口，它可以是代理接口继承方法的代理接口的超接口。</p>
<p>传递给 <code>invoke</code> 的第三个参数是一个对象数组，其中包含在代理实例上的方法调用中传递的参数的值。原始类型的参数包装在适当的原始包装类的实例中，例如 <code>java.lang.Integer</code> 或 <code>java.lang.Boolean</code>。 <strong><code>invoke</code> 方法的实现可以自由修改此数组的内容。</strong></p>
<p><code>invoke</code> 方法返回的值将成为代理实例上方法调用的返回值。如果接口方法的声明返回值是基本类型，则 invoke 返回的值必须是相应原始包装类的实例；否则，它必须是可分配给声明的返回类型的类型。如果 <code>invoke</code> 返回的值为 <code>null</code>，并且接口方法的返回类型为原始类型，则代理实例上的方法调用将抛出 <code>NullPointerException</code>。如果 <code>invoke</code> 返回的值与上面描述的方法声明的返回类型不兼容，则代理实例将抛出 <code>ClassCastException</code>。</p>
<p>如果 <code>invoke</code> 方法抛出异常，它也将在代理实例上的方法调用中抛出。异常的类型必须可分配给在接口方法的签名中声明的任何异常类型，或者分配给未经检查的异常类型 <code>java.lang.RuntimeException</code> 或 <code>java.lang.Error</code>。如果通过调用抛出已检查的异常，该异常不能分配给接口方法的 <code>throws</code> 子句中声明的任何异常类型，在代理实例上的方法调用时将抛出 <code>UndeclaredThrowableException</code>，该异常由 <code>invoke</code> 方法抛出的异常来构造。</p>
</li>
<li>
<p>在代理实例上的 <code>java.lang.Object</code> 中声明的 <code>hashCode</code>，<code>equals</code> 或 <code>toString</code> 方法的调用将被编码并调度到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，其方式与编码和分派接口方法调用的方式相同，如上所述。 传递给 <code>invoke</code> 的 <code>Method</code> 对象的声明类将是 <code>java.lang.Object</code>。 从 <code>java.lang.Object</code> 继承的代理实例的其他公共方法不会被代理类覆盖，因此这些方法的调用行为就像它们对 java.lang.Object 的实例所做的一样。</p>
</li>
</ul>
<h3 id="序列化">序列化</h3>
<p>由于 <code>java.lang.reflect.Proxy</code> 实现了 <code>java.io.Serializable</code>，因此可以序列化代理实例。</p>
<h3 id="在多个代理接口中重复的方法">在多个代理接口中重复的方法</h3>
<p>当两个或多个代理接口包含具有相同名称和参数签名的方法时，代理类接口的顺序就变得很重要。</p>
<p>当在代理实例上调用重复方法时，包含代理类接口列表中的方法（直接或通过超接口继承）的<strong>最前面接口中方法的 Method 对象</strong>将传递给调用处理程序的 <code>invoke</code> 方法。</p>
<h3 id="Examples">Examples</h3>
<h4 id="Example-1">Example 1</h4>
<p>下面是一个简单的示例，它在实现任意接口列表的对象上的方法调用之前和之后打印出一条消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    Object <span class="title function_">bar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> BazException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooImpl</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    Object <span class="title function_">bar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> BazException &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugProxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.lang.reflect.InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(</span><br><span class="line">            obj.getClass().getClassLoader(),</span><br><span class="line">            obj.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DebugProxy</span>(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DebugProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before method &quot;</span> + m.getName());</span><br><span class="line">            result = m.invoke(obj, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unexpected invocation exception: &quot;</span> +</span><br><span class="line">                                       e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after method &quot;</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为 <code>Foo</code> 接口的实现构造 <code>DebugProxy</code> 并调用其方法之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> (Foo) DebugProxy.newInstance(<span class="keyword">new</span> <span class="title class_">FooImpl</span>());</span><br><span class="line">foo.bar(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Example-2">Example 2</h4>
<p>下面是一个实用程序调用处理程序类的示例，它为从 <code>java.lang.Object</code> 继承的方法提供默认代理行为，并根据被调用方法的接口实现对不同对象的某些代理方法调用的委派：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delegator</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preloaded Method objects for the methods in java.lang.Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashCodeMethod = Object.class.getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            equalsMethod =</span><br><span class="line">                Object.class.getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Object.class &#125;);</span><br><span class="line">            toStringMethod = Object.class.getMethod(<span class="string">&quot;toString&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class[] interfaces;</span><br><span class="line">    <span class="keyword">private</span> Object[] delegates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Delegator</span><span class="params">(Class[] interfaces, Object[] delegates)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.interfaces = (Class[]) interfaces.clone();</span><br><span class="line">        <span class="built_in">this</span>.delegates = (Object[]) delegates.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">declaringClass</span> <span class="operator">=</span> m.getDeclaringClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (declaringClass == Object.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.equals(hashCodeMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxyHashCode(proxy);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.equals(equalsMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxyEquals(proxy, args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.equals(toStringMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxyToString(proxy);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(</span><br><span class="line">                    <span class="string">&quot;unexpected Object method dispatched: &quot;</span> + m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (declaringClass.isAssignableFrom(interfaces[i])) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> m.invoke(delegates[i], args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> invokeNotDelegated(proxy, m, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">invokeNotDelegated</span><span class="params">(Object proxy, Method m,</span></span><br><span class="line"><span class="params">                                        Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;unexpected method dispatched: &quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">proxyHashCode</span><span class="params">(Object proxy)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(System.identityHashCode(proxy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Boolean <span class="title function_">proxyEquals</span><span class="params">(Object proxy, Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (proxy == other ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">proxyToString</span><span class="params">(Object proxy)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> proxy.getClass().getName() + <span class="string">&#x27;@&#x27;</span> +</span><br><span class="line">            Integer.toHexString(proxy.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Delegator</code> 的子类可以覆盖 <code>invokeNotDelegated</code> 以实现代理方法调用的行为，而不是直接委托给其他对象，并且可以覆盖 <code>proxyHashCode</code>、<code>proxyEquals</code> 和 <code>proxyToString</code> 来覆盖代理从 java.lang.Object 继承的方法的默认行为。</p>
<p>构造实现 <code>Foo</code> 接口的 <code>Delegator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class[] proxyInterfaces = <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Foo.class &#125;;</span><br><span class="line"><span class="type">Foo</span> <span class="variable">foo</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), proxyInterfaces, </span><br><span class="line">                                       <span class="keyword">new</span> <span class="title class_">Delegator</span>(proxyInterfaces, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="keyword">new</span> <span class="title class_">FooImpl</span>() &#125;));</span><br></pre></td></tr></table></figure>
<p>请注意，上面给出的 <code>Delegator</code> 类的实现旨在说明用途而不是优化。</p>
<blockquote>
<p>由于 <code>InvocationHandler</code> 是一个函数接口，因此可以使用 <code>lambda</code> 表达式内联定义处理程序。</p>
</blockquote>
<h4 id="Example-3">Example 3</h4>
<p>将代理模式和工厂模式结合起来，可以无感的创建基于代理的实例。很多框架都是这样提供的实例，比如 Spring 的 Bean、MyBatis 的 Mapper、Hibernate 的关联集合、Spring Data JPA 的 Repository 等。</p>
<ul>
<li>工厂方法用于抽象或隐藏对象创建的逻辑。</li>
<li>代理类用于正确代理并委托所有方法给实现，为需要代理的类提供统一抽象处理，或者为代理类不同生命周期阶段提供钩子（Hook）。</li>
</ul>
<p>比如 MyBatis 的 Mapper 的实例化，通过 Mapper 接口类来实例化 Mapper。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CGLIB-代理">CGLIB 代理</h2>
<p><code>JDK 动态代理</code>通常用于动态创建代理。JDK 动态代理很容易使用，但 JDK 动态代理方法要求目标对象实现一个或多个接口。对象不一定实现接口，对象集合不一定共享相同的接口。面对这样的需求，JDK 动态代理无法提供答案。</p>
<p><code>CGLIB</code> 是一个功能强大的高性能代码生成库。它在基于代理的面向方面编程（<code>AOP</code>）框架（如 <code>Spring AOP</code> 和 <code>dynaop</code>）中广泛使用，以提供方法拦截。<code>Hibernate</code> 使用 <code>CGLIB</code> 为持久化类生成代理。<code>EasyMock</code> 和 <code>jMock</code> 是使用模拟对象测试 <code>Java</code> 代码的库。它们都使用 <code>CGLIB</code> 库为没有接口的类创建模拟对象。</p>
<p>在幕后，CGLIB 库使用 <code>ASM</code>，一个小但快速的字节码操作框架，来转换现有的字节码并生成新的类。除了 <code>CGLIB</code> 库之外，脚本语言（如 <code>Groovy</code> 和 <code>BeanShell</code>）也使用 <code>ASM</code> 生成 <code>Java</code> 字节码。 <code>ASM</code> 使用类似 <code>SAX</code> 解析器的机制来实现高性能。不鼓励直接使用 <code>ASM</code>，因为它需要熟悉 <code>JVM</code>，包括类文件格式和指令集。</p>
<p><img data-src="../../images/java/cglib.PNG" alt="CGLIB and ASM"></p>
<blockquote>
<p>请注意，某些框架（如 <code>Spring AOP</code> 和 <code>Hibernate</code>）通常同时使用 <code>CGLIB</code> 库和 <code>JDK 动态代理</code>来满足其需求。<code>Hibernate</code> 使用 JDK 动态代理为 <code>WebShere</code> 应用程序服务器实现事务管理器适配器；默认情况下，<code>Spring AOP</code> 使用 <strong>JDK 动态代理</strong>来代理接口，除非您强制使用 CGLIB 代理。</p>
</blockquote>
<h3 id="CGLIB-代理-API">CGLIB 代理 API</h3>
<p><code>CGLIB</code> 库代码库很小，但由于缺少文档，很难学习。<code>CGLIB</code> 库的版本组织如下：</p>
<ul>
<li>
<p><code>net.sf.cglib.core</code></p>
<p>低级字节码操作类；他们中的大多数都与 <code>ASM</code> 有关。</p>
</li>
<li>
<p><code>net.sf.cglib.transform</code></p>
<p>运行时或构建时的类文件转换的类</p>
</li>
<li>
<p><code>net.sf.cglib.proxy</code></p>
<p>代理创建和方法拦截的类</p>
</li>
<li>
<p><code>net.sf.cglib.reflect</code></p>
<p>用于更快反射的类和 <code>C#</code> 样式的委托</p>
</li>
<li>
<p><code>net.sf.cglib.util</code></p>
<p>集合排序工具类</p>
</li>
<li>
<p><code>net.sf.cglib.beans</code></p>
<p><code>JavaBean</code> 相关工具类</p>
</li>
</ul>
<p>要动态创建代理，大多数情况下，您只需要使用代理包中的一些 API。</p>
<p>如前一节所述，<code>CGLIB</code> 库是 <code>ASM</code> 之上的高级层。它对代理不实现接口的类非常有用。本质上，它动态生成一个子类来覆盖代理类的非 final 方法，并连接回调用户定义的拦截器的钩子。它比 JDK 动态代理方法更快。</p>
<p><img data-src="../../images/java/cblig-2.PNG" alt="CGLIB APIs commonly used for proxying classes"></p>
<p>通常用于代理具体类的 CGLIB 库 API 如上图所示。<code>net.sf.cglib.proxy.Callback</code> 接口是一个标记接口。 <code>net.sf.cglib.proxy.Enhancer</code> 类使用的所有回调接口都扩展了此接口。</p>
<p><code>net.sf.cglib.proxy.MethodInterceptor</code> 是最常用的回调类型。它在 AOP 术语中启用 ”around advice“（围绕建议） - 也就是说，您可以在调用 “super” 方法之前和之后调用自定义代码。此外，您可以在调用 super 方法之前修改参数，或者根本不调用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, java.lang.reflect.Method method,</span></span><br><span class="line"><span class="params">        Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure>
<p>当 <code>net.sf.cglib.proxy.MethodInterceptor</code> 是代理的所有方法的回调时，代理上的方法调用将在调用原始对象上的方法之前路由到此方法。如下图所示。第一个参数是代理对象。第二个和第三个参数分别是截获的方法和方法参数。可以使用 <code>java.lang.reflect.Method</code> 对象或使用 <code>net.sf.cglib.proxy.MethodProxy</code> 对象通过常规反射调用原始方法。<code>net.sf.cglib.proxy.MethodProxy</code> 通常是首选，因为它更快。在此方法中，可以在调用原始方法之前或之后注入自定义代码。</p>
<p><img data-src="../../images/java/cglib-3.PNG" alt="CGLIB MethodInterceptor"></p>
<p><code>net.sf.cglib.proxy.MethodInterceptor</code> 满足任何拦截需求，但在某些情况下可能有点过分。为了简化和性能，提供了开箱即用的其他专用回调类型。举些例子，</p>
<ul>
<li>
<p><code>net.sf.cglib.proxy.FixedValue</code></p>
<p>出于性能原因，强制特定方法返回固定值很有用。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.NoOp</code></p>
<p>它将方法调用直接委托给超类中的默认实现。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.LazyLoader</code></p>
<p>当真实对象需要延迟加载时，它很有用。加载实际对象后，它将用于代理实例的每个未来方法调用。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.Dispatcher</code></p>
<p>它与 <code>net.sf.cglib.proxy.LazyLoader</code> 具有相同的签名，但在调用代理方法时始终会调用 <code>loadObject</code> 方法。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.ProxyRefDispatcher</code></p>
<p>它与 <code>Dispatcher</code> 相同，但它允许将代理对象作为 <code>loadObject</code> 方法的参数传入。</p>
</li>
</ul>
<p>回调通常用于代理类中的所有方法，如上图所示，但您可以使用 <code>net.sf.cglib.proxy.CallbackFilter</code> 有选择地对方法应用回调。JDK 动态代理中没有这种细粒度控制功能，其中 <code>java.lang.reflect.InvocationHandler</code> 的 <code>invoke</code> 方法适用于代理对象的所有方法。</p>
<p>除了代理类之外，CGLIB 还可以通过提供 <code>java.lang.reflect.Proxy</code> 的替代代码 <code>net.sf.cglib.proxy.Proxy</code> 来代理接口，以支持 JDK 1.3 之前的 Java 代理。由于很少使用此替换代理功能，因此此处不涉及相关代理 API。</p>
<p>代理包还提供对 <code>net.sf.cglib.proxy.Mixin</code> 的支持。基本上，它允许将多个对象组合成一个更大的对象。代理上的方法调用委托给底层对象。</p>
<p>让我们看看如何使用 CGLIB 代理 API 创建代理。</p>
<h4 id="创建代理类-2">创建代理类</h4>
<p>CGLIB 代理的核心是 <code>net.sf.cglib.proxy.Enhancer</code> 类。要创建 CGLIB 代理，至少需要一个类。让我们先使用内置的 NoOp 回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用NoOp回调创建代理。目标类必须有一个默认的零参数构造函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass 代理的超类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标类实例的新代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Class targetClass)</span> &#123;</span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    enhancer.setSuperclass(targetClass);</span><br><span class="line">    enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值是目标类实例的代理。在此示例中，为 <code>net.sf.cglib.proxy.Enhancer</code> 类配置了单个 <code>net.sf.cglib.proxy.Callback</code>。可以看出，创建一个简单的代理是相当简单的。而不是创建 <code>net.sf.cglib.proxy.Enhancer</code> 的新实例，您可以简单地使用 <code>net.sf.cglib.proxy.Enhancer</code> 类中的静态帮助器方法来创建代理。但是最好使用上例中显示的方法，因为它允许您配置 <code>net.sf.cglib.proxy.Enhancer</code> 实例以精确控制生成的代理。</p>
<p>请注意，目标类作为生成的代理的超类传入。与 JDK 动态代理不同，您无法在代理创建期间传递目标对象。目标对象必须由 CGLIB 库创建。在此示例中，默认的零参数构造函数用于创建目标实例。如果您希望 CGLIB 使用一些参数创建实例，<code>net.sf.cglib.proxy.Enhancer.create(Class[]，Object[])</code> 应当使用该方法替代 <code>net.sf.cglib.proxy.Enhancer.create()</code>。第一个参数指定参数类型和第二个指定参数值。原始类型在参数中应该使用包装类型。</p>
<h4 id="使用-MethodInterceptor">使用 MethodInterceptor</h4>
<p>要使代理更有用，可以使用自定义 <code>net.sf.cglib.proxy.MethodInterceptor</code> 替换 net.sf.cglib.proxy.NoOp 回调。代理上的所有方法调用都被调度到 <code>net.sf.cglib.proxy.MethodInterceptor</code> 的单个 <code>intercept</code> 方法。然后，<code>intercept</code> 方法将调用委托给底层对象。</p>
<p>假设您要对目标对象的所有方法调用应用授权检查。如果授权失败，将抛出运行时异常 <code>AuthorizationException</code>。 <code>Authorization.java</code> 接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用于说明目的的简单授权服务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthorizationService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法调用的授权检查。如果检查失败将抛出 AuthorizationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">authorize</span><span class="params">(Method method)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>net.sf.cglib.proxy.MethodInterceptor</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> com.lizjason.cglibproxy.AuthorizationService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的 MethodInterceptor 实现，对代理方法调用应用授权检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AuthorizationService authorizationService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的 AuthorizationServic 创建 AuthorizationInterceptor </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorizationInterceptor</span> <span class="params">(AuthorizationService authorizationService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authorizationService = authorizationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截代理方法调用以注入授权检查。通过 MethodProxy 调用原始方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 拦截方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法传参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 用于调用原始方法的代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 可抛出任何异常；如果抛出异常，将不会调用 super 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与代理方法的签名兼容的任何值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy methodProxy )</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (authorizationService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//may throw an AuthorizationException if authorization failed</span></span><br><span class="line">            authorizationService.authorize(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(object, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>intercept</code> 方法中，首先检查授权。如果授权通过，则 <code>intercept</code> 方法将调用目标对象上的原始方法。出于性能原因，使用 <code>CGLIB</code> <code>net.sf.cglib.proxy.MethodProxy</code> 对象而不是使用 <code>java.lang.reflect.Method</code> 对象进行常规反射来调用原始方法。</p>
<h4 id="使用-CallbackFilter">使用 CallbackFilter</h4>
<p><code>net.sf.cglib.proxy.CallbackFilter</code> 允许您在方法级别设置回调。假设您有一个 <code>PersistenceServiceImpl</code> 类，它有两个方法：<code>save</code> 和 <code>load</code>。 <code>save</code> 方法需要授权检查，但 <code>load</code> 方法不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lizjason.cglibproxy.PersistenceService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersistenceService 接口的简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PersistenceService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> id, String data)</span> &#123;</span><br><span class="line">        System.out.println(data + <span class="string">&quot; has been saved successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(<span class="type">long</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Jason Zhicheng Li&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>PersistenceServiceImpl</code> 类实现了 <code>PersistenceService</code> 接口，但这不是使用 <code>CGLIB</code> 生成代理所必需的。 <code>PersistenceServiceImpl</code> 的 <code>net.sf.cglib.proxy.CallbackFilter</code> 实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersistenceServiceImpl 的 CallbackFilter 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistenceServiceCallbackFilter</span> <span class="keyword">implements</span> <span class="title class_">CallbackFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save 方法的回调索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SAVE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load 方法的回调索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOAD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定要用于所调用方法的回调。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@method</span> 被调用的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此方法的回调数组中的回调索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;save&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SAVE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于其他方法，包括 load方法，使用第二个回调</span></span><br><span class="line">        <span class="keyword">return</span> LOAD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>accept</code> 方法将代理方法映射到回调。返回值是特定方法的回调数组中的索引。以下是 <code>PersistenceServiceImpl</code> 类的代理创建实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line"></span><br><span class="line"><span class="type">CallbackFilter</span> <span class="variable">callbackFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersistenceServiceCallbackFilter</span>();</span><br><span class="line">enhancer.setCallbackFilter(callbackFilter);</span><br><span class="line"></span><br><span class="line"><span class="type">AuthorizationService</span> <span class="variable">authorizationService</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Callback</span> <span class="variable">saveCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationInterceptor</span>(authorizationService);</span><br><span class="line"><span class="type">Callback</span> <span class="variable">loadCallback</span> <span class="operator">=</span> NoOp.INSTANCE;</span><br><span class="line">Callback[] callbacks = <span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;saveCallback, loadCallback &#125;;</span><br><span class="line">enhancer.setCallbacks(callbacks);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> (PersistenceServiceImpl)enhancer.create();</span><br></pre></td></tr></table></figure>
<p>在此示例中，<code>AuthorizationInterceptor</code> 实例应用于 <code>save</code> 方法，<code>NoOp.INSTANCE</code> 应用于 <code>load</code> 方法。可选的，您可以通过 <code>net.sf.cglib.proxy.Enhancer.setInterfaces(Class [])</code> 方法指定代理对象要实现的接口。</p>
<p>除了设置 <code>net.sf.cglib.proxy.Enhancer</code> 的回调数组外，还可以通过 <code>net.sf.cglib.proxy.Enhancer.setCallbackTypes(Class [])</code> 方法指定回调类型数组。如果在代理创建期间没有实际回调实例数组，则回调类型很有用。与回调类似，您需要使用 <code>net.sf.cglib.proxy.CallbackFilter</code> 为每个方法指定回调类型索引。</p>
<h2 id="总结-3">总结</h2>
<p>**<code>JDK 动态代理</code>**允许我们在运行时动态的创建代理类。但必须要求代理对象实现一个或多个接口。它大量使用反射进行操作，使用原生 Java 代码。</p>
<p><strong><code>CGLIB</code></strong> 是一个功能强大的高性能代码生成库。它是 JDK 动态代理的补充，除了实现接口之外，还允许代理扩展具体的基类。底层，它使用 ASM 字节码操作框架。实质上，CGLIB 动态生成一个子类来覆盖代理类的非 final 方法。它比使用 Java 反射的 JDK 动态代理方法更快。</p>
<p><strong>CGLIB 不能代理 final 类或任何 final 方法。</strong></p>
<p>对于一般情况，您使用 JDK 动态代理方法来创建代理。 当接口不可用或性能问题时，CGLIB 是一个很好的选择。</p>
<blockquote>
<p><em>原文链接：<a target="_blank" rel="noopener" href="http://jnb.ociweb.com/jnb/jnbNov2005.html">使用 CGLIB 库动态创建代理</a></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>CGLIB</tag>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream 使用</title>
    <url>/java/Java8-Stream%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="流的创建">流的创建</h2>
<h3 id="空流">空流</h3>
<p>如果创建空流，则应使用 <code>Stream.empty()</code> 方法。</p>
<p>通常情况下创建空流的目的是避免返回 null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Stream&lt;String&gt; <span class="title function_">streamOf</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">list</span> <span class="operator">=</span>= <span class="literal">null</span> || list.isEmpty() ? Stream.empty() : list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从数组或集合创建流">从数组或集合创建流</h3>
<p>我们可以从数组使用 <code>stream()</code> 或者 <code>of()</code> 方法来创建流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">stream</span><span class="params">(T[] array)</span></span><br></pre></td></tr></table></figure>
<p>返回以指定数组作为源的顺序Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>返回其元素为指定值的顺序有序流。</p>
<blockquote>
<p>Stream 的 <code>of</code> 方法内部还是使用 Arrays <code>stream</code> 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">stream = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在集合的接口上 java8 添加了默认的 <code>stream()</code> 方法允许使用任何集合作为元素源创建 Stream <T>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br></pre></td></tr></table></figure>
<p>如果想要多个流合并成单个流，可以使用流的 <code>concat</code> 方法：</p>
<blockquote>
<p>可以在里面嵌套使用方法，但是注意 java8 的流不能复用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Object&gt; concatStream = Stream.concat(Stream.concat(collection1.stream(), collection2.stream()), collection3.stram());</span><br></pre></td></tr></table></figure>
<h3 id="静态工厂方法创建流">静态工厂方法创建流</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> IntStream <span class="title function_">range</span><span class="params">(<span class="type">int</span> startInclusive, <span class="type">int</span> endExclusive)</span>;</span><br></pre></td></tr></table></figure>
<p>从 startInclusive（包括）到 endExclusive（不包括）的递增步长返回顺序排序的 IntStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(T seed, UnaryOperator&lt;T&gt; f)</span>;</span><br></pre></td></tr></table></figure>
<p>返回通过将函数 f 迭代应用于初始元素种子而生成的无限顺序有序流，生成由种子，f(seed)，f(f(seed)) 等组成的流。</p>
<h3 id="构建器、生成器、迭代器生成流">构建器、生成器、迭代器生成流</h3>
<ul>
<li>
<p>构建器</p>
<p>使用构建器时，应在语句的右侧部分另外指定所需类型，否则 build() 方法将创建 Stream <Object> 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamBuilder =</span><br><span class="line">  Stream.&lt;String&gt;builder().add(<span class="string">&quot;a&quot;</span>).add(<span class="string">&quot;b&quot;</span>).add(<span class="string">&quot;c&quot;</span>).build();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成器 - 可用于生成无限流</p>
<p>generate() 方法接受 Supplier <T> 以生成元素。由于结果流是无限的，开发人员应指定所需的大小，否则 generate() 方法将一直有效，直到达到内存限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamGenerated =</span><br><span class="line">  Stream.generate(() -&gt; <span class="string">&quot;element&quot;</span>).limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器 - 可用于生成无限流</p>
<p>iterate() 方法有两个参数：种子和函数。 种子是流的第一个元素。通过将函数应用于第一元素来生成第二元素。通过在第二个元素上应用函数来生成第三个元素。</p>
<p>因此，元素是：<code>seed, f(seed), f(f(seed)), f(f(f(seed)))....</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">2L</span>, n  -&gt;  n  + <span class="number">1</span>)</span><br><span class="line">    .filter(Main::isOdd)</span><br><span class="line">    .limit(<span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::printf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOdd</span><span class="params">(<span class="type">long</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码返回以下执行结果：</p>
<p>3 5 7 9 11</p>
</li>
</ul>
<h3 id="创建无尽流">创建无尽流</h3>
<p>我们已经知道了流可以分为中间和终止操作。我们也可以利用流的惰性话来创建一个无尽流。<br>
我们创建一个从 0 开始每次加 2 的无限流，在调用终止操作前限制它的长度。<br>
**在调用终止操作前执行 limit 操作是至关重要的。**不然程序将无限制的运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// given</span></span><br><span class="line">Stream&lt;Integer&gt; infiniteStream = Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// when</span></span><br><span class="line">List&lt;Integer&gt; collect = infiniteStream</span><br><span class="line">  .limit(<span class="number">10</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">assertEquals(collect, Arrays.asList(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>));</span><br></pre></td></tr></table></figure>
<p>我们使用 iterate() 方法创建一个无限流。然后调用 limit() 转换和 collect() 终止操作。由于 Stream 的惰性，我们将拥有无限序列的前 10 个元素组成的集合。</p>
<h4 id="创建自定义元素的无限流">创建自定义元素的无限流</h4>
<p>假设我们想创建一个无限的随机 UUID 流。<br>
使用 Stream API 实现此目的的第一步是创建这些随机值的供应商（Supplier）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;UUID&gt; randomUUIDSupplier = UUID::randomUUID;</span><br></pre></td></tr></table></figure>
<p>当我们定义好供应商时，我们可以使用 generate() 方法创建无限流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;UUID&gt; infiniteStreamOfRandomUUID = Stream.generate(randomUUIDSupplier);</span><br></pre></td></tr></table></figure>
<p>然后我们可以从流中获取一些元素。如果你希望程序在有限时间内完成，请记得使用 limit() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;UUID&gt; randomInts = infiniteStreamOfRandomUUID</span><br><span class="line">.skip(<span class="number">10</span>)</span><br><span class="line">.limit(<span class="number">10</span>)</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>我们使用 skip() 转换来丢弃前 10 个结果并采用接下来的 10 个元素。我们可以通过将 Supplier 接口的函数传递给 Stream 上的 generate() 方法来创建任何自定义类型元素的无限流。</p>
<h3 id="字符串流">字符串流</h3>
<p>String 也可以用作创建流的源。</p>
<p>借助 String 类的 chars() 方法。由于 JDK 中没有接口 CharStream，因此 IntStream 用于表示字符流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">streamOfChars</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>.chars();</span><br></pre></td></tr></table></figure>
<p>以下示例根据指定的 RegEx 将 String 拆分为子字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamOfString =</span><br><span class="line">  Pattern.compile(<span class="string">&quot;, &quot;</span>).splitAsStream(<span class="string">&quot;a, b, c&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="文件流">文件流</h3>
<p>Java NIO 类 Files 允许通过 lines() 方法生成文本文件的 Stream <String>。文本的每一行都成为流的一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:\\file.txt&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; streamOfStrings = Files.lines(path);</span><br><span class="line">Stream&lt;String&gt; streamWithCharset = </span><br><span class="line">  Files.lines(path, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>可以将 Charset 指定为 lines() 方法的参数。</p>
<blockquote>
<p>Java 8 流不能重用。</p>
<p>流管道，是源流，中间操作和终止操作组成的链。</p>
<p>每个流只能使用一个终止操作。</p>
<p>中间操作是惰性的。这意味着只有在执行终止操作时才会调用它们。</p>
<p>减少流大小的中间操作应放在应用于每个元素的操作之前。因此，在流管道的顶部保留skip()，filter()，distinct() 等方法。</p>
</blockquote>
<h2 id="流的归约">流的归约</h2>
<p>API 有许多终止操作，它们将流聚合到类型或原始类型，例如 <code>count()</code>，<code>max()</code>，<code>min()</code>，<code>sum()</code>，但这些操作根据预定义的实现工作。如果开发人员需要定制 Stream 的归约机制呢？有两种方法可以实现这一点 - <code>reduce()</code> 和 <code>collect() </code>方法。</p>
<h3 id="reduce-方法">reduce 方法</h3>
<p>这种方法有三种变体，它们的传参和返回类型不同。它们可以具有以下参数：</p>
<p><strong>identity(标识)</strong> - 累加器的初始值或者如果流为空且没有任何可累积的默认值;</p>
<p><strong>accumulator(累加器)</strong> - 一个指定元素聚合逻辑的函数。累加器为每个减少步骤创建一个新值。</p>
<p><strong>combiner(结合器)</strong> - 聚合累加器结果的函数。仅在并行模式下从不同线程归约累加器结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">reducedParams</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .reduce(<span class="number">10</span>, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;combiner was called&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">U</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="built_in">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>结果与未使用结合器中的结果相同，都为 16 (10 + 1 + 2 +3)，并且没有日志，这意味着没有调用该组合器。要使组合器工作，流应该是并行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">reducedParallel</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).parallelStream()</span><br><span class="line">    .reduce(<span class="number">10</span>, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">       log.info(<span class="string">&quot;combiner was called&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这里的结果是不同的（36），并且组合器被调用两次。操作并行进行。首先（10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13;）。现在组合器可以合并这三个结果。它需要两次迭代（12 + 13 = 25; 25 + 11 = 36）。</p>
<h3 id="collect-方法">collect 方法</h3>
<blockquote>
<p>参考 java8-stream 学习</p>
</blockquote>
<p>Collector <code>toMap</code> 方法，可以允许将流转换为 Map 类型，并提供了 key 相同时的合并方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toMap(keyMapper, valueMapper, mergeFunction)</span><br></pre></td></tr></table></figure>
<h2 id="并行流">并行流</h2>
<p>在 Java 8 之前，并行化很复杂。 <code>ExecutorService</code> 和 <code>ForkJoin</code> 的出现简化了开发人员的生活，但是他们仍然应该记住如何创建一个特定的执行器，如何运行它，使用 <code>fork/join</code> 框架，您必须指定问题的细分方式（分区）等等。Java 8 引入了一种函数风格的新方式来实现并行机制。</p>
<p>在使用集合的应用程序中实现并行性的一个难点是集合不是线程安全的，这意味着多线程无法在不<strong>引入线程干扰</strong>或<strong>内存一致性错误</strong>的情况下操作集合。 <code>Collections</code> 框架提供了同步包装器，它将自动同步添加到任意集合，使其成为线程安全的。 但是，同步会引入线程争用。 您希望避免线程争用，因为它会阻止线程并行运行。 聚合操作和并行流使您可以实现与非线程安全集合的并行性，前提是您在操作集合时不要修改集合。</p>
<p>API 允许创建并行流，以并行模式执行操作。当流的源是 <code>Collection</code> 或数组时，可以在<code>parallelStream()</code> 方法的帮助下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Product&gt; streamOfCollection = productList.parallelStream();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isParallel</span> <span class="operator">=</span> streamOfCollection.isParallel();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">bigPrice</span> <span class="operator">=</span> streamOfCollection</span><br><span class="line">  .map(product -&gt; product.getPrice() * <span class="number">12</span>)</span><br><span class="line">  .anyMatch(price -&gt; price &gt; <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>如果流的源不同于 <code>Collection</code> 或数组，则应使用 <code>parallel()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">intStreamParallel</span> <span class="operator">=</span> IntStream.range(<span class="number">1</span>, <span class="number">150</span>).parallel();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isParallel</span> <span class="operator">=</span> intStreamParallel.isParallel();</span><br></pre></td></tr></table></figure>
<p>内部，<code>Stream API</code> 自动使用 <code>ForkJoin</code> 框架并行执行操作。默认情况下，将使用公共线程池，并且没有办法（至少现在）为它分配一些自定义线程池。</p>
<blockquote>
<p>并行流内部使用了默认的 <code>ForkJoinPool</code>，它默认的线程数量就是你的处理器数量，这个值是由 <code>Runtime.getRuntime().availableProcessors()</code> 得到的。<br>
但是你可以通过系统属性 <code>java.util.concurrent.ForkJoinPool.common.parallelism</code> 来改变线程池大小，如下所示: <code>System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;12&quot;);</code> 这是一个全局设置，因此它将印象代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让 <code>ForkJoinPool</code> 的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议不要修改它。</p>
</blockquote>
<p>在并行模式下使用流时，避免阻塞操作并在任务需要相同的执行时间时使用并行模式（如果一个任务比另一个任务持续时间长，则可能会减慢整个应用程序的工作流程）。</p>
<p>可以使用 <code>sequential()</code> 方法将并行模式的流转换回顺序模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">intStreamSequential</span> <span class="operator">=</span> intStreamParallel.sequential();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isParallel</span> <span class="operator">=</span> intStreamSequential.isParallel();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 并行流的顺序是由流来源的 <code>Spliterator</code> 的属性决定的，比如 <code>List</code>、<code>LinkedHashSet</code> 实现的 <code>Spliterator</code> 就包含 <code>Spliterator.ORDERED</code> 属性，我们可以通过调用 <code>Stream.unordered()</code> 无序处理以加快并行速度。</p>
<p><code>Stream forEach</code> 在并行流下不保证顺序，但是我们可以使用 <code>forEachOrdered</code>  使具有顺序的流顺序输出。</p>
</blockquote>
<h2 id="新的流式写法">新的流式写法</h2>
<h3 id="Do-While">Do-While</h3>
<p>假设在我们的代码里有这样一个简单的 do…while 循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们想要实现类似于标准 do-while 循环的功能时，我们需要使用 <code>limit()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = Stream</span><br><span class="line">  .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>);</span><br><span class="line">integers</span><br><span class="line">  .limit(<span class="number">10</span>)</span><br><span class="line">  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>我们用较少的代码实现了相同功能，但是使用 limit() 函数并没有 doWhile 那样容易阅读。</p>
<h3 id="if-else">if/else</h3>
<h4 id="在-forEach-中使用-if-else">在 forEach() 中使用 if/else</h4>
<p>首先，让我们创建一个 Integer 数组，然后在 Integer 流的 forEach() 方法中使用传统的 if / else 逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ints = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">ints.stream()</span><br><span class="line">   .forEach(i -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span> (i.intValue() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           Assert.assertTrue(i.intValue() % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Assert.assertTrue(i.intValue() % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>我们的 forEach 方法包含 if-else 逻辑，它使用 Java 模运算符验证 Integer 是奇数还是偶数。</p>
<h4 id="使用-filter-作为-if-else">使用 filter 作为 if/else</h4>
<p>其次，让我们看一下使用 Stream filter() 方法的更优雅的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; evenIntegers = ints.stream()</span><br><span class="line">    .filter(i -&gt; i.intValue() % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">Stream&lt;Integer&gt; oddIntegers = ints.stream()</span><br><span class="line">    .filter(i -&gt; i.intValue() % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">evenIntegers.forEach(i -&gt; Assert.assertTrue(i.intValue() % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">oddIntegers.forEach(i -&gt; Assert.assertTrue(i.intValue() % <span class="number">2</span> != <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>上面我们使用 Stream filter() 方法实现了 if / else 逻辑，将整数列表分成两个 Streams，一个用于偶数整数，另一个用于奇数整数。</p>
<h4 id="使用-partitioningBy-分割为两部分">使用 partitioningBy 分割为两部分</h4>
<p>我们也可以使用约减操作的 <code>partitioningBy</code> 分割将结果分割成两部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; integerMap = </span><br><span class="line">  ints.stream().collect(Collectors.partitioningBy(i -&gt; i.intValue() % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样我们会得到 true 的 偶数数组和 false 的奇数数组。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 日期类</title>
    <url>/java/Java-%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    <content><![CDATA[<p>Java 的 API 提供了很多有用的组件，能帮我们构建复杂的应用。比如日期处理，Java 从 1.0，就提供了 <code>java.util.Date</code> 类用于支持日期和时间的处理，不过由于该 API 设计的缺陷，产生了糟糕的易用性。随着 1.0 退出舞台，Date 类中的很多方法都被废弃了，Java 1.1 使用 <code>java.util.Calendar</code> 类取而代之，很不幸，Calendar 类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</p>
<p>所有这些缺陷和不一致导致用户们转投第三方的日期和时间库，比如 <code>Joda-Time</code>。为了解决这些问题，Oracle 决定在原生的 Java API 中提供高质量的日期和时间支持。你会看到 Java 8 在 <code>java.time</code> 包中整合了很多 Joda-Time 的特性。</p>
<p>在开始介绍日期类之前，我们先陈述几个经常出现的名次：</p>
<p><em><strong>UTC</strong></em></p>
<p><strong>协调世界时</strong>，是最主要的<strong>世界时间标准</strong>，基于原子钟。</p>
<span id="more"></span>
<blockquote>
<p>在 UTC 中，大约每一年或两年会多出一秒，称为“闰秒”，添加到一天的最后一秒，并且总是在 12 月 31 日或 6 月 30 日。</p>
</blockquote>
<p><em><strong>GMT</strong></em></p>
<p><strong>格林尼治标准时间，代表时区</strong>，标准时间为 UTC+0，是之前的民间标准，根据地球的自转和公转来计算时间，在欧洲国家和非洲国家用做当地标准时间。</p>
<blockquote>
<p>GMT 因为是根据地球的转动来计算时间的，而地球的自转目前正在缓速变慢，所以 UTC 比 GMT 更加精准。但是一些计算机的标准是根据格林尼治标准时间（GMT）定义的，所以大多数计算机时钟不够精确。</p>
<p>在民用领域可以认为两者相同。</p>
</blockquote>
<p><em><strong>CST</strong></em></p>
<p><strong>北美中部时区，代表时区</strong>，标准时间为 UTC-6。</p>
<blockquote>
<p>这种缩写的时区代表一片区域，但是由于没有明确的标准，CST 概念来说在中国也代表中国标准时间。具体缩写的定义可以查看 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html#SHORT_IDS">ZoneId.SHORT_IDS</a> 定义。</p>
<p>所以 java 提供了明确的时区表示方法，具体可用的时区字符串 Id 可以通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html#getAvailableZoneIds--">ZoneId.getAvailableZoneIds()</a> 方法查看。</p>
</blockquote>
<p><em><strong>ISO 8601</strong></em></p>
<p>代表国际标准的日期和时间表示方法。</p>
<p>日期格式一般为：<strong>yyyy-MM-dd</strong>；</p>
<p>带时区的日期一般格式为：<strong>yyyy-MM-dd’T’HH:mm:ss.SSSZ</strong>。</p>
<blockquote>
<p>在 Java 中定义了一些参见的格式化表示方法，在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">DateTimeFormatter</a> 有具体的静态格式化类表示。</p>
</blockquote>
<p><em><strong>UNIX 纪元（Epoch）</strong></em></p>
<p>代表 1970 年 1 月 1 日 0 时 0 分 0 秒 GMT 午夜</p>
<h2 id="Date">Date</h2>
<p><strong>Date 类表示特定的时刻，精度为毫秒，该类反映的是协调世界时（UTC），不反映时区。</strong></p>
<p>该类在使用时有几点需要注意：</p>
<ul>
<li>该时刻表示的当前时间与纪元的差（以毫秒为单位）；</li>
<li>年代表与 <strong>1900</strong> 的差</li>
<li>一个月由 0 到 11 之间的整数表示；0 是一月，1 是二月，以此类推；</li>
<li>日期（一个月中的一天）由 1 到 31 之间的整数表示；</li>
<li>小时用 0 到 23 之间的的整数表示；</li>
<li>分钟用 0 到 59 之间的整数表示；</li>
<li>秒用 0 到 61 之间的整数表示；值 60 和 61 仅在闰秒出现；</li>
<li><strong>使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a> 格式化显示，该类非线程安全。</strong></li>
<li><strong>该类是可变类，线程不安全。</strong></li>
</ul>
<h3 id="使用-2">使用</h3>
<h4 id="创建">创建</h4>
<p>创建当前时刻：<code>new Date()</code>，相当于：<code>new Date(System.currentTimeMillis())</code>，使用纪元时间与当前时间毫秒差创建日期。</p>
<p>使用 Java8 Instant 转换：<code>Date.from(Instant instant)</code>，内部还是使用纪元时间差，其它日期对象转换思想相同。</p>
<h4 id="日期">日期</h4>
<p>Date 实现了 <code>Comparable</code> 接口，可以使用 <code>compareTo</code> 直接比较两个对象；</p>
<p>使用 <code>after</code> 和 <code>before</code> 实例方法；</p>
<h4 id="文本间转换">文本间转换</h4>
<p>使用 <code>DateFormat</code> 抽象类静态方法转换简单的 ISO 格式：</p>
<blockquote>
<p>该抽象类非线程安全，由于使用了成员变量 calendar 维护内部时间状态，导致 format 等方法依赖状态。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dateInstance</span> <span class="operator">=</span> DateFormat.getDateInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dateInstance.format(date);</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> dateInstance.parse(format);</span><br><span class="line">System.out.println(parse + <span class="string">&quot; DateInstance format：&quot;</span> + format);</span><br><span class="line"><span class="comment">// Sun May 31 00:00:00 CST 2020 DateInstance format：2020-5-31</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">dateTimeInstance</span> <span class="operator">=</span> DateFormat.getDateTimeInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">format1</span> <span class="operator">=</span> dateTimeInstance.format(date);</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse1</span> <span class="operator">=</span> dateInstance.parse(format1);</span><br><span class="line">System.out.println(parse1 + <span class="string">&quot; DateTimeInstance format：&quot;</span> + format1);</span><br><span class="line"><span class="comment">// Sun May 31 00:00:00 CST 2020 DateTimeInstance format：2020-5-31 21:04:03</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">instance</span> <span class="operator">=</span> DateFormat.getInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">format2</span> <span class="operator">=</span> instance.format(date);</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse2</span> <span class="operator">=</span> instance.parse(format2);</span><br><span class="line">System.out.println(parse2 + <span class="string">&quot; Instance format：&quot;</span> + format2);</span><br><span class="line"><span class="comment">// Sun May 31 21:04:00 CST 2020 Instance format：20-5-31 下午9:04</span></span><br><span class="line"></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">timeInstance</span> <span class="operator">=</span> DateFormat.getTimeInstance();</span><br><span class="line"><span class="type">String</span> <span class="variable">format3</span> <span class="operator">=</span> timeInstance.format(date);</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse3</span> <span class="operator">=</span> timeInstance.parse(format3);</span><br><span class="line">System.out.println(parse3 + <span class="string">&quot; TimeInstance format：&quot;</span> + format3);</span><br><span class="line"><span class="comment">// Thu Jan 01 21:04:03 CST 1970 TimeInstance format：21:04:03</span></span><br></pre></td></tr></table></figure>
<p>或使用 <code>DateFormat</code> 实现类 <code>SimpleDateFormat</code> 基于 Pattern 形式转换：</p>
<blockquote>
<p>该类非线程安全，原因和 DateFormat 相同。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>日期或时间元素</th>
<th>Presentation</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>Era 年代</td>
<td>Text</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>年</td>
<td>Year</td>
<td>1996; 96</td>
</tr>
<tr>
<td>Y</td>
<td>Week year</td>
<td>Year</td>
<td>2009; 09</td>
</tr>
<tr>
<td>M</td>
<td>一年中的月份 (上下文敏感)</td>
<td>Month</td>
<td>July; Jul; 07</td>
</tr>
<tr>
<td>L</td>
<td>一年中的月份 (独立格式)</td>
<td>Month</td>
<td>July; Jul; 07</td>
</tr>
<tr>
<td>w</td>
<td>一年中的周</td>
<td>Number</td>
<td>27</td>
</tr>
<tr>
<td>W</td>
<td>一月中的周</td>
<td>Number</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>一年中的天</td>
<td>Number</td>
<td>189</td>
</tr>
<tr>
<td>d</td>
<td>一月中的天</td>
<td>Number</td>
<td>10</td>
</tr>
<tr>
<td>F</td>
<td>每月的星期几</td>
<td>Number</td>
<td>2</td>
</tr>
<tr>
<td>E</td>
<td>Day name in week</td>
<td>Text</td>
<td>Tuesday; Tue</td>
</tr>
<tr>
<td>u</td>
<td>星期几 (1 = 星期一, …, 7 = 星期天)</td>
<td>Number</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>Am/pm 标记</td>
<td>Text</td>
<td>PM</td>
</tr>
<tr>
<td>H</td>
<td>小时 (0-23)</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>k</td>
<td>小时 (1-24)</td>
<td>Number</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>基于上午/下午表示的时间 am/pm (0-11)</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>h</td>
<td>基于上午/下午表示的时间 am/pm (1-12)</td>
<td>Number</td>
<td>12</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
<td>Number</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
<td>Number</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
<td>Number</td>
<td>978</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>一般时区</td>
<td>Pacific Standard Time; PST; GMT-08:00</td>
</tr>
<tr>
<td>Z</td>
<td>时区</td>
<td>RFC 822 时区</td>
<td>-0800</td>
</tr>
<tr>
<td>X</td>
<td>时区</td>
<td>ISO 8601 时区</td>
<td>-08; -0800;  -08:00</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(format);</span><br></pre></td></tr></table></figure>
<h2 id="Calendar">Calendar</h2>
<p>该类是一个抽象类，和 Date 一样，代表特定的时刻，该类提供了一些操作日历字段的方法，比如获得下一周的日期。</p>
<p>该类使用时需要注意一下几点：</p>
<ul>
<li>支持指定时区和区域构造日历。最常见的实现是 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/GregorianCalendar.html">GregorianCalendar</a>，代表公历；</li>
<li>该时刻表示的当前时间与纪元的差（以毫秒为单位）；</li>
<li>年份不再从 1900 年开始，月份依旧从 0 开始计算；</li>
<li><strong>没有专门的文本格式转换，通过 Date 作为中转</strong>；</li>
<li><strong>该类是可变类，线程不安全。</strong></li>
</ul>
<h3 id="使用-3">使用</h3>
<h4 id="创建-2">创建</h4>
<ul>
<li>使用静态工厂方法获取基于系统时区的当前时刻：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<ul>
<li>使用静态内部类构建器构建时间日历：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Calendar</span>.Builder()</span><br><span class="line">        .setCalendarType(<span class="string">&quot;iso8601&quot;</span>)</span><br><span class="line">        .setWeekDate(<span class="number">2013</span>, <span class="number">1</span>, MONDAY)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Date</code> 转 <code>Calendar</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calendar</span>.Builder().setInstant(d).build();</span><br></pre></td></tr></table></figure>
<h4 id="比较">比较</h4>
<p>该类同样实现了 <code>Comparable</code> 接口，可以使用 <code>compareTo</code> 直接比较两个对象；</p>
<p>使用 <code>after</code> 和 <code>before</code> 实例方法；</p>
<h4 id="修改字段">修改字段</h4>
<p>通过 <code>set(int field, int value)</code> 修改<strong>当前日历对象</strong>字段，第一个参数为字段类型，定义在类的静态常量中：</p>
<p><code>ERA</code>, <code>YEAR</code>, <code>MONTH</code>(<code>JANUARY</code>, <code>FEBRUARY</code>, <code>MARCH</code>, <code>APRIL</code>, <code>MAY</code>, <code>JUNE</code>, <code>JULY</code>, <code>AUGUST</code>, <code>SEPTEMBER</code>, <code>OCTOBER</code>, <code>NOVEMBER</code>, <code>DECEMBER</code>, <code>UNDECIMBER</code>), <code>WEEK_OF_YEAR</code>, <code>WEEK_OF_MONTH</code>, <code>DATE</code>, <code>DAY_OF_MONTH</code>, <code>DAY_OF_YEAR</code>, <code>DAY_OF_WEEK</code>(<code>SUNDAY</code>, <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, <code>SATURDAY</code>), <code>DAY_OF_WEEK_IN_MONTH</code>, <code>AM_PM</code>, <code>HOUR</code>, <code>HOUR_OF_DAY</code>, <code>MINUTE</code>, <code>SECOND</code>, <code>MILLISECOND</code>, <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">rightNow.set(Calendar.MONTH, Calendar.JANUARY);</span><br></pre></td></tr></table></figure>
<p>或者 <code>set(int year, int month, int date, int hourOfDay, int minute)</code> 和 <code>set(int year, int month, int date)</code> 等。</p>
<p>增加或降低字段值：<code>add(int field, int amount)</code>；</p>
<p>滚动增加或减小某个单位值，不影响前一个字段值：<code>roll(int field, boolean up)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a calendar</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// displays the current calendar</span></span><br><span class="line">System.out.println(<span class="string">&quot;Month is &quot;</span> + cal.get(Calendar.MONTH));</span><br><span class="line"><span class="comment">// Month is 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// roll month</span></span><br><span class="line">cal.roll(Calendar.MONTH, <span class="literal">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Month is &quot;</span> + cal.get(Calendar.MONTH));</span><br><span class="line"><span class="comment">// Month is 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// roll downwards</span></span><br><span class="line">cal.roll(Calendar.MONTH, <span class="literal">false</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Month is &quot;</span> + cal.get(Calendar.MONTH));</span><br><span class="line"><span class="comment">// Month is 4</span></span><br></pre></td></tr></table></figure>
<h2 id="new-package-java-time">new package java.time</h2>
<p>该包中定义的类代表基本的日期时间概念，包括瞬间，持续时间，日期，时间，时区和时间段。它们基于 ISO 日历系统（公历）。所有的类都是<strong>不可变的并且是线程安全的</strong>。</p>
<p>每个日期实例都是由方便获取的字段 API 组成。对于较低级别的字段访问，可以参考 <code>java.time.temporal</code> 包。每个类都支持打印和解析为各种日期和时间，具体参阅 <code>java.time.format</code> 包以获取自定义选项。</p>
<p><code>java.time.chrono</code> 包包含日历中立 API <code>ChronoLocalDate</code>，<code>ChronoLocalDateTime</code>，<code>ChronoZonedDateTime</code> 和 <code>Era</code>，这些类可以用来构建地区化的日历系统，比如农历等，系统内置提供了 4 中日历系统，分别是：</p>
<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>
<h2 id="package-java-time-temporal">package java.time.temporal</h2>
<p>我们可以使用字段、单位和日期时间调节器来访问日期和时间。</p>
<p>该程序包在基本程序包上扩展，以提供更多功能来满足更强大的用例。支持包括：</p>
<ul>
<li>日期时间单位，例如年，月，日和小时</li>
<li>日期时间字段，例如一年中的某月，一周中的某日或一天中的某小时</li>
<li>日期时间调整功能</li>
<li>周的不同定义</li>
</ul>
<h3 id="字段和单位">字段和单位</h3>
<p>日期和时间以字段和单位表示。单位用于测量时间量，例如年，天或分钟。所有单位都实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html"><code>TemporalUnit</code></a>。众所周知的单位集在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html"><code>ChronoUnit</code></a> 中定义，例如 DAYS。该单位中也定义了一些常用的单位操作 API，例如：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#addTo-R-long-">addTo</a></strong>(R temporal, long amount) - 添加指定时间段</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#between-java.time.temporal.Temporal-java.time.temporal.Temporal-">between</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> temporal1Inclusive, <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> temporal2Exclusive) - 比较两个时间对象之间的时间</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#isSupportedBy-java.time.temporal.Temporal-">isSupportedBy</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> temporal) - 指定时间对象是否支持此单位</li>
</ul>
<p>字段用于表示较大日期时间的一部分，例如年，一年中的月或一分钟中的秒。所有字段都实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html"><code>TemporalField</code></a>。在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html"><code>ChronoField</code></a> 中定义了一组众所周知的字段，例如 HOUR_OF_DAY。其他字段由 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/JulianFields.html"><code>JulianFields</code></a>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html"><code>WeekFields</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/IsoFields.html"><code>IsoFields</code></a> 定义。该字段也有一些常用的 API，例如：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#getFrom-java.time.temporal.TemporalAccessor-">getFrom</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">TemporalAccessor</a> temporal) - 从指定的时间对象获取此字段的值</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#isSupportedBy-java.time.temporal.TemporalAccessor-">isSupportedBy</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">TemporalAccessor</a> temporal) - 检查时间对象是否支持此字段</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#range--">range</a></strong>() - 获取此字段的有效范围</li>
</ul>
<p>字段的一种用法是从时间对象中获取没有便利方法的字段。例如，获取月中的某天很常见，以至于 <code>LocalDate</code> 上有一个名为 <code>getDayOfMonth()</code> 的方法。但是，对于更特殊的字段，必须使用该字段。例如，获取月中的周数，date.get(ChronoField.ALIGNED_WEEK_OF_MONTH)。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html"><code>Temporal</code></a> 作为支持字段的日期时间类型的抽象。其方法支持获取字段的值、创建修改字段值后的新日期时间以及查询其他信息（通常用于提取偏移量或时区）。</p>
<h3 id="调整和查询">调整和查询</h3>
<p>日期时间问题中的关键部分是将日期调整为新的相关值，例如“每月的最后一天”或“下一个星期三”。这些被建模为调整基准日期时间的函数。该函数实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjuster.html"><code>TemporalAdjuster</code></a> 并在 Temporal 上运行。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html"><code>TemporalAdjusters</code></a> 中提供了一组常用功能。例如，要查找给定日期后一周中某天的第一次出现，请使用 TemporalAdjusters.next(DayOfWeek)，例如 date.with(next(MONDAY))。</p>
<p>TemporalAdjuster 函数接口有一些常见的静态实现：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dayOfWeekInMonth</td>
<td>创建一个新的日期，它的值为同一个月中每一周的第几天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfMonth</td>
<td>创建一个新的日期，它的值为当月的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfNextMonth</td>
<td>创建一个新的日期，它的值为下月的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfNextYear</td>
<td>创建一个新的日期，它的值为明年的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfYear</td>
<td>创建一个新的日期，它的值为当年的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstInMonth</td>
<td>创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的值</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfMonth</td>
<td>创建一个新的日期，它的值为当月的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfNextMonth</td>
<td>创建一个新的日期，它的值为下月的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfNextYear</td>
<td>创建一个新的日期，它的值为明年的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfYear</td>
<td>创建一个新的日期，它的值为今年的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastInMonth</td>
<td>创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的值</td>
</tr>
<tr>
<td style="text-align:left">next/previous</td>
<td>创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期</td>
</tr>
<tr>
<td style="text-align:left">nextOrSame/previousOrSame</td>
<td>创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期，如果该日期已经符合要求，直接返回该对象</td>
</tr>
</tbody>
</table>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html"><code>TemporalAmount</code></a> 接口模拟相对时间量，比如常用的实现类 <code>Duration</code>，<code>Period</code>。</p>
<p>除了调整日期时间外，还提供了一个接口以启用通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQuery.html"><code>TemporalQuery</code></a> 进行查询。查询接口的最常见实现是方法引用。可以使用主要时间对象类上的 <code>from(TemporalAccessor)</code> 方法，例如 <code>LocalDate::from</code> 或 <code>Month::from</code>。在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQueries.html"><code>TemporalQueries</code></a> 中作为静态方法提供了进一步的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ZonedDateTime</span> <span class="variable">now</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now: 2020-06-11T00:00:39.096326+08:00[Asia/Shanghai]</span></span><br><span class="line">System.out.format(<span class="string">&quot;Now: %s%n&quot;</span>, now);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> now.query(TemporalQueries.localDate());</span><br><span class="line"><span class="keyword">final</span> <span class="type">LocalDate</span> <span class="variable">toLocalDate</span> <span class="operator">=</span> now.toLocalDate();</span><br><span class="line"><span class="keyword">final</span> <span class="type">LocalDate</span> <span class="variable">fromLocalDate</span> <span class="operator">=</span> now.query(LocalDate::from);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(localDate.isEqual(toLocalDate) &amp;&amp; localDate.isEqual(fromLocalDate));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">TemporalUnit</span> <span class="variable">unit</span> <span class="operator">=</span> now.query(TemporalQueries.precision());</span><br><span class="line"><span class="keyword">final</span> <span class="type">Chronology</span> <span class="variable">chronology</span> <span class="operator">=</span> now.query(TemporalQueries.chronology());</span><br><span class="line"><span class="keyword">final</span> <span class="type">ZoneId</span> <span class="variable">zone</span> <span class="operator">=</span> now.query(TemporalQueries.zoneId());</span><br><span class="line"><span class="keyword">final</span> <span class="type">ZoneOffset</span> <span class="variable">offset</span> <span class="operator">=</span> now.query(TemporalQueries.offset());</span><br><span class="line"></span><br><span class="line"><span class="comment">// TemporalUnit: Nanos, Chronology: ISO, ZoneId: Asia/Shanghai, ZoneOffset: +08:00</span></span><br><span class="line">System.out.format(<span class="string">&quot;TemporalUnit: %s, Chronology: %s, ZoneId: %s, ZoneOffset: %s %n&quot;</span>, unit, chronology, zone, offset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> now.query(Month::from);</span><br><span class="line"><span class="keyword">final</span> <span class="type">MonthDay</span> <span class="variable">monthDay</span> <span class="operator">=</span> now.query(MonthDay::from);</span><br><span class="line"><span class="keyword">final</span> <span class="type">YearMonth</span> <span class="variable">yearMonth</span> <span class="operator">=</span> now.query(YearMonth::from);</span><br><span class="line"><span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> now.query(DayOfWeek::from);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> now.query(ZoneId::from);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ZoneOffset</span> <span class="variable">zoneOffset</span> <span class="operator">=</span> now.query(ZoneOffset::from);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Month: JUNE, MonthDay: --06-11, YearMonth: 2020-06, DayOfWeek: THURSDAY, zoneId: Asia/Shanghai, zoneOffset: +08:00</span></span><br><span class="line">System.out.format(<span class="string">&quot;Month: %s, MonthDay: %s, YearMonth: %s, DayOfWeek: %s, zoneId: %s, zoneOffset: %s %n&quot;</span>, month, monthDay, yearMonth, dayOfWeek, zoneId, zoneOffset);</span><br></pre></td></tr></table></figure>
<h3 id="周">周</h3>
<p>不同的语言环境对星期有不同的定义。例如，在欧洲，一周通常从星期一开始，而在美国，则从星期日开始。 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html"><code>WeekFields</code></a> 类为这种区别建模。IOS 定义星期一为一周开始，一周至少需要四天。</p>
<p>ISO 日历系统定义了一个额外的基于周的年划分。这定义了基于从一年整个星期一到星期一的一年，它是在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/IsoFields.html"><code>IsoFields</code></a> 中建模的。</p>
<h2 id="日期和时间">日期和时间</h2>
<p>日期和时间类的接口都提供了一致的设计，所以再很多 API 上都做了通用的处理，比如一致的方法前缀：</p>
<ul>
<li><code>of</code> - 静态工厂方法</li>
<li><code>parse</code> - 侧重于解析的静态工厂方法</li>
<li><code>get</code> - 获取值或其它</li>
<li><code>is</code> - 检查是否为真</li>
<li><code>with</code> - 等同于 setter 的不可变修改，返回新的副本</li>
<li><code>plus</code> - 增加一定数量的单位</li>
<li><code>minus</code> - 减少一定数量的单位</li>
<li><code>to</code> - 将一个对象转换为另一个对象</li>
<li><code>at</code> - 将一个对象结合到该对象中，例如 <code>date.atTime(time)</code></li>
</ul>
<p>这里主要以 Insant 展开介绍。</p>
<h3 id="Instant">Instant</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html"><code>Instant</code></a> 实质上是一个数字时间戳。可以从时钟（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html"><code>Clock</code></a>）中获取当前的瞬时信息。这对于时间点的记录和持久化很有用，存储的结果与 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis--"><code>System.currentTimeMillis()</code></a>` 相关联。</p>
<h4 id="创建-3">创建</h4>
<p>从 <code>Date</code> 获取：<code>new Date().toInstant()</code>；</p>
<p>使用静态工厂方法：</p>
<ul>
<li>从系统时钟（Clock）构建：<code>Instant.now()</code>，<code>Instant.now(Clock clock)</code></li>
<li>根据纪元差毫秒构建构建：<code>Instant.ofEpochMilli(long epochMilli)</code></li>
<li>使用标准 ISO 格式字符串构建：<code>Instant.parse(CharSequence text)</code>，格式例如：2007-12-03T10:15:30.00Z</li>
<li>从 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">TemporalAccessor</a> 实现类构建，该类可以为 Instant 或支持 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html#INSTANT_SECONDS"><code>INSTANT_SECONDS</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html#NANO_OF_SECOND"><code>NANO_OF_SECOND</code></a> 字段的实现类，比如：<code>ZonedDateTime</code></li>
</ul>
<h4 id="比较-2">比较</h4>
<p>使用前需明确该对象支持的单位或字段类型，API 文档中有说明支持的类型；</p>
<p>或者使用：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#isSupported-java.time.temporal.TemporalUnit-">isSupported</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit) 和 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#isSupported-java.time.temporal.TemporalUnit-">isSupported</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit) 判断</p>
<ul>
<li>
<p>比较与指定 Temporal 实现类指定单位的差：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#until-java.time.temporal.Temporal-java.time.temporal.TemporalUnit-">until</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> endExclusive, <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit)</p>
</li>
<li>
<p>使用 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#isAfter-java.time.Instant-">isAfter</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">Instant</a> otherInstant) 或 isBefore(Instant otherInstant) 或 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#compareTo-java.time.Instant-">compareTo</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">Instant</a> otherInstant)</p>
</li>
</ul>
<h4 id="获取">获取</h4>
<p>获取时间的字段值前同样得确认是否支持，这些方法通常以 <code>get*</code> 单位的形式存在，或者直接通过：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#get-java.time.temporal.TemporalField-">get</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field)</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#get-java.time.temporal.TemporalField-">getLong</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field)</li>
<li>构建查询获取：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#query-java.time.temporal.TemporalQuery-">query</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQuery.html">TemporalQuery</a><R> query)</li>
</ul>
<p>获取字段的有效值范围：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#range-java.time.temporal.TemporalField-">range</a>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field)</p>
<h4 id="调整">调整</h4>
<p>所有的修改方法都返回新的副本：</p>
<ul>
<li>调整字段值：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#with-java.time.temporal.TemporalField-long-">with</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field, long newValue)</li>
<li>截断操作会将小于该单位的字段都设置为 0：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#truncatedTo-java.time.temporal.TemporalUnit-">truncatedTo</a>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit)</li>
<li>增加或减少某个字段：<code>plus*</code>、<code>minus*</code></li>
<li>通过 TemporalAdjuster 函数接口实现调整：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#with-java.time.temporal.TemporalAdjuster-">with</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjuster.html">TemporalAdjuster</a> adjuster)</li>
</ul>
<h3 id="LocalDate">LocalDate</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html"><code>LocalDate</code></a> 存储没有时间的日期，也不附带时区信息。它会存储 <code>yyyy-MM-dd</code> 格式的日期，可以用来存储生日。</p>
<h3 id="LocalTime">LocalTime</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html"><code>LocalTime</code></a> 存储没有日期的时间。它将存储类似于 <code>HH:mm:ss</code> 格式的时间。</p>
<h3 id="LocalDateTime">LocalDateTime</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html"><code>LocalDateTime</code></a> 存储日期和时间。它将存储类似于 <code>yyyy-MM-dd HH:mm:ss</code> 格式的时间。</p>
<h3 id="ZonedDateTime">ZonedDateTime</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html"><code>ZonedDateTime</code></a> 存储带有时区的日期和时间。如果要考虑到 ZoneId（例如“欧洲/巴黎”）对日期和时间进行准确的计算，这将很有用。如果可能，建议使用没有时区的简单类。时区的广泛使用往往会增加应用程序的复杂性。</p>
<p>该类存储类似于 <code>yyyy-MM-dd HH:mm:ss.zzz</code> 格式的时间。可通过上面所述时间类通过：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#atZone-java.time.ZoneId-">atZone</a>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html">ZoneId</a> zone) 添加时区而来。</p>
<p>下图对 ZoneDateTime 的组成部分进行了说明。</p>
<p><img data-src="../../images/java/zoneDateTime.jpg" alt="zoneDateTime"></p>
<h2 id="持续时间和周期">持续时间和周期</h2>
<h3 id="Duration">Duration</h3>
<p>持续时间是沿时间线以纳秒为单位的时间的简单度量。</p>
<p>此类以秒和纳秒为单位对时间量进行建模。也可以使用其他基于持续时间的单位（例如分钟和小时）来访问它。</p>
<h4 id="创建-4">创建</h4>
<p>目前为止, 我们看到的所有类都实现了 <code>Temporal</code> 接口, <code>Temporal</code> 接口定义了如何读取和操纵为时间建模的对象的值。</p>
<p><code>Duration</code> 类的静态工厂方法 <code>between</code> 就可以为两个 Temporal 对象创建持续时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Duration</span> <span class="variable">d1</span> <span class="operator">=</span> Duration.between(time1, time2); </span><br><span class="line"><span class="type">Duration</span> <span class="variable">d1</span> <span class="operator">=</span> Duration.between(dateTime1, dateTime2); </span><br><span class="line"><span class="type">Duration</span> <span class="variable">d2</span> <span class="operator">=</span> Duration.between(instant1, instant2);</span><br></pre></td></tr></table></figure>
<p>也可以使用静态工厂从其它时间单位创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Duration</span> <span class="variable">threeMinutes</span> <span class="operator">=</span> Duration.ofMinutes(<span class="number">3</span>); </span><br><span class="line"><span class="type">Duration</span> <span class="variable">threeMinutes</span> <span class="operator">=</span> Duration.of(<span class="number">3</span>, ChronoUnit.MINUTES);  </span><br></pre></td></tr></table></figure>
<h3 id="Period">Period</h3>
<p>周期以对人类有意义的单位表示时间量。例如年、月或天。</p>
<h4 id="创建-5">创建</h4>
<p>使用静态工厂方法创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Period</span> <span class="variable">tenDays</span> <span class="operator">=</span> Period.between(LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">8</span>), LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Period</span> <span class="variable">tenDays</span> <span class="operator">=</span> Period.ofDays(<span class="number">10</span>); </span><br><span class="line"><span class="type">Period</span> <span class="variable">threeWeeks</span> <span class="operator">=</span> Period.ofWeeks(<span class="number">3</span>); </span><br><span class="line"><span class="type">Period</span> <span class="variable">twoYearsSixMonthsOneDay</span> <span class="operator">=</span> Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<hr>
<p><code>Duration</code> 类和 <code>Period</code> 类共享了很多相似的方法，参见下表所示。</p>
<table>
<thead>
<tr>
<th>方 法 名</th>
<th>是否是静态方法</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>between</td>
<td>是</td>
<td>创建两个时间点之间的 interval</td>
</tr>
<tr>
<td>from</td>
<td>是</td>
<td>由一个临时时间点创建 interval</td>
</tr>
<tr>
<td>of</td>
<td>是</td>
<td>由它的组成部分创建 interval 的实例</td>
</tr>
<tr>
<td>parse</td>
<td>是</td>
<td>由字符串创建 interval 的实例</td>
</tr>
<tr>
<td>addTo</td>
<td>否</td>
<td>创建该 interval 的副本,并将其?加到某个指定的 temporal 对象</td>
</tr>
<tr>
<td>get</td>
<td>否</td>
<td>读取该 interval 的状态</td>
</tr>
<tr>
<td>isNegative</td>
<td>否</td>
<td>检查该 interval 是否为负值,不包含零</td>
</tr>
<tr>
<td>isZero</td>
<td>否</td>
<td>检查该 interval 的时长是否为零</td>
</tr>
<tr>
<td>minus</td>
<td>否</td>
<td>通过减去一定的时间创建该 interval 的副本</td>
</tr>
<tr>
<td>multipliedBy</td>
<td>否</td>
<td>将 interval 的值乘以某个标量创建该 interval 的副本</td>
</tr>
<tr>
<td>negated</td>
<td>否</td>
<td>以忽略某个时长的方式创建该 interval 的副本</td>
</tr>
<tr>
<td>plus</td>
<td>否</td>
<td>以增加某个指定的时长的方式创建该 interval 的副本</td>
</tr>
<tr>
<td>subtractFrom</td>
<td>否</td>
<td>从指定的 temporal 对象中减去该 interval</td>
</tr>
</tbody>
</table>
<h2 id="打印输出及解析日期">打印输出及解析日期</h2>
<p>处理日期和时间对象时，格式化以及解析日期-时间对象是另一个非常重要的功能。新的 <code>java.time.format</code> 包就是特别为这个目的而设计的。</p>
<p>这个包中，最重要的类是 <strong><code>DateTimeFormatter</code></strong>。创建格式器最简单的方法是通过它的静态工厂方法以及常量。</p>
<p>它包含了 IOS 格式定义的常见格式，像 <code>BASIC_ISO_DATE</code> 和 <code>ISO_LOCAL_DATE</code>  这样的常量是 DateTimeFormatter 类的预定义实例。</p>
<p>所有的 DateTimeFormatter 实例都能用于以一定的格式创建代表特定日期或时间的字符串。比如，下面的这个例子中，我们使用了两个不同的格式器生成了字符串:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> date.format(DateTimeFormatter.BASIC_ISO_DATE);	&lt;-- <span class="number">20140318</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> date.format(DateTimeFormatter.ISO_LOCAL_DATE);  &lt;-- <span class="number">2014</span>-<span class="number">03</span>-<span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过解析代表日期或时间的字符串重新创建该日期对象。所有的日期和时间API 都提供了表示时间点或者时间段的工厂方法,你可以使用工厂方法parse达到重创该日期对象的目的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;20140318&quot;</span>, DateTimeFormatter.BASIC_ISO_DATE); </span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2014-03-18&quot;</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>
<p>和老的 <em><code>java.util.DateFormat</code></em> 相比较，所有的 <code>DateTimeFormatter</code> 实例<strong>都是线程安全的</strong>。所以，我们能够以单例模式创建格式器实例，就像 DateTimeFormatter 所定义的那些常量，并能在多个线程间共享这些实例。DateTimeFormatter 类还支持一个静态工厂方法,它可以按照某个特定的模式创建格式器，代码清单如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;dd/MM/yyyy&quot;</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>); </span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> date1.format(formatter); </span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDate.parse(formattedDate, formatter);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream 学习</title>
    <url>/java/Java8-Stream%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Java 8 提供了一个新的 API（称为”流“，Stream），它支持大数据的并行操作，其思路和在数据库查询语言中的思路相似 – 用更高级的方式表达想要的东西，而由”实现“（在这里是 Streams 库）来选择最佳低级执行机制。这样就可以避免用 <code>synchronized</code> 来编写代码，这一行代码不仅容器出错，而且在多核 CPU 上执行所需的成本比想象要高<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h2 id="思想">思想</h2>
<blockquote>
<p>是函数式编程（functional programming）的一种 Java 实现</p>
</blockquote>
<blockquote>
<p>强调将计算过程分解成可复用的函数，主要使用 map 方法和 reduce 方法组合而成的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce</a> 算法，最好的实现 Apache Hadoop</p>
</blockquote>
<span id="more"></span>
<h2 id="Streams-和-Collections-的不同">Streams 和 Collections 的不同</h2>
<ul>
<li><strong>不储存元素。</strong> Stream 不是储存元素的数据结构；相反的，它通过管道对源就像数据结构、数组、构造方法、IO 流的元素进行操作。</li>
<li><strong>纯粹的方法，也叫无副作用 (no side effect)。</strong> Stream 上的操作会产生结果，但不会修改其来源。例如，过滤从集合获取的流会生成一个没有过滤元素的新 Stream，而不是从源集合中删除元素。</li>
<li><strong>惰性化。</strong> 许多流操作（例如过滤，映射或重复移除）可以被惰性化实现，从而为优化提供机会。流操作分为中间 (intermediate) 操作和终结 (terminal) 操作，中间操作总是惰性的。</li>
<li><strong>可能没有限制。</strong> 尽管集合的大小有限，但流不需要。诸如 limit(n) 或 findFirst() 之类的短路操作可以允许无限流上的计算在有限的时间内完成。</li>
<li><strong>一次性。</strong> 流的元素在流的生命周期中仅访问过一次。像 Iterator 一样，必须生成一个新的流来重新访问源的相同元素。</li>
</ul>
<blockquote>
<p>集合和流，它们有不同的关注点，集合主要关注集合的有效管理和访问。<br>
相反，流不直接提供访问和操作元素的手段，而是关注于声明性地描述它们的来源和将在该来源上进行的计算操作。如果流操作没有你想要的功能，你可以使用 iterator() 或 spliterator() 来遍历操作。</p>
</blockquote>
<blockquote>
<p>外部迭代器是客户端主动调用迭代的，内部迭代器是由内部迭代器自身迭代的。枚举，增强 for 循环还是使用 iterator() 来进行遍历，它们同属于外部遍历器，java8 集合的 forEach 和 stream 的 forEach() 属于内部遍历器，流的内部遍历器可以使用到流的并行（parallel）特性，从而加快速度。</p>
</blockquote>
<p>流操作分为中间操作（intermediate operations）和终结操作（terminal operations），结合形成流管道。流管道由源（例如集合，数组，生成器函数或 I/O 通道）组成; 随后是零个或多个中间操作，例如 <code>Stream.filter</code> 或 <code>Stream.map</code> 和诸如 <code>Stream.forEach</code> 或 <code>Stream.reduce</code> 之类的终结操作。</p>
<p><img data-src="../../images/java/stream/stream.jpg" alt="stream"></p>
<h2 id="常用操作">常用操作</h2>
<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>使用的类型/函数式接口</th>
<th>函数描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter</td>
<td>中间</td>
<td>Stream<T></td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>distinct</td>
<td>中间 (有状态 - 无界)</td>
<td>Stream<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>中间 (有状态 - 有界)</td>
<td>Stream<T></td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>limit</td>
<td>中间 (有状态 - 有界)</td>
<td>Stream<T></td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>中间</td>
<td>Stream<T></td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>
<tr>
<td>flatMap</td>
<td>中间</td>
<td>Stream<T></td>
<td>Function&lt;T, Stream<R>&gt;</td>
<td>T -&gt; Stream<R></td>
</tr>
<tr>
<td>sorted</td>
<td>中间 (有状态 - 无界)</td>
<td>Stream<T></td>
<td>Comparator<T></td>
<td>(T, T) -&gt; int</td>
</tr>
<tr>
<td>anyMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>noneMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>allMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>findAny</td>
<td>终端</td>
<td>Optional<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>findFirst</td>
<td>终端</td>
<td>Optional<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>forEach</td>
<td>终端</td>
<td>void</td>
<td>Consumer<T></td>
<td>T -&gt; void</td>
</tr>
<tr>
<td>collect</td>
<td>终端</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>终端 (有状态 - 有界)</td>
<td>Optional<T></td>
<td>BinaryOperator<T></td>
<td>(T, T) -&gt; T</td>
</tr>
<tr>
<td>count</td>
<td>终端</td>
<td>long</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="Intermediate-operations（中间操作）">Intermediate operations（中间操作）</h2>
<p><strong>中间操作返回一个新的流（Stream<T>）。</strong></p>
<p>他们总是惰性的，执行诸如 <code>filter()</code> 之类的中间操作实际上并不执行任何过滤，而是创建一个新的流，该流在遍历时包含与给定谓词相匹配的初始流的元素。在管道的终结操作被执行时对源的流水遍历才会开始。</p>
<p>中间操作进一步分为无状态和有状态操作。无状态操作（如 <code>filter</code> 和 <code>map</code>）在处理新元素时不会保留先前看到的元素的状态 – 每个元素可以独立于其他元素上的操作进行处理。有状态的操作（如 <code>distinct</code> 和 <code>sorted</code>）可能会在处理新元素时结合之前看到的元素的状态。</p>
<p>有状态的操作可能需要在生成结果之前处理整个输入。例如，只有在查看了流的所有元素之后，才能对排序流产生任何结果。因此，在并行计算中，一些包含有状态中间操作的管道可能需要对数据进行多次传递，或者可能需要缓存重要数据。只包含无状态中间操作的流水线可以一次处理，无论是顺序处理还是并行处理，只需最少的数据缓冲。</p>
<p>常用的一些操作：</p>
<h3 id="map">map</h3>
<p><img data-src="../../images/java/stream/map-operation.jpg" alt="map"></p>
<p><strong>返回由给定函数作用于此流的元素后产生的结果组成的流。</strong><br>
 给定函数应为无干涉，无状态的操作作用于每个元素。不然对于并发流后面的操作结果可能不会很准确。</p>
<ul>
<li><strong>无干涉</strong><br>
无干涉主要是指在流操作期间不去修改<strong>源流</strong>。</li>
</ul>
<p>+ <strong>无状态</strong><br>
无状态是指我们在处理时不产生中间状态，操作不依赖之前的状态。</p>
<h3 id="filter">filter</h3>
<p>过滤是按照一定的规则对流中的元素进行检查，将<strong>符合条件</strong>的元素抽取到新的流中的操作。</p>
<p><img data-src="../../images/java/stream/filter-operation.jpg" alt="filter"></p>
<h3 id="distinct">distinct</h3>
<p><img data-src="../../images/java/stream/distinct-operation.jpg" alt="distinct"></p>
<p><code>distinct</code> 保证输出的流中包含唯一的元素，它是通过 <code>Object.equals(Object)</code> 来检查是否包含相同的元素。它是一个有状态的中间操作。</p>
<blockquote>
<p>在并行流中对无序数组去重效率更高，对于有序数组可以使用 <code>unordered()</code> 无序检索提高速度，或者使用<code>sequential()</code>来实现串行。</p>
<p>相反有序数组更适合使用串行流。</p>
</blockquote>
<h3 id="peek">peek</h3>
<p><img data-src="../../images/java/stream/peek-operation.jpeg" alt="peek"></p>
<p><code>peek</code> 产生一个和原流相同的流，并在遍历流的过程中去消费每个元素。</p>
<blockquote>
<p>使用 peek 的主要目的是**“看，不要动”**。<br>
此方法主要用于支持调试，您希望在元素流经管道中的某个点时看到这些元素：请谨慎使用此方法作为副作用，因为它有可能会修改源流。</p>
</blockquote>
<h3 id="flatMap">flatMap</h3>
<p><img data-src="../../images/java/stream/flat-map-operation.jpeg" alt="flatmap"></p>
<p>返回一个流，该流包含将原流的<em>每个元素替换为映射函数应用于每个元素而生成的映射流的内容</em>的结果。每个映射流都将其内容放入此流后关闭。（如果映射流为空，则使用空流代替）<br>
简而言之，扁平化多个流为一个新流。</p>
<blockquote>
<p>flatMap() 操作具有对流的元素应用一对多转换，然后将生成的元素展平为新流的效果。</p>
</blockquote>
<p><strong>example</strong></p>
<p>orders 是采购订单流，并且每个采购订单都包含一系列采购列，则以下内容会生成包含所有订单中的所有采购列的流：</p>
<p><code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code></p>
<p>如果 path 是文件的路径，那么下面的内容会生成包含在该文件中的单词流：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8);</span><br><span class="line">Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(<span class="string">&quot; +&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>上面 flatmap 中的映射函数使用的正则比较简单，具体单词划分的正则不是这样。</p>
<h3 id="limit">limit</h3>
<p><img data-src="../../images/java/stream/limit-operation.jpeg" alt="limit"></p>
<p>对流进行截断操作，获取其前 N 个元素，如果原流中包含的元素个数小于 N，那就获取其所有的元素。</p>
<h3 id="count">count</h3>
<p>返回此流中元素的数量。这是一个简写，相当于：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> mapToLong(e -&gt; <span class="number">1L</span>).sum();</span><br></pre></td></tr></table></figure>
<h2 id="Terminal-operations（终结操作）">Terminal operations（终结操作）</h2>
<blockquote>
<p>终结操作返回确定类型的结果</p>
</blockquote>
<p>如 <code>Stream.forEach</code> 或 <code>IntStream.sum</code>，可能会遍历流以产生结果或副作用(side-effect)。终结操作执行后，流管道被视为消耗，并不能再使用；如果你需要再次遍历相同的数据源，则必须返回到数据源以获取新的流。在几乎所有情况下，终结操作都非常急切，在返回之前完成数据源的遍历和管道的处理。只有终结操作 <code>iterator()</code> 和 <code>spliterator()</code> 不是。</p>
<h3 id="副作用（side-effect）">副作用（side-effect）</h3>
<p>副作用可能会违反无状态要求和对线程安全产生危害。<br>
许多计算可能会产生副作用，但是可以更安全有效地表达，而不会产生副作用，例如使用 <code>归约</code> 而不是 <code>可变累加器</code>。少量流操作（例如 <code>forEach()</code> 和 <code>peek()</code>）只能通过副作用操作，应该小心使用。比如我们在对流操做以期望得到想要的结果，而无意修改了原始流，便产生了副作用。</p>
<p>常见的副作用包括：</p>
<ul>
<li>修改任何外部变量或对象属性（例如，全局变量或流作用域外部的变量）</li>
<li>打印日志</li>
<li>文件读写</li>
<li>网络请求</li>
<li>触发外部事件</li>
<li>调用其它由副作用的方法</li>
<li>等等</li>
</ul>
<h3 id="归约（Reduction-operations）">归约（Reduction operations）</h3>
<p>归约操作（也称为折叠）将一系列输入元素，通过重复应用组合操作（例如查找一组数字的和或最大值）或将元素累加到列表中来将它们组合为单个汇总结果。</p>
<p>流类具有多种形式的<strong>通用归约操作</strong>，称为 <code>reduce()</code> 和 <code>collect()</code>，以及多个<strong>专用简化形式</strong>，如 <code>sum()</code>，<code>max()</code> 或 <code>count()</code>。</p>
<h4 id="规约方法的优势与并行化">规约方法的优势与并行化</h4>
<p>相比于逐步迭代求和，使用 <code>reduce</code> 的好处在于，这里的迭代被内部迭代抽象掉了，这让内部实现得以选择并行执行 reduce 操作。而迭代式求和要更新共享变量 sum，这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争抵消了并行本应带来的性能提升，这种计算的并行化需要另一种办法：将输入分块，分块求和，最后再合并起来。参见：<a href="#">Post not found: ForkJoin-框架入门 ForkJoin 框架</a><br>
但现在重要的是要认识到，可变的累加器模式对于并行化来说是思路一条。需要一种新的模式，这正是 reduce 所提供的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.parallelStream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>但要并行执行这段代码也要付出一定代价：传递给 reduce 的 Lambda 不能更改状态（如实例变量），而且操作作必须满足结合律才可以按任意顺序执行。</p>
<h4 id="可变归约（Mutable-reduction）">可变归约（Mutable reduction）</h4>
<p>可变归约操作将输入元素累加到<strong>可变结果容器</strong>中，例如 <code>Collection</code> 或 <code>StringBuilder</code>，因为它处理流中的元素。</p>
<p>可变归约操作称为 <code>collect()</code>，因为它将所需结果一起收集到结果容器（如集合）中。 收集操作需要三个功能：构造结果容器的新实例的供应者函数，将输入元素并入结果容器的累加器函数以及将一个结果容器的内容合并到另一个结果容器的组合函数。</p>
<ul>
<li>供应器 (supplier())</li>
<li>累加器 (accumulator())</li>
<li>组合器 (combiner())</li>
<li>修整器 (finisher()) <em>可省略</em></li>
</ul>
<blockquote>
<p>归约 (reduce) 方法旨在把两个值结合起来生成一个新值，它是一个不可变的规约。与此相反，collect 方法的设计就是要改变容器，从而累加要输出的结果。错误的使用归约方法可能导致并行工作不正常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">            BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">            BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (T element : stream) &#123;</span><br><span class="line">   strings.add(element.toString());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>我们可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = stream.collect(() -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),</span><br><span class="line">                                        (c, e) -&gt; c.add(e.toString()),</span><br><span class="line">                                        (c1, c2) -&gt; c1.addAll(c2));</span><br></pre></td></tr></table></figure>
<p>简写作：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = stream.map(Object::toString)</span><br><span class="line">                                    .collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>
<p>在这里，我们的供应器是 <code>ArrayList</code> 构造函数，累加器将字符串化的元素添加到 <code>ArrayList</code>，组合器只是简单地使用 <code>addAll</code> 将字符串从一个容器复制到另一个容器中。<br>
<code>collect</code> 的供应器，累加器和组合器三个方面紧密耦合。我们可以使用抽象的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html">Collector</a> 来包含三个方面，上面的代码可以重写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = stream.map(Object::toString)</span><br><span class="line">                                  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h5 id="Collector-收集器接口">Collector 收集器接口</h5>
<p>使用收集器对流的元素执行可变归约操作。收集器封装了用作收集参数的函数 (供应器，累加器，组合器），从而允许重用收集策略和组合收集操作，例如多级分组或分区。</p>
<h5 id="收集器（Collectors）实现类">收集器（Collectors）实现类</h5>
<p><strong>Collectors 是 Collector 接口的实现类，它里面包含了常用的收集策略。</strong><br>
常见的策略以静态工厂方法的形式提供，包括：</p>
<ul>
<li>将元素累加到集合中；<br>
<code>toList</code> <code>toMap</code> <code>toSet</code> <code>toCollection</code></li>
<li>使用 <code>StringBuilder</code> 连接字符串：<code>joining</code></li>
<li>计算关于总和，最小值，最大值或平均值等元素的摘要信息；
<ul>
<li>求和 <code>counting()</code> <code>collectingAndThen</code></li>
<li>汇总 <code>summarizingDouble</code> <code>summingDouble</code>…</li>
<li>最大值、最小值 <code>maxBy</code> <code>minBy</code></li>
<li>平均值 <code>averagingDouble</code> <code>averagingInt</code>…</li>
</ul>
</li>
<li>计算“数据透视表”摘要，例如“卖方最大价值交易”等。
<ul>
<li>分组 <code>groupingBy</code></li>
<li>分割 <code>partitioningBy</code></li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将用户姓名归约成一个集合</span></span><br><span class="line">List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把用户姓名归约到 TreeSet 集中</span></span><br><span class="line">Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象转换为字符串并将它们用逗号分隔连接起来</span></span><br><span class="line"><span class="type">String</span> <span class="variable">joined</span> <span class="operator">=</span> things.stream()</span><br><span class="line">        .map(Object::toString)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算输入员工的工资总和 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> employees.stream()</span><br><span class="line">                .collect(Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入员工按部门分组</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按部门分组计算工资总额 </span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把学生分成及格和不及格数组</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">                .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>多核 CPU 的每个处理器内核都有独立的高速缓存。加锁需要这些高速缓存同步运行，然而这又需要在内核间进行较慢的缓存一致性协议通信。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Java8 修复代码烂味道</title>
    <url>/java/Java8-%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E7%83%82%E5%91%B3%E9%81%93/</url>
    <content><![CDATA[<p>在学习 Java8 时发现一些写法真的很优秀，用了就有种回不去的感觉，很好的处理了 Java 代码上的烂味道。</p>
<h4 id="匿名内部类">匿名内部类</h4>
<p>在任何使用内部类的地方都使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lamdba表达式</a> 进行重构，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span> <span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以更简洁的写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort((o1,o2) -&gt; o1.length() - o2.length());</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="静态类">静态类</h4>
<p>通常我们用 Util 或者 Helper 命名结尾的类来包含静态方法，现在我们可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">interface 来支持静态方法</a>，类可能比接口更好用，但是如果方法是无状态且设计出来为了重写了，可能方法存在接口中更好。</p>
<h4 id="嵌套的-for-if-语句">嵌套的 for/if 语句</h4>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">Stream API</a> 设计出来就是为了更高效的查询 Collections，当你看到下面的代码时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Field&gt; validFields = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Field&gt;();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (meetsCriteria(field)) &#123;</span><br><span class="line">        validFields.add(field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> validFields;</span><br></pre></td></tr></table></figure>
<p>你应该考虑使用 Stream API代替，这种情况，使用 filter 和 collect 代替更合适：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> fields.stream()</span><br><span class="line">             .filter(<span class="built_in">this</span>::meetsCriteria)</span><br><span class="line">             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>对于循环内部的 if 语句可以使用 anyMatch 或者 findFirst 进行重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String current : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.equals(wanted)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>可以重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> strings.stream()</span><br><span class="line">              .anyMatch(current -&gt; current.equals(wanted));</span><br></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String current : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.equals(wanted)) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>可以重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> strings.stream()</span><br><span class="line">              .filter(current -&gt; current.equals(wanted))</span><br><span class="line">              .findFirst()</span><br><span class="line">              .orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这里的 orElse null 看起来非常难看，我们会在后面进行重构。</p>
<h4 id="一个-Collection-多个操作">一个 Collection 多个操作</h4>
<p>为了高效执行代码，我们通常会在一个 Collection 或者多个 Collection 中执行多个操作来取得结果，考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 收集登录消息</span></span><br><span class="line">List&lt;LogLine&gt; lines = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">    lines.add(<span class="keyword">new</span> <span class="title class_">LogLine</span>(message));</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 排序</span></span><br><span class="line">Collections.sort(lines);</span><br><span class="line"> <span class="comment">// 记录他们</span></span><br><span class="line"><span class="keyword">for</span> (LogLine line : lines) &#123;</span><br><span class="line">    line.log(LOG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分离的步骤可以让我们看清每一步的操作，但在调用 Collection.sort 时我们就该考虑到使用 Streams API，如果我们这样做，就可以将这些多个操作合并为一个 stream ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">messages.stream()</span><br><span class="line">    	.map(LogLine::<span class="keyword">new</span>)</span><br><span class="line">        .sorted()</span><br><span class="line">        .forEach(logLine -&gt; logLine.log(LOG));</span><br></pre></td></tr></table></figure>
<p>这样做不仅削减了一个 Collection，而且可读性更高，代码执行效率也高。</p>
<h4 id="使用-Iterator-remove-元素">使用 Iterator remove 元素</h4>
<p>在 java8 之前的代码可能像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = strings.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">current</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (current.endsWith(“jnilib”)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，代码可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.removeIf (current -&gt; current.endsWith(“jnilib”));</span><br></pre></td></tr></table></figure>
<p>同样的代码不仅看起来可读性高，而且执行效率更高。</p>
<h4 id="Null-检查">Null 检查</h4>
<p>NullPointerException 严重影响着 Java 开发人员的工作，为了避免遇到空指针异常我们都会对可能出现 Null 的地方进行检查，采用 Optional 意味着我们可以更明确的知道一个方法期望的返回类型和消除不必要的 Null 检查，考虑我们前面的 orElse(null) ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">findString</span> <span class="params">(String wanted)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> strings.stream()</span><br><span class="line">                  .filter(current -&gt;current.equals(wanted))</span><br><span class="line">                  .findFirst()</span><br><span class="line">                  .orElse(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何调用 findString 的代码都必须检查值是否为空，如果是的话需要采取适当的行动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">foundString</span> <span class="operator">=</span> findString(wantedString);</span><br><span class="line"><span class="keyword">if</span> (foundString == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> “Did not find value” and</span><br><span class="line">    wantedString;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foundString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来有些丑以及繁琐，如果我们使用 Optional 代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;String&gt; <span class="title function_">findString</span><span class="params">(String wanted)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> strings.stream()</span><br><span class="line">                  .filter(current -&gt;current.equals(wanted))</span><br><span class="line">                  .findFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以更优雅的处理值找不到的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> findString(wantedString)</span><br><span class="line">       .orElse(“Did notfind value” and wantedString);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Cache 入门</title>
    <url>/java/Java-%E7%BC%93%E5%AD%98%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="什么是缓存">什么是缓存</h2>
<p>术语缓存在计算机中无处不在。在应用程序设计的上下文中，它经常被用来描述应用程序开发人员利用单独的内存或低延迟的数据结构。缓存，用于临时存储或缓存信息的副本或引用，应用程序可能会在稍后的某个时间点重复使用，从而减轻重新访问或重新创建它的成本。</p>
<p>在 JCache 的上下文中，术语缓存描述了 Java 的技术开发人员使用缓存提供程序临时缓存 Java 对象。</p>
<h2 id="什么时候引入缓存">什么时候引入缓存</h2>
<p>引入缓存会提高系统复杂度，因为你要考虑缓存的失效、更新、一致性等问题。</p>
<p>冒着上述种种风险，仍能说服你引入缓存的理由，总结起来无外乎以下两种：</p>
<ul>
<li>为缓解 CPU 压力而做缓存：譬如把方法运行结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用，这可以节省 CPU 算力，顺带提升响应性能。</li>
<li>为缓解 I/O 压力而做缓存：譬如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩部件（如缓存中间件）的访问，顺带提升响应性能。</li>
</ul>
<p>请注意，缓存虽然是典型以空间换时间来提升性能的手段，但它的出发点是缓解 CPU 和 I/O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。这里的言外之意是如果可以通过增强 CPU、I/O 本身的性能（譬如扩展服务器的数量）来满足需要的话，那升级硬件往往是更好的解决方案，即使需要一些额外的投入成本，也通常要优于引入缓存后可能带来的风险。</p>
<h2 id="缓存设计模式">缓存设计模式</h2>
<h3 id="Cache-Aside">Cache Aside</h3>
<p>其中最简单、成本最低的 Cache Aside 模式是指：</p>
<ul>
<li>读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。</li>
<li>写数据时，先写数据源，然后失效（而不是更新）掉缓存。</li>
</ul>
<p>读数据方面一般没什么出错的余地，但是写数据时，就有必要专门强调两点：一是先后顺序是先数据源后缓存。试想一下，如果采用先失效缓存后写数据源的顺序，那一定存在一段时间缓存已经删除完毕，但数据源还未修改完成，此时新的查询请求到来，缓存未能命中，就会直接流到真实数据源中。这样请求读到的数据依然是旧数据，随后又重新回填到缓存中。当数据源的修改完成后，结果就成了数据在数据源中是新的，在缓存中是老的，两者就会有不一致的情况。另一点是应当失效缓存，而不是去尝试更新缓存，这很容易理解，如果去更新缓存，更新过程中数据源又被其他请求再次修改的话，缓存又要面临处理多次赋值的复杂时序问题。所以直接失效缓存，等下次用到该数据时自动回填，期间无论数据源中的值被改了多少次都不会造成任何影响。</p>
<p>Cache Aside 模式依然是不能保证在一致性上绝对不出问题的，否则就无须设计出 <a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/consensus/paxos.html">Paxos</a> 这样复杂的共识算法了。典型的出错场景是如果某个数据是从未被缓存过，请求会直接流到真实数据源中，如果数据源中的写操作发生在查询请求之后，结果回填到缓存之前，也会出现缓存中回填的内容与数据库的实际数据不一致的情况。但这种情况的概率是很低的，Cache Aside 模式仍然是以低成本更新缓存，并且获得相对可靠结果的解决方案。</p>
<h3 id="Read-Write-Through">Read/Write Through</h3>
<p>Write Through 将数据同时写入高速缓存和相应的主内存位置。缓存的数据允许按需快速检索，而主存储器中的相同数据可确保在发生崩溃，电源故障或其他系统中断时不会丢失任何内容。</p>
<p>尽管直写可以最大程度地减少数据丢失的风险，但是每个写操作必须执行两次，并且这种冗余需要时间。活动的应用程序必须等待，直到将每个数据块都写入主内存和高速缓存中，然后才能开始下一个操作。因此，“数据保险”是以牺牲系统速度为代价的。</p>
<p>直写是无法容忍数据丢失的应用程序（例如银行和医疗设备控制）中首选的数据存储方法。</p>
<h3 id="Write-Behind-Caching">Write Behind Caching</h3>
<p>回写在每次发生更改时，数据都会先写入高速缓存，但仅在指定的时间间隔或特定条件下，数据才会写入主存储中的相应位置。</p>
<h2 id="JSR107-JCache">JSR107 (JCache)</h2>
<p>JCache 是 Java 的缓存 API。它由 JSR107 定义。它定义了供开发人员使用的标准 Java 缓存 API 和供实现者使用的标准 SPI（“服务提供者接口”）。</p>
<p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit">标准定义文档</a></p>
<span id="more"></span>
<h3 id="JCache-核心概念">JCache 核心概念</h3>
<p>Java 的缓存 API 定义了五个核心接口：<code>CachingProvider</code>，<code>CacheManager</code>，<code>Cache</code>，<code>Entry</code>  和 <code>ExpiryPolicy</code>。</p>
<p><em><strong><code>CachingProvider</code></strong></em></p>
<p>定义了建立，配置，获取，管理和控制零个或多个 <code>CacheManager</code> 的机制。应用程序可以在运行期间访问和使用零个或多个 <code>CacheProvider</code>。</p>
<p><em><strong><code>CacheManager</code></strong></em><br>
定义在上下文中了建立，配置，获取，管理和控制零个或多个唯一命名的缓存的机制。 <code>CacheManager</code> 被单个 <code>CachingProvider</code> 拥有。</p>
<p><em><strong><code>Cache</code></strong></em><br>
是一个像 Map 一样的数据结构，它允许基于 Key 的临时储存。缓存被单个 <code>CacheManager</code> 拥有。</p>
<p><em><strong><code>Entry</code></strong></em><br>
是被 <code>Cache</code> 存储的单个 key-value 对，JCache 允许我们定义按值或按引用来存储条目。</p>
<p><em><strong><code>ExpiryPolicy</code></strong></em></p>
<p>每一个被 Cache 存储的 entry 都定义了存活时间，被称作过期持续时间。**缓存过期时间是可以动态设置的，在执行某些缓存操作后，缓存条目将在设置的时间后过期。**一旦这个过期时间到达，该条目就被认为是过期了。一旦过期，就会从缓存中驱逐出去，不能再访问，更新和删除条目。</p>
<ul>
<li>getExpiryForCreation() - 创建条目时的持续时间</li>
<li>getExpiryForAccess() - 条目被访问时的新持续时间</li>
<li>getExpiryForUpdate() - 条目被更新时的新持续时间</li>
</ul>
<p>另外，getExpiryForUpdate() 和 getExpiryForAccess() 也可能返回 null，这表示缓存实现应保留创建时这些操作的条目的有效期限不变。</p>
<h3 id="按值存储和按引用存储">按值存储和按引用存储</h3>
<p>条目（Entry）由每个缓存使用两种机制之一存储。</p>
<p><em><strong>默认的机制，称为值存储。</strong></em></p>
<p>指示实现使副本应用程序在将它们储存在 Cache 中之前提供键和值，之后在访问缓存时再返回新的条目副本。复制条目的目的是存储在缓存和从缓存中再次返回时应用程序继续变异键和值的状态，不会对缓存持有的条目造成副作用。</p>
<p>一个简单的方法实现可用于制作键和值的副本是 Java 序列化。</p>
<p><em><strong>替代和可选机制，称为引用存储。</strong></em></p>
<p>指示 Cache 实现简单地存储和返回对应用程序提供的键和值的引用，而不是按照按值存储方法的要求制作副本。如果应用程序稍后使用引用存储语义来改变提供给缓存的键或值，则突变的副作用对于从缓存访问条目的人来说是可见的，而应用程序不必更新缓存。</p>
<p>对于在 Java 堆上实现的缓存，引用存储是最快的存储技术。</p>
<h3 id="其它">其它</h3>
<p>除了定义核心接口， JCache 还为我们定义了：</p>
<ul>
<li>
<p>缓存无效时的读写集成定义</p>
<p>JCache 定义基本的配置，具体服务提供商可以提供相应的实现，以便：</p>
<p>配置 <code>isReadThrough</code> 为 <code>true</code> 时，当请求的值不在高速缓存中时，配置的 <code>cacheLoaderFactory</code> 提供从 <code>CacheLoader</code> 读取值的功能（通过高速缓存读取）<br>
配置 <code>isWriteThrough</code> 为 <code>true</code> 时，当从缓存中创建/更新/删除值时，配置的 <code>cacheWriterFactory</code> 提供将值写入 <code>CacheWriter</code> （通过缓存写入）</p>
</li>
<li>
<p>缓存条目监听器接口</p>
<p>我们可以注册条目不同事件的监听器在运行期或配置阶段，通过 <code>CacheEntryListenerConfiguration</code> 注册 <code>CacheEntryListener</code>。</p>
</li>
<li>
<p>缓存注解，为用户提供与缓存交互的类的方法拦截器处理，类定义在 <code>javax.cache.annotation</code> 包中</p>
<ul>
<li>@CacheDefaults - 类级别注解，定义类中使用的所有缓存相关注解的默认属性值，如缓存名称、缓存处理器、key 生成器</li>
<li>@CacheResult - 方法级别注解，标记方法使用参数生成的键缓存自身返回的结果。</li>
<li>@CachePut</li>
<li>@CacheRemove</li>
<li>@CacheRemoveAll</li>
</ul>
</li>
<li>
<p>监控管理</p>
<p><code>javax.cache.management</code> 包提供了用于缓存管理和统计的 <code>MXBean</code> 接口</p>
<p>默认情况下，管理和统计信息均处于禁用状态。 要在配置时将其打开，可以在 <code>MutableConfiguration</code> 上使用以下方法：</p>
<ul>
<li>setManagementEnabled(boolean enabled) 启用管理</li>
<li>setStatisticsEnabled(boolean enabled)  启用统计</li>
</ul>
</li>
</ul>
<h2 id="从-JCache-到-EhCache">从 JCache 到 EhCache</h2>
<p>使用 JCache 可以完成大部分的缓存操作，但是如果需要使用到 EhCache 的特性，则必须使用提供给程序的特定 API。</p>
<p>EhCache 的主要特性如下：</p>
<ul>
<li>**快速，简单。**EhCache 的线程机制是为大型高并发系统设计的，使用 EhCache 也不需要特别复杂的配置，很容易部署上线和运行。</li>
<li>**多种缓存策略。**提供 LRU、LFU 和 FIFO 缓存策略。支持基于 Cache 和 Element 的过期策略。</li>
<li>**缓存数据有两级。**内存和磁盘，因此无需担心容量问题。EhCache 为大数据存储做过优化。在大内存情况下，所有进程可以支持数百 GB 的吞吐，在单台虚拟机上可以支持多缓存管理器，还可以通过 Terracotta 服务器矩阵伸缩到数百个节点。</li>
<li>**缓存数据会在虚拟机重启的过程中写入磁盘。**EhCache 是第一个引入缓存持久化存储到开源 Java 缓存框架，缓存的数据可以在机器重启后从磁盘上重新获得，可以根据需要使用 cache.flush 方法将缓存刷到磁盘上面。</li>
<li><strong>可以通过 RMI、JMS、JGroups、可插入 API 等方式进行分布式缓存。</strong></li>
<li><strong>具有缓存和缓存管理器的侦听接口。</strong></li>
<li><strong>提供 Hibernate、Mysql 等框架的缓存实现。</strong></li>
</ul>
<p>下图是 EhCache 的架构图：</p>
<p><img data-src="../../images/cache/layered_architecture.png" alt="Image result for ehcache architecture diagram"></p>
<h3 id="使用-EhCache-作为-JCache-供应商">使用 EhCache 作为 JCache 供应商</h3>
<p>JCache 作为标准有很多的实现，我们这里主要以 EhCache 来展开学习，要想使用 EhCache 作为 JCache 的供应商很简单，我们只要将 EhCache 的 jar 包和 JCache 放在一起便可以使用。</p>
<p>通过 JCache 的接口，我们便可以操控缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CachingProvider</span> <span class="variable">provider</span> <span class="operator">=</span> Caching.getCachingProvider();  </span><br><span class="line"><span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> provider.getCacheManager();   </span><br><span class="line">MutableConfiguration&lt;Long, String&gt; configuration =</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MutableConfiguration</span>&lt;Long, String&gt;()  </span><br><span class="line">        .setTypes(Long.class, String.class)   </span><br><span class="line">        .setStoreByValue(<span class="literal">false</span>)   </span><br><span class="line">        .setExpiryPolicyFactory(CreatedExpiryPolicy.factoryOf(Duration.ONE_MINUTE));  </span><br><span class="line">Cache&lt;Long, String&gt; cache = cacheManager.createCache(<span class="string">&quot;jCache&quot;</span>, configuration); </span><br><span class="line">cache.put(<span class="number">1L</span>, <span class="string">&quot;one&quot;</span>); </span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(<span class="number">1L</span>); </span><br></pre></td></tr></table></figure>
<p>JCache 会从应用程序的类路径中检索默认的 <code>CachingProvider</code> 实现。但这必须保证类路径上只有一个 JCache 实现，否则必须指定具体的供应商名称，可以使用设置系统变量 <code>javax.cache.spi.CachingProvider</code> 或通过调用 <code>Caching.getCachingProvider(String)</code> 静态方法指定完整的类名称。</p>
<p>上述代码中，我们获取到缓存的供应器，并从中得到一个默认的 <code>CacheManager</code> 实例，使用不可用的配置类设置了键和值的类型，条目的存储类型，以及过期方案来生成一个名称为 JCache 的缓存对象，并向缓存中添加了一组数据，并使用键获取值。</p>
<p>JCache 提供了一组最小配置，非常适合内存缓存。但是 EhCache 在拓扑和功能方面提供了更强大的实现。</p>
<h3 id="从-JCache-配置访问基础-Ehcache-配置">从 JCache 配置访问基础 Ehcache 配置</h3>
<p>当以使用 JCache 创建了配置时，你任然可以访问底层的 EhCache <code>CacheRuntimeConfiguration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MutableConfiguration&lt;Long, String&gt; configuration = <span class="keyword">new</span> <span class="title class_">MutableConfiguration</span>&lt;&gt;();</span><br><span class="line">configuration.setTypes(Long.class, String.class);</span><br><span class="line">Cache&lt;Long, String&gt; cache = cacheManager.createCache(<span class="string">&quot;someCache&quot;</span>, configuration); </span><br><span class="line"></span><br><span class="line">CompleteConfiguration&lt;Long, String&gt; completeConfiguration = cache.getConfiguration(CompleteConfiguration.class); </span><br><span class="line"></span><br><span class="line">Eh107Configuration&lt;Long, String&gt; eh107Configuration = cache.getConfiguration(Eh107Configuration.class); </span><br><span class="line"></span><br><span class="line">CacheRuntimeConfiguration&lt;Long, String&gt; runtimeConfiguration = eh107Configuration.unwrap(CacheRuntimeConfiguration.class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们还可以使用 Ehcache CacheConfiguration 创建 JCache 缓存。</p>
<p>EhCache 不总是同意 JCache 的默认行为。两者在默认值上存在一定的差异。</p>
</blockquote>
<h3 id="使用编程的方式配置-EhCache">使用编程的方式配置 EhCache</h3>
<p>我们可以使用编程配置或 XML 来配置 EhCache，个人比较喜欢以编程的形式配置大多数不是很容易变动的配置，通过使用提供流畅 API 的构建器我们可以很容易完成配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> CacheManagerBuilder.newCacheManagerBuilder() </span><br><span class="line">    .withCache(<span class="string">&quot;preConfigured&quot;</span>,</span><br><span class="line">        CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class, ResourcePoolsBuilder.heap(<span class="number">10</span>))) </span><br><span class="line">    .build(); </span><br><span class="line">cacheManager.init(); </span><br><span class="line"></span><br><span class="line">Cache&lt;Long, String&gt; preConfigured =</span><br><span class="line">    cacheManager.getCache(<span class="string">&quot;preConfigured&quot;</span>, Long.class, String.class); </span><br><span class="line"></span><br><span class="line">Cache&lt;Long, String&gt; myCache = cacheManager.createCache(<span class="string">&quot;myCache&quot;</span>, </span><br><span class="line">    CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class, ResourcePoolsBuilder.heap(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">myCache.put(<span class="number">1L</span>, <span class="string">&quot;da one!&quot;</span>); </span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myCache.get(<span class="number">1L</span>); </span><br><span class="line"></span><br><span class="line">cacheManager.removeCache(<span class="string">&quot;preConfigured&quot;</span>); </span><br><span class="line"></span><br><span class="line">cacheManager.close(); </span><br></pre></td></tr></table></figure>
<p>这里的配置很清晰明了，具体配置我们可以查看配置参数查看。</p>
<h3 id="EhCache-存储层">EhCache 存储层</h3>
<p>我们可以配置 Ehcache 以使用各种数据存储区域。当缓存配置为使用多个存储区域时，这些区域将按层排列和管理。它们按层次结构组织，最低层（更远）称为权限层，其他层则是缓存层的一部分（更近，也称为近缓存）。缓存层本身可以由多个存储区域组成。最热门的数据保存在缓存层中，这通常不如权限级别那么丰富但速度更快。所有数据都保存在权限层中，这更慢但更丰富。</p>
<p>Ehcache 支持的数据存储包括：</p>
<p><em><strong>堆内存储</strong></em></p>
<p>利用 Java 的堆内 RAM 内存来存储缓存条目。此层使用与 Java 应用程序相同的堆内存，所有这些都必须由 JVM 垃圾收集器扫描。JVM 使用的堆空间越多，应用程序性能就越会受到垃圾收集暂停的影响。这个存储非常快，但通常是您最有限的存储资源。</p>
<p><em><strong>堆外存储</strong></em></p>
<p>大小受限于可用的 RAM 内存。不受 Java 垃圾收集（GC）的限制。速度非常快，但比堆内存储慢，因为数据必须在存储和重新访问时移入和移出 JVM 堆，移入移出对象可能涉及到对象的序列化和反序列化。</p>
<p><em><strong>磁盘存储</strong></em></p>
<p>利用磁盘（文件系统）来存储缓存条目。这种类型的存储资源通常非常丰富，但比基于 RAM 的存储要慢得多。对于使用磁盘存储的所有应用程序，建议使用快速专用磁盘来优化吞吐量。</p>
<p><em><strong>集群存储</strong></em></p>
<p>此数据存储是远程服务器上的缓存。远程服务器可以可选地提供具有高可用性的故障转移服务器。由于集群存储会因网络延迟以及建立客户端/服务器一致性等因素而导致性能下降，这个层本质上比本地堆外存储慢。</p>
<p><img data-src="../../images/cache/EhcacheTerminology.png" alt="EhcacheTerminology"></p>
<h3 id="用户管理的缓存">用户管理的缓存</h3>
<p>用户管理的缓存为我们提供了一种直接配置缓存的简单方法，而无需设置或使用 CacheManager 的复杂性。是否使用 <code>UserManagedCache</code> 而不是 CacheManager 的选择通常取决于我们是否需要 CacheManager 的所有内置功能。如果缓存要求相对简单，并且不需要 CacheManager 的全部功能，则可以考虑使用 UserManagedCache。</p>
<p>使用 UserManagedCache 的典型方案有：方法本地缓存，线程本地缓存或缓存生命周期短于应用程序生命周期的任何其他位置。</p>
<p><a target="_blank" rel="noopener" href="http://www.ehcache.org/documentation/3.5/usermanaged.html">使用介绍</a></p>
<h2 id="Hibernate-缓存">Hibernate 缓存</h2>
<p>数据库抽象层（如ORM（对象 - 关系映射）框架）的一个优点是它们能够透明地缓存从底层存储中检索的数据。这有助于消除频繁访问数据的数据库访问成本。</p>
<p>在运行时，Hibernate 处理将数据移入和移出二级缓存以响应 Session 执行的操作，该操作充当持久数据的事务级缓存。<strong>一旦实体被管理，该对象就会被添加到当前持久化上下文（EntityManager 或 Session）的内部缓存中。持久化上下文也称为第一级缓存，默认情况下已启用。</strong></p>
<p>但由于 Hibernate 会话（session）绑定到当前正在运行的逻辑事务，所以一旦事务结束，该会话也将被销毁，会话中持有的上下文也会消失。</p>
<p>适当的缓存解决方案必须跨越多个 Hibernate 会话，这就是 Hibernate 也支持附加的二级缓存的原因。 **二级缓存是绑定到 SessionFactory 域的生命周期，意味着它由使用相同会话工厂创建的所有会话共享，仅在关闭 SessionFactory 时（通常是在应用程序关闭时）才销毁。**二级缓存主要基于实体，也支持可选的查询缓存解决方案。</p>
<blockquote>
<p>Hibernate 缓存不了解其他应用程序对持久性存储所做的更改。比如 EhCache 管理的缓存。要解决此限制，可以在二级缓存区域级别配置 TTL（生存时间）保留策略，以便底层缓存条目定期到期。</p>
</blockquote>
<h3 id="配置二级缓存">配置二级缓存</h3>
<p>Hibernate 可以与各种缓存提供程序集成，以便在特定会话的上下文 (session) 之外缓存数据。要配置启用二级缓存，则需提供 <code>RegionFactory</code> 的实现类。</p>
<h4 id="RegionFactory">RegionFactory</h4>
<p><code>RegionFactory</code> 是 <code>Region</code> 的工厂类，Region 不代表缓存中的特定概念，它只是定义一些具有共同特征的基本合同，而与打算在该区域内存储的数据类型无关。更具体的子类型是 DomainDataRegion（存储实体，集合和自然 ID 数据）和 DirectAccessRegion（存储查询结果和时间戳数据）。</p>
<p><code>org.hibernate.cache.spi.RegionFactory</code> 定义了 Hibernate 与可插拔缓存提供程序之间的集成。Hibernate 二级缓存设计为让我们感觉不到所使用的实际缓存，SPI（服务提供者接口）为缓存实现者定义了接口，Hibernate 只需要提供 org.hibernate.cache.spi.RegionFactory 接口的实现，该接口封装了特定于实际缓存提供者的所有细节。基本上，它充当 Hibernate 和缓存提供者之间的桥梁。Hibernate 内置支持 Java 缓存标准 <code>JCache</code> 以及两个流行的缓存库：<code>Ehcache</code> 和 <code>Infinispan</code>。</p>
<h4 id="缓存配置属性">缓存配置属性</h4>
<p>除了提供程序特定的配置之外，集成的 Hibernate 端还有许多配置选项可控制各种缓存行为：</p>
<p><em><strong><code>hibernate.cache.use_second_level_cache</code></strong></em></p>
<p>整体启用或禁用二级缓存。默认情况下，如果当前配置的 RegionFactory 不是 <code>NoCachingRegionFactory</code>，则将启用第二级缓存。否则，将禁用二级缓存。</p>
<p><em><strong><code>hibernate.cache.use_query_cache</code></strong></em></p>
<p>启用或禁用查询结果的二级缓存。默认值为 false。</p>
<p><em><strong><code>hibernate.cache.query_cache_factory</code></strong></em></p>
<p>查询结果缓存由特殊的规则处理，该规则定义了数据的实效策略。默认实现是不失效，适合用于对数据要求松散的应用。或者我们可以指定自己的规则。自定义的规则只需要实现  <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/cache/spi/QueryCacheFactory.html"><code>QueryCacheFactory</code></a> 接口。hibernate 默认内置的是 <code>StandardQueryCacheFactory</code>。</p>
<p><em><strong><code>hibernate.cache.auto_evict_collection_cache</code></strong></em></p>
<p>当关联仅从拥有方改变时，启用或禁用双向关联的集合缓存条目的自动驱逐。默认情况下禁用该选项，因为它会跟踪关联状态并对性能产生影响。但是，如果您的应用程序不管理高速缓存集合端的双向关联的双方，则替代方法是在该集合缓存中保留陈旧数据。</p>
<blockquote>
<p>使用陈旧数据时很可能会出现数据不一致的情况，比如实体存在于缓存中但不存在于数据库中，在做级联删除时，会报 <code>EntityNotFoundException</code> 异常，可以在级联删除的集合上配置 <code>@NotFound(action = NotFoundAction.IGNORE)</code> 忽略该异常或者启用该选项。</p>
</blockquote>
<p><em><strong><code>hibernate.cache.use_reference_entries</code></strong></em></p>
<p>允许将实体引用直接存储到二级缓存中，以用于只读或不可变实体。使用引用存储缓存的好处是我们不用显式的维护缓存，缓存更新时直接反映给调用者。缺点是该缓存只可用于只读状态，否则对象逸出，会很难控制。</p>
<p><em><strong><code>hibernate.cache.default_cache_concurrency_strategy</code></strong></em></p>
<p>在 hibernate 二级缓存中，可以对所有区域进行不同的配置，包括在访问特定区域时要使用的并发策略。此设置允许定义要使用的默认策略。有效值包括：</p>
<ul>
<li>read-only</li>
<li>read-write</li>
<li>nonstrict-read-write</li>
<li>transactional</li>
</ul>
<p><em><strong><code>hibernate.cache.keys_factory</code></strong></em></p>
<p>当将条目 (entries) 作为键值对存储到二级缓存中时，标识符可以包装为元组 &lt;实体类型，租户，标识符&gt; 以确保唯一性，以防第二级缓存将所有实体存储在单个空间中。这些元组然后用作高速缓存中的键。当前，仅当 <code>Infinispan</code> 配置为第二级缓存实现时才支持此属性。有效值为：</p>
<ul>
<li>default（将标识符包装在元组中）</li>
<li>simple（使用标识符作为键，无需任何包装）</li>
<li>实现 <code>org.hibernate.cache.spi.CacheKeysFactory</code> 的完全限定的类名</li>
</ul>
<p><em><strong><code>hibernate.cache.use_structured_entries</code></strong></em></p>
<p>如果为 <code>true</code>，则强制 Hibernate 以更人性化的格式将数据存储在二级缓存中。如果希望能够直接在缓存中“浏览”数据，则可能会很有用，但确实会对性能产生影响。</p>
<h3 id="配置二级缓存映射">配置二级缓存映射</h3>
<p>可以通过 JPA 注解或 XML 描述符或使用特定于 Hibernate 的映射文件来配置缓存映射。默认情况下，实体不是二级缓存的一部分，我们可以通过配置 <code>javax.persistence.sharedCache.mode</code> 来映射缓存。该配置有四个选项：</p>
<p><em><strong><code>ENABLE_SELECTIVE</code></strong></em></p>
<p>默认也是推荐的选项。除非明确标记为可缓存（使用 <code>@Cacheable</code> 注解），否则不会缓存实体。</p>
<p><em><strong><code>DISABLE_SELECTIVE</code></strong></em></p>
<p>除非明确标记为不可缓存 <code>@Cachable</code> 注解 value 设置为 false，否则实体将被缓存。</p>
<p><em><strong><code>ALL</code></strong></em></p>
<p>即使标记为不可缓存，实体也始终被缓存。</p>
<p><em><strong><code>NONE</code></strong></em></p>
<p>即使标记为可缓存，也不会缓存任何实体。此选项可以完全禁用二级缓存。</p>
<p>默认情况下使用的缓存并发策略可以通过以下方式全局设置 <code>hibernate.cache.default_cache_concurrency_strategy</code> 来配置属性，配置选项如下：</p>
<p><em>read-only</em></p>
<p>如果您的应用程序需要读取但不修改持久化类的实例，则只读缓存是最佳选择。应用程序仍然可以删除实体，这些更改应该反映在二级缓存中，以便缓存不提供过时的实体。实现可以基于实体的不变性来使用性能优化。</p>
<p><em>read-write</em></p>
<p>如果应用程序需要更新数据，则读写缓存可能是合适的。此策略提供对单个实体的一致访问，但不提供可序列化的事务隔离级别；实现可以基于实体的不变性来使用性能优化。</p>
<p><em>nonstrict-read-write</em></p>
<p>与读写策略类似，但在并发访问实体时可能偶尔会出现过时读取。如果应用程序很少同时更新相同的数据并且不需要严格的事务隔离，则可以选择此策略。实现可以使用利用宽松一致性保证的性能优化。</p>
<p><em>transactional</em></p>
<p>提供可序列化的事务隔离级别。</p>
<blockquote>
<p>建议不要使用全局设置，而是基于每个实体、方法或集合字段上定义缓存并发策略。为此，请使用 <code>@ org.hibernate.annotations.Cache</code> 注解。</p>
</blockquote>
<p>该注解有三个属性：</p>
<p><em>usage</em></p>
<p>定义 <code>CacheConcurrencyStrategy</code>。</p>
<p><em>region</em></p>
<p>定义存储条目的缓存区域。对于每个实体类，Hibernate 将使用单独的缓存区域来存储该类的实例状态。区域名称是完全限定的类名。</p>
<p><em>include</em></p>
<p>是否（lazy）延迟加载属性应包含在二级缓存中。默认值是所有延迟属性都可缓存。另一个可能的值是非延迟，因此延迟属性不可缓存。</p>
<h3 id="实体继承和二级缓存映射">实体继承和二级缓存映射</h3>
<p>传统上，当使用实体继承时，Hibernate 要求实体层次结构完全缓存或根本不缓存。因此，如果要缓存属于给定实体层次结构的子类，则 JPA <code>@Cacheable</code> 和特定于 Hibernate 的 <code>@Cache</code> 注解必须仅在根实体级别声明。</p>
<blockquote>
<p>Cacheable 注解的值由子类继承；可以通过在子类上指定 Cacheable 来覆盖它。从 Hibernate ORM 5.3 开始，您现在可以在子类级别覆盖基类 @Cacheable 或 @Cache 定义。但是，Hibernate 缓存并发策略（例如，只读，非严格读写，读写，事务）仍然在根实体级别定义，并且不能被覆盖。</p>
</blockquote>
<h3 id="管理缓存数据">管理缓存数据</h3>
<p>传统上，Hibernate 定义了 <code>CacheMode</code> 枚举来描述与缓存数据交互的方式。 JPA 通过存储（<code>CacheStoreMode</code>）和检索（<code>CacheRetrieveMode</code>）分割缓存模式。两者的关系如下表：</p>
<table>
<thead>
<tr>
<th>Hibernate</th>
<th>JPA</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CacheMode.NORMAL</td>
<td><code>CacheStoreMode.USE</code> 和 <code>CacheRetrieveMode.USE</code></td>
<td>默认。from/into 缓存读取/写入数据</td>
</tr>
<tr>
<td>CacheMode.REFRESH</td>
<td><code>CacheStoreMode.REFRESH</code> 和 <code>CacheRetrieveMode.BYPASS</code></td>
<td>不从缓存中读取，而是在从数据库加载时写入缓存</td>
</tr>
<tr>
<td>CacheMode.PUT</td>
<td><code>CacheStoreMode.USE</code> 和 <code>CacheRetrieveMode.BYPASS</code></td>
<td>不从缓存中读取，而是在从数据库读取时写入缓存</td>
</tr>
<tr>
<td>CacheMode.GET</td>
<td><code>CacheStoreMode.BYPASS</code> 和 <code>CacheRetrieveMode.USE</code></td>
<td>从缓存中读取，但不写入缓存</td>
</tr>
<tr>
<td>CacheMode.IGNORE</td>
<td><code>CacheStoreMode.BYPASS</code> 和 <code>CacheRetrieveMode.BYPASS</code></td>
<td>不从缓存读取/写入数据</td>
</tr>
</tbody>
</table>
<p>设置缓存模式可以在直接加载实体或执行查询时完成。</p>
<ul>
<li>使用 JPA 自定义缓存模式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; hints = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">hints.put( <span class="string">&quot;javax.persistence.cache.retrieveMode&quot;</span> , CacheRetrieveMode.USE );</span><br><span class="line">hints.put( <span class="string">&quot;javax.persistence.cache.storeMode&quot;</span> , CacheStoreMode.REFRESH );</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> entityManager.find( Person.class, <span class="number">1L</span> , hints);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Hibernate 自定义缓存模式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setCacheMode( CacheMode.REFRESH );</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> session.get( Person.class, <span class="number">1L</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Spring Data JPA 自定义缓存模式（1.10 版本之后）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@QueryHints(value = &#123;</span></span><br><span class="line"><span class="meta">    @QueryHint(name = &quot;javax.persistence.cache.retrieveMode&quot;, value = &quot;USE&quot;),</span></span><br><span class="line"><span class="meta">    @QueryHint(name = &quot;javax.persistence.cache.storeMode&quot;, value = &quot;REFRESH&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Optional&lt;Person&gt; <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure>
<p>查询缓存，集合缓存，和缓存统计以后再来补充。</p>
<h2 id="Spring-Boot-使用-EhCache">Spring Boot 使用 EhCache</h2>
<p>个人使用 Gradle 管理项目依赖，以下所述依赖皆是以基于Groovy 的特定于域的语言（DSL）定义。</p>
<h3 id="仅使用缓存">仅使用缓存</h3>
<p>Spring Boot 使用缓存非常简单，我们只需要导入所需要的包即可开箱即用，如果我们仅仅想使用缓存，则直接引入：<code>org.springframework.boot:spring-boot-starter-cache</code> starter 便可使用。</p>
<p>在配置类或启动类上加入  <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/EnableCaching.html"><code>@EnableCaching</code></a> 注解，该注解会触发一个后处理器（post processor）去检测每个 Spring Bean 上是否存在公共方法的缓存注解。如果找到这样的注解，则自动创建代理以拦截方法调用并相应地处理缓存行为。</p>
<p>此后处理器管理的注解是 <code>Cacheable</code>，<code>CachePut</code> 和 <code>CacheEvict</code>。Spring Boot 会自动配置合适的 <code>CacheManager</code> 作为相关缓存的提供程序。如果只引入了该包，则默认只会使用 Spring 上下文 <strong><code>ConcurrentHashMap</code></strong> 结构来存储缓存，这完全符合 JCache 的标准。</p>
<p>如果当前上下文中存在 JSR-107 API，即 <code>javax.cache:cache-api</code> 该 jar 包，将额外的为 JSR-107 API 注解的 bean 创建代理，这些注解是 <code>@CacheResult</code>，<code>@CachePut</code>，<code>@CacheRemove</code> 和 <code>@CacheRemoveAll</code>。</p>
<h3 id="使用-JCache-来构建-Hibernate-二级缓存">使用 JCache 来构建 Hibernate 二级缓存</h3>
<p>要使用 JCache 的内置集成，您需要将 <code>hibernate-jcache</code> 模块 <code>org.hibernate:hibernate-jcache</code> jar 集成进去。此外，还需要添加 JCache 实现。</p>
<p><code>hibernate-jcache</code> 模块定义了以下区域工厂：<code>JCacheRegionFactory</code>。</p>
<p>要使用该 <code>JCacheRegionFactory</code>，只需配置该属性为：<code>hibernate.cache.region.factory_class: org.hibernate.cache.jcache.JCacheRegionFactory</code>。</p>
<p>JCache 要求共享相同 URI 和类加载器的 CacheManagers 在 JVM 中是唯一的。如果未指定其他属性，JCacheRegionFactory 将加载默认的 JCache 提供程序并创建默认的 CacheManager。同样的，将使用默认的 <code>javax.cache.configuration.MutableConfiguration</code> 创建缓存。</p>
<p>为了控制使用哪个提供程序为 CacheManager 和 Caches 指定配置，您可以使用以下两个属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;hibernate.javax.cache.provider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;org.ehcache.jsr107.EhcacheCachingProvider&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;hibernate.javax.cache.uri&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;file:/path/to/ehcache.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-EhCache-2-0-构建-Hibernate-二级缓存">使用 EhCache 2.0 构建 Hibernate 二级缓存</h3>
<p>使用 Ehcache 的内置集成要求我们引入 <code>org.hibernate:hibernate-ehcahe</code> jar 作为依赖。</p>
<p>同样的我们需要配置 RegionFactory 为：<code>hibernate.cache.region.factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory</code> 。</p>
<p>强制 Hibernate 使用单个 Ehcache CacheManager：<code>hibernate.cache.region.factory_class: org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory</code> 。</p>
<h3 id="使用-EhCache-3-0-构建-Hibernate-二级缓存">使用 EhCache 3.0 构建 Hibernate 二级缓存</h3>
<p>使用 EhCache 3.0 时，hibernate 并没有默认的模块支持。但是我们可以通过 JCache 来指定具体的实现完成。</p>
<p>我们同时引入 <code>org.ehcache:ehcache</code> 和 <code>org.hibernate:hibernate-jcache</code>，这里我们并没有指明具体版本，因为我们使用 spring boot starter 管理的版本，具体可以查看自己 spring boot starter 的版本和依赖版本。</p>
<p>我们可以指定服务提供者 <code>hibernate.javax.cache.provider</code> 来完成配置。但是 <code>JCacheRegionFactory</code> 会使用默认的 <code>MutableConfiguration</code> 来创建 Cache，如果我们需要使用 EhCache 的配置来定义缓存，我们需要自己定义 RegionFactory 并以此作为 RegionFactory 配置。</p>
<p>为了防止 JCacheRegionFactory 自动创建缓存，我们可以按如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoDefaultJCacheRegionFactory</span> <span class="keyword">extends</span> <span class="title class_">JCacheRegionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCEPTION_MESSAGE</span> <span class="operator">=</span> <span class="string">&quot;All Hibernate caches should be created upfront. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;Please update CacheConfiguration.java to add&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Cache&lt;Object, Object&gt; <span class="title function_">createCache</span><span class="params">(String regionName, Properties properties, CacheDataDescription</span></span><br><span class="line"><span class="params">        metadata)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(EXCEPTION_MESSAGE + <span class="string">&quot; &quot;</span> + regionName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后指定二级缓存 CacheManager 的创建方法，并使用当前的 CalssLoader，修复了 Spring Boot 2.0.3 中引入的 Spring 类加载器问题。 这允许对 ehcache 使用相同的类加载器，包括 Spring Cache 抽象和 Hibernate  2nd 级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanClassLoaderAwareJCacheRegionFactory</span> <span class="keyword">extends</span> <span class="title class_">NoDefaultJCacheRegionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> CacheManager <span class="title function_">getCacheManager</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(classLoader, <span class="string">&quot;Please set Spring&#x27;s classloader in the setBeanClassLoader &quot;</span> +</span><br><span class="line">            <span class="string">&quot;method before using this class in Hibernate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">CachingProvider</span> <span class="variable">cachingProvider</span> <span class="operator">=</span> getCachingProvider(properties);</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheManagerUri</span> <span class="operator">=</span> getProp(properties, CONFIG_URI);</span><br><span class="line"></span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> getUri(cachingProvider, cacheManagerUri);</span><br><span class="line">        <span class="type">CacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> cachingProvider.getCacheManager(uri, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To prevent some class loader memory leak this might cause</span></span><br><span class="line">        setBeanClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> URI <span class="title function_">getUri</span><span class="params">(CachingProvider cachingProvider, String cacheManagerUri)</span> &#123;</span><br><span class="line">        URI uri;</span><br><span class="line">        <span class="keyword">if</span> (cacheManagerUri != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                uri = <span class="keyword">new</span> <span class="title class_">URI</span>(cacheManagerUri);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CacheException</span>(<span class="string">&quot;Couldn&#x27;t create URI from &quot;</span> + cacheManagerUri, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri = cachingProvider.getDefaultURI();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method must be called from a Spring Bean to get the classloader.</span></span><br><span class="line"><span class="comment">     * For example: BeanClassLoaderAwareJCacheRegionFactory.setBeanClassLoader(this.getClass().getClassLoader());</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader The Spring classloader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">        BeanClassLoaderAwareJCacheRegionFactory.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以使用 EhCache 的配置来创建缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> javax.cache.configuration.Configuration&lt;Object, Object&gt; jcacheConfiguration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheConfiguration</span><span class="params">(ApplicationProperties applicationProperties)</span> &#123;</span><br><span class="line">        BeanClassLoaderAwareJCacheRegionFactory.setBeanClassLoader(<span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">        ApplicationProperties.Cache.<span class="type">Ehcache</span> <span class="variable">ehcache</span> <span class="operator">=</span></span><br><span class="line">            applicationProperties.getCache().getEhcache();</span><br><span class="line"></span><br><span class="line">        <span class="type">CacheEventListenerConfigurationBuilder</span> <span class="variable">cacheEventListenerConfiguration</span> <span class="operator">=</span> CacheEventListenerConfigurationBuilder</span><br><span class="line">            .newEventListenerConfiguration(<span class="keyword">new</span> <span class="title class_">CacheListener</span>(applicationProperties), EventType.CREATED, EventType.UPDATED, EventType.EVICTED, EventType.EXPIRED, EventType.REMOVED)</span><br><span class="line">            .unordered().asynchronous();</span><br><span class="line"></span><br><span class="line">        jcacheConfiguration = Eh107Configuration.fromEhcacheCacheConfiguration(</span><br><span class="line">            CacheConfigurationBuilder.newCacheConfigurationBuilder(Object.class, Object.class,</span><br><span class="line">                ResourcePoolsBuilder.heap(ehcache.getMaxEntries()))</span><br><span class="line">                .add(<span class="keyword">new</span> <span class="title class_">Jsr107CacheConfiguration</span>(ConfigurationElementState.ENABLED, ConfigurationElementState.ENABLED))</span><br><span class="line">                .add(cacheEventListenerConfiguration)</span><br><span class="line">                .withExpiry(ExpiryPolicyBuilder.timeToLiveExpiration(Duration.ofSeconds(ehcache.getTimeToLiveSeconds())))</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JCacheManagerCustomizer <span class="title function_">cacheManagerCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cm -&gt; &#123;</span><br><span class="line">         cm.createCache(com.zeral.domain.User.class.getName(), jcacheConfiguration);</span><br><span class="line">         cm.createCache(com.auo.spc.domain.User.class.getName() + <span class="string">&quot;.authorities&quot;</span>, jcacheConfiguration);</span><br><span class="line">         <span class="comment">// application-needle-ehcache-add-entry</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用了堆内存储，并指定了每个域最大缓存条目数，指定了缓存键和值的类型，以及过期策略，并开启了监控，配置了缓存监听器。</p>
<p>这里我们并没有使用 Hibernate 的 <code>@Cacheable</code> 来显示指明需要缓存哪里实体或集合，而是手动的通过调用 cacheManager 创建了基于 Ehcache 配置的缓存，<code>JCacheManagerCustomizer</code> 回掉函数允许我们在 Spring Boot 根据当前环境服务提供者 JCacheRegionFactory 创建缓存管理器时做一些额外的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">jCacheCacheManager</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="type">CacheManager</span> <span class="variable">jCacheCacheManager</span> <span class="operator">=</span> createCacheManager();</span><br><span class="line">   List&lt;String&gt; cacheNames = <span class="built_in">this</span>.cacheProperties.getCacheNames();</span><br><span class="line">   <span class="keyword">if</span> (!CollectionUtils.isEmpty(cacheNames)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String cacheName : cacheNames) &#123;</span><br><span class="line">         jCacheCacheManager.createCache(cacheName, getDefaultCacheConfiguration());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   customize(jCacheCacheManager);</span><br><span class="line">   <span class="keyword">return</span> jCacheCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hibernate-二级缓存如何工作">Hibernate 二级缓存如何工作</h2>
<p>每当要加载实体时，都会触发 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/event/spi/LoadEvent.html">LoadEevent</a>，并且 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/event/internal/DefaultLoadEventListener.html">DefaultLoadEventListener</a> 对其进行如下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> loadFromSessionCache( event,</span><br><span class="line">    keyToLoad, options );</span><br><span class="line"><span class="keyword">if</span> ( entity == REMOVED_ENTITY_MARKER ) &#123;</span><br><span class="line">    LOG.debug(<span class="string">&quot;Load request found matching entity</span></span><br><span class="line"><span class="string">        in context, but it is scheduled for removal;</span></span><br><span class="line"><span class="string">        returning null&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( entity == INCONSISTENT_RTN_CLASS_MARKER ) &#123;</span><br><span class="line">    LOG.debug(<span class="string">&quot;Load request found matching entity</span></span><br><span class="line"><span class="string">        in context, but the matched entity was of</span></span><br><span class="line"><span class="string">        an inconsistent return type;</span></span><br><span class="line"><span class="string">        returning null&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( entity != <span class="literal">null</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( traceEnabled ) &#123;</span><br><span class="line">        LOG.tracev(<span class="string">&quot;Resolved object in &quot;</span></span><br><span class="line">            + <span class="string">&quot;session cache: &#123;0&#125;&quot;</span>,</span><br><span class="line">            MessageHelper.infoString( persister,</span><br><span class="line">                event.getEntityId(),</span><br><span class="line">                event.getSession().getFactory() )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">entity = loadFromSecondLevelCache( event,</span><br><span class="line">    persister, options );</span><br><span class="line"><span class="keyword">if</span> ( entity != <span class="literal">null</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( traceEnabled ) &#123;</span><br><span class="line">        LOG.tracev(<span class="string">&quot;Resolved object in &quot;</span></span><br><span class="line">            + <span class="string">&quot;second-level cache: &#123;0&#125;&quot;</span>,</span><br><span class="line">            MessageHelper.infoString( persister,</span><br><span class="line">                event.getEntityId(),</span><br><span class="line">                event.getSession().getFactory() )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( traceEnabled ) &#123;</span><br><span class="line">        LOG.tracev(<span class="string">&quot;Object not resolved in &quot;</span></span><br><span class="line">            + <span class="string">&quot;any cache: &#123;0&#125;&quot;</span>,</span><br><span class="line">            MessageHelper.infoString( persister,</span><br><span class="line">                event.getEntityId(),</span><br><span class="line">                event.getSession().getFactory() )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    entity = loadFromDatasource( event, persister,</span><br><span class="line">        keyToLoad, options );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 <code>doLoad</code> 方法协调加载给定实体的工作。首先，尝试从会话级缓存中加载实体。如果在此处找不到，再尝试从二级缓存加载。最后，尝试直接从数据源加载它。</p>
<h3 id="二级缓存内部">二级缓存内部</h3>
<p>实体被作为 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/cache/spi/entry/CacheEntry.html"><em>CacheEntry</em></a> 存储，实体 <em>水合 (hydrated)</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 状态用于创建缓存条目值。</p>
<h4 id="水合">水合</h4>
<p>在 Hibernate 中，<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/persister/entity/Loadable.html#hydrate">水合作用</a> 是将 <em>JDBC ResultSet</em> 转换为由原始值组成的数组的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] values = persister.hydrate(</span><br><span class="line">    rs, id, object,</span><br><span class="line">    rootPersister, cols, eagerPropertyFetch, session</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>水合状态以 EntityEntry 对象的形式保存在当前运行的持久化上下文中，该对象封装了加载时的实体快照。然后通过以下方式使用水合状态：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://vladmihalcea.com/the-anatomy-of-hibernate-dirty-checking/">默认脏检查机制</a>，它将当前实体数据与加载时的快照比较</li>
<li>二级缓存，其缓存项是根据加载时实体快照构建的</li>
</ul>
<p>反向操作称为<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/persister/entity/AbstractEntityPersister.html#dehydrate">脱水</a>，它将实体状态复制到 <em>INSERT</em> 或 <em>UPDATE</em> 语句中。</p>
<h4 id="二级缓存键">二级缓存键</h4>
<p>键 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/cache/spi/CacheKey.html">CacheKey</a> 在之前介绍过，默认会将标识符封装在元组中构建。</p>
<h4 id="二级缓存值元素">二级缓存值元素</h4>
<p>二级缓存值元素使用拆解的水合状态构建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">CacheEntry</span> <span class="variable">entry</span> <span class="operator">=</span> persister.buildCacheEntry(entity, hydratedState, version, session);</span><br></pre></td></tr></table></figure>
<p>水合状态在存储到 CacheEntry 中之前先进行分解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.disassembledState = TypeHelper.disassemble(</span><br><span class="line">    state, </span><br><span class="line">    persister.getPropertyTypes(),</span><br><span class="line">    persister.isLazyPropertiesCacheable() ? <span class="literal">null</span> : persister.getPropertyLaziness(),</span><br><span class="line">    session,</span><br><span class="line">    owner</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下来会根据配置来选择是否结构化存储值，其中：</p>
<ul>
<li>不存储 id（主键）它作为缓存键的一部分存储</li>
<li>瞬态（Transient）属性不存储</li>
<li>集合不存储</li>
<li>非关联属性值以其原始格式存储</li>
<li>ToOne 关联仅存储 id（外键）</li>
</ul>
<p>我们必须明确指出集合（OneToMany 或 ManyToMany 关联）是可缓存的，否则就不会缓存。</p>
<p>实际上，Hibernate 将集合存储在单独的缓存区域中，每个集合一个。区域名称是完全限定的类名称加上集合属性的名称。如上诉代码手动添加的用户角色关联缓存。</p>
<h3 id="总结-4">总结</h3>
<p>二级缓存是关系数据缓存，因此它以规范化形式存储数据，并且每个实体更新仅影响一个缓存条目。由于在二级缓存条目中未实现实体关联，因此无法读取整个实体图（entity graph）。</p>
<p>聚合的实体图以使写入操作复杂化为代价，但为读取操作提供了更好的性能。如果未对缓存的数据进行规范化并将其散布在各种聚合模型中，则实体更新将不得不修改多个缓存项，从而影响写入操作的性能。</p>
<p>由于它反映了基础关系数据，因此二级缓存提供了各种并发策略机制，因此我们可以平衡读取性能和保证一致性。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>水合，最初是一个术语，表示从 DB 中填充实例化但为空的值-对象/模型。在给某物补水时，例如干无花果，该物质的本质在那里，但缺乏饱满感。这就是“水合”对象时发生的事情。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Cache</tag>
        <tag>EhCache</tag>
      </tags>
  </entry>
  <entry>
    <title>替代 Java 中繁琐的 If 语句</title>
    <url>/java/%E6%9B%BF%E4%BB%A3-Java-%E4%B8%AD%E7%B9%81%E7%90%90%E7%9A%84-If-%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="案例分析">案例分析</h2>
<p>我们经常遇到涉及很多条件的业务逻辑，每个都需要不同的处理。我们以 Calculator 类为例。我们将有一个方法，它接受两个数字和一个运算符作为输入，并根据操作返回结果：</p>
  <span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String operator)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a + b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;multiply&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a * b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;divide&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a / b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;subtract&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 switch 语句实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateUsingSwitch</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String operator)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">        result = a + b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// other cases    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在典型的开发中，if 语句可能会变得更大，更复杂。此外，当存在复杂条件时，switch 语句不适合。</p>
<p>嵌套决策结构的另一个副作用是它们变得难以管理。例如，如果我们需要添加一个新的运算符，我们必须添加一个新的 if 语句并实现该操作。</p>
<h2 id="重构">重构</h2>
<p>让我们探索替代选项，将上面的复杂if语句替换为更简单和易于管理的代码。</p>
<ul>
<li>
<h3 id="工厂类">工厂类</h3>
</li>
</ul>
<p>很多时候我们遇到决策结构，最终在每个分支中执行类似的操作。这提供了提取工厂方法的机会，该工厂方法返回给定类型的对象并基于具体对象行为执行操作。<br>
对于上述用例，我们定义一个 Operation 接口，它仅有一个 apply 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法接受两个数字，输出结果。让我们定义一个类来执行加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Addition</span> <span class="keyword">implements</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现一个工厂类，它根据给定的运算符返回 Operation 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Operation&gt; operationMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        operationMap.put(<span class="string">&quot;add&quot;</span>, <span class="keyword">new</span> <span class="title class_">Addition</span>());</span><br><span class="line">        operationMap.put(<span class="string">&quot;divide&quot;</span>, <span class="keyword">new</span> <span class="title class_">Division</span>());</span><br><span class="line">        <span class="comment">// more operations</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Operation&gt; <span class="title function_">getOperation</span><span class="params">(String operator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(operationMap.get(operator));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，在 Calculator 类中，我们可以查询工厂以获取相关操作并应用源数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateUsingFactory</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String operator)</span> &#123;</span><br><span class="line">    <span class="type">Operation</span> <span class="variable">targetOperation</span> <span class="operator">=</span> OperatorFactory</span><br><span class="line">        .getOperation(operator)</span><br><span class="line">        .orElseThrow(() -&gt; nwe <span class="title function_">IllegalArgumentException</span><span class="params">(<span class="string">&quot;Invalid Operator&quot;</span>)</span>);</span><br><span class="line">    <span class="keyword">return</span> targetOperation.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们已经看到了如何将责任委托给工厂类提供的松散耦合对象。但是有可能嵌套的 if 语句只是转移到了工厂类，这违背了我们的目的。<br>
或者，我们可以在 Map 中维护一个对象存储库，可以查询该存储库以进行快速查找。</p>
<ul>
<li>
<h3 id="使用枚举">使用枚举</h3>
除了使用 Map 之外，我们还可以使用 Enum 来标记特定的业务逻辑。之后，我们可以在嵌套的 if 语句或 switch case 语句中使用它们。或者，我们也可以将它们用作对象的工厂并制定策略以执行相关的业务逻辑。<br>
这也会减少嵌套 if 语句的数量，并将责任委托给单个 Enum 值。<br>
让我们看如何实现它，首先，定义一个枚举：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    ADD, MULTIPLY, SUBTRACT, DIVIDE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以观察到，这些值是不同运算符的标签，将进一步用于计算。我们总是可以选择在嵌套的 if 语句或 switch case<br>
中使用这些值作为不同的条件，<br>
但是让我们设计一种将逻辑委托给 Enum 本身的替代方法。 我们将为每个 Enum 值定义方法并进行计算。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    ADD &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// other operators</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法称作 <code>Constant-specific methods</code>， 参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enums.html">枚举</a><br>
然后在 Calculator 类中，我们可以定义一个方法来执行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Operator operator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> operator.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以通过使用 <code>Operator＃valueOf()</code> 方法将String 值转换为 Operator 来调用该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCalculateUsingEnumOperator_thenReturnCorrectResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.calculate(<span class="number">3</span>, <span class="number">4</span>, Operator.valueOf(<span class="string">&quot;ADD&quot;</span>));</span><br><span class="line">    assertEquals(<span class="number">7</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="命令模式">命令模式</h3>
我们还可以设计一个 <code>Calculator＃calculate</code> 方法来接受可以在输入上执行的命令。这将是替换嵌套 if 语句的另一种方法。<br>
首先定义我们的 Command 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    Integer <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们实现一个 AddCommand：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">// Instance variables</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddCommand</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们在 Calculator 中添加一个接收和执行 Command 的新方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以通过实例化 <code>AddCommand</code> 调用计算并将其发送到 <code>Calculator＃calculate</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenCalculateUsingCommand_thenReturnCorrectResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculator.calculate(<span class="keyword">new</span> <span class="title class_">AddCommand</span>(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">    assertEquals(<span class="number">10</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="规则引擎">规则引擎</h3>
</li>
</ul>
<p>当我们最终编写大量嵌套 if 语句时，每个条件都描述了一个业务规则，必须对其进行评估才能处理正确的逻辑。规则引擎从主代码中分离了这种复杂性。 RuleEngine 评估规则并根据输入返回结果。<br>
让我们通过设计一个简单的 RuleEngine 来演示一个例子，该 RuleEngine 通过一组规则处理 Expression 并返回所选规则的结果。首先，我们将定义一个 Rule 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rule</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">evaluate</span><span class="params">(Expression expression)</span>;</span><br><span class="line">    Result <span class="title function_">getResult</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，让我们实现一个 RuleEngine：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleEngine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Rule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        rules.add(<span class="keyword">new</span> <span class="title class_">AddRule</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">process</span><span class="params">(Expression expression)</span> &#123;</span><br><span class="line">        <span class="type">Rule</span> <span class="variable">rule</span> <span class="operator">=</span> rules</span><br><span class="line">          .stream()</span><br><span class="line">          .filter(r -&gt; r.evaluate(expression))</span><br><span class="line">          .findFirst()</span><br><span class="line">          .orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expression does not matches any Rule&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> rule.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RuleEngine 接受 Expression 对象并返回 Result。现在，让我们将 Expression 类设计为一组包含两个 Integer 对象的 Operator，它将被应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Expression</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">    <span class="keyword">private</span> Operator operator;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后让我们定义一个自定义的 AddRule 类，它仅在指定 ADD 操作时进行求值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddRule</span> <span class="keyword">implements</span> <span class="title class_">Rule</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">evaluate</span><span class="params">(Expression expression)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">evalResult</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (expression.getOperator() == Operator.ADD) &#123;</span><br><span class="line">            <span class="built_in">this</span>.result = expression.getX() + expression.getY();</span><br><span class="line">            evalResult = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evalResult;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在将使用 Expression 调用 RuleEngine ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whenNumbersGivenToRuleEngine_thenReturnCorrectResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Expression</span>(<span class="number">5</span>, <span class="number">5</span>, Operator.ADD);</span><br><span class="line">    <span class="type">RuleEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuleEngine</span>();</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> engine.process(expression);</span><br><span class="line"> </span><br><span class="line">    assertNotNull(result);</span><br><span class="line">    assertEquals(<span class="number">10</span>, result.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsafe.park vs Object.wait</title>
    <url>/java/Unsafe.park-vs-Object.wait/</url>
    <content><![CDATA[<p><code>Unsafe.park/unpark</code> 和 <code>Object.wait/notify</code> 都可以用来实现线程的阻塞和唤醒，但两者有些本质的区别。</p>
<h2 id="LockSupport">LockSupport</h2>
<p><code>Unsafe.park</code> 通常被用在 <code>LockSupport</code> 的 <code>park</code> 方法中，<code>LockSupport</code> 用于创建锁和其他同步类的<strong>基本线程阻塞原语</strong>。</p>
<p><code>AbstractQueuedSynchronizer(AQS)</code> 框架中的方法大量使用该类来构建，该抽象类用于实现依赖先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件等），位于 <code>java.util.concurrent</code> 包下的大部分状态依赖类都构建于它之上，例如 <code>ReentrantLock</code>、<code>Semaphore</code> 等。</p>
<span id="more"></span>
<p>此类与使用它的每个线程相关联一个许可（在 <code>Semaphore</code> 信号量类的意义上）。如果许可证可用，<code>park</code> 调用将立即返回，进程也将消费掉该许可；否则可能会阻塞。如果许可证不可用，则调用 <code>unpark</code> 可使许可证可用。（与信号量不同，许可不会累积。最多只有一个。）<br>
方法 <code>park</code> 和 <code>unpark</code> 提供了阻塞和解除阻塞线程的有效方法，并且不会遇到导致过时方法 <code>Thread.suspend</code> 和 <code>Thread.resume</code> 因为以下目的变得不可用的问题：由于许可的存在，调用 <code>park</code> 的线程和另一个试图将其 <code>unpark</code> 的线程之间的竞争将保持活性。此外，如果调用者的线程被中断， <code>park</code> 将返回，并且支持超时版本。 <code>park</code> 方法还可以在其他任何时间由于虚假唤醒“毫无理由”地返回，<strong>因此通常必须在重新检查返回条件的循环里调用此方法</strong>。从这个意义上说，<code>park</code> 是“忙碌等待”的一种优化，它不会浪费这么多的时间进行自旋，但是必须将它与 <code>unpark</code> 配对使用才更高效。</p>
<p>这些方法旨在用作创建更高级别同步实用程序的工具，并且它们本身对大多数并发控制应用程序没有用处。 <code>park</code> 方法通常的使用形式：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(!canProceed()</span>) &#123;</span><br><span class="line">   <span class="comment">// ensure request to unpark is visible to other threads</span></span><br><span class="line">   ...</span><br><span class="line">   LockSupport.park<span class="comment">(this)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Java docs 中的示例用法：先进先出非重入锁类的草图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOMutex</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Thread&gt; waiters</span><br><span class="line">    = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasInterrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 发布当前线程给 unparkers</span></span><br><span class="line">    waiters.add(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程不是队列中的第一个或无法获取锁时阻塞</span></span><br><span class="line">    <span class="keyword">while</span> (waiters.peek() != Thread.currentThread() ||</span><br><span class="line">           !locked.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">      LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">      <span class="comment">// 等待时忽略中断</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        wasInterrupted = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waiters.remove();</span><br><span class="line">    <span class="comment">// 在返回时确保正确的中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (wasInterrupted)</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    locked.set(<span class="literal">false</span>);</span><br><span class="line">    LockSupport.unpark(waiters.peek());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 减小由于类加载导致的程序无响应“丢失 unpark”的风险</span></span><br><span class="line">    Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Object-wait-notify">Object.wait/notify</h2>
<p>Object 中的 <code>wait</code>、<code>notify</code>、 <code>notifyAll</code> 方法构成了内部条件队列的 API。一个对象的内部锁与它的内部条件队列是相关的：为了能够调用对象 X 中的任一个条件队列方法，你必须持有对象 X 的锁。</p>
<p>条件队列可以让一组线程 一一 称作等待集，以某种方式等待相关条件变成真，它也由此得名。不同于传统的队列，它们的元素是数据项，条件队列的元素是等待相关条件的线程。就像每个 Java 对象都能当作锁一样，每个对象也能当作条件队列。</p>
<p>这是因为“等待基于状态的条件”机制必须和“维护状态一致性”机制紧密地绑定在一起：除非你能检査状态，否则你不能等待条件；同时，除非你能改变状态，否则你不能从条件等待(队列)中释放其他的线程。</p>
<p><code>object.wait</code> <strong>会自动释放锁</strong>，并请求 OS（操作系统）挂起当前线程，让其他线程获得该锁进而修改对象的状态。当它被唤醒时，它会在返回前重新获得锁。直观上看，调用 <code>wait</code> 意味着“我要去休息了，但是发生了需要关注的事情后叫醒我”，调用通知（<code>notify/notifyAll</code>）方法意味着“需要关注的事情发生了”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件依赖方法的规范式</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stateDependentMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 条件谓词必须被锁守护</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!conditionPredicate()) &#123;  <span class="comment">// 使用while的原因也是避免虚假唤醒，唤醒后重新检查状态</span></span><br><span class="line">            lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在,对象处于期望的状态中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较-3">比较</h2>
<p>他们都将挂起正在运行的线程并将其置于等待状态，有 3 种方法可以使线程处于 <code>Thread.state.WAITING</code> 状态：</p>
<ul>
<li>没有超时的 <code>Object.wait</code></li>
<li>没有超时的 <code>Thread.join</code></li>
<li>没有超时的 <code>LockSupport.park</code></li>
</ul>
<p>但这两种方法的工作原理不同。 <strong><code>Object.wait()</code> 方法适用于基于监视器的同步</strong>，在调用时会自动释放监视器锁，Unsafe.park 不会处理监视器锁。因此，这与 Java 中的“happens-before”关系很相配。为了将等待线程恢复为可运行状态，我们将在同一个监视器对象上使用 <code>Object.notify()</code> 方法。因此，当线程回到可运行状态时，它肯定会获得跨多个线程共享的变量的更新值。<strong>JVM 将确保线程状态与主内存同步，但这是额外的开销。</strong></p>
<p><code>Unsafe.park()</code> 方法将线程作为参数。要将 <code>park</code> 的线程变回可运行状态，我们需要在同一线程上调用 <code>Unsafe.unpark()</code> 方法。它在许可的基础上工作，许可与传入的线程关联，并且只有一个许可。当 <code>Unsafe.unpark()</code> 被调用时，如果线程已经被 <code>park</code>，它将解除阻塞，或者将确保线程上的下一个 <code>park</code> 调用立即解除阻塞。<strong>所以它的性能应该更好，因为不需要与主存同步。</strong> 这就是为什么线程池（例如 <code>ExecutorService</code>）在等待来自阻塞队列的任务时使用 <code>park</code> 方法的原因。</p>
<p>如您所见，这些用例是不同的。如果您有跨线程共享的状态并且您想确保一个线程在继续更新之前应该等待另一个线程，那么您应该继续使用 <code>wait()</code> 和 <code>notify()</code> 方法。作为应用程序开发人员，<strong>大多数情况下您不必使用 <code>park()</code> 方法，它的 API 级别太低</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>park/unpark</tag>
        <tag>wait/notify</tag>
        <tag>LockSupport</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Consul 入门</title>
    <url>/middleware/Consul-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>Consul 简介</h1>
<p>Consul 解决了各种规模的组织在微服务架构中遇到的挑战。包括各种分布式环境下及跨地理位置下的所有应用程序流量的保护，它关注计算网络层。</p>
<p>Consul 是一个服务网格解决方案，它的核心功能主要包含：</p>
<ul>
<li><strong>Service Discovery - 服务发现</strong>：Consul 的客户端可以注册服务，例如 <code>api</code> 或 <code>mysql</code>，其他客户端可以使用 Consul 发现给定服务的提供者。使用 DNS 或 HTTP，应用程序可以轻松找到它们所依赖的服务。</li>
<li><strong>Health Checking - 健康检查</strong>：Consul 客户端可以提供任意数量的健康检查，或者与给定服务相关联（“网络服务器是否返回 200 OK”），或者与本地节点相关联（“内存利用率是否低于 90%”）。操作员可以使用此信息来监控集群的健康状况，服务发现组件使用它将流量路由到健康的主机。</li>
<li><strong>KV Store - KV 存储</strong>：应用程序可以将 Consul 的分层键/值存储用于任意数量的目的，包括动态配置、特征标记、协调、领导者选举等。简单的 HTTP API 也使其易于使用。</li>
<li><strong>Secure Service Communication - 安全服务通信</strong>：Consul 可以为服务生成和分发 TLS 证书以建立相互 TLS 连接。<a target="_blank" rel="noopener" href="https://www.consul.io/docs/connect/intentions">Intentions</a> 可用于定义允许通信的服务。可以通过实时更改意图轻松管理服务分段，而不是使用复杂的网络拓扑和静态防火墙规则。</li>
<li><strong>Multi Datacenter - 多数据中心</strong>：Consul 开箱即用地支持多个数据中心。这意味着 Consul 的用户不必担心构建额外的抽象层以扩展到多个区域。</li>
</ul>
<p>Consul 旨在对 DevOps 社区和应用程序开发人员都友好，使其非常适合现代、弹性的基础设施。</p>
<span id="more"></span>
<h1>Consul 术语</h1>
<p>本节收集了 Consul 和 Consul Enterprise 文档中使用的一些技术术语的简要定义，以及在整个 Consul 社区的对话中经常出现的一些术语。</p>
<h2 id="Agent">Agent</h2>
<p><strong>代理 - Agent</strong> 是 Consul 集群每个成员上长时间运行的守护进程，代理负责节点上的服务以及节点本身的健康检查。它是通过运行 <code>consul agent</code> 启动的。代理可以在客户端或服务器模式下运行。由于所有节点都必须运行代理，发现其他服务或获取/设置键/值数据不需要运行代理，因此将节点称为客户端或服务器更简单，但还有其他代理实例。所有代理都可以运行 DNS 或 HTTP 接口，并负责运行检查和保持服务同步。</p>
<h3 id="Client">Client</h3>
<p><strong>客户端 - Client</strong> 是将所有 RPC 转发到服务器的代理。客户端是相对无状态的。客户端执行的唯一后台活动是参与 LAN gossip 池。这具有最小的资源开销并且仅消耗少量的网络带宽。</p>
<h3 id="Server">Server</h3>
<p><strong>服务器 - Server</strong> 是具有扩展职责集的代理，包括参与 Raft 仲裁、维护集群状态、响应 RPC 查询、与其他数据中心交换 WAN gossip、并将查询转发给领导者或远程数据中心。</p>
<h2 id="Datacenter">Datacenter</h2>
<p>我们将数据中心定义为私有、低延迟和高带宽的网络环境。这不包括穿越公共互联网的通信，但就我们而言，单个 EC2 区域内的多个可用区将被视为单个数据中心的一部分。</p>
<h2 id="Access-Control-List-ACL">Access Control List (ACL)</h2>
<p>访问控制列表 - Access Control List (ACL) 是文件、文件夹或其他对象的用户权限列表。它定义了哪些用户和组可以访问对象以及他们可以执行哪些操作。</p>
<p>Consul 使用访问控制列表 (ACL) 来保护 UI、API、CLI、服务通信和代理通信。</p>
<p>访问 <a target="_blank" rel="noopener" href="https://www.consul.io/docs/acl">Consul ACL 文档和指南</a>。</p>
<h1>Consul 架构</h1>
<p>俯视整个 Consul ，它的架构是这样的：</p>
<p><img data-src="../../images/middleware/consul/consul-arch.png" alt="consul-arch"></p>
<p>让我们分解这张图片并描述每一块。首先，我们可以看到有两个数据中心，分别标记为“DATACENTER 1”和“DATACENTER 2”。 Consul 对<a target="_blank" rel="noopener" href="https://learn.hashicorp.com/tutorials/consul/federarion-gossip-wan">多个数据中心</a>有最高级别的支持，并希望这是常见的使用情况。</p>
<p>在每个数据中心内，我们混合了客户端和服务器。预计将有三到五台服务器。这在故障情况下的可用性和性能之间取得了平衡，因为随着添加更多机器，共识将变得越来越慢。但是，客户端数量没有限制，它们可以轻松扩展到数千或数万。</p>
<p>数据中心中的所有代理都参与 <a target="_blank" rel="noopener" href="https://www.consul.io/docs/internals/gossip">gossip 协议</a>。这意味着有一个 gossip 池包含给定数据中心的所有代理。这有几个目的：首先，不需要使用服务器地址配置客户端；发现是自动完成的。其次，检测代理故障的工作不是放在服务器上而是分布式的。这使得故障检测比简单的心跳方案更具可扩展性。它还为节点提供故障检测；如果代理不可访问，则节点可能遇到故障。第三，它用作消息传递层，以在发生领导者选举等重要事件时进行通知。</p>
<p>每个数据中心中的服务器都是单个 <code>Raft</code> 对等集的一部分。这意味着他们一起工作来选举一个领导者，领导者为一个有额外职责的选定服务器。领导者负责处理所有查询和事物。作为<a target="_blank" rel="noopener" href="https://www.consul.io/docs/internals/consensus">共识协议</a>的一部分，事物还必须复制到所有对等点。由于这个要求，当一个非领导服务器收到一个 RPC 请求时，它会将它转发给集群领导。</p>
<p>服务器代理还作为 WAN gossip 池的一部分运行。此池与 LAN 池不同，因为它针对 Internet 的更高延迟进行了优化，并且只期待与其他 Consul 服务器代理交互。这个池的目的是允许数据中心以低接触的方式发现彼此。使新数据中心上线就像加入现有的 WAN gossip 池一样简单。因为服务器都在这个池中运行，所以它也支持跨数据中心请求。当服务器收到对不同数据中心的请求时，它会将其转发到正确数据中心中的随机服务器。该服务器然后可以转发给本地领导。</p>
<p>这导致数据中心之间的耦合非常低，但由于故障检测、连接缓存和多路复用，跨数据中心请求相对快速和可靠。</p>
<p>通常，不同的 Consul 数据中心之间不会复制数据。当对另一个数据中心中的资源发出请求时，本地 Consul 服务器会将 RPC 请求转发到该资源的远程 Consul 服务器并返回结果。如果远程数据中心不可用，那么这些资源也将不可用，但这不会影响本地数据中心。在某些特殊情况下，可以复制有限的数据子集，例如使用 Consul 的内置 <a target="_blank" rel="noopener" href="https://learn.hashicorp.com/tutorials/consul/access-control-replication-multiple-datacenters">ACL 复制</a>功能，或使用 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/consul-replicate">consul-replicate</a> 等外部工具。</p>
<p>在某些地方，客户端代理可能会缓存来自服务器的数据，以使其在本地可用以提高性能和可靠性。比如连接证书和意图，它们允许客户端代理对入站连接请求做出本地决策，而无需往返服务器。一些 API 端点还支持可选的结果缓存。这有助于提高可靠性，因为即使与服务器的连接中断或服务器暂时不可用，本地代理也可以继续响应某些查询，如服务发现或缓存中的连接授权。</p>
<h1>共识协议 - Consensus Protocol</h1>
<p>Consul 使用共识协议来提供<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem">一致性（由 CAP 定义）</a>。共识协议基于“<a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">Raft：寻找可理解的共识算法</a>”。有关 Raft 的可视化解释，请参阅<a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">数据的秘密生活</a>。</p>
<h2 id="Raft-协议概述">Raft 协议概述</h2>
<p>Raft 是一种基于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paxos_%28computer_science%29">Paxos</a> 的共识算法。与 Paxos 相比，Raft 被设计为具有更少的状态和更简单、更易于理解的算法。</p>
<p>在讨论 Raft 时，有几个关键术语需要了解：</p>
<ul>
<li><strong>Log</strong> - Raft 系统中的主要工作单元是日志条目。一致性问题可以分解为<em>复制日志</em>。日志是有序的条目序列。条目包括任何集群更改：添加节点、添加服务、新的键值对等。如果所有成员都同意条目及其顺序，我们认为日志是一致的。</li>
<li><strong>FSM</strong> - 有限状态机（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite State Machine</a>）。FSM 是有限状态的集合，它们之间有转换。随着新日志的应用，FSM 被允许在状态之间转换。应用相同的日志序列必须导致相同的状态，这意味着行为必须是确定性的。</li>
<li><strong>Peer set</strong> - 对等集是所有参与日志复制的成员的集合。出于 Consul 的目的，所有服务器节点都在本地数据中心的对等集中。</li>
<li><strong>Quorum</strong> - 法定人数是来自对等集合的大多数成员：对于大小为 <code>N</code> 的集合，法定人数至少需要 <code>(N/2)+1</code> 名成员。例如，如果对等集中有 5 个成员，我们将需要 3 个节点来形成法定人数。如果法定节点因任何原因不可用，则集群将不可用且无法提交新日志。</li>
<li><strong>Committed Entry</strong> - 当条目持久地存储在法定节点上时，该条目被视为已提交。一旦一个条目被提交，它就可以被应用。</li>
<li><strong>Leader</strong> - 在任何给定时间，peer set 都会选择一个节点作为领导者。领导者负责摄取新的日志条目，复制到追随者，并管理条目何时被视为已提交。</li>
</ul>
<p>Raft 是一个复杂的协议，这里不会详细介绍（对于那些想要更全面处理的人，可以在<a target="_blank" rel="noopener" href="https://raft.github.io/raft.pdf">本文</a>中找到完整的规范）。然而，我们将尝试提供可能对构建心智模型有用的高级描述。</p>
<p>Raft 节点始终处于以下三种状态之一：跟随者（follower）、候选者（candidate）或领导者（leader）。所有节点最初都是从跟随者开始的。在这种状态下，节点可以接受来自领导者的日志条目并投票。如果一段时间内没有收到条目，节点会自我提升到候选状态。在候选状态中，节点向其对等节点请求投票。如果候选人获得法定人数的选票，则将其提升为领导者。领导者必须接受新的日志条目并复制到所有其他追随者。此外，如果陈旧读取是不可接受的，则所有查询也必须在领导者上执行。</p>
<p>一旦集群有了领导者，它就能够接受新的日志条目。客户端可以请求领导者附加一个新的日志条目（从 Raft 的角度来看，日志条目是一个不透明的二进制 blob）。领导者然后将条目写入持久存储并尝试复制到法定人数的追随者。一旦日志条目被认为已提交，就可以将其应用于有限状态机。这允许 Raft 在某个时间点捕获 FSM 状态，然后删除用于达到该状态的所有日志。这是在没有用户干预的情况下自动执行的，可以防止无限制的磁盘使用，同时最大限度地减少重放日志所花费的时间。使用 MemDB 的优势之一是它允许 Consul 继续接受新事务，即使在对旧状态进行快照时，也可以防止任何可用性问题。</p>
<p>共识是容错的，直到法定人数可用。如果法定节点不可用，则无法处理日志条目或定位有关对等成员资格的原因。例如，假设只有 2 个对等节点：A 和 B。法定人数大小也是 2，这意味着两个节点都必须同意提交日志条目。如果 A 或 B 失败，则不可能达到法定人数。这意味着集群无法添加或删除节点或提交任何其他日志条目。这将导致系统<em>不可用</em>。此时，需要手动干预以删除 A 或 B 并以引导模式重新启动剩余节点。</p>
<p>3 个节点的 Raft 集群可以容忍单个节点故障，而 5 个节点的集群可以容忍 2 个节点故障。推荐的配置是每个数据中心运行 3 或 5 个 Consul 服务器。这在不极大地牺牲性能的情况下最大限度地提高了可用性。下面的部署表总结了潜在的集群大小选项和每个选项的容错能力。</p>
<p>在性能方面，Raft 可以与 Paxos 相媲美。假设领导者稳定，提交日志条目需要一次往返集群的一半。因此，性能受磁盘 I/O 和网络延迟的约束。虽然 Consul 并不是设计成一个高吞吐量的写系统，但也可以每秒处理数百到数千个事务，具体取决于网络和硬件配置。</p>
<h2 id="Raft-in-Consul">Raft in Consul</h2>
<p>只有 Consul <strong>服务器节点</strong>参与 Raft 并且是 peer set 的一部分。所有客户端节点将请求转发到服务器。这种设计的部分原因是，随着更多成员添加到对等集中，法定人数的大小也会增加。这会引入性能问题，因为您可能正在等待数百台机器就一个条目而不是少数机器达成一致。</p>
<p>开始时，单个 Consul 服务器被置于“引导 - bootstrap”模式。这种模式允许它自选为领导者。一旦选举出领导者，其他服务器可以以保持一致性和安全性的方式添加到对等集中。最终，一旦添加了前几台服务器，就可以禁用引导模式。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.consul.io/docs/install/bootstrapping">此文档</a>。</p>
<p>由于所有服务器都作为对等集的一部分参与，因此它们都知道当前的领导者。当 RPC 请求到达非领导服务器时，请求被转发给领导者。如果 RPC 请求是查询类型，意味着它是只读的，则领导者会根据 FSM 的当前状态生成结果。如果 RPC 是事务类型，这意味着它会修改状态，则领导者会生成一个新的日志条目并使用 Raft 应用它。一旦日志条目提交并应用到 FSM，事务就完成了。</p>
<p>由于 Raft 复制的性质，性能对网络延迟很敏感。出于这个原因，每个数据中心都会选举一个独立的领导者并维护一个不相交的对等集。数据是按数据中心划分的，所以每个领导者只对自己数据中心的数据负责。当收到远程数据中心的请求时，该请求将转发给正确的领导者。这种设计允许在不牺牲一致性的情况下实现更低的延迟事务和更高的可用性。</p>
<h2 id="一致性模式">一致性模式</h2>
<p>尽管对复制日志的所有写入都通过 Raft，但读取更加灵活。为了支持开发人员可能想要的各种权衡，Consul 支持 3 种不同的读取一致性模式。</p>
<p>三种读取模式是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.consul.io/docs/architecture/consensus#default"><code>default</code></a> - Raft 使用了领导者租期 - <code>leasing</code>，提供了一个时间窗口，领导者在其中扮演稳定的角色。但是，如果领导者与其余对等体分开，则可能会在旧领导者持有租期时选出新领导者。这意味着有 2 个领导节点。不存在脑裂的风险，因为旧的领导者将无法提交新的日志。但是，如果旧的领导者仍然为任何读取提供服务，则这些值可能是陈旧的。默认的一致性模式仅依赖于领导者租期，将会给客户端暴露潜在的陈旧值。我们进行这种权衡是因为读取速度很快，通常具有很强的一致性，并且仅在难以触发的情况下才会失效。过时读取的时间窗口也是有界的，因为领导者将因分区而下台。</li>
<li><a target="_blank" rel="noopener" href="https://www.consul.io/docs/architecture/consensus#consistent"><code>consistent</code></a> - 这种模式提供强一致性。它要求领导者与法定人数的对等方一起验证它仍然是领导者。这引入了到所有服务器节点的额外往返。权衡的利：总是一致的读取，弊：由于额外的往返行程而增加了延迟。</li>
<li><a target="_blank" rel="noopener" href="https://www.consul.io/docs/architecture/consensus#stale"><code>stale</code></a> - 这种模式允许任何服务器为读取提供服务，而不管它是否是领导者。这意味着读取可以任意陈旧，但通常在领导者的 50 毫秒内。权衡是非常快速和可扩展的读取，但具有过时的值。这种模式允许在没有领导者的情况下进行读取，这意味着不可用的集群仍然能够响应。</li>
</ul>
<p>有关使用这些不同模式的更多文档，请参阅 <a target="_blank" rel="noopener" href="https://www.consul.io/api/features/consistency">HTTP API</a>。</p>
<h2 id="部署表">部署表</h2>
<p>下表显示了各种集群大小的法定人数大小和容错能力。推荐的部署是 3 或 5 个服务器。<strong>强烈</strong>建议不要使用单个服务器部署，因为在故障情况下数据丢失是必然的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Servers - 服务器数量</th>
<th style="text-align:left">Quorum Size - 法定人数大小</th>
<th style="text-align:left">容忍故障的服务器数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">3</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">4</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">4</td>
<td style="text-align:left">3</td>
</tr>
</tbody>
</table>
<h1>Gossip 协议</h1>
<p>Paxos、Raft、ZAB 等分布式算法经常会被称作是“强一致性”的分布式共识协议，其实这样的描述扣细节概念的话是很别扭的，会有语病嫌疑，但我们都明白它的意思其实是在说“尽管系统内部节点可以存在不一致的状态，但从系统外部看来，不一致的情况并不会被观察到，所以整体上看系统是强一致性的”。与它们相对的，还有另一类被冠以“最终一致性”的分布式共识协议，这表明系统中不一致的状态有可能会在一定时间内被外部直接观察到。一种典型且极为常见的最终一致的分布式系统就是<a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/dns-lookup.html">DNS 系统</a>，在各节点缓存的 TTL 到期之前，都有可能与真实的域名翻译结果存在不一致。在本节中，笔者将介绍在比特币网络和许多重要分布式框架中都有应用的另一种具有代表性的“最终一致性”的分布式共识协议：Gossip 协议。</p>
<p>Gossip 最早由<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Xerox">施乐公司</a>（Xerox，现在可能很多人不了解施乐了，或只把施乐当一家复印产品公司看待，这家公司是计算机许多关键技术的鼻祖，图形界面的发明者、以太网的发明者、激光打印机的发明者、MVC 架构的提出者、RPC 的提出者、BMP 格式的提出者……） Palo Alto 研究中心在论文《<a target="_blank" rel="noopener" href="http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf">Epidemic Algorithms for Replicated Database Maintenance</a>》中提出的一种用于分布式数据库在多节点间复制同步数据的算法。从论文题目中可以看出，最初它是被称作“流行病算法”（Epidemic Algorithm）的，只是不太雅观，今天 Gossip 这个名字已经用得更为普遍了，除此以外，它还有“流言算法”、“八卦算法”、“瘟疫算法”等别名，这些名字都是很形象化的描述，反应了 Gossip 的特点：要同步的信息如同流言一般传播、病毒一般扩散。</p>
<p><img data-src="../../images/distributed/gossip.gif" alt="gossip"></p>
<p>上图是 Gossip 传播过程的示意图，根据示意图和 Gossip 的过程描述，我们很容易发现 Gossip 对网络节点的连通性和稳定性几乎没有任何要求，它一开始就将网络某些节点只能与一部分节点<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_topology#Partially_connected_network">部分连通</a>（Partially Connected Network）而不是以<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Network_topology#Fully_connected_network">全连通网络</a>（Fully Connected Network）作为前提；能够容忍网络上节点的随意地增加或者减少，随意地宕机或者重启，新增加或者重启的节点的状态最终会与其他节点同步达成一致。Gossip 把网络上所有节点都视为平等而普通的一员，没有任何中心化节点或者主节点的概念，这些特点使得 Gossip 具有极强的鲁棒性，而且非常适合在公众互联网中应用。</p>
<p>同时我们也很容易找到 Gossip 的缺点，消息最终是通过多个轮次的散播而到达全网的，因此它必然会存在全网各节点状态不一致的情况，而且由于是随机选取发送消息的节点，所以尽管可以在整体上测算出统计学意义上的传播速率，但对于个体消息来说，无法准确地预计到需要多长时间才能达成全网一致。另外一个缺点是消息的冗余，同样是由于随机选取发送消息的节点，也就不可避免的存在消息重复发送给同一节点的情况，增加了网络的传输的压力，也给消息节点带来额外的处理负载。</p>
<p>达到一致性耗费的时间与网络传播中消息冗余量这两个缺点存在一定对立，如果要改善其中一个，就会恶化另外一个，由此，Gossip 设计了两种可能的消息传播模式：反熵（Anti-Entropy）和传谣（Rumor-Mongering），这两个名字都挺文艺的。熵（Entropy）是生活中少见但科学中很常用的概念，它代表着事物的混乱程度。反熵的意思就是反混乱，以提升网络各个节点之间的相似度为目标，所以在反熵模式下，会同步节点的全部数据，以消除各节点之间的差异，目标是整个网络各节点完全的一致。但是，在节点本身就会发生变动的前提下，这个目标将使得整个网络中消息的数量非常庞大，给网络带来巨大的传输开销。而传谣模式是以传播消息为目标，仅仅发送新到达节点的数据，即只对外发送变更信息，这样消息数据量将显著缩减，网络开销也相对较小。</p>
<p>Consul 使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip 协议</a> 来管理成员并向集群广播消息。所有这些都是通过使用 <a target="_blank" rel="noopener" href="https://www.serf.io/">Serf 库</a>提供的。Serf 使用的 gossip 协议基于“<a target="_blank" rel="noopener" href="http://www.cs.cornell.edu/info/projects/spinglass/public_pdfs/swim.pdf">SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol</a>”，做了一些小的修改。<a target="_blank" rel="noopener" href="https://www.serf.io/docs/internals/gossip.html">这里</a>有关于 Serf 协议的更多细节。</p>
<h2 id="Gossip-in-Consul">Gossip in Consul</h2>
<p>Consul 使用了两个不同的 gossip 池。我们将每个池分别称为 LAN 或 WAN 池。每个数据中心 Consul 都有一个 LAN gossip 池，其中包含数据中心的所有成员，包括客户端和服务器。LAN 池有几个用途。其中成员信息允许客户端自动发现服务器，从而减少所需的配置量；分布式故障检测允许故障检测的工作由整个集群共享，而不是集中在少数服务器上；最后，gossip 池允许可靠且快速的事件广播。</p>
<p>WAN 池是全局唯一的，因为无论数据中心如何，所有服务器都应参与 WAN 池。 WAN 池提供的成员信息允许服务器执行跨数据中心请求。集成的故障检测允许 Consul 优雅地处理丢失连接的整个数据中心，或仅处理远程数据中心中的单个服务器。</p>
<p>所有这些功能都是通过利用 <a target="_blank" rel="noopener" href="https://www.serf.io/">Serf</a> 提供的。它用作嵌入式库以提供这些功能。从用户的角度来看，这并不重要，因为抽象而被 Consul 屏蔽。然而，作为开发人员，了解如何利用该库是很有用的。</p>
<h2 id="Lifeguard-增强">Lifeguard 增强</h2>
<p>SWIM 假设本地节点是健康的，因为可以对数据包进行软实时处理。但是，在本地节点遇到 CPU 或网络耗尽的情况下，可能会违反此假设。结果就是 <code>serfHealth</code> 检查状态偶尔会抖动，导致错误的监控警报，给远程监测增加误判，并会导致整个集群浪费 CPU 和网络资源来诊断可能并不真正存在的故障。</p>
<p>Lifeguard 通过对 SWIM 的特别增强完全解决了这个问题。</p>
<p>有关 Lifeguard 的更多详细信息，请参阅 Lifeguard 博客文章<a target="_blank" rel="noopener" href="https://www.hashicorp.com/blog/making-gossip-more-robust-with-lifeguard/">【使 gossip 更健壮】</a>，其中提供了 HashiCorp 研究论文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1707.00788">Lifeguard：SWIM-ing with Situational Awareness</a> 的高级概述。<a target="_blank" rel="noopener" href="https://www.serf.io/docs/internals/gossip.html#lifeguard">Serf gossip 协议指南</a>还提供了一些关于 gossip 协议和 Lifeguard 的较低级别的详细信息。</p>
<h1>反墒 - Anti-Entropy</h1>
<p>Consul 使用一种先进的方法来维护服务和健康信息。此页面详细介绍了如何注册服务和检查、如何填充目录以及如何在更改时更新健康状态信息。</p>
<h2 id="组件">组件</h2>
<p>首先了解服务和健康检查中涉及的移动部分很重要：<a target="_blank" rel="noopener" href="https://www.consul.io/docs/architecture/anti-entropy#agent">agent</a> 和 <a target="_blank" rel="noopener" href="https://www.consul.io/docs/architecture/anti-entropy#catalog">catalog</a>。下面从概念上描述了这些，以使反熵更容易理解。</p>
<h4 id="Agent-2">Agent</h4>
<p>每个 Consul 代理维护自己的一组服务并检查注册以及健康信息。代理负责执行自己的健康检查并更新其本地状态。</p>
<p>代理上下文中的服务和检查具有一组丰富的可用配置选项。这是因为代理负责通过使用<a target="_blank" rel="noopener" href="https://www.consul.io/docs/agent/checks">健康检查</a>生成有关其服务及其健康状况的信息。</p>
<h4 id="Catalog">Catalog</h4>
<p>Consul 的服务发现由服务目录支持。该目录由代理提交的信息聚合而成。该目录维护集群的高级视图，包括哪些服务可用、哪些节点运行这些服务、运行状况信息等。该目录用于通过 Consul 提供的各种接口公开此信息，包括 DNS 和 HTTP。</p>
<p>与代理相比，目录上下文中的服务和检查的字段集更为有限。这是因为目录只负责记录和返回有关服务、节点和健康状况的信息。</p>
<p>目录仅由<strong>服务器节点</strong>维护。这是因为目录是通过 <a target="_blank" rel="noopener" href="https://www.consul.io/docs/internals/consensus">Raft 日志</a>复制的，以提供集群的统一和一致的视图。</p>
<h2 id="Anti-Entropy">Anti-Entropy</h2>
<p>熵是系统变得越来越无序的趋势。 Consul 的反熵机制旨在对抗这种趋势，即使在其组件出现故障时也能保持集群的状态有序。</p>
<p>如上所述，Consul 在全局服务目录和代理的本地状态之间有明确的分离。反熵机制调和了这两种世界观：反熵是本地代理状态和目录的同步。例如，当用户注册新服务或向代理进行检查时，代理会依次通知目录此新服务存在。同样，当从代理中删除服务时，它也会从目录中删除。</p>
<p>反熵也用于更新可用性信息。当代理运行他们的健康检查时，他们的状态可能会发生变化，在这种情况下，他们的新状态会同步到目录中。使用此信息，目录可以根据节点和服务的可用性智能地响应有关其节点和服务的查询。</p>
<p>在此同步过程中，还会检查目录的正确性。如果目录中存在代理不知道的任何服务或检查，它们将被自动删除，以使目录反映该代理的正确服务和健康信息集。 Consul 将代理的状态视为权威；如果代理视图和目录视图之间存在任何差异，将始终使用代理本地视图。</p>
<h2 id="定期同步">定期同步</h2>
<p>除了在代理发生更改时运行之外，反熵也是一个长期运行的过程，它会定期唤醒以同步服务并检查目录状态。这可确保目录与代理的真实状态密切匹配。即使在数据完全丢失的情况下，这也允许 Consul 重新填充服务目录。</p>
<p>为避免饱和，周期性反熵运行之间的时间量将根据集群大小而变化。下表定义了集群大小和同步间隔之间的关系：</p>
<table>
<thead>
<tr>
<th style="text-align:left">集群大小</th>
<th style="text-align:left">同步周期间隔</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1 - 128</td>
<td style="text-align:left">1 minute</td>
</tr>
<tr>
<td style="text-align:left">129 - 256</td>
<td style="text-align:left">2 minutes</td>
</tr>
<tr>
<td style="text-align:left">257 - 512</td>
<td style="text-align:left">3 minutes</td>
</tr>
<tr>
<td style="text-align:left">513 - 1024</td>
<td style="text-align:left">4 minutes</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>上面的间隔是近似值。每个 Consul 代理将在间隔窗口内选择一个随机交错的开始时间，以避免雷鸣般的羊群。</p>
<h2 id="最大努力交付">最大努力交付</h2>
<p>反熵可能会在多种情况下失败，包括代理或其操作环境的错误配置、I/O 问题（磁盘满、文件系统权限等）、网络问题（代理无法与服务器通信）等。因此，代理会尝试以最大努力的方式进行同步。</p>
<p>如果在反熵运行期间遇到错误，则会记录该错误并继续运行代理。反熵机制会定期运行以自动从这些类型的瞬态故障中恢复。</p>
<h2 id="启用标签覆盖">启用标签覆盖</h2>
<p>可以部分修改服务注册的同步，以允许外部代理更改服务的标签。这在需要外部监控服务作为标签信息真实来源的情况下非常有用。比如 Redis 数据库和它的监控服务 Redis Sentinel 就有这种关系。 Redis 实例负责其大部分配置，但哨兵决定 Redis 实例是主实例还是辅助实例。使用 Consul 服务配置项 <code>enable_tag_override</code> 可以指示运行 Redis 数据库的 Consul 代理在反熵同步期间不更新标签。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.consul.io/docs/agent/services#enable-tag-override-and-anti-entropy">服务</a>页面。</p>
<h1>所需端口</h1>
<p>Consul 需要多达 6 个不同的端口才能正常工作，其中一些使用 TCP、UDP 或两种协议。下面我们记录了每个端口的要求。</p>
<h2 id="端口表">端口表</h2>
<p>在运行 Consul 之前，您应该确保以下绑定端口可以访问。</p>
<table>
<thead>
<tr>
<th style="text-align:left">用途</th>
<th style="text-align:left">默认端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DNS: The DNS server (TCP and UDP)</td>
<td style="text-align:left">8600</td>
</tr>
<tr>
<td style="text-align:left">HTTP: The HTTP API (TCP Only)</td>
<td style="text-align:left">8500</td>
</tr>
<tr>
<td style="text-align:left">HTTPS: The HTTPs API</td>
<td style="text-align:left">disabled (8501)*</td>
</tr>
<tr>
<td style="text-align:left">gRPC: The gRPC API</td>
<td style="text-align:left">disabled (8502)*</td>
</tr>
<tr>
<td style="text-align:left">LAN Serf: The Serf LAN port (TCP and UDP)</td>
<td style="text-align:left">8301</td>
</tr>
<tr>
<td style="text-align:left">Wan Serf: The Serf WAN port (TCP and UDP)</td>
<td style="text-align:left">8302</td>
</tr>
<tr>
<td style="text-align:left">server: Server RPC address (TCP Only)</td>
<td style="text-align:left">8300</td>
</tr>
<tr>
<td style="text-align:left">Sidecar Proxy Min: 用于自动分配的边车服务注册的最小端口号。</td>
<td style="text-align:left">21000</td>
</tr>
<tr>
<td style="text-align:left">Sidecar Proxy Max: 用于自动分配的边车服务注册的最大端口号。</td>
<td style="text-align:left">21255</td>
</tr>
</tbody>
</table>
<p>*对于 HTTPS 和 gRPC，表中指定的端口只是建议。</p>
<h2 id="端口信息">端口信息</h2>
<p><strong>DNS 接口</strong> 用于解析 DNS 查询。</p>
<p><strong>HTTP API</strong> 客户端使用它来与 HTTP API 对话，包括 UI 访问。</p>
<p><strong>HTTPS API</strong>（可选）默认关闭，但端口 8501 是各种工具使用的默认约定。</p>
<p><strong>gRPC API</strong>（可选）。目前 gRPC 仅用于向 Envoy 代理公开 xDS API。默认情况下它是关闭的，但端口 8502 是各种工具使用的默认约定。在 -dev 模式下默认为 8502。</p>
<p><strong>Serf LAN</strong> 用于处理 LAN 中的 gossip。所有 agent 代理都需要该端口。</p>
<p><strong>Serf WAN</strong> 服务器使用它来通过 WAN 向其他服务器进行 gossip。从 Consul 0.8 开始，WAN 加入泛洪功能要求 Serf WAN 端口（TCP/UDP）同时监听 WAN 和 LAN 接口。另请参阅：<a target="_blank" rel="noopener" href="https://github.com/hashicorp/consul/blob/main/CHANGELOG.md#080-april-5-2017">Consul 0.8.0 CHANGELOG</a> 和 <a target="_blank" rel="noopener" href="https://github.com/hashicorp/consul/issues/3058">GH-3058</a>。</p>
<p><strong>服务器 RPC</strong> 服务器使用它来处理来自其他代理的传入请求。</p>
<p>请注意，可以在<a target="_blank" rel="noopener" href="https://www.consul.io/docs/agent/options#ports">代理配置</a>中更改默认端口。</p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Consul</tag>
        <tag>Raft</tag>
        <tag>Gossip</tag>
        <tag>Consensus Protocol</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 入门</title>
    <url>/middleware/Elasticsearch-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img data-src="../../images/middleware/elasticsearch/1280px-Elasticsearch_logo.svg.png" alt="Elasticsearch logo"></p>
<p>ElasticSearch 是基于 Apache Lucene 的分布式搜索和分析引擎，为所有类型的数据提供近乎实时的搜索和分析。</p>
<h1>什么是 Elasticsearch？</h1>
<h2 id="数据输入：文档和索引">数据输入：文档和索引</h2>
<p>Elasticsearch 是一个分布式文档存储搜索引擎。Elasticsearch 不会将信息存储为列数据的行，而是存储已序列化为 JSON 文档的复杂数据结构。当集群中有多个 Elasticsearch 节点时，存储的文档会分布在整个集群中，并且可以从任何节点立即访问。</p>
<p>存储文档后，将在 1 秒钟内几乎实时地对其进行索引并可搜索。为了使文本可搜索，传统数据库每个字段存储一个值的方式不足以进行全文搜索。文本字段中的每个单词都需要可搜索，这意味着数据库需要能够在单个字段中索引多个值（在本例中为单词）。最能支持单字段多值要求的数据结构是<strong>倒排索引（inverted index）</strong>，该结构支持非常快速的全文本搜索。倒排索引列出了出现在任何文档中的每个唯一值，或者词项/单词（term），并标识了每个单词出现的所有文档。</p>
<p>**索引（Index）**可以认为是文档的优化集合，每个文档都是字段 (<code>field</code>) 的集合，这些字段是包含数据的键值对。默认情况下，Elasticsearch 对每个字段中的所有数据建立索引，并且每个索引字段都具有专用的优化数据结构。例如，文本字段存储在倒排索引中，数字字段和地理字段存储在 BKD 树中。使用按字段数据结构组合并返回搜索结果的能力使 Elasticsearch 如此之快。</p>
<p>Elasticsearch 还具有无模式的能力，这意味着无需显式指定如何处理文档中可能出现的每个不同字段即可对文档建立索引。启用动态映射后，Elasticsearch 自动检测并向索引添加新字段。这种默认行为使索引和浏览数据变得容易-只需开始建立索引文档，Elasticsearch 就会检测布尔值，浮点数和整数值，日期和字符串并将其映射到适当的 Elasticsearch 数据类型。</p>
<p>但是，最终，您比 Elasticsearch 更了解您的数据以及如何使用它们。您可以定义规则来控制动态映射，也可以显式定义映射以完全控制字段的存储和索引方式。</p>
<span id="more"></span>
<p>定义自己的映射使您能够：</p>
<ul>
<li>区分全文字符串字段和精确值字符串字段</li>
<li>执行特定于语言的文本分析</li>
<li>优化字段以进行部分匹配</li>
<li>使用自定义日期格式</li>
<li>使用无法自动检测到的数据类型，例如 <code>geo_point</code> 和 <code>geo_shape</code></li>
</ul>
<p>为不同的目的以不同的方式对同一字段建立索引通常很有用。例如，您可能希望将一个字符串字段索引为全文搜索的文本字段和索引关键字，以便对数据进行排序或汇总(定义映射时对字段使用 <code>fields</code> 定义额外的类型)。或者，您可能选择使用多个语言分析器来处理包含用户输入的字符串字段的内容。</p>
<h2 id="数据输出：搜索和分析">数据输出：搜索和分析</h2>
<p>尽管您可以将 Elasticsearch 用作文档存储并检索文档及其元数据，但真正的强大之处在于能够轻松访问基于 <code>Apache Lucene</code> 搜索引擎库构建的全套搜索功能。</p>
<p>Elasticsearch 提供了一个简单、一致的 REST API，用于管理您的集群以及索引和搜索数据。为了进行测试，您可以轻松地直接从命令行或通过 Kibana 中的开发者控制台提交请求。在您的应用程序中，您可以为您选择的语言使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch客户端</a> ：Java，JavaScript，Go，.NET，PHP，Perl，Python 或 Ruby。</p>
<h2 id="搜索数据">搜索数据</h2>
<p>Elasticsearch REST API 支持<strong>结构化查询</strong>，<strong>全文查询</strong>和<strong>结合了两者的复杂查询</strong>。结构化查询类似于您可以在 <code>SQL</code> 中构造的查询类型。例如，您可以搜索索引中的 <code>gender</code> 和 <code>age</code> 字段，<code>employee</code> 然后按 <code>hire_date</code> 字段对匹配项进行排序。全文查询会找到所有与查询字符串匹配的文档，并按<em><strong>相关性</strong></em>对它们进行返回（它们与您的搜索词的匹配程度如何）。</p>
<p>除了搜索单个词项（<code>term</code>）外，您还可以执行短语搜索（<code>phrase searches</code>），相似性搜索（<code>similarity searches</code>）和前缀搜索（<code>prefix searches</code>），并获得自动完成建议。</p>
<p>是否要搜索地理空间或其他数字数据？Elasticsearch 在支持高性能地理和数字查询的优化数据结构中索引非文本数据。</p>
<p>您可以使用 Elasticsearch 全面的 JSON 样式查询语言（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Query DSL</a>）访问所有这些搜索功能。您还可以构造 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-overview.html">SQL样式的查询</a> 以在 Elasticsearch 内部本地搜索和聚合数据，并且 JDBC 和 ODBC 驱动程序使范围广泛的第三方应用程序可以通过 SQL 与 Elasticsearch 进行交互。</p>
<h2 id="可扩展性和弹性：集群、节点和分片">可扩展性和弹性：集群、节点和分片</h2>
<p>Elasticsearch 旨在始终可用并根据您的需求进行扩展。它通过自然分布来做到这一点。您可以将**服务器（节点 - node）<strong>添加到</strong>集群（Cluster）**以增加容量，Elasticsearch 会自动在所有可用节点之间分配您的数据和负载查询。无需大修您的应用程序，Elasticsearch 知道如何平衡多节点集群以提供可扩展性和高可用性。节点越多，能力越大。</p>
<p>这是如何运作的？在幕后，Elasticsearch 索引实际上只是一个或多个物理**分片（Shard）**的逻辑分组，其中每个分片实际上是一个独立的索引，它是一个 Lucene 索引的实例。通过将索引中的文档分布在多个分片中，并将这些分片分布在多个节点上，Elasticsearch 可以确保冗余，这既可以防止硬件故障，又可以在将节点添加到集群时增加查询能力。随着集群的增大（或缩小），Elasticsearch 会自动迁移分片以重新平衡集群。</p>
<p>当数据写入分片时，它会定期发布到磁盘上新的不可变 Lucene <strong>片段（Segement）<strong>中，此时它可以用于查询。这称为</strong>刷新（refresh）</strong>。提交（Commiting）一个新的片段到磁盘需要一个 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Fsync"><code>fsync</code></a> 来确保片段被物理性地写入磁盘，这样在断电的时候就不会丢失数据。 但是 <code>fsync</code> 操作代价很大；如果每次索引一个文档都去执行一次的话会造成很大的性能问题。Elasticsearch 使用介于内存和磁盘之间的**文件系统缓存（Page Cache）<strong>来临时部分存储提交，并在合适的时间将其</strong>冲刷（flush）**到磁盘。并增加了一个 <em>translog</em> ，或者叫事务日志，在每一次对 Elasticsearch 进行操作时均进行了日志记录，以防在完整提交之前丢失数据。 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/guide/current/inside-a-shard.html">Elasticsearch：权威指南</a>中更详细地描述了它的工作原理。</p>
<p>随着片段数量的增加，这些片段会定期合并为更大的片段的过程称为<strong>合并（merge）</strong>。由于所有片段都是不可变的，这意味着使用的磁盘空间通常会在索引期间波动，因为在删除用来替换它们的片段之前需要先创建新的合并段。合并可能会占用大量资源，尤其是在磁盘 I/O 方面。</p>
<p>有两种类型的分片：主分片和副本。索引中的每个文档都属于一个主分片。副本分片是主分片的副本。副本提供数据的冗余副本，以防止硬件故障并增加处理读取请求（如搜索或检索文档）的能力。</p>
<p>索引中的主分片数量在创建索引时是固定的，但副本分片的数量可以随时更改，而不会中断索引或查询操作。</p>
<p>分片是 Elasticsearch 在集群范围分布数据的单位。 Elasticsearch 在重新平衡数据时，例如发生故障后，其移动分片的速度，将取决于分片的大小和数量以及网络和磁盘性能。</p>
<h1>分析数据</h1>
<p>文本分析是将非结构化文本（例如电子邮件的正文或产品说明）转换为针对搜索优化的结构化格式的过程。当索引或搜索文本（<code>text</code>）字段类型时，Elasticsearch 执行文本分析，然后将其添加到倒排索引中以便进行搜索。</p>
<p>Elasticsearch 对每个分析的文本字段都要经过许多步骤，用来归一化和规范化次元，该过程由 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"><em>分析器（analyzer）</em></a> 执行，经历以下步骤：</p>
<ul>
<li>
<p><em>字符过滤</em> — 使用字符过滤器（<code>Character filters</code>）转换或过滤字符，<strong>单词过滤器有零个或多个，按顺序处理。</strong></p>
</li>
<li>
<p><em>分词</em> — 使用分词器（<code>Tokenizer</code>）将文本分成一个或多个词元（<code>token</code>），<strong>将这些令牌存储到索引中</strong>。</p>
</li>
<li>
<p><em>词元过滤</em> — 词元过滤器（<code>Token filters</code>）接收词元流，并可以添加，删除或更改词元。例如，小写（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenfilter.html"><code>lowercase</code></a>）词元过滤器会将所有词元转换为小写，停顿词（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-tokenfilter.html"><code>stop</code></a>）元过滤器会从词元流中删除常见的词（停顿词），同义词（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html"><code>synonym</code></a>）词元过滤器将同义词引入词元流，<strong>可以有零个或多个，按顺序处理</strong>。</p>
</li>
<li>
<p><em>词元索引</em> — 将这些词元存储到倒排索引中。</p>
</li>
</ul>
<p><img data-src="../../images/middleware/elasticsearch/elasticsearch-analyzer.png" alt="elasticsearch-analyzer"></p>
<h1>倒排索引</h1>
<p>倒排索引的结构，允许非常快速的全文搜索。倒排索引由出现在任何文档中的所有唯一词的列表以及每个词出现的文档列表组成。</p>
<p>例如，假设我们有两个文档，每个文档都有一个包含以下内容的<code>内容</code>字段：</p>
<ol>
<li>The quick brown fox jumped over the lazy dog</li>
<li>Quick brown foxes leap over lazy dogs in summer</li>
</ol>
<p>要创建倒排索引，我们首先将每个文档的<code>内容</code>字段拆分为单独的单词（我们称之为<em>词项-term</em> 或<em>词元-token</em>），经过上面的文本分析归一化处理，创建得到所有唯一词元的排序列表，然后列出每个词项出现在哪个文档中。结果可能如下所示：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Term      Doc_1  Doc_2</span><br><span class="line">-------------------------</span><br><span class="line">quick   |<span class="string">       </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">brown   </span>|<span class="string">   X   </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">dog     </span>|<span class="string">   X   </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">fox     </span>|<span class="string">   X   </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">in      </span>|<span class="string">       </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">jumpe   </span>|<span class="string">   X   </span>|</span><br><span class="line">lazy    |<span class="string">   X   </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">leap    </span>|<span class="string">       </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">over    </span>|<span class="string">   X   </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">quick   </span>|<span class="string">   X   </span>|</span><br><span class="line">summer  |<span class="string">       </span>|<span class="string">  X</span></span><br><span class="line"><span class="string">------------------------</span></span><br></pre></td></tr></table></figure>
<p>现在，如果我们想搜索 quick brown，我们只需要找到每个词出现的文档：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">Term      Doc_1  Doc_2</span></span><br><span class="line"><span class="section">-------------------------</span></span><br><span class="line">brown   |   X   |  X</span><br><span class="line"><span class="section">quick   |   X   |</span></span><br><span class="line"><span class="section">------------------------</span></span><br><span class="line">Total   |   2   |  1</span><br></pre></td></tr></table></figure>
<p>两个文档都匹配，但第一个文档比第二个文档有更多的匹配。如果我们应用一个简单的相似度算法，只计算匹配项的数量，那么我们可以说第一个文档比第二个文档更匹配——与我们的查询<em>更相关 - relevant</em>。</p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>JMS vs AMQP</title>
    <url>/middleware/JMS-vs-AMQP/</url>
    <content><![CDATA[<p>关于 <code>JMS</code> 和 <code>AMQP</code> 在消息和代理上的一些说明。</p>
<p>如今，AMQP 越来越受欢迎。因此，我认为这是一个很好的机会，以了解它如何与旧的 JMS 匹配。</p>
<hr>
<h1>JMS</h1>
<p>包括 Java RMI 在内的远程过程调用（<code>RPC</code>）系统基本都是是同步的 – 调用者必须阻塞并等待，直到被调用的方法完成执行，因此，如果不使用多个线程，则无法开发松耦合的企业应用程序。换句话说，<code>RPC</code> 系统要求客户端和服务器同时可用。然而，在某些应用中，这种紧密耦合可能是不可能的或奢望的。面向消息的中间件 - <code>Message Oriented Middleware（MOM）</code>系统为此类问题提供了解决方案。它们基于异步交互模型，并提供可通过网络访问的消息队列的抽象。</p>
<span id="more"></span>
<p>由 Sun Microsystems 和其他几家公司在 Java Community Process 下以 <a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=914">JSR 914</a> 设计的 <code>Java Message Service（JMS）</code>是第一个获得业界广泛支持的企业消息 <strong><code>API</code></strong>。Java 消息服务（JMS）旨在简化开发异步发送和接收业务数据和事件的业务应用程序的过程。它定义了一个通用的企业消息传递 API，该 API 旨在为各种企业在消息产品上提供轻松高效地支持。 JMS 支持两种消息传递模型：<strong>点对点（队列）</strong> 和 <strong>发布-订阅（主题）</strong>。</p>
<p>JMS 定义了一组接口和语义，这些接口和语义允许 Java 应用程序与其他消息传递实现进行通信。JMS 实现被称为 JMS 提供程序 - provider。 JMS 通过最小化 Java 开发人员使用企业消息产品必须学习的概念集来简化学习过程，同时，它使消息传递应用程序的可移植性最大化。</p>
<p>下图描述了生产和消费消息的高层视图。</p>
<p><img data-src="../../images/middleware/jms.gif" alt="Producing and consuming messages"></p>
<h2 id="总结-5">总结</h2>
<p>JMS 是用于与面向消息的中间件通信的标准 Java API。</p>
<p>JMS 是 Java <code>J2EE</code> 的一部分，由 <a target="_blank" rel="noopener" href="https://jcp.org/aboutJava/communityprocess/final/jsr914/index.html"><code>JSR 914</code></a> 定义。它被认为是健壮和成熟的。</p>
<p>JMS 允许两个不同的 Java 应用程序进行通信，这些应用程序可能正在使用 JMS 客户端，即能够进行通信，也保证解耦。</p>
<p>如果您正在寻找 JMS 消息代理，则您的代码中可能需要 <code>ActiveMQ</code> 或 <code>HornetQ</code> 客户端。ActiveMQ 更受欢迎。</p>
<p>因此，JMS 允许 Java 组件仅用几行代码就可以可靠地发送和接收消息，实现低耦合。</p>
<p>可以用最少的代码，甚至根本不更改代码，就可以用一个 <code>JMS 代理</code>替换另一个。</p>
<h1>AMQP</h1>
<p><code>AMQP</code>（代表“<code>高级消息队列协议</code> - <code>Advanced Message Queuing Protocol</code>”）是一种开放标准的应用程序层协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。</p>
<p>AMQP 的工作过程如下图：<strong>消息</strong>（<code>message</code>）被<strong>发布者</strong>（<code>publisher</code>）发送给<strong>交换机</strong>（<code>exchange</code>），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的<strong>队列</strong>（<code>queue</code>）。最后 AMQP 代理会将消息投递给订阅了此队列的<strong>消费者（consumer）</strong>，或者消费者按照需求自行获取。</p>
<p><img data-src="../../images/middleware/amqp-message-routing.png" alt="enter image description here"></p>
<p><strong>发布者</strong>（<code>publisher</code>）发布消息时可以给消息指定各种<strong>消息属性</strong>（<code>message meta-data</code>）。有些属性有可能会被<strong>消息代理</strong>（<code>brokers</code>）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</p>
<p>从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP 模块包含了一个<strong>消息确认</strong>（<code>message acknowledgements</code>）的概念：当一个消息从队列中投递给<strong>消费者</strong>后（<code>consumer</code>），消费者会通知一下消息代理（<code>broker</code>），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的<strong>确认回执</strong>（<code>acknowledgement</code>）。</p>
<p>在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的<strong>死信队列</strong>（<code>Dead letter queue</code>）中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</p>
<p><strong>队列</strong>，<strong>交换机</strong>和<strong>绑定</strong>统称为 AMQP实体（AMQP entities）。</p>
<h2 id="交换机和交换机类型">交换机和交换机类型</h2>
<p>交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定（bindings）的规则所决定的。AMQP 0-9-1的代理提供了四种交换机</p>
<table>
<thead>
<tr>
<th>交换机类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct exchange（直连交换机）</td>
<td>根据消息携带的路由键路由消息。路由键（routing key）是一串单词，由句点分隔，与消息有一定的相关性。</td>
</tr>
<tr>
<td>Fanout exchange（扇型交换机）</td>
<td>将消息路由到所有可用队列。在这种广播类型的交换中，路由键被忽略。</td>
</tr>
<tr>
<td>Topic exchange（主题交换机）</td>
<td>根据与路由键的完全或部分匹配将消息路由到一个或多个队列。</td>
</tr>
<tr>
<td>Headers exchange（头交换机）</td>
<td>根据消息头路由消息，消息头可以包含比路由键更多的属性。</td>
</tr>
</tbody>
</table>
<p>除交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：</p>
<ul>
<li>Name</li>
<li>Durability （消息代理重启后，交换机是否还存在）</li>
<li>Auto-delete （当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它）</li>
<li>Arguments（依赖代理本身）</li>
</ul>
<p>交换机可以有两个状态：持久（durable）、暂存（transient）。持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。然而并不是所有的应用场景都需要持久化的交换机。</p>
<h2 id="总结-6">总结</h2>
<p>AMQP 提供统一消息服务的应用层高级消息队列规范，基于此规范的客户端与消息中间件可传递消息，并不受客户端不同产品和不同开发语言等条件的限制。</p>
<p>如果你想使用 AMQP，则可以选择 <code>RabbitMQ</code>，<code>Qpid</code> 或 <code>StormMQ</code>。</p>
<p>AMQP 提供了有关如何构造消息的描述。它没有提供有关如何发送消息的 API。</p>
<h1>总结</h1>
<p>好吧…… JMS 是一个 API，AMQP 是一个协议。</p>
<p>早在定义 JMS 时，JMS 实际上就没有在 JMS 客户端和 JMS 消息传递服务器之间强制使用协议。</p>
<p>实现 JMS API 的 JMS 客户端可以使用任何协议与 JMS 服务器进行通信。但是，JMS 客户端需要确保与 JMS API 兼容。而已。</p>
<p>另一方面，AMQP 只是消息客户端和消息中间件之间的协议。因此，JMS 客户端可以使用 AMQP 作为协议与消息传递服务器进行通信。</p>
<p>实际上，它已经存在，例如，ActiveMQ 正在提供对 AMQP 1.0 的支持。</p>
<p><strong>简而言之，AMQP 定义了消息的通讯协议，JMS 定义了 Java 程序间消息通讯接口。</strong></p>
<h1>参考资料</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html">Getting Started with Java Message Service</a>  JMS 入门</li>
<li><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/jms-vs-amqp-eran-shaham/">JMS vs AMQP</a></li>
<li><a target="_blank" rel="noopener" href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">AMQP Model Explained</a> AMQP 模型解释</li>
</ol>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>AMQP</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka VS RabbitMQ</title>
    <url>/middleware/Kafka-VS-RabbitMQ/</url>
    <content><![CDATA[<p><img data-src="../../images/middleware/kafka-vs-rabbitmq.jpg" alt="cover"></p>
<h2 id="引言-2">引言</h2>
<p>无论您是要集成多个微服务、希望提高应用程序可靠性还是构建新的流应用，您都可能需要消息队列 (MQ) 或消息代理平台。这些类型的软件将消息从生产应用程序或服务传递到消费应用程序或服务。</p>
<p>两个最流行的消息处理平台是 <a target="_blank" rel="noopener" href="https://www.instaclustr.com/products/managed-apache-kafka/">Apache Kafka</a> 和 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a> 。在高层次上，它们具有相似的功能，尽管它们之间存在重要差异。了解这些差异可以帮助您为特定用例选择一种或另一种。</p>
<p>在本博客中，我们将探讨 Kafka 和 RabbitMQ 的工作原理、它们的一些差异以及各自的最佳用例。</p>
<span id="more"></span>
<h2 id="RabbitMQ">RabbitMQ</h2>
<p><code>RabbitMQ</code> 通常被概括为“开源分布式消息代理”。用 Erlang 编写，于 2007 年首次发布。它通常被认为是传统的消息队列。</p>
<p>开发人员通常选择 RabbitMQ 是因为它的灵活性。它有助于在<strong>复杂的路由场景</strong>中有效地传递消息。最初围绕流行的 <a target="_blank" rel="noopener" href="https://www.amqp.org/"><code>AMQP</code></a> 协议构建，还支持其它多种消息传递协议，包括 <code>MQTT</code> 和 <code>STOMP</code> 等，同时可以通过服务器上启用的插件扩展其功能。它可以通过部署在分布式环境中以扩展和提供高可用性。</p>
<h3 id="架构">架构</h3>
<p>RabbitMQ 架构包括生产者、交换器、队列、绑定和消费者。生产者将消息推送到交换器，然后将消息路由到绑定的队列（或其他交换）。然后消费者继续从队列中读取消息，通常达到预定的消息限制。</p>
<p>参见 <a href="/middleware/JMS-vs-AMQP/" title="JMS vs AMQP">JMS vs AMQP</a> 的 AMQP 介绍。</p>
<p><strong>RabbitMQ 具有很强的路由能力。</strong> 它可以通过复杂的交换机和队列系统路由消息。生产者将消息发送到根据其配置进行操作的交换机。</p>
<p>下图是使用 <a target="_blank" rel="noopener" href="http://tryrabbitmq.com">http://tryrabbitmq.com</a> 模拟的 RabbitMQ 路由：</p>
<p><img data-src="../../images/middleware/rabbitmq/rabbitmq-system.gif" alt="'RabbitMQ routing simulation'"></p>
<h2 id="Kafka">Kafka</h2>
<p><code>Apache Kafka</code> 是一个开源分布式事件流平台。最初由 LinkedIn 开发用于跟踪网站活动，如今 Kafka 通常用于构建实时数据管道和流应用。它不是专注于灵活路由，而是提高原始吞吐量。用 Scala 和 Java 编写，Kafka 建立在 “distributed append-only log” 的思想之上，其中消息被写入到持久化到磁盘的日志的末尾，并且客户端可以选择从该日志开始读取的位置。同样，Kafka 集群可以跨多台服务器分布和集群，以获得更高程度的可用性。</p>
<h3 id="架构-2">架构</h3>
<p>Kafka 架构包括生产者、消费者、集群、代理、主题和分区。生产者将记录发送到集群，集群存储这些记录，然后将它们传递给消费者，集群中的每个服务器节点都是一个“代理”，它存储生产者提供的数据，直到被消费者读取为止。</p>
<p>参见 <a href="/middleware/Kafka-%E5%85%A5%E9%97%A8/" title="Kafka 入门">Kafka 入门</a> 介绍。</p>
<h2 id="RabbitMQ-vs-Kafka">RabbitMQ vs Kafka</h2>
<p>虽然它们不是同一个服务，但许多人经常将他们的消息队列选项缩小到这两个，想知道哪一个更好。这不是正确的问题，相反，您希望专注于每个服务的优势，分析它们的差异，然后决定这两个服务中哪一个最适合您的用例。即使在任一服务的功能之外，您还应该考虑操作服务所需的技能以及围绕它们的开发人员社区。</p>
<p>Confluent 也有一份 Kafka 和 RabbitMQ 以及 Pulsar 的比较，里面列举了很多方面，但客观性存在争议：<a target="_blank" rel="noopener" href="https://www.confluent.io/kafka-vs-pulsar/">Kafka vs. Pulsar vs. RabbitMQ: Performance, Architecture, and Features Compared</a>。</p>
<h3 id="要求和用例">要求和用例</h3>
<p>在撰写最初的博文时，RabbitMQ 和 Kafka 之间在设计上存在非常明显的差异，因此，在用例上也存在差异。</p>
<p>RabbitMQ 的消息代理设计在<strong>具有特定路由需求</strong>和<strong>单消息保证</strong>的用例中表现出色，而 Kafka 的 append-only 日志允许开发人员<strong>访问流历史记录</strong>和更<strong>直接的流处理</strong>。虽然这两种技术可以实现的用例的维恩图非常紧凑，但在某些情况下，其中一种显然比另一种更好。</p>
<p>然而，在 RabbitMQ 新版本中，它引入一种新的数据结构：<em><a target="_blank" rel="noopener" href="https://blog.rabbitmq.com/posts/2021/07/rabbitmq-streams-overview">streams - 流</a></em>，对 append-only 日志进行建模，具有非破坏性的消费语义。这种新的数据结构将与 Kafka 的持久日志非常相似，对于希望扩展其流处理用例的 RabbitMQ 用户来说，这将是一个令人兴奋的补充。此功能将与 AMQP 协议兼容，但它还将引入基于二进制的流协议。</p>
<h3 id="开发者体验">开发者体验</h3>
<p>这两项服务的开发人员体验基本保持不变，由于各自社区的工作，客户端和库的列表都在继续增长。<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/devtools.html">RabbitMQ</a> 和 <a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/Clients">Kafka</a> 的客户端库列表都在稳步增长。随着越来越多的语言和框架越来越流行，为这两种服务找到一个支持良好且完整的库变得更加容易。</p>
<p>需要注意的一件事是 Kafka Streams 的增长，这是一个客户端库实现，使开发人员可以更轻松地处理流数据。它用于从 Kafka 读取数据、处理数据并将其写入另一个 Kafka 队列的常见用例。此外，对于希望构建流应用程序同时利用他们对关系数据库的熟悉的开发人员来说，ksqlDB 非常值得一试。</p>
<p>在一些其他部分的帮助下，RabbitMQ 可以完成类似的事情，例如 <a target="_blank" rel="noopener" href="https://dataflow.spring.io/docs/">Spring Cloud Data Flow</a>。此外，请注意上一节中提到的 RabbitMQ 的流式更改，这可以为开发人员打开与 RabbitMQ 交互的新方式。</p>
<h3 id="性能">性能</h3>
<p>正如在最初的帖子中所指出的，性能可能很难量化，因为有这么多变量在起作用，包括服务的配置方式、您的代码与它的交互方式，当然还有它运行的硬件。从网络到内存和磁盘速度的一切都会极大地影响服务的性能。当然，RabbitMQ 和 Kafka 都针对性能进行了优化，但您还应该确保您的用例利用它们来最大限度地提高效率。</p>
<p>对于 RabbitMQ，有一些关于最大化性能的很好的操作方法资源，例如如何对<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/blog/2020/06/18/cluster-sizing-and-other-considerations/">集群</a>进行<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/blog/2020/06/04/how-to-run-benchmarks/">基准测试</a>和调整<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/blog/2020/06/18/cluster-sizing-and-other-considerations/">大小</a>。这些指南详细介绍了有关如何配置集群以及您的代码应如何与它们交互以获得最佳性能的最佳实践。大部分建议都围绕诸如管理队列大小和连接以及注意客户端如何使用消息等问题。该 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/clustering.html">RabbitMQ 的集群指南</a>还包括构建集群时需要注意的事项。</p>
<p>同样，Confluent 有一个很棒的<a target="_blank" rel="noopener" href="https://docs.confluent.io/current/kafka/deployment.html">在生产中运行 Kafka</a>指南，它涵盖了许多相同的问题，当您构建将运行 Kafka 集群的硬件时，以及如何配置集群本身。由于 Kafka 在 JVM 之上运行，因此您需要记住几件事，该指南也包含了如何调整虚拟机。</p>
<p>如果您对原始数据感兴趣，<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/blog/category/performance-2/">RabbitMQ 团队</a>和 <a target="_blank" rel="noopener" href="https://www.confluent.io/blog/kafka-fastest-messaging-system/">Confluent 团队</a>最近都发布了各自的基准。两者都包含有关如何配置集群以及放置在集群上的工作负载的大量详细信息，因此请确保在阅读结果时考虑这些信息。用例和操作也应在您的决策中发挥重要作用。</p>
<p>由 Confluent 团队发布的基准测试来看，Kafka 在吞吐量、和性能上还是有明显的优势。但是在延迟上 RabbitMQ 更胜一筹。</p>
<h2 id="选择消息队列时的考虑">选择消息队列时的考虑</h2>
<p>选择消息代理时，你需要考虑以下各种因素：</p>
<ul>
<li>支持的编程语言：你选择的消息代理应该支持尽可能多的编程语言。</li>
<li>支持的消息标准：消息代理是否支持多种消息标淮，比如 AMQP 和 STOMP， 还是它仅支持专用的消息标准？</li>
<li>消息排序：消息代理是否能够保留消息的排序？</li>
<li>投递保证：消息代理提供什么样的消息投递保证？</li>
<li>持久性：消息是否持久化保存到磁盘并且能够在代理崩溃时恢复？</li>
<li>耐久性：如果接收方重新连接到消息代理，它是否会收到断开连接时发送的消息？</li>
<li>可扩展性：消息代理的可扩展性如何？</li>
<li>延迟：端到端是否有较大延迟？</li>
<li>竞争性（并发）接收方：消息代理是否支持竞争性接收方？</li>
</ul>
<p>每个消息代理都有不同的侧重点。例如，一个非常低延迟的代理可能不会保留消息的顺序，不保证消息投递成功，只在内存中存储消息。保证投递成功并在磁盘上可靠地存储消息的代理可能具有更高的延迟。哪种消息代理最适合取决于你的应用程序的需求。你的应用程序的不同部分甚至可能具有不同的消息传递需求。</p>
<p>但是，消息顺序和可扩展性很可能是必不可少的。</p>
<h2 id="参考">参考</h2>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-中的恰好一次交付和事物性消息【翻译】</title>
    <url>/middleware/Kafka-%E4%B8%AD%E7%9A%84%E6%81%B0%E5%A5%BD%E4%B8%80%E6%AC%A1%E4%BA%A4%E4%BB%98%E5%92%8C%E4%BA%8B%E7%89%A9%E6%80%A7%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<blockquote>
<p>本文为 <a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-98+-+Exactly+Once+Delivery+and+Transactional+Messaging">KIP-98 - Exactly Once Delivery and Transactional Messaging</a> 的部分翻译</p>
</blockquote>
<h1>动机</h1>
<p>本文档概述了增强 Kafka 消息交付语义的提议。这建立在之前已经完成的重要工作的基础上，特别是在<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/Idempotent+Producer">幂等生产者</a>和<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/Transactional+Messaging+in+Kafka">Kafka 中的事务性消息传递</a>。</p>
<p>Kafka 目前提供至少一次（<code>at least once</code>）语义，即。 在针对可靠性进行调整时，用户可以保证每次写入的消息将至少持久化一次，而不会丢失数据。 由于生产者重试，流中可能会出现重复。 例如，代理可能会在提交消息和向生产者发送确认之间崩溃，导致生产者重试，从而导致流中出现重复的消息。</p>
<p>消息传递系统的用户极大地受益于更严格的幂等生产者语义，即。每个消息写入都将被持久化一次，不会重复，也不会丢失数据 - 即使在客户端重试或代理失败的情况下也是如此。这些更强的语义不仅使编写应用程序更容易，而且也让更多的应用程序可以使用给定消息传递系统。<br>
但是，幂等生产者不为跨多个 <code>TopicPartition</code> 的写入提供保证。为此，人们需要更强的事物保证，即。能够以原子方式写入多个 <code>TopicPartition</code>。原子地，我们的意思是能够将一组消息作为一个单元跨 <code>TopicPartitions</code> 提交：要么提交所有消息，要么都不提交。</p>
<span id="more"></span>
<p>流处理应用程序是“消费(consume)-转换(transform)-生产(produce)”任务的管道，当流的重复处理不可接受时，绝对需要事务保证。因此，向 Kafka（一个流处理平台）添加事务保证使其不仅对流处理有用，而且对各种其他应用程序也更有用。</p>
<h2 id="关于事物和流的一些东西">关于事物和流的一些东西</h2>
<p>在上一节中，我们提到事务的主要动机是在 Kafka Streams 中启用一次处理。值得深入研究这个用例，因为它激发了我们设计中的许多权衡。<br>
回想一下，使用 Kafka Streams 的数据转换通常通过多个流处理器进行，每个流处理器都由 Kafka 主题连接。这种设置被称为流拓扑，基本上是一个有向无环图 - DAG，其中流处理器是节点，连接的 Kafka 主题是顶点。这种模式是所有流架构的典型特征。您可以在<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/streams">此处</a>阅读有关 Kafka 流架构的更多信息。<br>
因此，Kafka 流的事务本质上将包含输入消息、本地状态存储的更新和输出消息。在事务中包含输入偏移量会促使将 <code>sendOffsets</code> API 添加到生产者接口，如下所述。更多细节将在单独的 KIP 中提供。<br>
此外，流拓扑可以变得非常深——10 个阶段并不少见。如果输出消息仅在事务提交时具体化，那么 N 阶段深度的拓扑将需要 N x T 时间来处理其输入，其中 T 是单个事务的平均时间。因此 Kafka Streams 需要推测执行，其中输出消息甚至在提交之前就可以被下游处理器读取。否则，对于严格的流处理应用程序来说，事务将不是一个选项。这激发了稍后描述的“<code>读未提交 - read uncommitted</code>”消费者模式。</p>
<p>这是我们选择针对流用例进行优化的两个特定实例。当读者阅读本文档时，我们鼓励他/她牢记这个用例，因为它激发了提案的大部分内容。</p>
<p><img data-src="../../images/middleware/kafka/kafka-transaction-workflow.png" alt="Kafka Transaction Example Workflow"></p>
<h1>公共接口</h1>
<h2 id="生产者接口">生产者接口</h2>
<p>生产者将获得五个新方法（<code>initTransactions</code>、<code>beginTransaction</code>、<code>sendOffsets</code>、<code>commitTransaction</code>、<code>abortTransaction</code>），并更新 <code>send</code> 方法以抛出新异常。详情如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Producer</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 需要在任何其他事务方法之前调用。假设 transactional.id 已经在生产者配置中指定。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 此方法执行以下操作：</span></span><br><span class="line"><span class="comment">   *   1.  确保由之前的生产者实例发起的任何事务都已完成。如果前一个实例因正在进行的事务而失败，它将被中止。</span></span><br><span class="line"><span class="comment">           如果最后一个事务已开始完成，但尚未完成，则此方法等待其完成。</span></span><br><span class="line"><span class="comment">   *   2. 获取内部生产者 id 和 epoch，用于生产者以后发布的所有事务性消息。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalStateException 如果没有在配置中设置生产者的 TransactionalId。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">initTransactions</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 应该在每个新事务开始之前调用。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> ProducerFencedException 如果另一个生产者有相同的 transactional.id 处于活动状态。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">beginTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将消耗的偏移量列表发送到消费者组协调器，并将这些偏移量标记为当前事务的一部分。</span></span><br><span class="line"><span class="comment">   * 仅当事务成功提交时，这些偏移量才会被视为已消耗。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 当您需要将消费和生产的消息一起批处理时，应该使用此方法，通常采用消费-转换-生产模式。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> ProducerFencedException 如果另一个生产者具有相同的 transactional.id 处于活动状态。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">sendOffsetsToTransaction</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets,</span></span><br><span class="line"><span class="params">                                String consumerGroupId)</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 提交正在进行的事务。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> ProducerFencedException 如果另一个生产者具有相同的 transactional.id 处于活动状态。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">commitTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 中止正在进行的事务。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> ProducerFencedException 如果另一个生产者具有相同的 transactional.id 处于活动状态。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">abortTransaction</span><span class="params">()</span> <span class="keyword">throws</span> ProducerFencedException;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 异步发送给定的记录并返回最终包含响应信息的 Future。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> record 要发送的记录</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 最终将包含响应信息的 Future</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送记录并在服务器确认记录后调用给定的回调</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title function_">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OutOfOrderSequence-异常">OutOfOrderSequence 异常</h3>
<p>如果代理检测到数据丢失，生产者将引发 <code>OutOfOrderSequenceException</code>。 换句话说，如果代理接收到的序列号大于它预期的序列号。 此异常将在 <code>Future</code> 中返回并传递给回调（如果有）。 这是一个致命的异常，未来对 <code>Producer</code> 方法（如 <code>send</code>、<code>beginTransaction</code>、<code>commitTransaction</code> 等）的调用将引发 <code>IlegalStateException</code>。</p>
<h2 id="示例">示例</h2>
<p>这是一个简单的应用程序，它演示了上面介绍的 API 的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaTransactionsExample</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(consumerConfig);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 请注意，‘transactional.id’ 配置_必须_在生产者中配置以使用事务。</span></span><br><span class="line">    KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(producerConfig);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 我们需要为每个生产者实例初始化一次事务。要使用交易， </span></span><br><span class="line">    <span class="comment">// 假设应用程序 id 是在配置中使用 transactional.id 键指定的值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 此方法将恢复或中止由具有相同应用程序 ID 的生产者的先前实例发起的事务。</span></span><br><span class="line">    <span class="comment">// 如果未执行初始化，任何其他事务性消息都将报错。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 响应指示成功或失败。有些故障是不可恢复的，需要一个新的生产者实例。</span></span><br><span class="line">    <span class="comment">// 有关错误代码列表，请参阅 TransactionMetadata 文档。</span></span><br><span class="line">    producer.initTransactions();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      ConsumerRecords&lt;String, String&gt; records = consumer.poll(CONSUMER_POLL_TIMEOUT);</span><br><span class="line">      <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 开始一个新的事务。这将开始执行原始记录以及由于处理输入记录而产生的记录的批消费过程。</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 我们需要检查响应以确保此生产者能够启动一个新的事物。</span></span><br><span class="line">        producer.beginTransaction();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 处理输入记录并将它们发送到输出主题。</span></span><br><span class="line">        List&lt;ProducerRecord&lt;String, String&gt;&gt; outputRecords = processRecords(records);</span><br><span class="line">        <span class="keyword">for</span> (ProducerRecord&lt;String, String&gt; outputRecord : outputRecords) &#123;</span><br><span class="line">          producer.send(outputRecord);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 为了确保消费和生产的消息是批处理的，我们需要生产者而不是消费者来提交偏移量。</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="comment">// 如果这返回错误，我们应该中止事务。</span></span><br><span class="line">         </span><br><span class="line">        sendOffsetsResult = producer.sendOffsetsToTransaction(getUncommittedOffsets());</span><br><span class="line">         </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 现在我们已经消费、处理和生产了一批消息，让我们提交结果。</span></span><br><span class="line">        <span class="comment">// 如果这没有返回成功，那么事务将被回滚。</span></span><br><span class="line">        producer.endTransaction();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="相关配置">相关配置</h2>
<h3 id="代理配置">代理配置</h3>
<table>
<thead>
<tr>
<th>配置 Key</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="http://transactional.id.timeout.ms">transactional.id.timeout.ms</a></td>
<td>事务协调器在主动使生产者 TransactionalId 过期而不从其接收任何事务状态更新之前将等待的最长时间（以毫秒为单位）。<br />默认值为 604800000（7 天）。这允许定期的每周生产者作业来维护它们的 ID。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://max.transaction.timeout.ms">max.transaction.timeout.ms</a></td>
<td>事务的最大允许超时时间。如果客户端请求事务的时间超过此时间，则代理将在 InitPidRequest 中返回 InvalidTransactionTimeout 错误。这可以防止客户端超时过长，这可能会阻止消费者从事务包含的主题中读取消息。<br />默认值为 900000（15 分钟）。这是需要发送消息事务的时间段的保守上限。</td>
</tr>
<tr>
<td>transaction.state.log.replication.factor</td>
<td>事务状态主题的副本数。默认: 3</td>
</tr>
<tr>
<td>transaction.state.log.num.partitions</td>
<td>事务状态主题的分区数。默认: 50</td>
</tr>
<tr>
<td>transaction.state.log.min.isr</td>
<td>必须考虑联机事务状态主题的每个分区的最小同步中的副本数。默认: 2</td>
</tr>
<tr>
<td>transaction.state.log.segment.bytes</td>
<td>事务状态主题的段大小。默认: 104857600 bytes.</td>
</tr>
</tbody>
</table>
<h3 id="生产者配置">生产者配置</h3>
<table>
<thead>
<tr>
<th>配置 Key</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>enable.idempotence</td>
<td>是否启用幂等（默认为 false）。如果禁用，生产者将不会在生产请求中设置 PID 字段，并且当前生产者交付语义将生效。请注意，必须启用幂等性才能使用事务。<br />当启用幂等性时，我们强制执行 <code>acks=all</code>、<code>retries &gt; 1</code> 和 <code>max.inflight.requests.per.connection=1</code>。如果没有这些配置的这些值，我们就不能保证幂等性。 如果应用程序未明确覆盖这些设置，则当启用幂等性时，生产者将设置 <code>acks=all</code>、<code>retries=Integer.MAX_VALUE</code> 和 <code>max.inflight.requests.per.connection=1</code>。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://transaction.timeout.ms">transaction.timeout.ms</a></td>
<td>事务协调器在主动中止正在进行的事务之前等待来自生产者的事务状态更新的最长时间（以毫秒为单位）。<br />此配置值将与 InitPidRequest 一起发送到事务协调器。如果此值大于代理中的 <code>max.transaction.timeout.ms</code> 设置，则请求将失败并显示“InvalidTransactionTimeout”错误。<br />默认为 60000。这使得事务不会阻塞下游消费超过一分钟，这在实时应用程序中通常是允许的。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://transactional.id">transactional.id</a></td>
<td>用于事务性交付的 TransactionalId。 这实现了跨越多个生产者会话的可靠性语义，因为它允许客户端保证使用相同 TransactionalId 的事务在开始任何新事务之前已经完成。如果未提供 TransactionalId，则生产者仅限于幂等交付。<br />请注意，如果配置了 TransactionalId，则必须启用 <code>enable.idempotence</code>。<br />默认为空，表示不能使用事务。</td>
</tr>
</tbody>
</table>
<h3 id="消费者配置">消费者配置</h3>
<table>
<thead>
<tr>
<th>配置 Key</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>isolation.level</td>
<td>以下是可能的值（默认为 read_uncommitted）：<br /><code>read_uncommitted</code>: 以偏移量顺序消费已提交和未提交的消息。<br /><code>read_committed</code>: 仅以偏移顺序消费非事务性消息或已提交的事务性消息。为了保持偏移顺序，此设置意味着我们必须在消费者中缓冲消息，直到我们看到给定事务中的所有消息。</td>
</tr>
</tbody>
</table>
<h1>保证概要</h1>
<h2 id="生产者幂等性保证">生产者幂等性保证</h2>
<p>为了实现幂等生产者语义，我们引入了生产者 ID（以下称为 PID）和 Kafka 消息的序列号的概念。在初始化期间，每个新生产者都将被分配一个唯一的 PID。 PID 分配对用户完全透明，永远不会暴漏给客户端。</p>
<p>对于给定的 PID，序列号将从零开始并单调递增，每个主题分区（topic partition）产生一个序列号。生产者发送的每条消息的序列号都会增加。类似地，代理将为该主题分区提交的每条消息增加与 PID -&gt; 主题分区对关联的序列号。最后，代理将拒绝来自生产者的消息，除非它的序列号恰好比来自该 PID -&gt; 主题分区对的最后提交的消息序列号大 1。</p>
<p>这确保了即使生产者必须在失败时重试请求，每条消息也将仅在日志中持久化一次。此外，由于生产者的每个新实例都分配了一个新的、唯一的 PID，<strong>我们只能保证在单个生产者会话中的幂等生产</strong>。这些语义已在本文档之前讨论过。</p>
<p>这些幂等生产者语义对于无状态应用程序（如指标跟踪和审计）可能很有用。</p>
<h2 id="事物保证">事物保证</h2>
<p>其核心，事务保证使应用程序能够以原子方式生成多个 <code>TopicPartition</code>，即。对这些 <code>TopicPartition</code> 的所有写入都将作为一个单元成功或失败。</p>
<p>此外，由于消费者进度被记录为对 <code>offsets</code> 主题的写入，因此利用上述功能使应用程序能够将消费和生产的消息批处理到单个原子单元中，即。 只有当整个“consume-transform-produce”完整执行时，一组消息才可以被视为已消费。</p>
<p>此外，有状态应用程序还将能够确保应用程序的多个会话之间的连续性。换句话说，Kafka 可以保证跨应用程序反弹的幂等生产和事务恢复。</p>
<p>为了实现这一点，我们要求应用程序提供一个在应用程序的所有会话中都稳定的唯一 ID。对于本文档的其余部分，我们将此类 ID 称为 <code>TransactionalId</code>。虽然 TransactionalId 和内部 PID 之间可能存在 1-1 映射，但主要区别在于 <code>TransactionalId</code> 是由用户提供的，并且是下面描述的跨生产者会话的幂等保证。</p>
<p>当提供这样的 TransactionalId 时，Kafka 将保证：</p>
<ol>
<li>恰好只有一个具有给定 TransactionalId 的活动生产者。这是通过在具有相同 TransactionalId 的新实例上线时隔离旧代来实现的。</li>
<li>跨应用程序会话的事务恢复。如果应用程序实例死亡，下一个实例可以保证任何未完成的事务都已完成（无论是中止还是提交），从而在恢复工作之前使新实例处于干净状态。</li>
</ol>
<p>请注意，这里提到的事务保证是从生产者的角度来看的。在消费者方面，保障力度稍弱。特别是，我们不能保证一个提交的事务的所有消息都会被一起消费。这有几个原因：</p>
<ol>
<li>对于压缩主题，事务的某些消息可能会被更新的版本覆盖。</li>
<li>事务可能跨越日志段。因此，当旧段被删除时，我们可能会在事务的第一部分丢失一些消息。</li>
<li>消费者可能会寻求事物中的任意点，因此会错过一些初始消息。</li>
<li>消费者可能不会从参与事物的所有分区中消费。因此，他们将永远无法读取包含事物的所有消息。</li>
</ol>
<h2 id="核心概念">核心概念</h2>
<p>为了实现事物，即。确保以原子方式生成和使用一组消息，我们引入了几个新概念：</p>
<ol>
<li>我们引入了一个称为<code>事务协调器（Transaction Coordinator）</code>的新实体。与消费者组协调器类似，每个生产者都分配了一个事务协调器，所有分配 PID 和管理事务的逻辑都由事务协调器完成。</li>
<li>我们引入了一个新的内部 kafka 主题，称为<code>事务日志（Transaction Log）</code>。与 <code>Consumer Offsets 主题</code>类似，事务日志是每个事务的持久和复制记录。事务日志是事务协调器的状态存储，日志最新版本的快照封装了每个活动事务的当前状态。</li>
<li>我们引入了<code>控制消息（Control Messages）</code>的概念。这些是写入用户主题的特殊消息，由客户端处理，但从未向用户公开。例如，它们用于让代理向消费者指示先前获取的消息是否已被原子提交。之前已经在 <a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/KAFKA-1639">Support control messages in Kafka</a> 提出了控制消息。</li>
<li>我们引入了 <code>TransactionalId</code> 的概念，使用户能够以持久的方式唯一标识生产者。具有相同 <code>TransactionalId</code> 的生产者的不同实例将能够恢复（或中止）由前一个实例实例化的任何事务。</li>
<li>我们引入了<code>生产者时代（producer epoch）</code>的概念，这使我们能够确保只有一个具有给定 <code>TransactionalId</code> 的生产者的合法活动实例，从而使我们能够在发生故障时维护事务保证。</li>
</ol>
<p>除了上述新概念之外，我们还引入了新的请求类型、现有请求的新版本和核心消息格式的新版本，以支持事务。所有这些的细节将推迟到其他文件。</p>
<h1>数据流</h1>
<p><img data-src="../../images/middleware/kafka/Kafka-Transactions-Data-Flow.png" alt="Kafka-Transactions-Data-Flow"></p>
<p>在上图中，矩形边框代表不同的机器。底部的圆角框代表 <code>Kafka TopicPartitions</code>，对角线不同圆角的框代表在 broker 内部运行的逻辑实体。</p>
<p>每个箭头代表一个 RPC 或对 Kafka 主题的写入。这些操作按每个箭头旁边的数字指示的顺序进行。下面的部分编号以匹配上图中的操作，并描述相关操作。</p>
<h2 id="1-寻找事务协调器-——-FindCoordinatorRequest">1. 寻找事务协调器 —— FindCoordinatorRequest</h2>
<p>由于事务协调器处于分配 PID 和管理事务的中心，因此生产者要做的第一件事就是发出 <code>FindCoordinatorRequest</code>到任意的代理以发现其协调器的位置。以前称为 <code>GroupCoordinatorRequest</code>，但为了更简单的用途而重命名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">发生在 Client 的 Producer：KafkaProducer:TransactionManager.lookupCoordinator</span><br></pre></td></tr></table></figure>
<h2 id="2-获取生产者-ID-——-InitProducerIdRequest">2. 获取生产者 ID —— InitProducerIdRequest</h2>
<p>在发现其协调器的位置后，下一步是获取生产者的 PID。这是通过向事务协调器发出 <code>InitProducerIdRequest</code> 来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">发生在 Client 的 Producer：KafkaProducer:TransactionManager.initializeTransactions</span><br></pre></td></tr></table></figure>
<h3 id="2-1-当指定-TransactionalId-时">2.1 当指定 TransactionalId 时</h3>
<p>如果设置了 <code>transactional.id</code> 配置，则此 <code>InitProducerIdRequest</code> 携带 <code>TransactionalId</code> 一起传递，并在步骤 <code>2a</code> 中将相应 PID 的映射记录在事务日志中。这使我们能够将 <code>TransactionalId</code> 的相同 PID 返回给生产者的未来实例，从而能够恢复或中止先前未完成的交易。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">发生在 <span class="type">Broker</span> <span class="type">Server</span> 的 <span class="type">TransactionCoordinator</span>：<span class="type">TransactionCoordinator</span>.handleInitProducerId</span><br></pre></td></tr></table></figure>
<p>除了返回 PID 之外，<code>InitProducerIdRequest</code> 还执行以下任务：</p>
<ol>
<li>提升 PID 的时代 - epoch，以便生产者的任何先前僵尸实例都被隔离，并且无法继续其事务。</li>
<li>恢复（前滚或回滚）生产者的前一个实例留下的任何未完成的事务。</li>
</ol>
<p><code>InitProducerIdRequest</code> 的处理是同步的。一旦它返回，生产者就可以发送数据并开始新的事务。</p>
<h3 id="2-2-未指定-TransactionalId-时">2.2 未指定 TransactionalId 时</h3>
<p>如果配置中没有指定 <code>TransactionalId</code>，则分配一个新的 PID，生产者在单个会话中只享受幂等语义和事务语义。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">发生在 <span class="type">Broker</span> <span class="type">Server</span> 的 <span class="type">TransactionCoordinator</span>：<span class="type">TransactionCoordinator</span>.handleInitProducerId</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 Zookeeper 来保证分布式下产生唯一 ID</p>
</blockquote>
<h2 id="3-开始事物-–-beginTransaction-API">3. 开始事物 – beginTransaction() API</h2>
<p>新的 <code>KafkaProducer</code> 将有一个 <code>beginTransaction()</code> 方法，必须调用该方法来表示新事务的开始。生产者记录本地状态，表明事物已经开始，但从协调者的角度来看，在发送第一条记录之前，事物不会开始。</p>
<h2 id="4-消费-转换-生产循环">4. 消费-转换-生产循环</h2>
<p>在这个阶段，生产者开始消费-转换-生产构成事物的消息。这是一个漫长的阶段，可能包含多个请求。</p>
<h3 id="4-1-AddPartitionsToTxnRequest">4.1 AddPartitionsToTxnRequest</h3>
<p>第一次将新 <code>TopicPartition</code> 作为事务的一部分写入时，生产者将此请求发送到事务协调器。将此 <code>TopicPartition</code> 添加到事务中由协调器在步骤 <code>4.1a</code> 中记录。我们需要这些信息，以便我们可以将提交或中止标记写入每个 <code>TopicPartition</code>（有关详细信息，请参阅第 5.2 节）。如果这是添加到事务的第一个分区，协调器还将启动事务计时器。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">发生在 <span class="type">Broker</span> <span class="type">Server</span> 的 <span class="type">TransactionCoordinator</span>：<span class="type">TransactionCoordinator</span>.handleAddPartitionsToTransaction</span><br></pre></td></tr></table></figure>
<h3 id="4-2-ProduceRequest">4.2 ProduceRequest</h3>
<p>生产者通过一个或多个 <code>ProduceRequests</code>（从生产者的 <code>send</code> 方法触发）向用户的 <code>TopicPartitions</code> 写入一堆消息。这些请求包括 PID 、纪元和序列号，如 <code>4.2a</code> 中所示。</p>
<p>在提交事务之前，消费的偏移量在外部是不可见的，我们现在将讨论这个过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">发生在 Client 的 Producer：KafkaProducer.send</span><br></pre></td></tr></table></figure>
<h2 id="5-提交或中止事物">5. 提交或中止事物</h2>
<p>写入数据后，用户必须调用 <code>KafkaProducer</code> 的新 <code>commitTransaction</code> 或 <code>abortTransaction</code> 方法。这些方法将分别开始提交或中止事务的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">发生在 Client 的 Producer：KafkaProducer:commitTransaction|abortTransaction</span><br></pre></td></tr></table></figure>
<h3 id="5-1-EndTxnRequest">5.1 EndTxnRequest</h3>
<p>当生产者完成事物时，必须调用新引入的 <code>KafkaProducer.endTransaction</code> 或 <code>KafkaProducer.abortTransaction</code>。前者使下游消费者可以使用 4 中产生的数据。后者有效地从日志中删除了生成的数据：用户永远无法访问它，即。下游消费者将读取并丢弃中止的消息。</p>
<p>无论调用哪个生产者方法，生产者都会向事务协调器发出 <code>EndTxnRequest</code>，并带有指示事务是提交还是中止的附加数据。收到此请求后，协调器：</p>
<ol>
<li>将 <code>PREPARE_COMMIT</code> 或 <code>PREPARE_ABORT</code> 消息写入<strong>事务日志</strong>。 （步骤 <code>5.1a</code>）</li>
<li>开始通过 <code>WriteTxnMarkerRequest</code> 将称为 <code>COMMIT</code>（或 <code>ABORT</code>）标记的命令消息写入<strong>用户日志</strong>的过程。 （见下文第 5.2 节）。</li>
<li>最后将 <code>COMMITTED</code>（或 <code>ABORTED</code>）消息写入<strong>事务日志</strong>。 （见下文 5.3）。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">发生在 <span class="type">Broker</span> <span class="type">Server</span> 的 <span class="type">TransactionCoordinator</span>：<span class="type">TransactionCoordinator</span>.handleEndTransaction</span><br></pre></td></tr></table></figure>
<h3 id="5-2-WriteTxnMarkerRequest">5.2 WriteTxnMarkerRequest</h3>
<p>该请求由事务协调器向作为事务一部分的每个 <code>TopicPartition</code> 的领导者发出。收到此请求后，每个代理都会将 <code>COMMIT(PID)</code> 或 <code>ABORT(PID)</code> 控制消息写入<strong>用户日志</strong>。 （步骤 <code>5.2a</code>）</p>
<p>此消息向消费者指示具有给定 PID 的消息是必须交付给用户还是丢弃。因此，消费者将缓冲具有 PID 的消息，直到它读取相应的 <code>COMMIT</code> 或 <code>ABORT</code> 消息，此时它将分别交付或丢弃消息。</p>
<p>请注意，如果 <code>__consumer-offsets</code> 主题是事务中的 <code>TopicPartitions</code> 之一，则提交（或中止）标记也会写入消费者偏移主题日志，并通知消费者协调器它需要在以下情况下实现这些偏移量：在中止的情况下提交或忽略它们（左侧的步骤 5.2a）。</p>
<h3 id="5-3-写入最后的-Commit-或-Abort-消息">5.3 写入最后的 Commit 或 Abort 消息</h3>
<p>在所有提交或中止标记写入数据日志后，事务协调器将最终的 <code>COMMITTED</code> 或 <code>ABORTED</code> 消息写入<strong>事务日志</strong>，表明事务已完成（图中的步骤 5.3）。此时，事务日志中与事务有关的大部分消息都可以删除。</p>
<p>我们只需要保留已完成交易的 PID 和时间戳，因此我们最终可以删除生产者的 TransactionalId-&gt;PID 映射。请参阅下面的过期 PID 部分。</p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 入门</title>
    <url>/middleware/Nacos-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>Nacos 简介</h1>
<p>Nacos 可以帮助我们发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助我们快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 的关键特性包括:</p>
<ul>
<li>
<p><strong>服务发现和服务健康监测</strong></p>
<p>Nacos 支持基于 DNS 和基于  RPC 的服务发现。服务提供者使用 <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a> 或一个独立的 Agent 注册 Service 后，服务消费者可以使用 DNS 或 <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a> 查找和发现服务。</p>
<p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP) 和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测 2 种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>
<blockquote>
<p>基于 DNS 的服务发现和查找在 V2.0.0 中使用 CoreDNS，但是暂未成熟、稳定；</p>
<p>独立的 Agent 是以 Sidecar 边车模式通过 <a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/tree/master/spring-cloud-alibaba-starters/spring-cloud-starter-alibaba-sidecar">spring-cloud-starter-alibaba-sidecar</a> 来提供的。</p>
</blockquote>
</li>
</ul>
<span id="more"></span>
<ul>
<li>
<p><strong>动态配置服务</strong></p>
<p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
<p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p>
<p>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p>
<p>Nacos 提供了一个简洁易用的UI 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>
</li>
<li>
<p><strong>服务及其元数据管理</strong></p>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>
</li>
</ul>
<h1>Nacos 术语</h1>
<p>Nacos 引入了一些基本的概念，系统性的了解一下这些概念可以帮助您更好的理解和正确的使用 Nacos 产品。</p>
<h2 id="命名空间-Namespace">命名空间 - Namespace</h2>
<p>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
<blockquote>
<p>bootstrap 中的 namespace 属性为命名空间的 ID，而非名称，默认 public 的 namespace 属性为空。</p>
</blockquote>
<h2 id="配置集-Data">配置集 - Data</h2>
<p>一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p>
<h2 id="配置集-ID-Data-ID">配置集 ID - Data ID</h2>
<p>Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。</p>
<h2 id="配置分组-Group">配置分组 - Group</h2>
<p>Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 <code>DEFAULT_GROUP</code> 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。</p>
<p>它们的关系如下图所示：</p>
<p><img data-src="../../images/middleware/nacos/nacos_data_model.png" alt="nacos_data_model"></p>
<h1>Nacos 架构</h1>
<p><img data-src="../../images/middleware/nacos/nacos-architecture.png" alt="nacos_arch"></p>
<p>Provider 和 Consumer 通过客户端 Client 或者边车 Sidecar 使用 HTTP/RPC/DNS 等方式与 Server 进行交互，Server 包含可选的配置服务（Config Service）和命名服务（Naming Service），Nacos 本身支持多数据中心，天然分布式，使用一致性协议 Raft 来保证一致性，同时提供了 Console 和 UI 进行监控和管理交互。</p>
<h2 id="客户端类试图">客户端类试图</h2>
<p><img data-src="../../images/middleware/nacos/class-diagram.png" alt="nacos_sdk_class_relation"></p>
<p>Factory 工厂用来创建相应的配置服务或命名服务。</p>
<p>配置服务类使用 ClientWorker 与服务端进行沟通，在传输层使用 RPC 代理进行通讯，Java 客户端使用的是 gRPC 实现。</p>
<p>命名服务类同样适用 RPC 与服务端进行沟通，命名服务不需要时常监听变更，所以少了 Worker 作业类的监听、同步和缓存等。</p>
<h1>Spring-Cloud 集成</h1>
<p>Nacos 提供了开箱即用的 spring boot autoconfig starter 帮助我们快速集成动态配置或服务发现及健康检查功能。</p>
<h2 id="动态配置">动态配置</h2>
<p>Spring Cloud Nacos Config 是通过 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-context-application-context-services">Spring Cloud Context</a> 的引导上下文 (Bootstrap Context) 来集成动态配置功能。</p>
<p>引导上下文从外部配置源加载配置属性并解密本地依赖的外部配置文件中的属性，它是整个应用程序的父上下文，在启动和 Environment 后处理期间可用，直到准备好应用上下文 (Application Context)。</p>
<p>这两个上下文共享环境 <code>Environment</code> ，它是任何 Spring 应用程序的外部属性的来源。<strong>默认情况下，引导加载到的外部属性有更高的优先级，它们不能被本地配置覆盖。</strong></p>
<blockquote>
<p>可以参考官方 <a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-config-example/readme-zh.md">DEMO 及文档</a> 快速了解集成及使用</p>
</blockquote>
<h3 id="应用上下文层级">应用上下文层级</h3>
<p>如果我们是从 <code>SpringApplication</code> 或 <code>SpringApplicationBuilder</code> 来启动构建应用程序上下文，则 Bootstrap 上下文会作为父级添加到该上下文中。Spring 的一个特性是子上下文从其父上下文继承属性源和配置文件，因此与在没有 Spring Cloud Config 的情况下构建相同的上下文相比，“main”应用程序上下文包含额外的属性源。这些额外的属性包含：</p>
<ul>
<li>
<p>“引导 - bootstrap”：如果在 Bootstrap 上下文中找到任何 <code>PropertySourceLocator</code> 并且它们具有非空属性，则以高优先级显示可选的 <code>CompositePropertySource</code>，<code>CompositePropertySource</code> 以链表形式组合多个属性源，头部的元素会优先被使用。</p>
<p>Nacos 正是实现了 <code>PropertySourceLocator</code> 并从 Server 加载并构建组合的多个属性源 <code>CompositePropertySource</code>，Nacos 会按如下顺序及规则加载属性源：</p>
<ul>
<li>加载共享配置：通过 <code>spring.cloud.nacos.config.shared-configs[0]=xxx</code> 配置项加载多个共享配置</li>
<li>加载扩展配置：通过 <code>spring.cloud.nacos.config.extension-configs[0]=xxx</code> 配置项加载多个扩展配置</li>
<li>加载应用程序配置</li>
</ul>
<p>在 Nacos 中，应用程序配置的 Data ID 的完整格式如下：</p>
<p><code>$&#123;prefix&#125;-$&#123;spring.profile.active&#125;.$&#123;file-extension&#125;</code></p>
<ol>
<li>prefix 默认为 <code>spring.application.name</code> 的值，也可以通过配置项 <code>spring.cloud.nacos.config.prefix</code> 来配置。</li>
<li><code>spring.profile.active</code> 即为当前激活的<strong>一个或多个</strong>环境 profile。</li>
<li><code>file-exetension</code> 为配置内容的数据格式，可以通过配置项 <code>spring.cloud.nacos.config.file-extension</code> 来配置。spring 配置使用 properties 或 yml 类型。</li>
</ol>
<p>Nacos 按如下顺序加载应用程序配置：</p>
<ul>
<li>只加载以 <code>$&#123;prefix&#125;</code> 为 Data ID 的配置文件，<code>file-extension</code> 配置项还是要和服务端的配置格式一致</li>
<li>包含后缀的  <code>$&#123;prefix&#125;.$&#123;file-extension&#125;</code></li>
<li>当前激活环境的多个 profile 的完整格式 Data ID</li>
</ul>
<p><strong>后加载的配置会被置于链表的头部，所以配置的优先顺序和加载顺序相反</strong></p>
</li>
<li>
<p>”应用程序配置：[classpath:bootstrap.yml]”（以及相关文件，如果 Spring 配置文件处于激活状态）：如果有 <code>bootstrap.yml</code>（或 <code>.properties</code>），则这些属性用于配置 Bootstrap 上下文。然后在设置其父级时将它们添加到子级上下文中。它们的优先级低于 <code>application.yml</code>（或 <code>.properties</code>）以及作为创建 Spring Boot 应用程序过程的正常部分添加到子级的任何其他属性源。</p>
</li>
</ul>
<h3 id="覆盖远程属性值">覆盖远程属性值</h3>
<p>通过引导上下文添加到应用程序的属性源通常是“远程的”（例如，来自 Nacos Config Server）。默认情况下，它们不能在本地被覆盖。如果你想让应用程序使用自己的系统属性或配置文件覆盖远程属性，<strong>远程属性源</strong>必须通过设置 <code>spring.cloud.config.allowOverride=true</code> 来授予它权限（在本地设置它不起作用）。一旦设置了该标志，两个更细粒度的设置将控制远程属性相对于系统属性和应用程序本地配置是否可被覆盖：</p>
<ul>
<li><code>spring.cloud.config.overrideNone=true</code>: 任何本地属性源可以覆盖远程设置。</li>
<li><code>spring.cloud.config.overrideSystemProperties=false</code>: 只有系统属性、命令行参数和环境变量（而不是本地配置文件）可以覆盖远程设置。</li>
</ul>
<blockquote>
<p>如果要完全禁用远程配置服务而使用本地配置，可以通过 <code>spring.cloud.nacos.config.enabled=false</code> 来设置。</p>
</blockquote>
<h3 id="Environment-变更">Environment 变更</h3>
<p><img data-src="../../images/middleware/nacos/nacos-config-starter-sequence.svg" alt="nacos-config-starter-sequence"></p>
<p>Nacos 通过 ClientWorker 的 Schedule 执行器线程轮询 Server 来监测配置变更，并将变更通知到 <code>ConfiService</code> 中添加的监听器；Nacos Config Starter 的 <code>NacosContextRefresher</code> 该类默认为所有获取数据成功的 Nacos 的配置项添加监听器，在监听到服务端配置发生变化时会发送 <code>RefreshEvent</code> 事件给 Spring 并实时触发 <code>ContextRefresher</code> 的 refresh 方法 。</p>
<p>Spring 的 <code>refresh</code> 方法主要做两件事：</p>
<ul>
<li>刷新环境 <code>Environment</code>，将环境中属性源 <code>PropertySource</code> 相对应的属性 bean 从旧的换成新的，并发布 <code>EnvironmentChangeEvent</code> 事件告知变更的属性源的键列表。</li>
<li>触发 <code>RefreshScope</code> 的 <code>refreshAll</code> 操作，针对 RefreshScope 来说就是清空了他所代理管理的缓存 bean，待再次调用时重新创建，创建过程就会注入新的属性源。</li>
</ul>
<h4 id="EnvironmentChangeEvent">EnvironmentChangeEvent</h4>
<p>应用程序可以监听 <code>EnvironmentChangeEvent</code> 并以几种标准方式对更改做出反应（例如用户可以以普通方式注册 <code>ApplicationListener</code> 为 <code>@Beans</code> 来实现监听）。当观察到 <code>EnvironmentChangeEvent</code> 时，该事件具有已更改的键列表，应用程序可以使用这些：</p>
<ul>
<li>在上下文中重新绑定任何 <code>@ConfigurationProperties</code> bean 的值</li>
<li>为 <code>logging.level.*</code> 中的任何属性设置日志级别</li>
</ul>
<p><code>EnvironmentChangeEvent</code> 涵盖了一部分刷新用例，只要您可以实际对 <code>Environment</code> 进行更改并发布事件即可。请注意，这些 API 是公共的，并且是核心 Spring 的一部分）。您可以通过访问 <code>/configprops</code> Endpoint（一个普通的 Spring Boot Actuator 功能）来验证更改是否绑定到 <code>@ConfigurationProperties</code> bean。例如，<code>DataSource</code> 可以在运行时更改其 <code>maxPoolSize</code>（Spring Boot 创建的默认 <code>DataSource</code> 是 <code>@ConfigurationProperties</code> bean）并动态增加容量。</p>
<blockquote>
<p>Nacos 也同样支持 Actuator 的 Endpoint 并提供了专门的 <code>/nacosconfig</code> Endpoint 来暴露配置信息。</p>
</blockquote>
<p>重新绑定 <code>@ConfigurationProperties</code> 不涵盖另一部分用例，在这些用例中，您需要对刷新进行更多控制，并且需要对整个 <code>ApplicationContext</code> 进行原子更改。为了解决这些问题，我们可以使用 <code>@RefreshScope</code>。</p>
<h4 id="Refresh-Scope">Refresh Scope</h4>
<p>当配置发生更改时，标记为 <code>@RefreshScope</code> 的 Spring <code>@Bean</code> 会被特殊处理。此功能解决了仅在初始化时才注入配置的有状态 bean 的问题。例如，如果在通过 <code>Environment</code> 更改数据库 URL 时 <code>DataSource</code> 具有打开的连接，您可能希望这些连接的持有者能够完成他们正在做的事情。然后，下一次从池中获取连接时，它会获得一个使用新 URL 的连接 。</p>
<p>有时，甚至可能强制在某些只能初始化一次的 bean 上应用 <code>@RefreshScope</code> 注释。如果 bean 是“不可变的”，则必须使用 <code>@RefreshScope</code> 注解 bean 或在属性键 <code>spring.cloud.refresh.extra-refreshable</code> 下指定类名。</p>
<p>刷新作用域的 bean 是在使用时（即调用方法时）初始化的惰性代理，作用域充当初始化值的缓存。要强制 bean 在下一个方法调用时重新初始化，您必须使其缓存条目无效。</p>
<p><code>RefreshScope</code> 是上下文中的一个 bean，并且有一个公共的 <code>refreshAll()</code> 方法通过清除目标缓存来刷新范围内的所有 bean。<code>/refresh</code> 端点公开了这个功能（通过 HTTP 或 JMX）。要按名称刷新单个 bean，还有一个 <code>refresh(String)</code> 方法。</p>
<h3 id="配置管理">配置管理</h3>
<p>Nacos 不但提供了 Actuator Endpoint 的 Rest 接口来暴露和管理配置项，还提供了可视化的 Web UI 来进行编辑、存储、分发、变更管理、历史版本管理、变更审计等。</p>
<h2 id="服务发现与健康检查">服务发现与健康检查</h2>
<blockquote>
<p>可以参考官方 <a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/readme-zh.md">DEMO 及文档</a>快速了解集成及使用</p>
</blockquote>
<h3 id="服务发现">服务发现</h3>
<h4 id="EnableDiscoveryClient-注解"><code>@EnableDiscoveryClient</code> 注解</h4>
<p>Spring Cloud Commons 提供了 <code>@EnableDiscoveryClient</code> 注解。这会寻找带有 <code>META-INF/spring.factories</code> 的 <code>DiscoveryClient</code> 和 <code>ReactiveDiscoveryClient</code> 接口的实现。服务发现的客户端实现在  <code>spring.factories</code> 的键 <code>org.springframework.cloud.client.discovery.EnableDiscoveryClient</code> 下中添加一个自己的配置类。<code>DiscoveryClient</code> 实现的示例包括  <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix Eureka</a>, <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-consul/">Spring Cloud Consul Discovery</a> 和 <a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-zookeeper/">Spring Cloud Zookeeper Discovery</a>。</p>
<blockquote>
<p>Nacos 并没有使用该种 SPI 的形式直接提供服务发现客户端实现，而是使用在 <code>spring.factories</code> 下提供 Spring Boot 的自动配置实现来自动注入 <code>DiscoveryClient</code> 的实现 <code>NacosDiscoveryClient</code>。</p>
</blockquote>
<p>Spring Cloud 默认提供阻塞和响应式服务发现客户端。您可以通过设置 <code>spring.cloud.discovery.blocking.enabled=false</code> 或 <code>spring.cloud.discovery.reactive.enabled=false</code> 轻松禁用阻塞和/或响应式客户端。要完全禁用服务发现，您只需设置 <code>spring.cloud.discovery.enabled=false</code>。</p>
<blockquote>
<p>Nacos 同样支持这两种类型的客户端配置，也可以直接使用 Nacos 的 <code>spring.cloud.nacos.discovery.enabled=false</code> 来禁用服务发现。</p>
</blockquote>
<p>默认情况下，<code>DiscoveryClient</code> 的实现会自动将本地 Spring Boot 服务器注册到远程发现服务器。可以通过在 <code>@EnableDiscoveryClient</code> 中设置 <code>autoRegister=false</code> 来禁用此行为。</p>
<blockquote>
<p><code>@EnableDiscoveryClient</code> 不再需要。如果类路径上发现 <code>DiscoveryClient</code> 的实现，Spring Boot 应用程序就会自动向服务发现服务器注册。</p>
</blockquote>
<h4 id="负载均衡">负载均衡</h4>
<p><code>NacosServerList</code> 实现了 <code>com.netflix.loadbalancer.ServerList</code> 接口，并在 <code>@ConditionOnMissingBean</code> 的条件下进行自动注入，</p>
<p>Nacos Discovery Starter 默认集成了 <code>Ribbon</code> ，所以对于使用了 <code>Ribbon</code> 做负载均衡的组件，可以直接使用 Nacos 的服务发现。</p>
<p>除了 Ribbon，Spring Cloud 也提供了自己的 Load-balancer 实现，我们可以轻松的将 <code>RestTemplate</code>、<code>FeignClient</code>、<code>WebClient</code> 配置为自动使用负载均衡器的客户端。</p>
<h3 id="服务注册">服务注册</h3>
<p>Spring Cloud Nacos Discovery 遵循了 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-commons-common-abstractions">Spring Cloud Common</a> 标准，实现了 <code>AutoServiceRegistration</code>、<code>ServiceRegistry</code>、<code>Registration</code> 这三个接口。</p>
<p>Commons 提供了一个 <code>ServiceRegistry</code> 接口，该接口提供了 <code>register(Registration)</code> 和 <code>deregister(Registration)</code> 等方法，可以让你提供自定义的注册服务。<code>Registration</code> 是一个标记接口。</p>
<blockquote>
<p>Nacos 同样也使用该接口来注册服务，通过 Spring Boot 自动配置类提供 <code>ServiceRegistry</code> 的实现 <code>NacosServiceRegistry</code>。</p>
</blockquote>
<p>每个 <code>ServiceRegistry</code> 实现都有自己的 <code>Registry</code> 实现。</p>
<ul>
<li><code>ZookeeperRegistration</code> 与 <code>ZookeeperServiceRegistry</code> 一起使用</li>
<li><code>EurekaRegistration</code> 与 <code>EurekaServiceRegistry</code> 一起使用</li>
<li><code>ConsulRegistration</code> 与 <code>ConsulServiceRegistry</code> 一起使用</li>
<li><code>NacosRegistration</code> 与 <code>NacosServiceRegistry</code> 一起使用</li>
</ul>
<p>在 Spring Cloud 应用的启动阶段，监听了 <code>WebServerInitializedEvent</code> 事件，当 Web 容器初始化完成后，即收到 <code>WebServerInitializedEvent</code> 事件后，会触发注册的动作，调用 <code>ServiceRegistry</code> 的 <code>register</code> 方法，将服务注册到 Nacos Server。</p>
<blockquote>
<p>如果需要有更加自定义的获取服务信息或管理服务，可以使用 <code>@Autowired</code> 注入一个 <code>NacosRegistration</code> 实例，通过其 <code>NacosDiscoveryProperties</code> 持有的 <code>NamingService</code> 字段内容直接调用 Nacos API。</p>
</blockquote>
<h4 id="服务注册-Actuator-Endpoint">服务注册 Actuator Endpoint</h4>
<p>Spring Cloud Commons 提供了一个 <code>/service-registry</code> 执行期端点。这个端点依赖于 Spring Application Context 中的 <code>Registration</code> bean。使用 GET 调用 <code>/service-registry</code> 会返回 <code>Registration</code> 服务实例的注册状态。使用带有 JSON 正文的同一端点的 POST 会将当前注册的状态更改为新值。 JSON 正文必须包含具有合法值的 <code>status</code> 字段。请参阅您在更新状态时使用的 <code>ServiceRegistry</code> 实现的文档以及为状态返回的值。例如，Eureka 支持的状态是 <code>UP、DOWN、OUT_OF_SERVICE</code> 和 <code>UNKNOWN</code>。</p>
<blockquote>
<p>Nacos 也同样支持 Actuator 的 Endpoint 并提供了专门的 <code>/nacos_discovery</code> Endpoint 来获取本机已订阅的服务信息及配置信息。</p>
</blockquote>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
        <tag>Service Discovery</tag>
        <tag>Service Config</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分布式锁</title>
    <url>/middleware/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1>用锁来做什么？</h1>
<p>在计算机科学中，锁是多线程环境中防止不同线程对同一资源进行操作的机制。锁的目的是确保在可能尝试执行同一工作的多个节点中，只有一个节点实际执行此操作（至少一次只有一个）。这项工作可能是将一些数据写入共享存储系统、执行一些计算、调用一些外部 API 等。概括而言，您可能需要在分布式应用程序中锁定的原因有两个：<strong>为了效率</strong>或<strong>为了正确性</strong>。为了区分这些情况，您可以询问如果锁定失败会发生什么：</p>
<ul>
<li><strong>效率 - Efficiency</strong>：获取锁可以避免你不必要地做同样的工作两次（例如一些昂贵的计算）。</li>
<li><strong>正确性 - Correctness</strong>：使用锁可以防止并发进程相互干扰并破坏系统状态。如果锁失败，两个节点同时处理同一份数据，结果是文件损坏，数据丢失，永久性不一致、错误的执行结果或其他一些严重问题。</li>
</ul>
<p>两者都是需要锁的有效情况，但您需要非常清楚您正在处理的是两者中的哪一个。</p>
<h1>安全性和活跃性保证</h1>
<p>我们将仅使用三个属性对我们的设计进行建模，从我们的角度来看，这是以有效方式使用分布式锁所需的最低保证。</p>
<ol>
<li><strong>安全特性</strong>：互斥。在任何给定时刻，只有一个客户端可以持有锁。</li>
<li>活跃性属性 A：无死锁。最终总是有可能获得锁，即使锁定资源的客户端崩溃或被分区。</li>
<li>活跃性属性 B：容错。只要大多数 Redis 节点都已启动，客户端就可以获取和释放锁。</li>
</ol>
<span id="more"></span>
<h1>分布式锁</h1>
<p>分布式锁在许多环境中是非常有用的原语，在这些环境中，不同的进程必须以互斥的方式使用共享资源。操作系统或我们的软件一般会使用锁管理器来组织和顺序化去访问资源。<strong>分布式锁管理器 (distributed lock manager - DLM</strong>) 运行在集群中的每台机器上，并具有集群范围相同副本的锁数据库。通过这种方式，DLM 为分布在多台机器上的集群中的软件应用程序提供了一种同步对共享资源的访问的方法。</p>
<h2 id="为什么基于故障转移的实现是不够的">为什么基于故障转移的实现是不够的</h2>
<p>为了了解我们想要改进的地方，让我们分析大多数基于 Redis 的分布式锁库的当前状态。</p>
<p>使用 Redis 锁定资源的最简单方法是在实例中创建 key。创建的 key 通常是有限的生存时间的，使用 Redis 过期功能，以便最终将其释放（我们列表中的属性 2）。</p>
<p>从表面上看，这很有效，但有一个问题：这是我们架构中的单点故障。如果 Redis master 宕机了怎么办？好吧，让我们添加一个 slave！如果 master 不可用，则使用它。不幸的是，这是不可行的。这样做我们无法实现互斥的安全属性，<strong>因为 Redis 复制是异步的</strong>。</p>
<p>这个模型有一个明显的竞争条件：</p>
<ol>
<li>客户端 A 获取 master 的锁</li>
<li>写入 key 到 slave 之前，master 崩溃了</li>
<li>slave 提升为 master</li>
<li>客户端 B 获取对 A 已经持有锁的同一资源的锁。<strong>违背安全性！</strong></li>
</ol>
<p>有时，在特殊情况下（例如在故障期间），多个客户端可以同时持有锁是完全没问题的。如果允许这种情况，您可以使用基于复制的解决方案。否则，我们建议实施本文档中描述的解决方案。</p>
<h1>基于单实例的正确实现</h1>
<p>在尝试克服上述单实例崩溃的限制之前，让我们检查一下如何在这个简单的情况下正确地做到这一点，因为在不经常出现竞争条件的应用程序中，这实际上是一个可行的解决方案，并且因为锁定单个实例是我们将用于此处描述的分布式算法的基础。</p>
<p>要获取锁，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>
<p>该命令仅在 key 不存在（NX 选项）时设置，过期时间为 30000 毫秒（PX 选项）。将 key 设置为值 “myrandomvalue”。该值在所有客户端和所有锁定请求中必须是唯一的。</p>
<p>随机值用于以安全的方式释放锁，该脚本告诉 Redis：仅当 key 存在并且存储在 key 中的值正是我期望的值时才删除它。这是通过以下 Lua 脚本完成的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这对于避免删除由另一个客户端创建的锁很重要。例如，客户端可能获取锁，在某些操作中被阻塞超过锁有效时间（key 将到期的时间），然后删除其他客户端已经获取的锁。仅使用 DEL 是不安全的，因为客户端可能会删除另一个客户端的锁。使用上面的脚本，每个锁都用一个随机字符串“签名”，因此只有当它仍然是试图删除它的客户端设置的锁时，才会删除它。</p>
<p>这个随机字符串应该是什么？我假设它是来自 /dev/urandom 的 20 个字节，但是你可以找到更便捷的方法来使它对你的任务足够唯一。例如，一个安全的选择是用 /dev/urandom 为 RC4 做种子，并从中生成一个伪随机流。一个更简单的解决方案是使用 unix 时间微秒，将它与客户端 ID 连接，它不是那么安全，但可能适合大多数环境中的任务。</p>
<p>我们用作 key *存活时间（time to live - TTL）*的时间，称为“锁有效时间”。它既是自动释放时间，也是客户端在另一个客户端能够再次获取锁之前执行操作所需的时间，也就是该客户端对该 key 的租期，在技术上不违反互斥保证的情况下，互斥保证只限于从获取锁那一刻起的给定时间窗口。</p>
<p>所以现在我们有一个很好的方法来获取和释放锁。我们推理由单个始终可用的实例组成的非分布式系统是安全的。让我们将这个概念扩展到没有这种保证的分布式系统。</p>
<h1>Redlock 算法</h1>
<p>在算法的分布式版本中，我们假设我们有 N 个 Redis master 节点。这些节点是完全独立的，所以我们不使用复制或任何其他隐式协调系统。我们已经描述了如何在单个实例中安全地获取和释放锁。我们理所当然地认为算法会在单个实例中使用这种方法来获取和释放锁。</p>
<p>为了获取锁，客户端执行以下操作：</p>
<ol>
<li>客户端以毫秒为单位获取当前时间。</li>
<li>它尝试顺序获取所有 N 个实例中的锁，并在所有实例中使用相同的 key 和随机值。在第 2 步中，当在每个实例中设置锁时，客户端使用一个比总锁自动释放时间更小的超时时间来获取锁。例如，如果自动释放时间为 10 秒，则超时时间可能在 ~ 5-50 毫秒范围内。这可以防止客户端长时间处于阻塞状态，试图与已关闭的 Redis 节点通信：如果实例不可用，我们应该尽快尝试与下一个实例通信。</li>
<li>客户端通过从当前时间中减去步骤 1 中获得的时间戳来计算获取锁所用的时间。当且仅当客户端能够在大多数实例（至少 3 个）中获取锁，并且获取锁所用的总时间小于锁有效时间，则认为该锁已获取。</li>
<li>如果获得了锁，则其有效时间被视为初始有效时间减去经过的时间，如步骤 3 中计算的那样。</li>
<li>如果客户端由于某种原因获取锁失败（或者它无法锁定 N/2+1 个实例或有效时间为负），它将尝试解锁所有实例（即使是它认为没有锁定的实例）能够锁定）。</li>
</ol>
<h2 id="算法是异步的吗？">算法是异步的吗？</h2>
<p>该算法依赖于这样的假设：虽然进程之间没有同步时钟，但每个进程中的本地时间仍然以大致相同的速率流动，与锁的自动释放时间相比误差很小。这个假设与现实世界的计算机非常相似：每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来实现很小的时钟漂移。</p>
<p>此时我们需要更好地指定我们的互斥规则：<strong>只有持有锁的客户端会在锁的有效期内（如步骤 3 中获得的）内终止其工作，我们才能保证互斥</strong>，减去一些时间（只需几毫秒以补偿进程之间的时钟漂移）。</p>
<p>有关需要绑定*时钟漂移（clock drift）*的类似系统的更多信息，这篇论文是一个有趣的参考：<a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=74870">Leases：一种用于分布式文件缓存一致性的高效容错机制。</a></p>
<p>如果在锁的有效期内未停止其工作，如下图：</p>
<p><img data-src="../../images/middleware/redis/exceed-ttl.png" alt="image-20200804204605476"></p>
<p>客户端 1 在获得锁之后发生了很长时间的 GC pause，在此期间，它获得的锁租约过期了，而客户端 2 重新获得了该锁。当客户端 1 从 GC pause 中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源发起了写数据请求，而这时锁实际上被客户端 2 持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</p>
<p>那怎么解决这个问题呢？<a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">Martin</a> 给出了一种方法，称为 fencing token。fencing token 是一个单调递增的数字，当客户端成功获取锁的时候它随同锁一起返回给客户端。而客户端访问共享资源的时候带着这个 fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突）。如下图：</p>
<p><img data-src="../../images/middleware/redis/fencing-token.png" alt="image-20200804204717901"></p>
<p>在上图中，客户端 1 先获取到的锁，因此有一个较小的 fencing token，等于 33，而客户端 2 后获取到的锁，有一个较大的 fencing token，等于 34。客户端 1 从 GC pause 中恢复过来之后，依然是向存储服务发送访问请求，但是带了 fencing token = 33。存储服务发现它之前已经处理过 34 的请求，所以会拒绝掉这次 33 的请求。这样就避免了冲突。</p>
<blockquote>
<p>但这种处理又将锁的排他安全性转移给了资源服务，如果资源服务本身就可以保证排他访问，为什么需要分布式锁？</p>
</blockquote>
<h2 id="失败时重试">失败时重试</h2>
<p>当客户端无法获取锁时，它应该在随机延迟后重试，以尝试使多个客户端同时尝试获取同一资源的锁（这可能会导致没有人获胜的脑裂情况）。此外，客户端尝试在大多数 Redis 实例中获取锁的速度越快，出现脑裂情况的窗口就越小（以及需要重试），<strong>所以理想情况下，客户端应该尝试使用多路复用将 SET 命令同时发送到 N 个实例。</strong></p>
<p>值得强调的是，对于未能获取大部分锁的客户端，尽快释放（部分）获取的锁是多么重要，这样就不需要等待 key 到期才能再次获取锁（但是，如果发生网络分区并且客户端不再能够与 Redis 实例通信，则在等待 key 到期时需要容忍可用性损失）。</p>
<h2 id="释放锁">释放锁</h2>
<p>释放锁很简单，只涉及在所有实例中释放锁，无论客户端是否相信它能够成功锁定给定的实例。</p>
<p>如果一个分布式锁占用资源时间过长，导致其他客户端无法在有效时间内获取同一资源，则可以使用 Redis 的发布订阅功能，去主动告知其他需要资源的客户端。</p>
<p><img data-src="../../images/middleware/redis/redis-lock-pub-sub.png" alt="Pub Sub Lock"></p>
<h2 id="安全性参数">安全性参数</h2>
<p>算法安全吗？我们可以尝试了解在不同场景中会发生什么。</p>
<p>首先让我们假设客户端能够在大多数情况下获取锁。所有实例都将包含一个具有相同生存时间的 key。但是，key 是在不同的时间设置的，因此 key 也会在不同的时间到期。但是如果第一个 key 最差在时间 T1（我们在联系第一台服务器之前采样的时间）设置，而最后一个 key 最差在时间 T2（我们从最后一个服务器获得回复的时间）设置，我们确信集合中第一个要过期的 key 至少会存在 MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT。所有其他 key 将在稍后到期，因此我们确信至少这次 key 将同时设置。</p>
<p>在设置了大多数 key 的时间内，另一个客户端将无法获取锁，因为如果 N/2+1 个 key 已经存在，则 N/2+1 次 SET NX 操作将无法成功。因此，如果获取了锁，则不可能同时重新获取它（违反互斥属性）。</p>
<p>但是，我们还希望确保多个客户端同时尝试获取锁不能同时成功。</p>
<p>如果客户端使用接近或大于锁定最大有效时间（我们用于 SET 的 TTL）的时间锁定大多数实例，它将认为锁定无效并解锁实例，所以我们只需要考虑客户端能够在小于有效时间的时间内锁定大多数实例的情况。在这种情况下，对于上面已经陈述的参数，对于  MIN_VALIDITY，没有客户端应该能够重新获取锁。因此，只有当锁定多数的时间大于 TTL 时间时，多个客户端才能同时锁定 N/2+1 个实例（“时间”为第 2 步的结束），从而使锁定无效。</p>
<h2 id="活跃性参数">活跃性参数</h2>
<p>系统活跃性基于三个主要特征：</p>
<ol>
<li>锁的自动释放（因为 key 过期）：最终 key 可以再次被锁定。</li>
<li>事实上，客户端通常会在没有获得锁时合作移除锁，或者当获得锁并且工作终止时合作移除锁，这使得我们可能不必等待 key 到期来重新获取锁锁。</li>
<li>事实上，当客户端需要重试锁时，它等待的时间比获取大多数锁所需的时间要长，以便在资源争用期间从概率上使脑裂情况不太可能发生。</li>
</ol>
<p>然而，我们在网络分区上容忍了与 <a target="_blank" rel="noopener" href="https://redis.io/commands/ttl">TTL</a> 时间相等的可用性损失，所以如果有连续的分区，我们需要无限期地容忍这个损失。每次客户端获取锁并在能够删除锁之前被分区时都会发生这种情况。</p>
<p>基本上，如果有无限连续的网络分区，系统可能会在无限长的时间内变得不可用。</p>
<h2 id="性能、崩溃恢复和-fsync">性能、崩溃恢复和 fsync</h2>
<p>许多使用 Redis 作为锁服务器的用户在获取和释放锁的延迟方面以及每秒可能执行的获取/释放操作数量方面都需要高性能。为了满足这个需求，与 N 个 Redis 服务器对话以减少延迟的策略肯定是多路复用（即把 socket 置于非阻塞模式，发送所有命令，然后读取所有命令，假设客户端和每个实例之间的 RTT 相似）。</p>
<p>然而，如果我们想要针对崩溃恢复系统模型，还有另一个关于持久性的考虑。</p>
<p>假设一共有 5 个 Redis 节点：A, B, C, D, E。设想发生了如下的事件序列：</p>
<ol>
<li>客户端 1 成功锁住了 A, B, C，<strong>获取锁</strong>成功（但 D 和 E 没有锁住）。</li>
<li>节点 C 崩溃重启了，但客户端 1 在 C 上加的锁没有持久化下来，丢失了。</li>
<li>节点 C 重启后，客户端 2 锁住了 C, D, E，<strong>获取锁</strong>成功。</li>
</ol>
<p>这样，客户端 1 和客户端 2 同时获得了锁（针对同一资源），违反了锁的排他性的安全属性。</p>
<p>如果我们启用 AOF 持久化，情况会有所改善。例如，我们可以通过发送 SHUTDOWN 并重新启动它来升级服务器。因为 Redis 过期是在语义上实现的，所以当服务器关闭时，实际上时间仍然在流逝，所以我们所有的要求都很好。然而，一切都很好，只要它是干净的关机。停电了怎么办？如果 Redis 配置为默认情况下每秒在磁盘上进行 fsync，则可能在重新启动后丢失我们的 key 。理论上，如果我们想在面对任何类型的实例重启时保证锁的安全，我们需要在持久化设置中启用 <code>fsync=always</code>。这样会破坏性能，将会和传统上用于以安全方式实现分布式锁的 CP 系统相同级别。</p>
<p>然而，事情总比乍一看的样子要好。基本上，只要实例在崩溃后重新启动，<strong>它不再参与任何当前活动的锁</strong>，就可以保留算法安全性。这样当实例重新启动时，当前活动的一组锁都是通过锁定实例而不是重新加入系统的实例获得的。</p>
<p>为了保证这一点，我们只需要确保一个实例，在崩溃后，至少在比我们使用的最大 TTL 多一点的时间内不可用，即实例崩溃时存在的所有锁的 key 所需的时间，即实例崩溃，失效并自动释放时存在的所有锁的 key 所需的时间。</p>
<p><strong>使用延迟重启</strong>，即使没有任何可用的 Redis 持久性，基本上也可以实现安全性，但是请注意，这可能会转化为可用性损失。例如，如果大多数实例崩溃，系统将在 TTL 中全局不可用（这里全局意味着在此期间根本没有资源可锁定）。</p>
<h2 id="使算法更可靠：扩展锁">使算法更可靠：扩展锁</h2>
<p>如果客户端执行的工作由小步骤组成，则可以默认使用较小的锁有效时间，并扩展实现锁扩展机制的算法。基本上客户端，如果在计算的中间，当锁有效性接近低值时，如果 key 存在并且它的值仍然是获取锁时客户端分配的随机值，可以通过向所有扩展 key 的实例的 Lua 脚本发送一个 Lua 脚本来扩展锁。 如果客户端能够将锁扩展到大多数实例，并且在有效时间内（基本上使用的算法与获取锁时使用的算法非常相似），客户端应该只考虑重新获取锁。 然而，这在技术上不会改变算法，因此应该限制锁重新获取尝试的最大次数，否则会违反活跃性属性之一。</p>
<p>在单实例时使用监视器也可以达成该目的，在多实例下实现会更加复杂。</p>
<p>比如使用守护线程或其他形式去观察并自动续约，例如 Redisson 的 watchdog。</p>
<p><img data-src="../../images/middleware/redis/redis-lock-monitor.png" alt="Monitor Lock"></p>
<h1>实现</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 作为 Java 版本的 Redis 客户端，底层使用 Netty 这种高性能无阻塞的 IO 框架，为我们提供了很多 Redis 数据结构的 Java 版本，还有很多分布式锁、分布式对象，分布式服务等，以及提供了异步、响应式的请求方式。</p>
<p><img data-src="../../images/middleware/redis/redisson.png" alt="img"></p>
<p>它也支持 Redis 的多种部署方式：复制、集群、哨兵、主从、单例模式。</p>
<h2 id="单实例下的有效锁">单实例下的有效锁</h2>
<p><code>Redisson</code> 中基于单实例的正确实现锁有很多，他们都实现了 RLock 接口，该接口继承与 Java 的 Lock 接口，实现该接口的类也都实现了可重入性。最基本的实现有：</p>
<ul>
<li><code>RedissonLock</code>：Java Lock 的分布式实现，实现可重入锁。如果客户端断开连接，锁定将自动解除。实现非公平锁定，因此不保证获取顺序。</li>
<li><code>RedissonFairLock</code>：和上述锁相同，但实现了公平性，以保证线程的获取顺序。</li>
</ul>
<h3 id="RedissonLock">RedissonLock</h3>
<p>接下来我们就来看下 <code>RedissonLock</code> 是如何实现锁的，他的 UML 类继承图如下：</p>
<p><img data-src="../../images/middleware/redis/redisson-lock.png" alt="RedissonLock"></p>
<p>这里需要有几点认知：</p>
<ul>
<li><code>RedissonLock</code> 实现了 <code>java.util.concurrent.locks.Lock</code> 接口中除了 <code>newCondition()</code> 方法外的所有方法，也就是可以基本无缝适配 <code>Lock</code> 接口，对于习惯 <code>Lock</code> 接口的 <code>API</code> 的使用者来说是一个福音</li>
<li><code>RedissonLock</code> 基本所有同步 <code>API</code> 都依赖于异步 <code>API</code> 的实现，也就是 <code>RLock</code> 的实现依赖于 <code>RLockAsync</code> 的实现，底层依赖的是 <code>Netty</code> 的 <code>io.netty.util.concurrent.Promise</code>，具体见 <code>RedissonPromise</code>，如果用过 <code>JUC</code> 中的 <code>Future</code> 的开发者应该比较熟悉 <code>Future#get()</code>，这里的做法类似</li>
<li>右边的几个父类的简单功能描述如下：
<ul>
<li><code>RObjectAsync</code>：所有 <code>Redisson</code> 对象的基础接口，提供一些内存测量、对象拷贝、移动等的异步方法</li>
<li><code>RObject</code>：<code>RObjectAsync</code> 的同步版本</li>
<li><code>RExpirableAsync</code>：提供对象 <code>TTL</code> 相关的异步方法</li>
<li><code>RExpirable</code>：<code>RExpirableAsync</code> 的同步版本</li>
<li><code>RedissonObject</code>：直接实现类 <code>RObject</code> 接口中的方法</li>
<li><code>RedissonExpirable</code>：主要是实现了 <code>RExpirable</code> 接口中的方法</li>
</ul>
</li>
</ul>
<p>下面我们就来看下如何使用该 Lock，一般我们使用 Java 的 Lock 典型用法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...;</span><br><span class="line"> <span class="keyword">if</span> (lock.tryLock(<span class="number">5L</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 操作保护资源</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 执行锁获取失败的可选操作</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 RedissonLock 中我们同样可以这样使用，但是就像我们之前陈述的，我们需要为锁定义有效时间（TTL），让我们看下代码中是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该类实现了 Lock 的 tryLock 接口，</span></span><br><span class="line"><span class="comment">// 调用自身的 tryLock，第二个参数为锁的有效时间，这里传入 -1  </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">return</span> tryLock(waitTime, -<span class="number">1</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加锁">加锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> unit.toMillis(waitTime);</span><br><span class="line">  <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">  <span class="comment">// 尝试获取锁，为 null 代表锁操作成功，可能是初次获取成功，或者重入获取成功，将会在后面的 lua 脚本说明</span></span><br><span class="line">  <span class="comment">// 否则返回锁的有效时间</span></span><br><span class="line">  <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果尝试获取锁的经过时间大于允许等待的时间，则获取锁失败</span></span><br><span class="line">  time -= System.currentTimeMillis() - current;</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    acquireFailed(waitTime, unit, threadId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新获取当前时间</span></span><br><span class="line">  current = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 使用 redis 的发布订阅 pub/sub 功能来等待该锁的释放通知，这里的 threadId 并没有什么意义</span></span><br><span class="line">  RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">  <span class="comment">// 订阅时间超过允许等待的时间，取消订阅，获取锁失败</span></span><br><span class="line">  <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="literal">false</span>)) &#123;</span><br><span class="line">      subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">          unsubscribe(subscribeFuture, threadId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    acquireFailed(waitTime, unit, threadId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 之前操作经过的时间超过允许等待的时间，获取锁失败</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      acquireFailed(waitTime, unit, threadId);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// 尝试获取锁</span></span><br><span class="line">      ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">      <span class="comment">// 获取锁成功</span></span><br><span class="line">      <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 继续判断是否超时</span></span><br><span class="line">      time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">      <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 锁有效时间一般都是 &gt;= 0 的，则实际等待时间取决于 ttl 和允许等待时间。</span></span><br><span class="line">      <span class="comment">// 等待内部使用 Java 许可数为 0 的信号量（Semaphore）进行等待，由于没有可用的许可，等待时线程将处于休眠状态。</span></span><br><span class="line">      <span class="comment">// 在锁释放时将放出一个信号量，则等待取消，继续尝试获取锁，否则一直等到过期</span></span><br><span class="line">      currentTime = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">        subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行超时，获取锁失败</span></span><br><span class="line">      time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">      <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 退出锁竞争(锁获取成功或者放弃获取锁)，则取消锁的释放订阅</span></span><br><span class="line">    unsubscribe(subscribeFuture, threadId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程如下图：</p>
<p><img data-src="../../images/middleware/redis/redisson-lock-lockinng.png" alt="img"></p>
<p>这里面比较重要的是获取锁 <code>tryAcquire</code> 的操作，如下。</p>
<h3 id="获取锁">获取锁</h3>
<p>在这里，它有两种处理方式，一种是带有过期时间的锁，一种是不带过期时间的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有过期时间，就像我们调用的那样，使用 watchdog 默认的租约时间：30s</span></span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经获取了锁</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 过期时间存在，设置 watchdog 的租约时间为该过期时间</span></span><br><span class="line">                internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 过期时间不存在，如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span></span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着往下看，<code>tryLockInnerAsync</code> 方法是真正执行获取锁的逻辑，它是一段 LUA 脚本代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="comment">// 如果锁不存在，则通过 hincrby 将锁对象的名称（RawName）key 下的该线程的锁（LockName）field 的数值递增 1</span></span><br><span class="line">            <span class="comment">// 并设置 RawName 作为 key 的过期时间为 leaseTime</span></span><br><span class="line">            <span class="comment">// 执行成功，返回 null，前面检查 为 null 代表执行成功</span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="comment">// 如果锁存在，且持有线程是当前线程，则通过 hincrby 将该锁对应的该线程的数值递增 1，并重新设置过期时间</span></span><br><span class="line">                    <span class="comment">// 执行成功，返回 null</span></span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                     <span class="comment">// 如果锁已存在，且持有锁的线程不是该线程，则返回该锁的有效时间</span></span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">            Collections.singletonList(getRawName()), </span><br><span class="line">            unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LUA 中的数组从 1 开始计数，KEYS 代表键数组，ARGV 代表参数数组。同时，Redis 保证以一种原子性的方式来执行脚本：当 LUA 脚本在执行的时候，不会有其他脚本和命令同时执行，这种语义类似于 MULTI/EXEC。从别的客户端的视角来看，一个 LUA 脚本要么不可见，要么已经执行完，这也因为 Redis 是单线程的原因。</p>
<h3 id="解锁">解锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 该锁不是由该线程占有的，返回 null</span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                     <span class="comment">// 该锁对应的该线程的数值 - 1，重入数 - 1</span></span><br><span class="line">                    <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                     <span class="comment">// 锁依然被占用，则续约，返回 0</span></span><br><span class="line">                    <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                     <span class="comment">// 锁无人占用，删除锁，并发布锁释放信号，这里会向之前等待的信号量释放一个许可</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), </span><br><span class="line">            LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁主要也是通过 LUA 脚本执行的，流程如下：</p>
<p><img data-src="../../images/middleware/redis/redisson-lock-unlock.png" alt="img"></p>
<hr>
<h1>参考链接：</h1>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">Distributed locks with Redis</a></li>
<li><a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">分布式锁的实现之 redis 篇</a></li>
<li><a target="_blank" rel="noopener" href="https://wendajiang.github.io/redis-distribute-lock/">Redis 分布式锁 [翻译]</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/14264804.html#%E5%B0%8F%E7%BB%93">冷饭新炒：理解Redisson中分布式锁的实现</a></li>
</ul>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Lock</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 入门</title>
    <url>/middleware/Kafka-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img data-src="../../images/middleware/kafka/kafka.png" alt="Kafka"></p>
<blockquote>
<p><code>Kafka</code> 是为了解决 <code>LinkedIn</code> 数据管道问题应用而生的，它的设计目的是提供一个高性能的消息<br>
系统，可以处理多种数据类型，并能够实时提供纯净且结构化的用户活动数据和系统度量指标。</p>
</blockquote>
<p>数据为我们所做的每一件事都提供了动力。<em>—— Jeff Weiner, LinkedIn CEO</em></p>
<h2 id="一、基础环境搭建（可选）">一、基础环境搭建（可选）</h2>
<h3 id="手动安装">手动安装</h3>
<p><code>Kafka</code> 依赖于 <code>Zookeeper</code> 的分布式节点选举功能，安装 <code>Kafka</code> 需安装 <code>Jdk</code>、<code>Zookeeper</code>、<code>Scala</code> 组件。(<a target="_blank" rel="noopener" href="https://www.confluent.io/blog/removing-zookeeper-dependency-in-kafka/">Kafka 正在逐渐削弱对 Zookeeper 的依赖，逐渐演变为自管理互相发现的模式</a>)</p>
<span id="more"></span>
<p>从 <code>Apache</code> 官网中心下载 <code>Zookeeper</code> 组件，然后安装 <code>Zookeeper</code> 环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建zookeeper的数据目录data</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">mdkir /usr/local/zookeeper/data</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改zookeeper配置文件zoo.cfg中的参数信息(指定数据目录、zookeeper暴露端口号)</span></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/usr/local/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动zookeeper服务,其会加载zoo.cfg作为其配置文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">/usr/local/zookeeper/bin/zkServer.sh starts</span></span><br></pre></td></tr></table></figure>
<p>在安装好 <code>Java</code> 和 <code>Zookeeper</code> 之后就可以进行安装 <code>Kafka</code> 消息中间件，可以从 <code>Apache Kafka</code> 官网下载 <code>kafka</code> 消息中间件，然后进行配置安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建<span class="built_in">log</span>目录用于临时存放kafka中间件日志信息</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> /tmp/kafka-logs</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">kafka broker启动时需要加载server.properties配置文件,指定kafka连接zookeeper地址</span></span><br><span class="line">zookeeper.connect=localhost:2181</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动kafka-server-start服务</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="variable">$KAFKA_HOME</span>/bin/kafka-server-start.sh -daemon <span class="variable">$KAFKA_HOME</span>/config/server.properties</span></span><br></pre></td></tr></table></figure>
<p>搭建好基础环境后对 <code>kafka</code> 消息中间件进行测试，创建新的 <code>topic</code> 并使用 <code>kafka-console-producer</code> 发送消息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用kafka工具创建topic, 在参数中指定zookeeper的地址、replication-factor复制比例、及分区大小</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="variable">$KAFKA_HOME</span>/bin/kafka-topics.sh --create --bootstrap-server localhost:9092</span></span><br><span class="line">\ --replication-factor 1 --partitions 1 --topic stream</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看当前broker中所有的topic列表</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="variable">$KAFKA_HOME</span>/bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span></span><br><span class="line">__consumer_offsets</span><br><span class="line">_schemas</span><br><span class="line">avro-stream stream </span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用生产者客户端生产消息</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="variable">$KAFKA_HOME</span>/bin/kafka-console-producer.sh</span> </span><br><span class="line">\ --broker-list localhost:9092 --topic stream </span><br><span class="line"><span class="meta">&gt;</span><span class="language-bash">this<span class="string">&#x27;s the first message</span></span> </span><br><span class="line"><span class="meta">&gt;</span><span class="language-bash"><span class="string">this&#x27;</span>s another message from kafka</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用消费者客户端消费,目前暂时使用--bootstrap-server客户端无法接收到消息,--zookeeper可以正常接收</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="variable">$KAFKA_HOME</span>/bin/kafka-console-consumer.sh</span> </span><br><span class="line">\ --bootstrap-server localhost:9092 </span><br><span class="line">\ --topic stream --from-beginning </span><br><span class="line">this&#x27;s the first message </span><br><span class="line">this&#x27;s another message from kafka</span><br></pre></td></tr></table></figure>
<h3 id="Docker-镜像使用">Docker 镜像使用</h3>
<p>Kafka 未提供官方的镜像，我们可以使用：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/confluentinc/cp-kafka">confluentinc Kafka</a> 或 <a target="_blank" rel="noopener" href="https://hub.docker.com/r/wurstmeister/kafka">wurstmeister Kafka</a> 作为构建镜像使用：<br>
使用时注意，如果不在同一主机中的客户端想要发送或者接收消息从该 Kafka 服务，需将该配置 <code>KAFKA_ADVERTISED_HOST_NAME </code> 或 <code>KAFKA_ADVERTISED_LISTENERS</code> 设为 Docker 主机对外的 IP 地址。具体解释见：<a target="_blank" rel="noopener" href="https://www.confluent.io/blog/kafka-listeners-explained/">kafka-listeners-explained</a>，简而言之：客户端使用消息代理返回的元信息进行消息发送和接收时的连接，这个元信息来源于该配置。</p>
<h2 id="二、broker-和-topic-部分配置参数">二、<code>broker</code> 和 <code>topic</code> 部分配置参数</h2>
<p><code>broker</code> 端常用配置信息：</p>
<p>1.<code>broker.id</code>：每个 <code>broker</code> 都需要一个标识符，使用 <code>broker.id</code> 来表示，它的默认值为 0 。其可以被设置成任何其它任意整数。这个值在整个 <code>kafka</code> 集群中必须是唯一的。</p>
<p>2.<code>port</code> 以及 <code>zookeeper.connect</code> 配置：<code>kafka</code> 默认是监听 <code>9092</code> 端口，修改 <code>port</code> 配置参数可以将其设置成任意其它可用的端口。若在端口号在 <code>1024</code> 以下，需要使用 <code>root</code> 权限启动 <code>kafka</code>。<code>zookeeper.connect</code> 是配置连接 <code>zookeeper</code> 的配置信息，默认连接 <code>zookeeper</code> 的 <code>2181</code> 端口。若为 <code>zookeeper</code> 集群，则使用<code>,</code>对 <code>zookeeper</code> 进行分割。</p>
<p>3.<code>log.dirs</code> 以及 <code>auto.create.topics.enable</code> 配置：<code>kafka</code> 会将所有消息都保存磁盘上，存放这些日志片段的目录就是通过 <code>log.dirs</code> 指定的，它是一组用逗号分割的本地文件系统路径。若 <code>auto.create.topics.enable</code> 配置值为 <code>true</code>，处于以下三种情况时 <code>kafka</code> 会自动创建主题：当一个生产者开始往主题写入消息时、当一个消费者开始从主体读取消息时、当任意一个客户端向主体发送原<br>
数据时。</p>
<p>4.<code>num.recovert.threads.per.data.dir</code>：<code>kafka</code> 会使用可配置线程池来处理日志片段，默认情况下每个日志目录只使用一个线程，因为这些线程只是在服务器启动和关闭时会用到。在进行恢复时使用并行操作可能会省下数小时的时间，设置此参数需要注意，所配置的数字对应的是log.dirs指定的单个日志目录。</p>
<p><code>topic</code> 常用配置参数：</p>
<p>1.<code>number.partions</code>：该参数指定了新创建的主题将包含多少个分区，若启用了主题自动创建功能（该功能默认是启用的），主题分区的个数就是该参数指定的值（其默认值为 1 ）。可以增加主题分区的个数，但不能减少分区的个数。<code>Kafka</code> 集群通过分区对主题进行横向扩展，所以当有新的 <code>broker</code> 加入集群时，可以通过分区个数实现集群的负载均衡。</p>
<p>2.<code>log.retention.ms</code>：<code>kafka</code> 通常根据时间来决定数据可以被保留多久，默认使用 <code>log.retention.hours</code> 参数来配置时间，默认值为  <code>168</code> 小时也就是一周。除此之外，还有其他两个参数 <code>log.retention.minutes</code> 和 <code>log.retention.ms</code>，这 3 个参数的作用是一样的，都是决定消息多久以后会被删除。</p>
<p>3.<code>log.retention.bytes</code>：另一种方式是通过保留的消息字节数来判断消息是否过期，它的值通过参数 <code>log.retention.bytes</code> 来指定，作用在每一个分区上。也就是说，如果有一个包含 8 个分区的主题，并且 <code>log.retention.bytes</code> 被设置为1GB，那么这个主题最多可以保留8GB的数据。当主题分区个数增加时，整个主题可以保留的数据也随之增加。</p>
<p>4.<code>log.segment.bytes</code>：当消息到达 <code>broker</code> 时，它们被追加到分区的当前日志片段上。当日志片段大小达到 <code>log.segment.bytes</code> 指定的上限时，当前日志片段就会被关闭，一个新的日志片段被打开，前一个日志片段等待过期（其默认过期时间为 10 天）。</p>
<p>5.<code>log.segment.ms</code>：另一个可以控制日志片段关闭时间的是 <code>log.segment.ms</code>，它指定过了多长时间之后日志片段就被关闭，<code>log.segment.bytes</code> 和 <code>log.segment.ms</code> 这两个参数之间不存在互斥问题，日志片段会在大小或时间达到上限时被关闭，就看哪个条件先得到满足。</p>
<p>6.<code>message.max.bytes</code>：<code>broker</code> 通过设置 <code>message.max.bytes</code> 参数来限制单个消息的大小，默认值是 <code>1MB</code>。若生产者尝试发送的消息超过这个大小，不仅消息不会被接收还会返回 <code>broker</code> 返回的错误消息。在消费者客户端设置的 <code>fetch.message.max.bytes</code> 必须与服务器设置的消息大小进行协调，如果这个值比 <code>message.max.bytes</code> 小，那么消费者就无法消费 比较大的消息。</p>
<h2 id="三、Kafka-基础术语：">三、Kafka 基础术语：</h2>
<p><code>kafka</code> 的数据单元称为消息 (Message)，与数据库里的一个&quot;数据行&quot;或者一条“记录”类似，为了提高效率消息被分批写入 <code>kafka</code>，批次就是一组消息（使用单独线程处理）。</p>
<p><img data-src="../../images/middleware/kafka/kafka-producer-consumer.png" alt="kafka-producer-consumer"></p>
<p><code>kafka</code> 的消息通过 <code>topic</code>（主题）进行分类，主题好比数据库中的表。<code>topic</code> 可以被分为若干分区，一个分区就是一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序读取。由于一个主题一般包含几个分区，因此无法在整个主题范围内保证消息的顺序，但可以保证在单个分区的顺序。</p>
<p><strong><code>kafka</code> <code>broker</code> 是如何持久化数据的？<strong>总的来说，<code>kafka</code> 使用消息日志（<code>log</code>）来保存数据的，一个日志就是磁盘上一个只能追加（<code>append only</code>）消息的物理文件。因为只能追加写入，故避免了缓慢的</strong>随机 <code>I/O</code></strong> 操作，改为性能更好的顺序 <code>I/O</code> 操作，这也是实现<code>kafka</code> 高吞吐量特性的一个重要手段。为了避免日志写满磁盘空间，<code>kafka</code> 必然要定期地删除消息以回收磁盘。其通过 <code>log segment</code> 机制，在 <code>kafka</code> 底层一个日志又近一步细分成多个日志片段，消息被追加写到当前新的日志段中。<code>kafka</code> 在后台通过定时任务会定期检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p>
<p><img data-src="../../images/middleware/kafka/consumer-offset.png" alt="consumer-offset"></p>
<p><code>kafka</code> 中分区机制指的是将每个主题划分多个分区（<code>partition</code>），每个分区是一组有序的消息日志。也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。</p>
<p><img data-src="../../images/middleware/kafka/partitioned_log.png" alt="img"></p>
<p><code>offset</code> 消费者位移：每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（<code>consumer offset</code>）。上面的位移表示的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就固定了。而消费者位移则会随着消息消费而发生变化，毕竟它是消费者消费进度的指示器。另外每个消费者都有着自己的消费者位移，因此一定要区分这两类位移的区别。</p>
<p>kafka 消费者会往一个叫做 <code>_consumer_offset</code> 的特殊主题发送消息，消息里包含每个分区的偏移量。在发生 <code>rebalance</code> 之后，为了能够继续之前的工作，消费者需要读取每一个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。当提交 <code>commit</code> 的偏移量小于客户端处理的最后一条消息的偏移量，消息会被<strong>重新处理导致重复</strong>。若提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的<strong>消息将会丢失</strong>。</p>
<h2 id="四、kafka-整合-schema-registry">四、kafka 整合 schema registry</h2>
<p>使用 <code>apache avro</code> 实现在生产者与消费者中对消息内容进行序列化与反序列化，<code>Avro</code> 是一种与编程语言无关的序列化格式。<code>Doug Cutting</code> 创建了这个项目，目的是提供一种共享数据文件的方式。</p>
<p><code>Avro</code> 数据通过与语言无关的 <code>schema</code> 来定义，<code>schema</code> 通过 <code>JSON</code> 来描述，数据被序列化为二进制或者 <code>JSON</code> 文件，不过一般会使用二进制文件。<code>Avro</code> 在读写文件时需要用到 <code>schema</code>，<code>schema</code> 一般会被内嵌在数据文件里。<code>Avro</code> 有一个很有意思的特性是，当负责写消息的应用程序使用了新的 <code>schema</code>，负责读消息的应用程序可以继续处理消息而无须做任何改动，这个特性使得它特别适合用在像 <code>kafka</code> 这样的消息系统上。</p>
<p><code>confluent</code> 在其共有平台发布了 <code>confluent schema registry</code> 工具，作为注册表 <code>schema</code> 的实现。可以从 <a target="_blank" rel="noopener" href="https://www.confluent.io/download/">https://www.confluent.io/download/</a> 进行下载，之后在服务器上启动 <code>schema registry</code> 服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sam@elementoryos: ~/kafka_schema_registry/confluent-tools-kafka$ bin/schema-registry-start </span><br><span class="line">\ etc/schema-registry/schema-registry.properties</span><br><span class="line">[2019-11-12 00 :13:01,160] INFO Logging initialized @1547ms to org.eclipse.jetty.util.log.Slf4jLog (org.eclipse.jetty.util.log:193)</span><br></pre></td></tr></table></figure>
<p>然后将需要进行序列化实体的 <code>schema</code> 注册到 <code>schema registry</code> 中，最终其会返回一个 <code>id</code> 表示注册成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sam@elementoryos: curl -X POST -H &quot;Content-Type:application/vnd.schemaregistry.v1+json&quot; --data</span><br><span class="line">\ &#x27;&#123;&quot;schema&quot;: &quot;&#123;\&quot;type\&quot;: \&quot;record\&quot;, \&quot;name\&quot;: \&quot;Customer\&quot;, \&quot;fields\&quot;: [&#123;\&quot;name\&quot;: \&quot;customerName\&quot;, \&quot;type\&quot;: \&quot;string\&quot;&#125;, &#123;\&quot;name\&quot;:\&quot;customerId\&quot;,\&quot;type\&quot;:\&quot;int\&quot;&#125;]&#125;&quot;&#125;&#x27;</span><br><span class="line">\ http://192.168.170.130:8081/subjects/avro-stream-value/versions</span><br><span class="line">&#123;&quot;id&quot;:21&#125;</span><br></pre></td></tr></table></figure>
<p>注册完成后，就可以分别在生产者和消费者的代码示例中使用 <code>avro</code> 进行序列化对象。同时在生产者和消费者的 <code>properties</code> 指定属性 <code>kafkaProperties.put(&quot;schema.registry.url&quot;, &quot;http://192.168.170.130:8081&quot;)。</code></p>
<h2 id="五、kafka-生产者—向-kafka-写入数据">五、kafka 生产者—向 kafka 写入数据</h2>
<p>向 <code>kafka</code> 发送数据从创建 <code>ProducerRecord</code> 对象开始，其包含目标主题、要发送的内容，还可以指定键或分区。在发 <code>ProducerRecord</code> 对象时，生产者要把键和值对象序列化成字节数组，这样其就可以在网络上传输。</p>
<p>接下来，将数据传给分区器。如果之前在 <code>ProducerRecord</code> 对象中指定了分区，那么分区器不会做任何事情，直接把指定的分区返回。若没有指定分区，那么分区器会根据 <code>ProducerRecord</code> 对象的键来选择一个分区。选好分区后，生产者就知道该往哪个主体和分区发送这条记录了。紧接着，这条记录会被添加到一个记录批次里，这个批次里的所有消息被发送到相同的主题和分区上。有一个单独的线程负责把<br>
这些记录批次发送到相应的 <code>broker</code> 上。</p>
<p>服务器在收到这些消息时会返回一个响应，如果消息成功写入 <code>kafka</code>，就返回一个 <code>RecordMetaData</code> 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误，生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息。</p>
<p><img data-src="../../images/middleware/kafka/producer-write.png" alt="producer-write"></p>
<h2 id="六、kafka-消费者—从-kafka-读取数据">六、kafka 消费者—从 kafka 读取数据</h2>
<p><code>kakfa</code> 消费者从属于消费者群组，一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。若消费者组中消费者的数量与主题分区的数量相等，则每一个消费者单独消费一个分区。当消费者组中消费者数量大于主题分区的数量，多余的消费者不会被分配到任何数据分区。引入消费者组的概念主要是为了提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）。消费者组里面的所有消费者实例不仅&quot;瓜分&quot;订阅主体的数据，而且更酷的是它们还能彼此协助。</p>
<p><code>Rebalance</code> 概念：群组中的消费者共同读取主题的分区，一个新的消费者加入群组时，它读取的是原本由其他消费者读取的消息。当一个消费者被关闭或发生崩溃时，它就离开群组，原本由它读取的分区将由群组里的其它消费者来读取。分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡，在 <code>rebalance</code> 时会产生 <code>stop the world</code> 的问题。</p>
<p><code>kafka</code> 检测方式：消费者通过向被指派为群组协调器的 <code>broker</code>（不同的群组可以有不同的协调器）发送心跳来维持他们和群组的从属关系。只要消费者以正常的时间发送心跳，就被认为是活跃的，说明它还在读分区里的消息。<strong>如果消费者停止发送心跳的时间足够长（可能是批数据过大导致的消费太慢、网络问题、服务失败等），会话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡。</strong></p>
<p>分配分区的过程：当消费者要加入群组时，它会向群组协调器发送一个 <code>JoinGroup</code> 的请求。第一个加入群组的消费者将成为“群主”。群主从协调器那里获得群组的成员列表（列表中包含了所有最近发送过心跳的消费者，它们被认为是活跃的），并负责给每一个消费者分配分区。它使用了一个实现了 <code>PartitionAssign</code> 接口的类来决定哪些分区应该被分配给哪个消费者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); </span><br><span class="line"><span class="comment">// 当从kafka server中poll 200条记录,当处理了50条记录时,可以立即进行提交</span></span><br><span class="line">currentOffsets.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition()), <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metadata&quot;</span>)); </span><br><span class="line">consumer.commitAsync(currentOffsets, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>提交特定的偏移量调用的是 <code>commitAsync</code>()，不过调用 <code>commitSync()</code> 也是完全可以的。当然，在提交特定偏移量时，仍然要处理可能发生的错误。</p>
<p><code>kafka</code> 的再均衡监听器：消费者在退出和进行分区再均衡之前，会做一些清理工作。需要在消费者失去对一个分区的所有权之前提交最后一个已处理记录的偏移量。如果消费者准备了一个缓冲区用于处理偶发的事件，那么在失去分区所有权之前，需要处理在缓冲区累积下来的记录。你可能还需要关闭文件句柄、数据库连接等。</p>
<p><code>ConsumerRebalanceListener</code> 有两个需要实现的方法：</p>
<p>1 ）<code>public void onPartitionRevoked(Collection&lt;TopicPartition&gt; partitions)</code> 方法会在再均衡开始之前和消费者停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取了。</p>
<p>2 ）<code>public void onPartitionsAssigned(Collection&lt;TopicPartition&gt; partitions)</code> 方法会在重新分配分区之后和消费者开始读取消息之前被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在consumer订阅主体topic时设定回调类HandleRebalance </span></span><br><span class="line">consumer.subscribe(topics, <span class="keyword">new</span> <span class="title class_">HandleRebalance</span>());</span><br></pre></td></tr></table></figure>
<p>从特定偏移量处开始处理记录：使用 <code>poll()</code> 方法从各个分区的最新偏移量处开始处理消息，有时候我们也需要从特定的偏移量处开始读取消息。<code>seekToBeginning(Collection&lt;TopicPartition&gt; tp)</code> 和 <code>seekToEnd(Collection&lt;TopicPartition&gt; tp)</code> 这两个方法。若循环运行在主线程中，可以在 <code>ShutdownHook</code> 里调用该方法，需记住 <code>consumer.wakeup()</code> 是消费者唯一一个可以从其他线程里安全调用的方法。调用 <code>consumer.wakeup()</code> 可以退出 <code>poll()</code> 并抛出 <code>WakeupException</code> 异常，或者如果调用 <code>consumer.wakeup()</code> 时线程没有等待轮询，那么异常将在下一轮 <code>poll()</code> 时抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;         </span><br><span class="line">      	consumer.wakeUp();     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="消费者的配置">消费者的配置</h3>
<p>Kafka 的文档列出了所有与<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs">消费者相关的配置说明</a>。大部分参数都有合理的默认值，一般不需要修改它们，不过有一些参数与消费者的性能和可用性有很大关系。接下来介绍这些重要的属性。</p>
<h4 id="fetch-min-bytes"><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs_fetch.min.bytes">fetch.min.bytes</a></h4>
<p>服务器应为抓取请求返回的最小数据量。如果没有足够的数据可用，则请求将在回答请求之前等待积累足够多的数据。1 字节的默认设置意味着只要有一个字节的数据可用或抓取请求超时等待数据到达就会响应获取请求。将此设置为大于 1 的值将导致服务器等待大量数据积累，这可以稍微提高服务器吞吐量，但会增加一些延迟。默认：1 byte。</p>
<h4 id="max-partition-fetch-bytes"><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs_max.partition.fetch.bytes">max.partition.fetch.bytes</a></h4>
<p>服务器从每个分区里返回给消费者的最大字节数。记录由消费者批量获取。如果抓取的第一个非空分区中的第一个记录批次大于此限制，则仍会返回该批次以确保消费者可以取得数据。代理接受的最大记录批次大小是通过 <code>message.max.bytes</code>（代理配置）或 <code>max.message.bytes</code>（主题配置）定义的。请参阅 <code>fetch.max.bytes</code> 以限制消费者请求大小。默认：1MB。</p>
<h4 id="max-poll-records"><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs_max.poll.records">max.poll.records</a></h4>
<p>单次调用 <code>poll()</code> 时返回的最大记录数。请注意， <code>max.poll.records</code> 不会影响底层抓取行为。消费者将从每个抓取请求中缓存记录，并从每个轮询中逐渐地返回它们。默认：500 条。</p>
<h4 id="heartbeat-interval-ms"><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms">heartbeat.interval.ms</a></h4>
<p>使用 Kafka 的组管理工具时，消费者协调器的心跳之间的预期时间。心跳用于确保消费者的会话保持活跃，并在新消费者加入或离开组时进行再平衡。</p>
<p>该配置指定了消费者向消费者组协调器<strong>发送心跳信号</strong>的频率。因此，如果这是 3000 毫秒（默认），那么消费者将每 3 秒向消息代理发送一次心跳信号。</p>
<p>在高负载的网络环境中，错过很少的心跳信号是正常的。所以建议在将消费者标记为死亡之前等待丢失 3 个心跳信号。这就是建议 <code>heartbeat.interval.ms</code> 为 <code>session.timeout.ms</code> 1/3 的原因。默认：3000 毫秒。</p>
<h4 id="session-timeout-ms"><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms">session.timeout.ms</a></h4>
<p>使用 Kafka 的组管理工具时用于<strong>检测客户端</strong>故障的超时。客户端定期发送心跳以向代理指示其活跃度。如果在此会话超时到期之前代理没有收到心跳，则代理将从组中删除此客户端并启动重新平衡。请注意，该值必须在由代理配置中配置的 <code>group.min.session.timeout.ms</code> 和 <code>group.max.session.timeout.ms</code> 的允许范围内。默认：45000 毫秒。</p>
<h4 id="max-poll-interval-ms"><a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/#consumerconfigs_max.poll.interval.ms">max.poll.interval.ms</a></h4>
<p>使用消费者组管理时调用 <code>poll()</code> 之间的最大延迟。这为消费者在获取更多记录之前可以空闲的时间设置了上限。如果在此超时到期之前没有调用 poll()，则认为消费者失败，组将重新平衡以将分区重新分配给另一个成员。对于使用达到此超时的非空 <code>group.instance.id</code> 的消费者，不会立即重新分配分区。相反，消费者将停止发送心跳，并且在 <code>session.timeout.ms</code> 到期后将重新分配分区。默认：5 分钟。</p>
<blockquote>
<p>在 KIP-62 之前，只有 <code>session.timeout.ms</code>（即 Kafka 0.10.0 及更早版本）。</p>
<p>KIP-62，通过后台心跳线程将心跳与对 <code>poll()</code> 的调用分离，允许比心跳间隔更长的处理时间（即，两个连续的 <code>poll()</code> 之间的时间）。KIP-62 将轮询和心跳分离，允许在两次连续轮询之间发送心跳。现在您有两个线程在运行，<em>心跳线程</em>和<em>处理线程</em>，因此，KIP-62 为每个线程引入了超时。<code>session.timeout.ms</code> 用于心跳线程，而 <code>max.poll.interval.ms</code> 用于处理线程。</p>
</blockquote>
<h2 id="七、深入理解kafka运行机制">七、深入理解kafka运行机制</h2>
<p><img data-src="../../images/middleware/kafka/Apache-Kafka-UML-Class-Diagram1.png" alt="Apache Kafka UML Class Diagram"></p>
<p><code>kafka</code> 使用 <code>zookeeper</code> 来维护集群成员的信息，每个 <code>broker</code> 都有一个唯一标识符，这个标识符可以在配置文件中指定，也可以自动生成。在 <code>broker</code> 启动时，它通过创建临时节点把自己的 <code>id</code> 注册到 <code>zookeeper</code> 上。控制器 <code>controller</code> 机制：控制器负责分区首领的选举，集群里第一个启动的 <code>broker</code> 通过在 <code>zookeeper</code> 里创建一个临时节点 <code>controller</code> 让自己成为控制器。当其它的 <code>broker</code> 进行创建时，会收到一个&quot;节点已存在&quot;的异常，然后&quot;意识&quot;到控制器节点已存在，也就是说集群里已经有一个控制器了（结合 <code>zookeeper</code> 进行结点选举）。</p>
<ol>
<li><code>kafka</code> 中复制是如何进行实现的？</li>
</ol>
<p><code>kafka</code> 使用主题来组织数据，每个主题被分为若干个分区，每个分区有多个副本。那些副本被保存在 <code>broker</code> 上，每个 <code>broker</code> 可以保存成百上千个属于不同主题和分区的副本。副本分为两种类型：首领 (<code>master</code>) 副本，为保持一致性，<code>kafka</code> 中所有生产者请求和消费者请求都会经过这个副本。跟随者 (<code>follower</code>) 副本，其主要是从 <code>master</code> 复制消息并与 <code>master</code> 上内容保持一致，若 <code>master</code> 节点崩溃，参与节点选举并提升为新首领（<code>follower</code> 副本不参与读、写）。</p>
<p>与 <code>master</code> 的同步实现：<code>follower</code> 为了与首领同步，向首领发送获取数据的请求，<code>master</code> 通过查看每个 <code>follower</code> 请求的最新偏移量，就可以知道每个跟随者复制的进度。如果跟随者在 <code>10s</code> 内没有请求任何消息，或者虽然在请求消息，但在 10s 内没有请求最新的数据，那么它就会被认为是不同步的。跟随者的正常不活跃时间或在成为不同步副本之前的时间是通过 <code>replica.lag.time.max.ms</code> 参数来配置的。</p>
<ol start="2">
<li><code>kafka</code> 是如何处理来自生产者和消费者的请求？</li>
</ol>
<p>生产请求和获取请求都必须发送给分区的首领副本，客户端使用元数据请求包含了客户端感兴趣的主题列表。服务器端的响应中指明了这些主题所包含的分区、每个分区都有哪些副本、以及哪个副本是 <code>master</code> 节点。客户端一般会缓存这些信息，并直接往目标 <code>broker</code> 上发送请求和获取请求（时间间隔通过 <code>metadata.max.age.ms</code> 来配置）。</p>
<p>在生产者配置中存在 <code>acks</code> 这个配置参数——该参数指定了需要多少个 <code>broker</code> 确认才可以认为一个消息写入是成功的，<code>acks=all</code> 需要所有 <code>broker</code> 收到消息才会成功；<code>acks=0</code> 意味着生产者在把消息发出去之后，完全不需要等待 <code>broker</code> 的响应。</p>
<p>客户端发送消费请求时向 <code>broker</code> 获取主题分区里具有特定偏移量的消息，客户端还可以指定为 <code>broker</code> 返回的数据分配足够的内存。否则， <code>broker</code> 返回的大量数据有可能耗尽客户端的内存。</p>
<ol start="3">
<li><code>kafka</code> 的存储细节，如文件格式和索引？</li>
</ol>
<p><code>kafka</code> 的基本存储单元是分区，分区无法在多个 <code>broker</code> 间进行再细分，也无法在同一个 <code>broker</code> 的多个磁盘上进行再细分。在配置 <code>kafka</code> 时候，管理员指定了一个用于存储分区的目录清单——也就是 <code>log.dirs</code> 参数的值，该参数一般会包含每个挂载点的目录。</p>
<p>文件管理部分，<code>kafka</code> 管理员为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。通常分区被分成若干个片段，默认情况下，每个片段包含 <code>1GB</code> 或一周的数据，以较小的那个为准。在 <code>broker</code> 往分区写入数据时，如果达到片段上限，就关闭当前文件，并打开一个新文件。当前正在写入数据非片段叫作活跃片段，活动片段永远不会被删除。</p>
<p>消息和偏移量保存在文件里，其格式除了键、值和偏移量外，消息里还包含了消息大小、校验和、消息格式版本号、压缩算法（Zstd、Snappy、GZip 或 LZ4）和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达 <code>broker</code> 的时间，可以配置。为了能快速从任意可用偏移量位置开始读取消息，<code>kafka</code> 为每个分区维护了一个索引，索引把偏移量映射到片段文件和偏移量在文件里的位置。</p>
<p>清理工作原理：若 <code>kafka</code> 启动时启用了清理功能（通过配置 <code>log.cleaner.enabled</code> 参数），每个 <code>broker</code> 会启动一个清理管理器线程或多个清理线程，它们负责执行清理任务，清理掉键重复的只保留一条，或清理 <code>value</code> 为空的消息等。这个线程会选择污浊率（污浊消息占分区总大小的比例）较高的分区进行清理。</p>
<p>为了清理分区，清理线程会读取分区的污浊部分，并在内存里创建一个 <code>map</code>。<code>map</code> 里的每个元素包含了消息键的散列值和消息的偏移量，键的散列值是 16B，加上偏移量总共是 24B。如果要清理一个 1GB 的日志偏移量，并假设每个消息大小为 1KB，那么这个片段就包含一百万个消息，而我们只需要 24MB 的 map 就可以清理这个片段（若有重复的键，可以重用散列项，从而使用更少的内存）。</p>
<ol start="4">
<li><code>zookeeper</code> 都存储了哪些信息，为什么需要 <code>zookeeper</code>？</li>
</ol>
<p>Kafka 使用 ZooKeeper 存储自身的元数据 (metadata)，Zookeeper 是 Apache 开发的顶级软件，充当中心化服务，用于维护命名和配置数据，并在分布式系统中提供灵活和健壮的同步。Zookeeper 跟踪 Kafka 集群节点的状态，它还跟踪 Kafka 主题、分区等。</p>
<p>Zookeeper 本身允许多个客户端同时执行读写操作，并充当系统内的共享配置服务。Zookeeper atomic broadcast (ZAB) 分布式一致协议是整个系统的大脑，使得 Zookeeper 可以作为一个原子广播系统，进行有序的更新，数据分布在集群的多个节点中，通过 ZAB 协议来保证不同节点数据的一致性，并提供高可用性，即使有一个主节点崩溃，也会立即选举新的节点。</p>
<p>它的作用主要有：</p>
<ul>
<li>
<p>控制器选举</p>
<p>控制器是 Kafka 生态系统中最重要的中介实体之一，它有责任维护所有分区之间的领导者 - 跟随者关系。如果某个节点由于某种原因关闭，则控制器有责任告诉所有副本去竞选分区领导者，以便在即将发生故障的节点上履行分区领导者的职责。因此，每当一个节点关闭时，都可以选择一个新的控制器，并且还可以确保在任何给定时间只有一个控制器，并且所有跟随节点都同意这一点。</p>
</li>
<li>
<p>主题、分区、消费者的状态及配置元数据维护</p>
<p>有关所有主题的配置，包括现有主题列表、每个主题的分区数量、所有副本的位置、所有主题的配置覆盖列表以及哪个节点是首选领导者等。具体存放的数据可以查看：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+data+structures+in+Zookeeper">Kafka data structures in Zookeeper</a></p>
</li>
<li>
<p>访问控制列表 ACL</p>
<p>所有主题的访问控制列表或 ACL 也在 Zookeeper 中维护。</p>
</li>
<li>
<p>集群成员</p>
<p>Zookeeper 还维护在任何给定时刻运行的所有代理的列表，它们是集群的一部分。</p>
</li>
</ul>
<h2 id="八、常见问题">八、常见问题</h2>
<h3 id="为什么选择-Kafka？">为什么选择 Kafka？</h3>
<img data-src="../../images/middleware/kafka/ecosystem.jpg" alt="img312" style="zoom: 67%;" />
<p>有很多发布/订阅的消息系统，为什么我们要选择 Kafka？</p>
<h4 id="多生产者">多生产者</h4>
<p>Kafka 能够无缝地处理多个生产者，而不用管客户端是否使用多个主题或同一主题。 这使得系统非常适合从许多前端系统聚合数据并使其保持一致。例如，一个通过许多微服务为用户提供内容的网站可以拥有一个页面视图主题，所有服务都可以使用通用格式写入该页面视图，然后，消费者应用程序可以为站点上的所有应用程序接收单个页面视图，而无需从每个应用程序多个主题协调消费。</p>
<h4 id="多消费者">多消费者</h4>
<p>除了多生产者之外，Kafka 还专为多个消费者设计，以读取任何单一的消息流而不会互相干扰。这与许多消息系统相反，这些消息系统一旦消息由其中一个客户端消费，其它客户端将不可消费。Kafka 可以通过多个消费者选择作为消费组的一部分运行并共享流，确保整个组仅处理给定消息一次来实现同样的目的。</p>
<h4 id="基于文件的保留">基于文件的保留</h4>
<p>Kafka 不仅可以处理多个消费者，而且持久（<strong>Durable</strong>）的消息保留意味着消费者并不总是需要实时工作。 消息已提交给磁盘，并将按可配置的保留规则保留数据。可以在每个主题的基础上选择这些选项，允许根据消费者需求进行不同的消息流，以具有不同的保留量。持久（Durable）的保留意味着如果消费者落后，由于处理缓慢或处理中出问题，则没有丢失数据的危险。这也意味着可以在消费者身上进行维护，在短时间内离线应用程序，不用担心备份生产者或丢失的消息。消费者可以停止，并且消息将保留在 Kafka。 这允许它们重新启动并拾取它们离开时的消息进行处理，而无需担心数据丢失。</p>
<h4 id="扩展性">扩展性</h4>
<p>Kafka 的灵活可伸缩性使其易于处理任何数量的数据。 用户可以以单个代理作为概念证明，扩展到三个代理的小型开发集群，随着时间的推移和数据的增长而增加一组或甚至数百个代理，并逐渐走向真实的生产环境。 集群在线时可以执行扩展，不会影响整个系统的可用性。 这也意味着多个代理集群可以接管单个代理的故障，并继续服务客户。需要容忍更多同时故障的集群可以配置更高的复制因子。</p>
<h4 id="高性能">高性能</h4>
<p>所有这些功能都汇集在一起，使 Apache Kafka 成为发布/订阅消息系统，在高负载下具有出色的性能。生产者，消费者和代理都可以水平扩展，以便轻松处理非常大的信息流，在提供高可用的同时也保证了低延迟的消息传递。</p>
<h3 id="Kafka-适合什么样的使用场景？">Kafka 适合什么样的使用场景？</h3>
<h4 id="消息代理">消息代理</h4>
<p>Kafka 可以很好地替代传统消息代理。消息代理的使用有多种原因（将消费处理与数据生产者分离，缓冲未处理的消息等）。与大多数消息系统相比，Kafka 具有更好的吞吐量，内置的分区，复制和容错能力，这使其成为大规模消息处理应用程序的理想解决方案。</p>
<p>根据我们的经验，消息传递的使用通常吞吐量较低，但是可能需要较低的端到端延迟，并且通常取决于 Kafka 提供的强大的持久性保证。</p>
<p>在这个领域，Kafka 可以与传统的消息传递系统（例如 <a target="_blank" rel="noopener" href="http://activemq.apache.org/">ActiveMQ</a> 或 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a>）相提并论。</p>
<h4 id="网站活动跟踪">网站活动跟踪</h4>
<p>Kafka 最初的用例是能够将用户活动跟踪管道重建为一组实时的发布-订阅供给。这意味着将网站活动（页面浏览量，搜索或用户可能采取的其他操作）发布到中心主题，每种活动类型只有一个主题。这些供给可用于一系列用例的订阅，包括实时处理，实时监控，以及加载到 Hadoop 或脱机数据仓库系统中以进行脱机处理和报告。</p>
<p>活动跟踪通常量很大，因为每个用户页面视图都会生成许多活动消息。</p>
<h4 id="指标（Metrics）">指标（Metrics）</h4>
<p>Kafka 通常用于操作监控数据。这涉及汇总来自分布式应用程序的统计信息，以生成集中的操作数据提要。</p>
<h4 id="日志聚合">日志聚合</h4>
<p>许多人使用 Kafka 替代日志聚合解决方案。日志聚合通常从服务器收集物理日志文件，并将它们放在中央位置（也许是文件服务器或  HDFS）以进行处理。Kafka 提取了文件的详细信息，并将日志或事件数据作为消息流进行了更清晰的抽象。这允许较低延迟的处理，并更容易支持多个数据源和分布式数据消费。与以日志为中心的系统（例如 Scribe 或 Flume）相比，Kafka 具有同样出色的性能，由于复制而提供的更强的持久性保证以及更低的端到端延迟。</p>
<h4 id="流处理">流处理</h4>
<p>Kafka 的很多用户使用多个阶段组成的处理管道处理数据，从 Kafka 主题中消费原始输入数据，然后将其聚合，增强或以其他方式转换为新主题，以供进一步消费或后续处理。例如，用于推荐新闻文章的处理管道可能会从 RSS 供给中检索文章内容，并将其发布到“文章”主题中。进一步的处理可能会使该内容规范化或删除重复数据，并将清洗后的文章内容发布到新主题中；最后的处理阶段可能会尝试向用户推荐此内容。这样的处理管道基于各个主题创建实时数据流的图形。从 0.10.0.0 开始，Apache Kafka 中提供了一个轻量但功能强大的流处理库，称为 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/streams">Kafka Streams</a>，可以执行上述数据处理。除了 Kafka Streams，替代的开源流处理工具包括 <a target="_blank" rel="noopener" href="https://storm.apache.org/">Apache Storm</a> 和 <a target="_blank" rel="noopener" href="http://samza.apache.org/">Apache Samza</a>。</p>
<h4 id="事件溯源（Event-Sourcing）">事件溯源（Event Sourcing）</h4>
<p><a target="_blank" rel="noopener" href="http://martinfowler.com/eaaDev/EventSourcing.html">事件溯源</a>是应用程序设计的一种样式，其中状态更改以时间顺序的记录序列记录下来。 Kafka 对非常大的存储日志数据的支持使其成为使用这种样式构建的应用程序的绝佳后端。</p>
<h4 id="提交日志（Commit-Log）">提交日志（Commit Log）</h4>
<p>Kafka 可以用作分布式系统的一种外部提交日志。该日志有助于在节点之间复制数据，并充当故障节点恢复其数据的重新同步机制。Kafka 中的<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#compaction">日志压缩</a>功能有助于支持此用法。在这种用法中，Kafka 类似于 <a target="_blank" rel="noopener" href="https://bookkeeper.apache.org/">Apache BookKeeper</a> 项目。</p>
<h3 id="如何保证消息顺序？">如何保证消息顺序？</h3>
<p>Kafka 可以保证同一个分区里的消息是有序的。也就是说，如果生产者按照一定的顺序发送消息，broker 就会按照这个顺序把它们写入分区，消费者也会按照同样的顺序读取它们。</p>
<p><strong>使用单个分区能最大程度保证消息的顺序，或者消息使用相同的 key。还需注意下面的配置。</strong></p>
<h4 id="生产者-4">生产者</h4>
<p><code>retries</code> ：生产者从服务器收到错误时的重试次数</p>
<p><code>max.in.flight.requests.per.connection</code> ：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
<p>消息是否写入成功也是非常关键的，如果把 <code>retries</code> 设为非零整数，同时把 <code>max.in.flight.requests.per.connection</code> 设为比 1 大的数，那么第一批消息写入失败，而第二批写入成功，broker 重试第一个批次。此时第一个批次写入成功，那么两个批次的顺序就反了。</p>
<p>为了保证写入的顺序，不建议把 <code>retries</code> 设为 0，可以把 <code>max.in.flight.requests.per.connection</code> 设为 <strong>1</strong> ，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker。不过这样的会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下。</p>
<h3 id="如何保证消息被消费-Exactly-Once-2">如何保证消息被消费 Exactly-Once</h3>
<p>由于各种故障，消息传递系统无法保证生产者和使用者应用程序之间的消息传递。根据客户端应用程序与此类系统交互的方式，可能会出现以下消息语义：</p>
<ul>
<li>如果消息传递系统永远不会复制消息，但可能会漏掉偶尔的消息，则我们称 <em><strong>最多一次 (at-most-once)</strong></em></li>
<li>如果它永远不会丢失一条消息，但可能会重复一条消息，则我们称 <em><strong>至少一次 (at-least-once)</strong></em>**</li>
<li>如果发送的所有消息时总是不重复，且保证消息只发送一次，那将是 <em><strong>恰好一次 (exactly-once)</strong></em> ，得保证生产者发送给服务器的消息只成功一次，消费者也只消费一次。Kafka 代理和客户端应用引入事物可确保进行一次准确的交付。</li>
</ul>
<h4 id="生产者-5">生产者</h4>
<p><img data-src="../../images/middleware/kafka/produce-message.png" alt="img"></p>
<p>从 Kafka 0.11 开始，<code>KafkaProducer</code> 支持另外两种模式：<strong>幂等生产者</strong>和<strong>事务性生产者</strong>。 幂等生产者将 <code>Kafka</code> 的传递语义从至少一次传递增强到恰好一次传递。 特别是生产者重试将不再引入重复。 事务生产者允许应用程序以原子方式将消息发送到多个分区（和主题！）。</p>
<h5 id="幂等生产者">幂等生产者</h5>
<p>由于生产者出错重试会导致消息重复，所以为了生产者成功提交的消息恰好一次，可以使用幂等操作来保证。如果发生导致生产者重试的错误，则相同的消息（仍由生产者多次发送）将仅写入到代理上的 Kafka 日志一次。对于单个分区，幂等生产者发送消除了由于生产者或代理错误而产生重复消息的可能性。要启用此功能并为每个分区获取 Exactly-Once 的语义（即没有重复，没有数据丢失和有序的语义），<strong>请将生产者配置为 <code>enable.idempotence = true</code></strong> 。</p>
<p><code>enable.idempotence</code> ：当设置为 “true” 时，生产者将确保每个消息的仅有一个副本被写入流中。如果为 “false”，则生产者由于代理失败等原因而重试，可能会将重试消息的副本写入流中。 请注意，启用幂等性要求 <code>max.in.flight.requests.per.connection</code> 小于或等于 5，重试大于 0， <code>ack</code> 必须为 “<strong>all</strong>”。 **如果用户未明确设置这些值，<code>retries</code> 配置将默认为 <code>Integer.MAX_VALUE</code> 并且 <code>acks</code> 配置将默认为 <code>all</code> **。 如果设置了不兼容的值，则将引发 <code>ConfigException</code>。</p>
<p><code>acks</code> ：该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有影响。</p>
<ul>
<li><code>acks=0</code> 不需要确认</li>
<li><code>acks=1</code> 需要集群首领确认。首领确认纪录后失败，如果跟随者还没复制，则记录可能丢失。</li>
<li><code>acks=all</code> 集群首领及其追随者都确认后，才会收到成功响应。安全性更高，吞吐率下降。</li>
</ul>
<h5 id="事务性生产者">事务性生产者</h5>
<p><strong>幂等生产者只能保证单个主题的写入提供保证</strong>，如果想将一组消息跨多个主题原子提交，则可以让生产者通过设定事物 Id ( <code>transactional.id</code> )，然后开启事物。</p>
<p>如果设置了 <code>transactional.id</code> ，<strong>则幂等性与幂等性所依赖的生产者配置一起自动启用</strong>。 此外，事物中包含的主题应配置为持久性。 特别是， <code>replication.factor</code> 至少应为 3 ，这些 <code>min.insync.replicas</code> 应设置为 2。 最后，为了从端到端实现事务性保证，消费者必须配置为<strong>仅读取已提交的消息</strong>。</p>
<h4 id="消费者-2">消费者</h4>
<h5 id="事物-3">事物</h5>
<p><code>isolation.level</code> ：控制如何读取事务写入的消息。如果设置为 <code>read_committed</code> ，<code>consumer.poll()</code> 将仅返回已提交的事务性消息。如果设置为 <code>read_uncommitted</code> （ <strong>默认</strong> ），<code>consumer.poll()</code> 将返回所有消息，甚至是已中止的事务性消息。非事务性消息在两种方式下都返回。</p>
<h5 id="手动提交-2">手动提交</h5>
<p><code>enable.auto.commit</code> ：该属性决定是否自动提交偏移量，默认为 true。为了避免数据出现重复和丢失，可以通过手动提交的方式自行提交偏移量。</p>
<h3 id="是什么使-Kafka-如此之快-2">是什么使 Kafka 如此之快</h3>
<h4 id="低延迟消息传递-2">低延迟消息传递</h4>
<p>Kafka 通过顺序 IO 操作日志避免了长时间的磁盘寻道；</p>
<p>零拷贝原则，避免了内核上下文和应用上下文的文件读取和发送，直接在系统内核上下文中进行文件读取和发送，避免了上下文切换的时间消耗和内存占用。</p>
<p>传统数据复制方法</p>
<p><img data-src="../../images/middleware/kafka/data-copying.gif" alt="Traditional data copying approach"></p>
<p>这里涉及的步骤有：</p>
<ol>
<li>read() 调用引发了一次从用户模式到内核模式的上下文切换。在内部，发出 sys_read()（或等效内容）以从文件中读取数据。直接内存存取（direct memory access，DMA）引擎执行了第一次拷贝，它从磁盘中读取文件内容，然后将它们存储到一个内核地址空间缓存区中。</li>
<li>所需的数据被从读取缓冲区拷贝到用户缓冲区，read() 调用返回。该调用的返回引发了内核模式到用户模式的上下文切换（又一次上下文切换）。现在数据被储存在用户地址空间缓冲区。</li>
<li>send() 套接字调用引发了从用户模式到内核模式的上下文切换。数据被第三次拷贝，并被再次放置在内核地址空间缓冲区。但是这一次放置的缓冲区不同，该缓冲区与目标套接字相关联。</li>
<li>send() 系统调用返回，结果导致了第四次的上下文切换。DMA 引擎将数据从内核缓冲区传到协议引擎，第四次拷贝独立地、异步地发生 。</li>
</ol>
<p>零拷贝使用 <code>java.nio.channels.FileChannel.transferTo()</code></p>
<p><img data-src="../../images/middleware/kafka/zero-copying.gif" alt="Data copy with transferTo"></p>
<h4 id="批处理数据和压缩-2">批处理数据和压缩</h4>
<p>通过批量读写来优化吞吐量，并将同一批次的消息高效压缩在一起传输，在日志中也同样保持压缩，仅由使用者解压缩。支持的压缩算法：<code>Zstd</code>、<code>Snappy</code>、<code>GZip</code> 或 <code>LZ4</code>。</p>
<h4 id="水平扩展-2">水平扩展</h4>
<p>首先让我们了解什么是垂直扩展。可以说，对于传统的数据库服务器，当负载增加时，一种解决方法是添加更多资源，例如：CPU，RAM，SSD 等。这称为垂直扩展。它具有以下几个缺点：</p>
<ul>
<li>每个硬件都有局限性，不能无限地向上扩展。</li>
<li>如果机器出现故障怎么办？通常需要停机。</li>
</ul>
<p><strong>水平扩展</strong>通过添加更多机器来解决相同的问题。 Kafka 能够为单个主题提供数千个分区，并将其分布在数千台计算机中，这意味着 Kafka 可以处理巨大的负载。</p>
<h2 id="九、开源监控工具">九、开源监控工具</h2>
<h3 id="CMAK-Cluster-Manager-for-Apache-Kafka-previously-known-as-Kafka-Manager"><a target="_blank" rel="noopener" href="https://github.com/yahoo/CMAK">CMAK</a>(Cluster Manager for Apache Kafka, previously known as Kafka Manager)</h3>
<p>分类：<em>WEB UI 服务</em></p>
<p>特性：可管理集群、监控集群状态（主题、消费者、偏移量、消息代理、复制副本、分区副本）、<strong>运行首选副本选举</strong>、创建/删除/修改主题及分区、<strong>分区主题重新分配</strong>、<strong>JMX 监控</strong>…</p>
<h3 id="kafdrop"><a target="_blank" rel="noopener" href="https://github.com/obsidiandynamics/kafdrop">kafdrop</a></h3>
<p>分类：<em>WEB UI 服务</em></p>
<p>特性：查看 Kafka 代理（主题和分区分配以及控制器状态）、查看主题（分区数，复制状态和自定义配置）、<strong>查看消息（JSON，纯文本和 Avro 编码）</strong>、查看消费者分组（每个分区的消费偏移量，合并和每个分区的滞后）、创建新主题、查看 ACLs…</p>
<h3 id="Kafka-Tool"><a target="_blank" rel="noopener" href="https://www.kafkatool.com/index.html">Kafka Tool</a></h3>
<p>分类：<em>GUI 应用</em></p>
<p>特性：快速查看所有 Kafka 集群，包括其代理，主题和消费者、<strong>查看分区中消息的内容并支持添加新消息</strong>、查看消费者的偏移量、支持 JSON 和 XML 等格式显示消息、添加和删除主题以及其他管理功能、<strong>将单个消息从您的分区保存到本地硬盘驱动器</strong>、Kafka Tool 可在Windows，Linux 和 Mac OS 上运行</p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>logstash 学习</title>
    <url>/middleware/logstash-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>logstash 版本（6.2）</p>
</blockquote>
<hr>
<h2 id="配置中的-codec-到底是什么">配置中的 <code>codec</code> 到底是什么</h2>
<p><code>codec</code> 属性用来配置编解码插件，它负责对输入输出的内容表现形式进行处理，插件本质上是个流式过滤器。<br>
以下是常用的插件:</p>
<ul>
<li><code>json</code></li>
</ul>
<blockquote>
<p>读取JSON格式的内容，在JSON数组中为每个元素创建一个事件</p>
</blockquote>
<ul>
<li><code>line</code></li>
</ul>
<blockquote>
<p>从行读取文本数据</p>
</blockquote>
<ul>
<li><code>plain</code></li>
</ul>
<blockquote>
<p>读取原始内容，不会进行转化</p>
</blockquote>
<ul>
<li><code>rubydebug</code></li>
</ul>
<blockquote>
<p>将输出打印到 logstash 的事件中</p>
</blockquote>
<span id="more"></span>
<p>所有的插件请查看：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html#codec-plugins">https://www.elastic.co/guide/en/logstash/current/codec-plugins.html#codec-plugins</a></p>
<h2 id="使用配置文件">使用配置文件</h2>
<ul>
<li>
<p><code>conf</code> 文件<br>
定义Logstash处理管道的管道配置文件</p>
</li>
<li>
<p><code>pipelines.yml</code> 文件<br>
pipeline 文件用于在单个实例中配置多个管道处理数据，是 logstash 的设置文件，每个管道拥有自己独立的线程，输入从管道中接受输入事件并按固定大小单位（batch size）存放到管道序列中（默认在内存，可以持久化到硬盘），过滤，输出从管道中消费序列，可以通过配置 <code>batch size</code> 和 <code>管道工作线程</code> 提高性能。具体参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/tuning-logstash.html"> Tuning and Profiling Logstash Performance</a></p>
</li>
<li>
<p>过滤增强插件</p>
</li>
</ul>
<ul>
<li>
<p><code>Grok</code> 过滤插件<br>
可以将非结构的数据转换成结构化的数据便于查询，Grok 通过组合<code>文本匹配模式(text pattern)</code>来匹配你的内容的方式工作。</p>
<ul>
<li>支持的匹配模式请查看<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns">https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns</a></li>
<li>可以对文本内容进行格式转化，支持 <code>int</code> 和 <code>float</code>。</li>
<li>支持自定义模式，正则等</li>
<li>支持增加、移除、重写字段，tag 等</li>
<li>具体详见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html">plugins-filters-grok</a></li>
</ul>
</li>
<li>
<p><code>Geoip</code> 增强过滤插件<br>
通过你指定的ip地址列，查询额外的地址信息：经纬度，国家，区域，编码等。</p>
</li>
<li>
<p><code>mutate</code> 过滤转换插件<br>
对事件字段执行一般转换。您可以重命名，删除，替换和修改事件中的字段</p>
</li>
<li>
<p>更多插件请查看：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a></p>
</li>
</ul>
<h2 id="启动服务">启动服务</h2>
<ul>
<li>启动参数
<ul>
<li>
<p><code>--node.name NAME</code><br>
指定 logstash 实例的名称，默认为当前的主机名。</p>
</li>
<li>
<p><code>-f, --path.config CONFIG_PATH</code><br>
从特定文件或目录加载 Logstash 配置。如果给出一个目录，那么该目录中的所有文件将按字典顺序连接，然后解析为单个配置文件。<br>
您可以指定通配符（globs），并且任何匹配的文件将按照上述顺序加载。例如，您可以使用通配符功能按名称加载特定文件：</p>
<blockquote>
<p>bin/logstash --debug -f ‘/tmp/{one,two,three}’</p>
</blockquote>
<p>使用此命令，Logstash会连接三个配置文件/ tmp / one，/ tmp / two和/ tmp / three，并将它们解析为单个配置。</p>
</li>
<li>
<p><code>-e, --config.string CONFIG_STRING</code><br>
使用给定的字符串作为配置数据。与配置文件相同的语法。</p>
</li>
<li>
<p><code>-t, --config.test_and_exit</code><br>
修改配置文件不重启服务：</p>
<blockquote>
<p>bin/logstash -f first-pipeline.conf -t</p>
</blockquote>
</li>
<li>
<p><code>-r, --config.reload.automatic</code><br>
测试，转换配置文件，并打印错误：</p>
<blockquote>
<p>bin/logstash -f first-pipeline.conf -r</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="使用-docker-获取镜像">使用 docker 获取镜像</h2>
<p>发布的镜像存放在 <a target="_blank" rel="noopener" href="https://www.docker.elastic.co/">www.docker.elastic.co</a>，源码放在<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash-docker/tree/6.2">GitHub</a>.</p>
<blockquote>
<p>默认版本安装 X-PACK<br>
oss 版本不安装 X-PACK。</p>
</blockquote>
<h3 id="配置">配置</h3>
<p>容器的管道配置文件目录：<code>/usr/share/logstash/pipeline/</code><br>
配置文件目录：<code>/usr/share/logstash/config/</code></p>
<h3 id="环境变量">环境变量</h3>
<p><code>PIPELINE_WORKERS</code> 对应 <code>pipeline.workers</code><br>
<code>LOG_LEVEL</code> 对应 <code>log.level</code><br>
<code>XPACK_MONITORING_ENABLED</code> 对应 <code>XPACK_MONITORING_ENABLED</code><br>
等</p>
<h2 id="Kafka-input-plugin-插件配置">Kafka input plugin 插件配置</h2>
<h3 id="元数据字段">元数据字段</h3>
<ul>
<li>[@metadata][kafka][topic]：消息来源处的原始 Kafka topic。</li>
<li>[@metadata][kafka][consumer_group]：消费者组</li>
<li>[@metadata][kafka][partition]：此讯息的分区信息。</li>
<li>[@metadata][kafka][offset]: 此消息的原始记录偏移量。</li>
<li>[@metadata][kafka][key]：Record key, 如果有的话。</li>
<li>[@metadata][kafka][timestamp]：kafka broker 收到此消息时的时间戳。</li>
</ul>
<p>如何使用：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  kafka &#123;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">decorate_events</span> =&gt; <span class="keyword">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">filter</span> &#123;    </span><br><span class="line">  mutate &#123;</span><br><span class="line">    <span class="attr">add_field</span> =&gt; &#123;<span class="string">&quot;[@metadata][index]&quot;</span> =&gt; <span class="string">&quot;%&#123;[kafka][topic]&#125;&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    <span class="attr">index</span> =&gt; <span class="string">&quot;kafka-%&#123;[@metadata][index]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用的配置选项">常用的配置选项</h3>
<ul>
<li>
<p><strong>auto_commit_interval_ms</strong>：消费者的 offset 提交 kafka 时间频率。<br>
单位：<code>毫秒</code><br>
默认值：<code>5000</code></p>
</li>
<li>
<p><strong>bootstrap_servers</strong>：用于建立群集初始连接的 Kafka 实例的 URL 列表。<br>
格式如下：<code>&quot;host1:port1,host2:port2&quot;</code><br>
默认值：<code>&quot;localhost:9092&quot;</code></p>
</li>
<li>
<p><strong>client_id</strong>：发出请求时传递给服务器的 id 字符串。这样做的目的是通过允许包含逻辑应用程序名称，能够跟踪 ip / port 之外的请求源。<br>
默认值：<code>&quot;logstash&quot;</code></p>
</li>
<li>
<p><strong>decorate_events</strong>：是否添加 kafka 的元数据。<br>
默认值：<code>false</code></p>
</li>
<li>
<p><strong>group_id</strong>：此用户所属组的标识符。消费者组是由多个处理器组成的单个逻辑用户。主题中的消息将分发给具有相同 group_id 的所有 Logstash 实例<br>
默认值：<code>&quot;logstash&quot;</code></p>
</li>
<li>
<p><strong>topics</strong>：要订阅的主题列表。<br>
-默认值：<code>[&quot;logstash&quot;]</code></p>
</li>
<li>
<p><strong>topics_pattern</strong>：要订阅的主题正则表达式模式。使用此配置时，topics 配置将被忽略。</p>
</li>
<li>
<p><strong>id</strong>：在有多个 kafka input 时，在这种情况下添加命名标识将有助于在使用监视 API 时监视 Logstash。</p>
</li>
</ul>
<h2 id="Elasticsearch-output-plugin-插件配置">Elasticsearch output plugin 插件配置</h2>
<h3 id="常用的配置选项-2">常用的配置选项</h3>
<ul>
<li><strong>action</strong> ：告示 Elasticsearch 要做的操作</li>
<li>默认值是 <code>index</code>
<ul>
<li>index ：索引一个文档</li>
<li>delete ：通过 id 删除文档</li>
<li>create ：索引一个文档，如果 id 已经存在索引中则创建失败</li>
<li>update ：通过 id 更新文档。如果文档不存在时如何处理，请查看<code>upsert</code>选项。</li>
</ul>
</li>
<li><strong>document_id</strong>：指定索引文档的 id。</li>
<li>没有默认值，默认<code>Elasticsearch</code>会创建随机 id</li>
<li><s><strong>document_type</strong>：指定索引文档的类型。</s></li>
<li>下个版本将被移除，原因见注脚。</li>
<li><strong>hosts</strong>：设置远程实例的<code>host</code>,给定数组的 host 会对请求负载均衡。</li>
<li>默认值：<code>[&quot;127.0.0.1&quot;]</code><br>
<strong>网址中出现的任何特殊字符必须是 URL 转义的！例如，这意味着＃应该是％23。</strong></li>
<li><strong>index</strong>：指定索引的名称。</li>
<li>默认值：<code>&quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot;</code><br>
完整的属性请查看：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html#plugins-outputs-elasticsearch-document_type">https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html#plugins-outputs-elasticsearch-document_type</a></li>
</ul>
<hr>
<p>下面放一个从 kafka 收集数据，输出到 Elasticsearch 的配置：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">  	<span class="attr">group_id</span> =&gt; <span class="string">&quot;test-consumer-group&quot;</span></span><br><span class="line">    <span class="attr">topics</span> =&gt; [<span class="string">&quot;test&quot;</span>]</span><br><span class="line">    <span class="attr">bootstrap_servers</span> =&gt; <span class="string">&quot;127.0.0.1:9092&quot;</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; json</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  stdout &#123; <span class="attr">codec</span> =&gt; rubydebug &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br><span class="line">    <span class="attr">document_id</span> =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>%&#123;id&#125;</code> 解释：<br>
假设我的输入数据格式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span><span class="string">&quot;info&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;Hii&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span><span class="string">&quot;2017-02-02T08:32:09.535Z&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>document_id =&gt; &quot;%&#123;id&#125;&quot;</code>及使用数据的 id 作为文档索引。</p>
<hr>
<p>注：开始时，我们把“index”类比为sql数据库的“database”，“type”类比为“table”。<br>
但是这是个错的认知，在 SQL 数据库中，表格彼此独立。一个表中的列与另一个表中的相同名称的列没有关系。但是映射类型（type）中的字段不是这种情况。<br>
在 Elasticsearch 索引中，在不同映射类型（type）中具有相同名称的字段在内部由相同的 Lucene 字段支持。<br>
这会导致你希望删除一个类型中的字段时另一个类型的相同字段会出错。<br>
最重要的是，存储同一索引中具有很少或没有共同字段的不同实体会导致稀疏数据并干扰 Lucene 高效压缩文档的能力。<br>
<strong>解决方法：</strong></p>
<ol>
<li>为每一个文档类型创建索引</li>
<li>自己定义一个 type 字段</li>
</ol>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Kafka</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP 联盟白皮书【翻译】</title>
    <url>/methodology/AOP-Alliance/</url>
    <content><![CDATA[<blockquote>
<p>本文档为 <a target="_blank" rel="noopener" href="http://aopalliance.sourceforge.net/white_paper/">AOP Alliance 白皮书</a>的部分翻译</p>
</blockquote>
<h1>引言</h1>
<p>本文档的目的是介绍 AOP 联盟项目。它的目标，它的哲学，它应该提供什么答案，它不应该提供什么。这是一个提案草案，必须与 AOP 联盟的其他成员进一步讨论，以便就我们在这里所做的工作达成共识。一旦从列表中的讨论中出现有趣的点，它也应该去完成。</p>
<p>本文档是一份白皮书，可供 AOP 联盟成员用于内部目的，也可以为外部人员提供有关 AOP 联盟的见解和理解。</p>
<p>在第<a target="_blank" rel="noopener" href="http://aopalliance.sourceforge.net/white_paper/node3.html#sec:aopalliance_goals">1</a>节中，我将尝试概括地解释 AOP 联盟的目标。我们的动机来自这样一个事实，即 AOP 可以改进诸如基于 J2EE 的解决方案。如果我们设法定义一组规范化的 API，就可以将 AOP 集成到现有解决方案中或使用现有 AOP 工具构建 AOP 环境。</p>
<p>第<a target="_blank" rel="noopener" href="http://aopalliance.sourceforge.net/white_paper/node7.html#sec:architectures">2</a>节概述了面向切面环境的拟议架构和 API。我们试着猜测 AOP 联盟应该指定哪些 API。</p>
<p>最后，在第<a target="_blank" rel="noopener" href="http://aopalliance.sourceforge.net/white_paper/node11.html#sec:comps">3</a>节中，我将详细介绍已识别的组件及其在 AOP 环境中的角色。</p>
<span id="more"></span>
<h1>AOP 概念及术语</h1>
<ul>
<li>
<p><strong>Cross-cutting concerns</strong>：横切关注点，指的是一些具有横越多个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E6%A8%A1%E7%B5%84">模块</a>的行为，使用传统的软件开发方法不能够达到有效的模块化的一类特殊<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%85%B3%E6%B3%A8%E7%82%B9&amp;action=edit&amp;redlink=1">关注点</a>。尽管 OO 模型中的大多数类将执行单个特定功能，但它们通常与其他类共享共同的次要需求。</p>
<blockquote>
<p>例如，我们可能希望在线程进入或退出方法时向数据访问层中的类添加日志记录。其它的关注点可能与安全有关，例如访问控制或信息流控制。尽管每个类具有非常不同的主要功能，但执行次要功能所需的代码通常是相同的。</p>
</blockquote>
</li>
<li>
<p><strong>Aspect</strong>：切面，跨越多个类的关注点的模块化，一个切面横切了程序的核心关注点。它由切入点和通知组合而成。</p>
<blockquote>
<p>例如，日志代码可以横切许多模块，但是日志的切面应该与其横切的模块功能关注点分离。将事物、日志和持久性等切面与业务逻辑隔离是面向切面编程 (AOP) 范式的核心。</p>
</blockquote>
</li>
<li>
<p><strong>Join point</strong>：连接点，程序<u>执行过程</u>中的一个点，例如方法的执行、字段的访问或异常的处理。在 Spring AOP 中，一个连接点总是代表一个方法的执行，Spring 只处理访问的执行，包括构造方法。</p>
<blockquote>
<p>在我们的例子中，连接点为线程进入或退出方法这一程序执行点。</p>
</blockquote>
</li>
<li>
<p><strong>Advice</strong>：通知/建议，切面在特定连接点采取的行动。许多 AOP 框架，包括 Spring，将通知建模为拦截器，并围绕连接点维护一系列拦截器。这是您要应用于现有模型的附加代码。</p>
<blockquote>
<p>在我们的例子中，这是我们想要在线程进入或退出方法时应用的日志记录代码。</p>
</blockquote>
</li>
<li>
<p><strong>Pointcut</strong>：切点，匹配连接点的 predicate - 谓词。 通知与切点表达式相关联，并在切点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。由切点表达式匹配的连接点的概念是 AOP 的核心，Spring 默认使用 AspectJ 切点表达式语言。</p>
<blockquote>
<p>在我们的例子中，切点为满足数据访问层类的方法这一谓词。</p>
</blockquote>
</li>
<li>
<p><strong>Introduction</strong>：引入，引入通过定义额外的接口方法或字段修改 Java 类的类型和结构，它可用于强制现有类使用另一个类的方法来实现额外的接口。它本质上允许开发人员在 Java 中创建 C++ 风格的多继承对象系统。Spring AOP 允许您向任何通知的对象引入新的接口（和相应的实现）。</p>
<p>在 Spring 中您可以使用 <code>@DeclareParents</code> 注解进行引入。此注解用于声明匹配类型具有新的父级（因此得名）。例如，给定一个名为 <code>UsageTracked</code> 的接口和一个名为 <code>DefaultUsageTracked</code> 的接口的实现，以下切面声明服务接口的所有实现者也实现 <code>UsageTracked</code> 接口（例如，通过 JMX 进行统计）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsageTracking</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> &#123;</span><br><span class="line">        usageTracked.incrementUseCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Target object</strong>：目标对象，由一个或多个切面通知的对象。也称为“通知对象”。由于 Spring AOP 是使用运行时代理实现的，所以这个对象始终是一个被代理的对象。</p>
</li>
<li>
<p><strong>AOP proxy</strong>：AOP 框架为了实现切面合约（通知方法执行等）而创建的对象。在 Spring Framework 中，AOP 代理是 JDK 动态代理或 CGLIB 代理。</p>
</li>
<li>
<p><strong>Weaving</strong>：将切面与其他应用程序类型或对象链接以创建通知对象。这可以在编译时完成（例如，使用 AspectJ 编译器），加载时或运行时。 Spring AOP 与其他纯 Java AOP 框架一样，在运行时执行编织。</p>
</li>
</ul>
<h1>AOP 联盟目标</h1>
<h2 id="AOP-优势：J2EE-案例">AOP 优势：J2EE 案例</h2>
<p>J2EE 是一个典型的目标环境（但不是唯一的），可以从 AOP 联盟中受益。事实上，J2EE 环境通过提供处理技术问题（如持久性或事务）的方法部分解决了一些问题。但是，J2EE 体系结构不够灵活，无法轻松添加与特定需求相关的新技术问题。此外，当不需要或更喜欢更轻的解决方案时，能够去除一种解决方案会很有趣。</p>
<p>AOP 提供了一种通用方法来构建新的技术关注点（横切关注点）并以灵活和模块化的方式将它们插入到应用程序中。在 J2EE 中应用一些 AOP 概念也可以真正简化它的使用。例如，可以使用常规 Java 对象 (POJO) 代替 EJB。因此，能够轻松地将完整的 AOP 应用到 J2EE 将大大提高 J2EE 的可用性。它还将为符合 J2EE 的应用程序服务器带来更多的功能。</p>
<h2 id="当前对-AOP-的约束">当前对 AOP 的约束</h2>
<p>AOP 越来越受欢迎。然而，大多数 AOP 工具并不是为了在任何环境中应用而设计的（主要是因为大多数工具是为了实验目的而设计的）。因此，当尝试在特定环境中使用 AOP 时，我们可能会遇到一些问题，因为例如，环境已经支持一些可能不符合 AOP 工具实现的内置方面。</p>
<p>出现这个问题是因为 AOP 需要修改应用程序的对象/类才能正常工作。这个对象修改逻辑是由 AOP 工具的一个特定部分实现的：Weaver - 编织器。Weaver 可以很好地适应给定的环境，但可能会破坏另一个环境中的一些重要系统属性。例如，Gregor 和 Rickard 之间关于 AOP 联盟列表的有趣讨论似乎表明，AspectJ 用于引入（特定编织操作）的编织器实现并不适合某些具有某种分布式和持久性能力的环境。</p>
<h2 id="AOP-联盟声明">AOP 联盟声明</h2>
<p>这里的大多数人都不相信完美的系统。我们认为一个系统总是适合给定的问题和环境（它不一定适合另一个）。这正是我们可能在复杂环境（如 J2EE）中使用的 AOP 工具的情况。根据面临的问题，有一个特定的 AOP 实现会很有用。</p>
<p>已经有很多 AOP 或 AOP 相关技术的具体实现，例如通用代理、拦截器（interceptor）或字节码翻译器（bytecode translator）。例如：</p>
<ul>
<li>AspectJ：AO 源代码级别（和字节码级别）编织器。切面编程新语言。</li>
<li>AspectWerkz：AO 框架（字节码级别的动态编织器 + XML 中的配置）。</li>
<li>BCEL：字节码翻译器。</li>
<li>JAC：AO 中间件（字节码级别的动态编织器+配置+切面）。框架。</li>
<li>Javassist：具有高级 API 的字节码翻译器。</li>
<li>JBoss-AOP：拦截和基于元数据的 AO 框架（在 JBoss 应用服务器上运行 + 独立版本）。</li>
<li>JMangler：具有翻译组合框架的字节码翻译器。</li>
<li>Nanning：AO 编织器（框架）。</li>
<li>Prose：AO 字节码级别的动态编织器（框架）。</li>
</ul>
<p>对我们来说，这些实现反映了没有好的或坏的实现，而是适合一些问题/环境的实现。</p>
<p>因此，AOP 联盟的目标既不是提供新的 AOP 模型，也不是提供适用于所有情况或给定 J2EE 应用程序服务器的出色 AOP 实现。<strong>AOP 联盟的目标是使所有现有的实现能够使用相同的核心语言</strong>，以便：</p>
<ul>
<li>避免因为复用而重新构建现有的 AOP 组件，</li>
<li>为给定的目标环境（通常是 J2EE 环境）简化现有 AOP 组件的适配，</li>
<li>通过拥有一个通用的根 AOP API 来简化切面的复用。</li>
<li>简化希望集成 AOP 功能的开发工具的实现。</li>
</ul>
<h1>面向切面的架构</h1>
<h2 id="一个共同的架构愿景">一个共同的架构愿景</h2>
<p>在前两节中，我们解释说很难就通用 AOP 模型和实现达成一致，因为它与使用上下文和环境的联系过于紧密（实现可能在纯 Java 方法和符合 J2EE 的方法中有所不同）。但是，我们认为有可能就面向切面的环境 (AOE) 的共同架构愿景达成一致。</p>
<p>实际上，在构建面向方面的环境 (AOE) 时，设计师需要定义一个架构。在大多数现有的 AOE 中，架构定义并组合了一些实现系统基本功能的基本模块/组件/API。通过查看现有工具，我们可以识别通用组件（即在所考虑的架构中提供紧密功能的组件，但不一定使用相同的实现技术）。例如，JBoss 的 weaver 使用 Javassist 来实现拦截机制（在客户端植入 - Instrument），而 JAC 的 weaver 使用 BCEL 来实现拦截机制（在服务器端植入 - Instrument）。可以使用其他技术（如介入 JIT 编译器）来实现相同的效果。所有这些都严重依赖环境。</p>
<p>在下一节中，我们将尝试提取对 AOE 有用的组件。这些组件可用于构建上下文相关的 AOE。</p>
<h2 id="三层典型架构">三层典型架构</h2>
<p><img data-src="/Users/zeral/Site/blog/source/images/aop/3-Layer.svg" alt="3-Layer"></p>
<p>可以绘制一个典型的架构，如上图所示。此简化图包含一些组件（框）和一些可以使用（粗体箭头）组件 API 的核心逻辑（圆框）。它旨在图的顶部运行初始 AO 程序。请注意，此架构不打算成为参考架构，而只是一种可能的架构。实际上，组合 AO 架构的不同核心组件存在多种可能性。</p>
<p>可以将此架构分为三层：</p>
<ul>
<li>一个低级层 (1)，提供基本组件以在目标平台上实现编织（AOP 的主要过程），</li>
<li>一个高级层 (2)，为 AOP 提供基本组件，在其原始含义中，加上实现 AO 语义的逻辑（将取决于目标平台），</li>
<li>开发级层 (3)，包括最大意义上的 UI（可以被语言支持，可以是建模工具）以及帮助开发人员信任 AO 程序所需的其他工具（例如类型检查、可视化工具、调试器等）。</li>
</ul>
<h2 id="AOP-联盟在这里指定什么？">AOP 联盟在这里指定什么？</h2>
<p>如前所述，AOP 联盟的目标不是提供新模型或现有工具的更好实现。事实上，AOP 联盟的目标是为通用面向切面环境 (AOE) 实现中标识的组件指定规范化 API。如果我们设法做到这一点，通过集成最适合我们想要使用 AOP 的上下文的组件，就有可能构建出比现有 AOE 更好的 AOE。特别是，即使在 J2EE 应用程序服务器等复杂环境中，也应该可以使用最好的 AOP。</p>
<p>因此，如果我们参考上图，<strong>AOP 联盟的角色应该是定义已识别组件的 API</strong>。最重要的组件是低级组件，因为它们的实现会影响可以使用 AOE 的环境。一些技术特征也可能对最终的系统属性产生深远的影响（例如，切面是否可以动态地编织/unwoven？系统是否可扩展？系统是否可以与内置切面共存，例如持久性或事务？）。但是，高级组件对于 IDE、调试器、建模工具等工具也很有趣。拥有一个通用的 AOP 概念操作 API 将有助于工具更好地支持不同环境中的多个 AOP 实现。</p>
<p>AOP 联盟可以为某些组件提供一些参考实现（通过使用现有工具）。但是，如果现有工具（大多数工具创建者都在联盟中）提供他们自己定义的 API 的实现，那就更好了。这些实现将验证 API 的正确性。</p>
<p>AOP 联盟不会解决编织逻辑和配置逻辑，因为它实际上取决于 AOE 实现。但是，我们还应该提供一些参考实现，以展示我们的 API 应该如何用于构建 AOE。</p>
<p>最后，AOP 联盟不会解决第三层（开发级）。我们应该让开发工具实现者在他们集成的 AOP 工具实现它时使用我们的 API。</p>
<h1>AOP 联盟组件</h1>
<p>现在让我们深入了解核心 AOP 联盟组件的全局图景。<strong>警告：这些组件是 AOP 联盟应指定的 API 的第一个提案草案。其中一些可能会被删除，一些可能会被添加。请注意，其中一些已经开始用 Java 接口指定。</strong></p>
<h2 id="底层组件">底层组件</h2>
<p>底层组件非常重要，因为整个 AOE 都依赖于它们来实现。这些组件的实现方式至关重要，可能会极大地影响系统的属性，例如性能、可扩展性、集成功能或安全性。</p>
<h3 id="反射">反射</h3>
<p>反射 API 对于任何 AOE 都非常重要。事实上，编织者需要内省基础程序的类，以便应用通知（Advice）或介绍（Introduction）。例如，如果一个切入点（Pointcut）告诉一个类的所有方法都应该被通知（Advice）（使用某种正则表达式或一个 ALL 关键字），那么编织者将需要使用反射 API 来明确知道实际需要通知（Advice）的方法列表。</p>
<p>当编织过程在运行时完成时，SUN 的 java.lang.reflect 实现足以构建 AOE。然而，在大多数现有系统中，编织过程发生在编译时或类加载时。在这些情况下，需要反射 API 的特定实现。根据 AOP 联盟的说法，为了能够根据 AOE 的运行上下文切换底层实现，对这个 API 进行规范化非常重要。</p>
<h3 id="程序植入-Instrumentation">程序植入 - Instrumentation</h3>
<p>从编织者的角度来看，如果反射是对编织程序的读访问，则植入 - Instrumentation 是写访问。然而，在 AOP 中，允许的程序修改是一组简化的修改，该修改代表初始程序的现有结构的增量，以便切面可以正确组合在一起。由于列表中先前的讨论，这些类型的增量修改被称为 Instrumentation - 植入。</p>
<p>没有用于植入的标准 API。但是，与反射一样，植入可以在运行时、编译时或加载时发生。此外，对于每个类别，可以根据上下文和 AOE 的环境执行不同的实现（例如，植入可以直接在源代码或字节码上完成）。因此，对我们来说重要的是对植入 API 进行规范化，以便根据 AOE 要求更改底层实现。</p>
<h3 id="拦截器框架">拦截器框架</h3>
<p>另一种对构建 AOE 非常有用的基础组件是拦截框架。通过动态代理，Java 提供了一个标准的 API/框架用于拦截。然而，透明度、性能等方面的一些增强可以通过其他实现来实现（其中大多数使用植入 API）。因此，定义一个具有清晰语义的标准拦截 API/框架也很有趣。</p>
<p>拦截框架有很多优点，因为它们允许非常容易地实现 AOP 模型的围绕通知 - Around Advice。此外，尽管它们是用纯 Java 编写的，但它们可以是独立的，并且大部分时间都提供非常清晰的类似 AOP 的代码。由于这些原因，许多项目和环境（包括 J2EE 应用服务器，请参阅 JBoss）中实现了几个拦截框架。因此，AOP 联盟应该提供一个抽象的拦截框架来规范这个 AOP 重要的工具箱。</p>
<h3 id="元数据处理">元数据处理</h3>
<p>元数据处理在实现 AOE 时很有用，尤其是与拦截框架结合使用时。它允许编织者以非侵入性的方式扩展类语义。由于元数据的大多数实现都允许动态性，因此它也可以用于切面的动态配置/重新配置。</p>
<p>即使 JDK1.5 将提供元数据的标准实现，提供一个允许多个实现的标准 API 应该是有用的。这些可能会考虑一些环境特性，例如分发、序列化，默认实现可能无法正确处理这些特性。</p>
<h3 id="类加载框架">类加载框架</h3>
<p>在许多 AOE 中，需要字节码级别的操作。它可以用来实现一个拦截框架，或者直接实现程序的编织植入。在某些情况下，这种字节码级别的操作可以在类的加载时完成，因为 AOP 植入非常简单。因此，大多数 AOE 使用 Java 灵活的类加载架构。</p>
<p>然而，一些环境也使用类加载器来实现它们自己的功能。例如，分布式环境可以使用特定的类加载器生成存根。在这些环境中，AOE 的类加载机制可能会由于类加载器不兼容而导致系统崩溃。</p>
<p>因此，我们认为规范化类加载框架可能很重要，该框架足够灵活，可以轻松地使来自不同环境的不同类加载器以安全的方式协作。</p>
<h2 id="高层组件">高层组件</h2>
<p>如果我们希望在第三层（开发层）中定义的工具总体上为 AOP 提供更好的支持，那么高级组件对于规范化很重要。</p>
<h3 id="AOP-API">AOP API</h3>
<p>引用 Gregor 的话可以很好地解释我们的 AOP API 的目标：“显然，我们想尽我们所能避免 AOP 工具之间不必要的不一致。现在真正标准化还为时过早，我们仍然需要有意义的差异空间。但不必要的差异显然值得消除。”</p>
<p>所以，我们的 AOP 模型不会是一个新模型。它只会尝试将所有当前模型的共同点结合在一起。AspectJ 模型无疑是最成功的模型，并且已经有一些工具支持它。所以我们可能会在这里采用 AspectJ 的一个子集。</p>
<h3 id="配置-API">配置 API</h3>
<p>许多切面可以以通用方式实现。这意味着它们实现了一种逻辑，对于您希望在其中编织切面功能的任何程序，该逻辑都可能可重用。大多数情况下，这个切面重用过程意味着通用方面的参数化（例如，告诉一个通用持久性切面哪个类应该持久化以及如何持久化）。在 AspectJ 中，这可以通过对抽象切面进行子类化来完成。但也可以通过使用外部工具（例如预处理器）来完成。在 J2EE 环境中，内置切面（EJB 容器的技术关注点）的配置过程由 XML 部署文件参数化。在 JBoss/AOP 等框架中，也可以使用 XML 文件进行配置。在 JAC 中，可以使用切面配置 API 在 Java 程序中完成配置，也可以使用特定的类似脚本的语言，等等。</p>
<p>如果我们可以规范化配置 API，那就太好了。这将使开发工具的 AOE 集成更容易。它还有助于将特定配置从 AOE 重用到另一个 AOE（例如 AspectJ 和 JBoss/AOP）。</p>
<p>请注意，由于潜在的重要差异，将切面从一个 AOE 移植到另一个可能是不现实的。但是使切面配置可移植似乎不那么不切实际，这已经是实现 AOE 互操作性的第一步。</p>
<h1>结论</h1>
<p>本文试图解释 AOP 联盟项目的原因，并指定一些目标。我试图以名单上许多人的名义就我所了解的内容发言。目前它是相当不精确的，并且只绘制了一个全局图。也许有些人会不同意或会失望。如果我们能进行一些非常好的讨论，帮助我们就我们真正想要的东西达成良好的感觉，那就太好了。</p>
]]></content>
      <categories>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>AOP Alliance</tag>
      </tags>
  </entry>
  <entry>
    <title>正则速查</title>
    <url>/methodology/%E6%AD%A3%E5%88%99%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h1>匹配单个字符</h1>
<h2 id="匹配任意字符：">匹配任意字符：<code>.</code></h2>
<p><code>.</code> 元字符可以匹配任何单个的字符、字母、数字甚至是 <code>.</code> 字符本身</p>
<h2 id="匹配特殊字符：">匹配特殊字符：<code>\</code></h2>
<p><code>\</code> 反斜杠是一个元字符( metacharacter，表示“这个字符有特殊含义，而不是字符本身含义&quot;)，反斜杠元字符可以对其它有特殊含义的元字符进行转义，来匹配该字符。</p>
<span id="more"></span>
<h1>匹配一组字符</h1>
<h2 id="匹配多个字符中的某一个：">匹配多个字符中的某一个：<code>[]</code></h2>
<p>可以使用元字符 <code>[</code> 和 <code>]</code> 来定义一个字符集合。这两个元字符之间的所有字符都是该集合的组成部分，字符集合的匹配结果是能够与该集合里的任意一个成员相匹配的文本。</p>
<h2 id="利用字符集合区间：">利用字符集合区间：<code>-</code></h2>
<p>在使用正则表达式的时候，会频繁地用到一些字符区间( 0 ~ 9、A ~ Z 等)。为了简化字符区间的定义，正则表达式提供了一个特殊的元字符，字符区间可以用 <code>-</code> (连字符)来定义，连字符只能用在 <code>[]</code> 之间，其它地方只是普通字符，不需要转义。</p>
<p>字符区间的首、尾字符可以是 ASCII 字符表里的任意字符。以下都是合法的字符区间：</p>
<ul>
<li>[0-9]，匹配从 0 到 9 的任意数字，0 (ASCII 48) and 9 (ASCII 57)，[0-9] 和 [0123456789] 等价。</li>
<li>[A-Z]，匹配从 A 到 Z 的任意大写字母。</li>
<li>[a-z]，匹配从 a 到 z 的任意小写字母。</li>
<li>[A-Za-z0-9]，匹配字幕、数字中的任意一个。</li>
</ul>
<h2 id="取非匹配：">取非匹配：<code>^</code></h2>
<p>除了那个字符集合里的字符，其他宇符都可以匹配。<code>^</code> 的效果将作用于给定宇符集合里的所有字符或字符区间，而不是仅限于紧跟在 <code>^</code> 字符后面的那一个字符或字符区间。例如：[ ^A-Za-z0-9 ] 表示匹配任何不是数字或字母的字符。</p>
<h1>使用元字符</h1>
<h2 id="匹配空白字符">匹配空白字符</h2>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符（Tab 键）</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
</tbody>
</table>
<p><code>\r\n</code> 是 Windows 所使用的文本行结束标签。 Unix 和 Linux 系统只使用一个换行符来结束一个文本行，换句话说，在 Unix/Linux 系统上匹配空白行只使用  <code>\n</code> 即可，不需要加上 <code>\r</code>。</p>
<h2 id="匹配特定的字符类别">匹配特定的字符类别</h2>
<p>前面介绍的都是匹配特定的字符、匹配单个字符。一些常用的字符集合可以用特殊元字符来代替，这些元字符匹配的是某一类别的字符(术语称之为”字符类&quot;)。</p>
<h3 id="匹配数字-或非数字">匹配数字(或非数字)</h3>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>任何一个数字字符（等价于 [ 0-9 ]）</td>
</tr>
<tr>
<td>\D</td>
<td>任何一个非数字字符（等价于 [ ^0-9 ]）</td>
</tr>
</tbody>
</table>
<h3 id="匹配字母和数字-与非字母和数字">匹配字母和数字(与非字母和数字)</h3>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\w</td>
<td>任何一个字母、数字字符（大小写均可）或下划线字符（等价与 [a-zA-Z0-9_] ）</td>
</tr>
<tr>
<td>\W</td>
<td>任何一个非字母数字或非下划线字符（等价与 [ ^a-zA-Z0-9_ ])</td>
</tr>
</tbody>
</table>
<ul>
<li>
<h3 id="匹配空白字符-与非空白字符">匹配空白字符(与非空白字符)</h3>
</li>
</ul>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\s</td>
<td>任何一个空白字符（等价千[ \f\n\r\t\v ]）</td>
</tr>
<tr>
<td>\S</td>
<td>任何一个非空白字符（等价于[ ^\f\n\r\t\v ]）</td>
</tr>
</tbody>
</table>
<h1>重复匹配</h1>
<h2 id="匹配一个或多个字符：">匹配一个或多个字符：<code>+</code></h2>
<p>要想匹配同一个字符（或字符集合）的多次重复，只要简单地给这个字符（或字符集合）加上一个 <code>+</code> 字符作为后缀就行了。</p>
<h2 id="匹配零个或多个字符：">匹配零个或多个字符：<code>*</code></h2>
<p><code>+</code> 最少匹配一个，<code>*</code> 匹配零个或多个字符（或字符集合）。</p>
<h2 id="匹配零个或一个字符：">匹配零个或一个字符：<code>?</code></h2>
<p><code>?</code> 只能匹配一个字符（或字符集合）的零次或一次出现，最多不超过一次。</p>
<h2 id="匹配的重复次数：">匹配的重复次数：<code>&#123;&#125;</code></h2>
<p>前面的匹配无法控制匹配次数，为了解决这些问题并让程序员对重复性匹配有更多的控制，正则表达式语言提供了一个用来设定重复次数（interval）的语法。重复次数要用 <code>&#123;</code> 和 <code>&#125;</code> 字符来给出，把数值写在它们之间。</p>
<ul>
<li>精确的匹配次数：<code>&#123;1&#125;</code>，恰好匹配一次</li>
<li>匹配次数范围：<code>&#123;0, 4&#125;</code>，最少零次，最多四次</li>
<li>至少重复多少次：<code>&#123;2, &#125;</code>，至少重复两次</li>
</ul>
<h2 id="防止过多重复">防止过多重复</h2>
<p>因为 <code>*</code> 和 <code>+</code> 都是所谓的&quot;贪婪型”元字符，它们在进行匹配时的行为模式是多多益善而不是适可而止的。它们会尽可能地从一段文本的开头一直匹配到这段文本的末尾，而不是从这段文本的开头匹配到碰到第一个匹配时为止。</p>
<p>在不需要这种“贪婪行为&quot;的时候该怎么办？答案是使用这些元字符的“懒惰型”版本（&quot;懒惰”在这里的含义是匹配尽可能少的字符，与“贪婪型”元字符的行为模式刚好相反)。懒惰型元字符的写法很简单，只要给贪婪型元字符加上一个 <code>?</code> 后缀即可。</p>
<table>
<thead>
<tr>
<th>贪婪型（Greedy）元字符</th>
<th>懒惰型（Reluctant）元字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>*?</td>
</tr>
<tr>
<td>+</td>
<td>+?</td>
</tr>
<tr>
<td>{n, }</td>
<td>{n, }?</td>
</tr>
</tbody>
</table>
<h1>位置匹配</h1>
<p>位置匹配用来解决在什么地方进行字符串匹配操作的问题。使用边界限定符，也就是在正则表达式里用一些特殊的元字符来表明我们想让匹配操作在什么位置（或边界）发生。<strong>边界限定符匹配的是某个位置，而不是具体的内容。</strong></p>
<h2 id="单词边界：-b">单词边界：<code>\b</code></h2>
<p>第一种边界（也是最常用的边界）是由限定符 <code>\b</code> 指定的单词边界。顾名思义，<code>\b</code> 用来匹配一个单词的开始或结尾。b 代表单词 boundary（边界）。</p>
<p>它匹配的是一个这样的位置，这个位置位于一个能够用来构成单词的字符（字母、数字和下划线，也就是与 \w 相匹配的字符）和一个不能用未构成单词的字符（也就是与 \W 相匹配的宇符）之间或者构成单词的 \w 的开始和结束位置，相当于如下正则的竖点线处：(^<span style="border-right: 2px dotted #dc00ff; padding-left: 2px; margin-right: 2px;"> </span>\w|\w<span style="border-right: 2px dotted #dc00ff; padding-left: 2px; margin-right: 2px;"> </span>$|\W<span style="border-right: 2px dotted #dc00ff; padding-left: 2px; margin-right: 2px;"> </span>\w|\w<span style="border-right: 2px dotted #dc00ff; padding-left: 2px; margin-right: 2px;"> </span>\W)。</p>
<p>如果想匹配单词本身，只需在单词前后加上 <code>\b</code> 即可，例如：<code>\bcap\b</code>，将匹配下面前后都是空白的字符：</p>
<pre>
  The captain wore his <b style="background: #f0f0f0;">cap</b> and cape proudly as he sat listening to the recap of how his crew saved the men from a capsized vessel.
</pre>
<p>如果想不匹配一个单词边界，可以使用 <code>\B</code>，即字母数字下划线之间，或非字母数字下划线之间。例如，我们可以使用 \B-\B 来查找其下面句子前后都有多余空格的连字符：</p>
<pre>
  Please enter the nine-digit id as it appears on your color  <b style="background: #f0f0f0;">-</b>  coded pass-key.
</pre>
<h2 id="字符串边界：">字符串边界：<code>^</code> <code>$</code></h2>
<p>单词边界可以用来进行与单词有关的位置匹配（单词的开头、单词的结束、整个单词等）。字符串边界有着类似的用途，只不过是用来进行与字符串有关的位置匹配而已（字符串的开头、字符串的结束、整个字符串等）。用来定义字符串边界的元字符有两个：一个是用来定义字符串开头的 <code>^</code> ，另一个是用来定义字符串结尾的 <code>$</code>。</p>
<h2 id="分行匹配模式">分行匹配模式</h2>
<p>有许多正则表达式都支待使用一些特殊的元字符去改变另外一些元字符行为的做法，用来启用分行匹配模式（multiline mode）的 (?m) 记号就是一个能够改变其他元字符行为的元字符序列。分行匹配模式将使得正则表达式引擎把行分隔符当作一个字符串分隔符来对待。</p>
<p>Java 下使用 <code>Pattern.MULTILINE</code> 来启用，或者嵌入 (?m) 到正则最前面，例如匹配行注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern.compile(<span class="string">&quot;(?m)^\\s*//.*$&quot;</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Pattern.compile(<span class="string">&quot;^\\s*//.*$&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>JavaScript 下可以通过字面量的形式定义在后面的 flag 中，或者使用对象的形式，例如同样匹配行注释：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^\s*\/\/.*$/m</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;^\s*\/\/.*$&quot;</span>, <span class="string">&quot;m&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在分行匹配模式下，<code>^</code> 不仅匹配正常的字符串开头，还将匹配行分隔符（换行符）后面的开始位置（这个位置是不可见的）; 类似地，<code>$</code> 不仅匹配正常的字符串结尾，还将匹配行分隔符（换行符）后面的结束位置。</p>
<h1>使用子表达式</h1>
<h2 id="子表达式：">子表达式：<code>()</code></h2>
<p>子表达式是一个更大的表达式的一部分；把一个表达式划分为一系列子表达式的目的是为了把那些子表达式当作一个独立元素来使用。子表达式必须用 <code>(</code> 和 <code>)</code> 括起来。</p>
<p>子表达式可以被当作整体和前面描述的重复匹配的元字符组合等。</p>
<h2 id="子表达式嵌套">子表达式嵌套</h2>
<p>子表达式允许嵌套。事实上，子表达式允许多重嵌套，这种嵌套的层次在理论上没有限制，但在实际工作中还是应该遵循适可而止的原则。</p>
<p>例如：<code>((A)(B(C)))</code>，A、B、C 都是独立的正则表达式。</p>
<h1>回溯引用</h1>
<h2 id="回溯引用匹配-n">回溯引用匹配 <code>\n</code></h2>
<p>假设你有一段文本，你想把这段文本里所有连续重复出现的单词（打字错误，其中有一个单词输了两遍）找出来。显然，在搜索某个单词的第二次出现时，这个单词必须是已知的。回溯引用（backreference）允许正则表达式模式引用前面的匹配结果（具体到这个例子，就是前面匹配到的单词）。</p>
<p>下面是一段包含着 3 组重复单词的文本，它们就是我们要找的东西：</p>
<p><strong>文本</strong></p>
<pre>
  This is a block of of text, several words here are are repeated, and and they should not be.
</pre>
<p><strong>正则</strong></p>
<p><code>[ ]+(\w+)[ ]+\1</code></p>
<p><strong>结果</strong></p>
<pre>
  This is a block <b style="background: #f0f0f0;">of of</b> text, several words here <b style="background: #f0f0f0;">are are</b> repeated, <b style="background: #f0f0f0;">and and</b> they should not be.
</pre>
<p><strong>分析</strong></p>
<p>这个模式的最后一部分是 \1；这是一个回溯引用，而它引用的正是前面划分出来的那个子表达式：当 (\w+) 匹配到单词 of 的时候，\1 也匹配单词 of；当 (\w+) 匹配到单词 and 的时候，\1 也匹配单词 and。</p>
<p>\1 到底代表着什么？它代表着模式里的第1 个子表达式，\2 代表着第 2 个子表达式、\3 代表着第 3 个；依次类推。可以把回溯引用想象成变量 。</p>
<blockquote>
<p>Java 中需要对回溯引用的反斜杠转义，变为：<code>[ ]+(\w+)[ ]+\\1</code></p>
</blockquote>
<h2 id="命名捕获：-name-X-k-name">命名捕获：<code>(?&lt;name&gt;X)</code> <code>\k&lt;name&gt;</code></h2>
<p>正如看到的那样，子表达式是通过它们的相对位置未引用的：\1 对应着笫 1 个子表达式，\5 对应着笫 5 个子表达式，等等。虽然受到普遍的支持，但这种语法存在着一个严重的不足：如果子表达式的相对位置发生了变化，整个模式也许就不能再完成原来的工作，删除或添加子表达式的后果可能更为严重。</p>
<p>为了弥补这一不足，一些比较新的正则表达式实现还支持“命名捕获&quot;（named capture）: 给某个子表达式起一个唯一的名字，然后用这个名字（而不是相对位置）来引用这个子表达式。</p>
<p>在 Java、JavaScript 中，可以使用语法 <code>(?&lt;name&gt;X)</code> 为捕获组分配显式名称。其中 X 是通常的正则表达式。</p>
<p>Java 中可以通过 <code>Matcher#group(String name)</code> 来访问命名捕获组匹配的内容，JavaScript 中通过 <code>match.groups.name</code> 直接访问。</p>
<p>例如找到下面的以 , 结尾的单词：</p>
<p><strong>文本</strong></p>
<pre>
  This is a block of of text, several words here are are repeated, and and they should not be.
</pre>
<p><strong>正则</strong></p>
<p><code>[ ]+(?&lt;stopWord&gt;\\w+,)[ ]+</code></p>
<p><strong>结果</strong></p>
<pre>
  This is a block of of <b style="background: #f0f0f0;">text,</b> several words here are are <b style="background: #f0f0f0;">repeated,</b> and and they should not be.
</pre>
<p>如果要回溯引用命名捕获分组，可以使用 <code>\k&lt;name&gt;</code>。</p>
<blockquote>
<p>Java 中同样需要对这个反斜杠转义，变为：<code>\\k&lt;name&gt;</code></p>
</blockquote>
<p>之前通过位置引用的使用命名分组可以修改为：<code>[ ]+(?&lt;repeatWord&gt;\\w+)[ ]+\\k&lt;repeatWord&gt;</code></p>
<h2 id="回溯引用在替换中的应用">回溯引用在替换中的应用</h2>
<p>正则不仅可以用来搜索匹配，也可以用在复杂的替换操作中，尤其是需要使用回溯引用的场合。</p>
<p>例如你需要把原始文本里的电子邮件地址全都转换为 HTML 中可点击的链接：</p>
<p><strong>文本</strong></p>
<pre>
  Hello, ben@forta.com is my email address.
</pre>
<p><strong>正则</strong></p>
<p><code>(\w+[\w\.]*@[\w\.]+\.\w+)</code></p>
<p><strong>替换</strong></p>
<p><code>&lt;a href=&quot;mailto:$1'&gt;$1&lt;/a&gt;</code></p>
<p><strong>结果</strong></p>
<pre>
  Hello, &lt;a href="mailto:ben@forta.com"&gt;ben@forta.com&lt;/a&gt; is my email address.
</pre>
<p>替换操作需要用到两个正则表达式：一个用来给出搜索模式，另一个用来给出匹配文本的替换模式。回溯引用可以跨模式使用，在第一个模式里被匹配的子表达式可以用在第二个模式里，回溯引用可以被引用任意多次。</p>
<p>我们再来看一个例子。在一个用来保存用户信息的数据库里，电话号码被保存为 313-555-1234。现在，你需要把电话号码重新排版为 (313) 555-1234。下面就是这个例子：</p>
<p><strong>文本</strong></p>
<pre>
313-555-1234 
248-555-9999 
810-555-9000
</pre>
<p><strong>正则</strong></p>
<p><code>(\d&#123;3&#125;)(-)(\d&#123;3&#125;)(-)(\d&#123;4&#125;)</code></p>
<p><strong>替换</strong></p>
<p><code>($1) $3-$5</code></p>
<p><strong>结果</strong></p>
<pre>
(313) 555-1234
(248) 555-9999 
(810) 555-9000  
</pre>
<p>正则将内容被划分为 5 个子表达式（5 个组成部分），这 5 个部分都可以单独拿出来使用，我们只使用了其中的 3 个。</p>
<h1>前后查找</h1>
<p>到目前为止，我们见过的正则表达式都是用来匹配文本的，但有时我们还需要用正则表达式<strong>标记要匹配的文本的位置</strong>（而不仅仅是文本本身）。这就引出了前后查找（lookaround，对某一位置的前、后内容进行查找）的概念,</p>
<h2 id="向前查找：-X">向前查找：<code>(?=X)</code></h2>
<p>向前查找（lookahead）指定了一个必须匹配但不在结果中返回的模式。向前查找实际就是一个子表达式，而且从格式上看也确实如此。从语法上看，一个向前查找模式其实就是一个以 <code>?=</code> 开头的子表达式，需要匹配的文本跟在 = 的后面。</p>
<p>例如，我们想把一些 URL 地址的协议提取出来：</p>
<p><strong>文本</strong></p>
<pre>
http://www.forta.com/ 
https://mail.forta.com/ 
ftp://ftp.forta.com/
</pre>
<p><strong>正则</strong></p>
<p><code>.+(?=:)</code></p>
<p><strong>结果</strong></p>
<pre>
<b style="background: #f0f0f0;">http</b>://www.forta.com/ 
<b style="background: #f0f0f0;">https</b>://mail.forta.com/ 
<b style="background: #f0f0f0;">ftp</b>://ftp.forta.com/
</pre>
<p><strong>分析</strong></p>
<p>模式 <code>.+</code> 匹配任意文本（第 1 个匹配是 http），子表达式 <code>(?=:)</code>  匹配 :。注意，被匹配到的 : 并没有出现在最终的匹配结果里；我们用 <code>?=</code> 向正则表达式引擎表明：从  :  位置处先前查找，但不要把它包括在最终的匹配结果里。</p>
<blockquote>
<p>向前查找（和向后查找）匹配本身其实是有返回结果的，只是这个结果的字节长度永远是 0 而已。因此，前后查找操作有时也被称为零宽度（zero - width）匹配操作。</p>
</blockquote>
<h2 id="向后查找：-X">向后查找：<code>(?&lt;=X)</code></h2>
<p>除了向前查找，许多正则表达式实现还支持向后查找，也就是从标记位置向后查找，向后查找操作符是 <code>?&lt;=</code>。</p>
<blockquote>
<p>向后查找的 &lt; 可以看作左闭合处需满足条件，然后向右边开放处匹配</p>
</blockquote>
<p>例如我们想把一份产品目录里面的产品价格提取出来：</p>
<p><strong>文本</strong></p>
<pre>
  ABC01: $23.45 
  HGG42: $5.31 
  CFMX1: $899.00 
  XTC99: $69.96 
  Total items found: 4
</pre>
<p><strong>正则</strong></p>
<p><code>&#123;?&lt;=\$)[0-9.]+</code></p>
<p><strong>结果</strong></p>
<pre>
  ABC01: $<b style="background: #f0f0f0;">23.45</b>
  HGG42: $<b style="background: #f0f0f0;">5.31</b>
  CFMX1: $<b style="background: #f0f0f0;">899.00</b>
  XTC99: $<b style="background: #f0f0f0;">69.96</b>
  Total items found: 4  
</pre>
<p><code>(?&lt;=\$)</code> 只匹配 $，但不消费它：最终的匹配结果里只有价格数字（没有前缀的 $ 字符）。</p>
<blockquote>
<p>向前查找 X 模式的长度是可变的，可以包含 . 或 + 之类的元字符。</p>
<p>向后查找模式只能是固定长度，所有正则实现都遵守该限制。</p>
</blockquote>
<h2 id="结合前后查找">结合前后查找</h2>
<p>向前查找和向后查找可以组合在一起使用。</p>
<p>例如我们想获取 title 标签内的内容：</p>
<p><strong>文本</strong></p>
<pre>
  &lt;HEAD&gt;
  	&lt;TITLE&gt;Ben Forta's Homepage&lt;/TITLE&gt;
  &lt;/HEAD&gt;
</pre>
<p><strong>正则</strong></p>
<p><code>(?&lt;=\&lt;[tT][iI][tT][lL][eE]&gt;).*(?=\&lt;\/[tT][iI][tT][lL][eE]&gt;)</code></p>
<p><strong>结果</strong></p>
<pre>
  &lt;HEAD&gt;
  	&lt;TITLE&gt;<b style="background: #f0f0f0;">Ben Forta's Homepage</b>&lt;/TITLE&gt;
  &lt;/HEAD&gt;
</pre>
<h2 id="对前后查找取非">对前后查找取非</h2>
<p>向前查找和向后查找通常用来匹配文本，其目的是为了确定将被返回为匹配结果的文本的位置（通过指定匹配结果的前后必须是哪些文本）。 这种用法被称为正向前查找（positive lookahead）和正向后查找（positive lookbehind） 。术语“正”指的是寻找匹配的事实。</p>
<p>前后查找还有一种不太常见的用法叫作负前后查找（negative lookaround）。负向前查找（negative lookahead）将向前查找不与给定模式相匹配的文本，负向后查找（negative lookbehind）将向后查找不与给定模式相匹配的文本。</p>
<p>前后查找必须用 ! 来取非（它将替换掉 = ）。下表列出了所有的前后查找操作符。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(?=)</code></td>
<td>正向前查找</td>
</tr>
<tr>
<td><code>(?!)</code></td>
<td>负向前查找</td>
</tr>
<tr>
<td><code>(?&lt;=)</code></td>
<td>正向后查找</td>
</tr>
<tr>
<td><code>(?&lt;!)</code></td>
<td>负向后查找</td>
</tr>
</tbody>
</table>
<p>为了掩饰正向后查找和负向后查找的区别，我们来看一个例子，下面是一段既包含价格又包含数量的文本，我们先来查找且只查找价格：</p>
<p><strong>文本</strong></p>
<pre>
  I paid $30 for 100 apples, 
  50 oranges, and 60 pears. 
  I saved $5 on this order.
</pre>
<p><strong>正则</strong></p>
<p><code>(?&lt;=\$)\d+</code></p>
<p><strong>结果</strong></p>
<pre>
  I paid $<b style="background: #f0f0f0;">30</b> for 100 apples, 
  50 oranges, and 60 pears. 
  I saved $<b style="background: #f0f0f0;">5</b> on this order.
</pre>
<p>接下来，我们再去查找且只查找数量：</p>
<p><strong>正则</strong></p>
<p><code>\b(?&lt;!\$)\d+\b</code></p>
<p><strong>结果</strong></p>
<pre>
  I paid $30 for <b style="background: #f0f0f0;">100</b> apples, 
  <b style="background: #f0f0f0;">50</b> oranges, and <b style="background: #f0f0f0;">60</b> pears. 
  I saved $5 on this order.
</pre>
<p><strong>分析</strong></p>
<p><code>\d+</code> 还是匹配数值，但这次只匹配数量，不匹配价格。表达式 <code>(?&lt;!\$)</code> 是一个负向后查找，它使得最终的匹配结果只包含那些不以 $ 开头的数值。把操作符 <code>?&lt;=</code> 改为操作符 <code>?&lt;!</code> 使得整个模式从一个正向后查找变成了一个负向后查找 。</p>
<h2 id="使用前后查找拆分字符串">使用前后查找拆分字符串</h2>
<p>正则有时也被用做字符串的拆分中，通过匹配分隔符的正则，将字符串一分为二拆分为自子串。但有时候我们想保留匹配的分隔符，则可以利用前后查找的零宽度只标记位置的特性来拆分字符串。</p>
<p>例如我们想把一段表达式根据逻辑运算符拆分开来，并保留逻辑运算符：</p>
<p><strong>文本</strong></p>
<pre>
  age > 18 and gender == male or age < 18 && gender == female
</pre>
<p><strong>正则</strong></p>
<p><code>(?&lt;=\s(and|or|&amp;&amp;|\|\|)\s)｜(?=\s(and|or|&amp;&amp;|\|\|)\s)</code></p>
<p><strong>结果</strong></p>
<pre>
  age > 18
   and 
  gender == male
   or 
  age < 18
   && 
  gender == female
</pre>
<h1>嵌入条件</h1>
<p>正则表达式语言还有一种威力强大（但不经常被用到）的功能在表达式的内部嵌入条件处理功能。</p>
<blockquote>
<p>Java 的 Pattern 不支持该带条件的表达式</p>
</blockquote>
<p>嵌入条件语法也使用了 <code>?</code> ，这并没有什么让人感到吃惊的地方，因为嵌入条件不外乎以下两种情况。</p>
<ul>
<li>根据一个回溯引用来进行条件处理。</li>
<li>根据一个前后查找来进行条件处理。</li>
</ul>
<h2 id="回溯引用条件">回溯引用条件</h2>
<p>回溯引用条件只在一个前面的子表达式搜索取得成功的情况下才允许使用一个表达式。</p>
<p>用来定义这种条件的语法是 <code>(?(backreference)true-regex)</code> ，其中 <code>?</code> 表明这是一个条件，括号里的 backreference 是一个回溯引用，true-regex 是一个只在 backreference 存在时才会被执行的子表达式。</p>
<p>听起来很费解，我们还是用一个例子来说明好了：你需要把一段文本里的 <code>&lt;IMG&gt;</code> 标签全都找出来；不仅如此，如果某个 <code>&lt;IMG&gt;</code> 标签是一个链接（被括在 <code>&lt;A&gt;</code> 和 <code>&lt;/A&gt;</code>  标签之间）的话，你还要把整个链接标签匹配出来。</p>
<p><strong>文本</strong></p>
<pre>
&lt;!-- Nav bar --&gt;
&lt;TD&gt;
&lt;A HREF="/home"&gt;&lt;IMG SRC="/images/home.gif"&gt;&lt;/A&gt;
&lt;IMG SRC="/images/spacer.gif">
&lt;A HREF="/search"&gt;&lt;IMG SRC="/images/search.gif"&gt;&lt;/A&gt;
&lt;IMG SRC="/images/spacer.gif">
&lt;A HREF="/help"&gt;&lt;IMG SRC="/images/help.gif"&gt;&lt;/A&gt;
&lt;/TD&gt;
</pre>
<p><strong>正则</strong></p>
<p><code>(&lt;[Aa]\s+[^&gt;]+&gt;\s*)?&lt;[Ii][Mm][Gg]\s+[^&gt;]+&gt;(?(1)\s*&lt;/[Aa]&gt;)</code></p>
<p><strong>结果</strong></p>
<pre>
&lt;!-- Nav bar --&gt;
&lt;TD&gt;
<b style="background: #f0f0f0;">&lt;A HREF="/home"&gt;&lt;IMG SRC="/images/home.gif"&gt;&lt;/A&gt;</b>
<b style="background: #f0f0f0;">&lt;IMG SRC="/images/spacer.gif"></b>
<b style="background: #f0f0f0;">&lt;A HREF="/search"&gt;&lt;IMG SRC="/images/search.gif"&gt;&lt;/A&gt;</b>
<b style="background: #f0f0f0;">&lt;IMG SRC="/images/spacer.gif"></b>
<b style="background: #f0f0f0;">&lt;A HREF="/help"&gt;&lt;IMG SRC="/images/help.gif"&gt;&lt;/A&gt;</b>
&lt;/TD&gt;
</pre>
<p><strong>分析</strong></p>
<p><code>(?(1)\s*&lt;/[Aa]&gt;)</code> 是一个回溯引用条件，?(1) 的含义是：如果第一个回溯引用（具体到本例，就是 <code>&lt;A&gt;</code> 标签）存在，则使用 <code>\s*&lt;/[Aa]&gt;</code> 继续进行匹配（换句话说，只有当前面的 <code>&lt;A&gt;</code> 标签匹配成功，才继续进行后面的匹配）。如果 (1) 存在，<code>\s*&lt;/[Aa]&gt;</code> 将匹配结束标签 <code>&lt;/A&gt;</code> 之后出现的任意空白字符。</p>
<p>条件还可以有否则表达式，否则表达式只在给定的回溯引用不存在（也就是条件没有得到满足）时才会被执行。用来定义这种条件的语法是 <code>(?(backre­ference)true-regex|false-regex)</code> 这个语法接受一个条件和两个将分别在这个条件得到满足和没有得到满足时执行的子表达式。</p>
<h2 id="前后查找条件">前后查找条件</h2>
<p>前后查找条件只在一个向前查找或向后查找操作取得成功的情况下才允许一个表达式被使用。定义一个前后查找条件的语法与定义一个回溯引用条件的语法大同小异，只需把回溯引用（括号里的回溯引用编号）替换为一个完整的前后查找表达式就行了。</p>
<p>作为一个例子，请你思考一下怎样匹配美国的邮政编码（简称 ZIP 编码）。美国邮政编码有两种格式，一种是 12345 形式的 ZIP 格式，另一种是 12345-6789 形式的 ZIP+4 格式。只有 ZIP+4 格式才必须使用连字符来分隔前 5 位和后 4 位数字。</p>
<p><strong>文本</strong></p>
<pre>
  11111 
  22222 
  33333-
  44444-4444
</pre>
<p><strong>正则</strong></p>
<p><code>\d&#123;5&#125;(?(?=-)-\d&#123;4&#125;)</code></p>
<p><strong>结果</strong></p>
<pre>
  <b style="background: #f0f0f0;">11111</b>
  <b style="background: #f0f0f0;">22222</b>
  33333- 
  <b style="background: #f0f0f0;">44444-4444</b>
</pre>
<p><strong>分析</strong></p>
<p>\d{5} 匹配前 5 位数字。接下来是一个 <code>(?(?=-)-\d&#123;4&#125;)</code> 形式的向前查找条件。这个条件使用了 <code>?=-</code> 来匹配（但不消费）一个连字符，如果条件得到满足（那个连字符存在），<code>-\d&#123;4&#125;</code> 将匹配那个连字符和随后的 4 位数。</p>
]]></content>
      <categories>
        <category>Regex</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型与网络协议入门</title>
    <url>/network/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>了解网络模型的目的</h1>
<p>在网络初期，大多数系统都使用专有软件和协议，这些软件和协议仅允许与同一制造商或可以访问这些协议的制造商的其他设备进行通信。 当时，这已不是什么大问题，因为组织会一直从同一制造商那里购买设备，并且没有在组织外部进行通信的真正方法。 但是，随着时间的流逝，这种情况已经改变，现在需要与其他组织拥有的系统进行通信。</p>
<p>其他组织不太可能拥有同一制造商的设备，因此这些设备无法相互通信。 为了解决这个问题，有人要求创建一个标准模型，并公开提供给所有人使用。 成为标准的两个模型如下：</p>
<ul>
<li><strong>国际标准化组织（ISO）的开放系统互连（OSI）模型</strong></li>
<li><strong>TCP / IP 模型</strong></li>
</ul>
<span id="more"></span>
<h1>OSI 模型</h1>
<p>OSI 模型是一个包括七个单独层的网络模型，如下图所示。 这些层中的每一层都与与其相邻的层以及接收设备上的等效层进行通信：</p>
<p><img data-src="../../images/network/osi.png" alt="OSI 模型"></p>
<p>顶部三层（应用，表示和会话）称为上层。 底层的四层（传输，网络，数据链路，物理）称为低层。</p>
<p>数据通过发送设备上的 OSI 模型时，将经历一个称为封装的过程。 封装只是从上一层获取数据，向其添加标头（有时是尾部），然后将其传递到重复该过程的下一层。 头层（和尾部）和向下传递到下一层的数据被始发层称为协议数据单元； 在接收层上，它被称为服务数据单元。 下图显示了处理过程中的封装，并在右侧列出了数据单元名称。</p>
<p><img data-src="../../images/network/osi-encapsulation.jpg" alt="OSI Encapusulation"></p>
<h2 id="第-7-层-应用层">第 7 层 应用层</h2>
<p>需要提及的一点，应用程序不驻留在 OSI 模型的应用程序层上。 实际上，它们位于 OSI 模型之上。 应用层充当应用程序和网络模型之间的接口。 任何支持网络通信的应用程序都将使用网络应用程序编程接口（API）进行开发。 该 API 包含告诉应用程序如何与应用层通信的代码。</p>
<p>应用程序将支持许多应用层协议，而不是应用程序位于应用层。 其中一些常用协议包括以下内容：</p>
<ul>
<li>
<p>简单邮件传输协议（SMTP）</p>
</li>
<li>
<p>邮局协议（POP）</p>
</li>
<li>
<p>Internet 邮件访问协议（IMAP）</p>
</li>
<li>
<p>超文本传输协议（HTTP）</p>
</li>
<li>
<p>域名系统（DNS）</p>
</li>
<li>
<p>安全外壳（SSH）</p>
</li>
<li>
<p>文本传输协议（FTP）</p>
</li>
</ul>
<h2 id="第-6-层-表示层">第 6 层 表示层</h2>
<p>表示层从应用程序层获取传递给它的数据，并将其转换为通用格式或语法。一些正在转换的数据将非常复杂，必须将其转换为平面文件，以准备流式传输到接收者。 该序列化的数据流被接收方的设备接收并反序列化并重建为其原始格式。进行此转换的原因是不同系统或应用程序的本机格式可能会有所不同。 通过将数据转换为通用格式，任何接收到数据的设备都可以理解它，并且可以扩展为接收应用程序可以理解的格式。</p>
<p>除了转换数据之外，表示层还提供数据压缩和加密/解密。 该层上使用的一些通用标准包括：</p>
<ul>
<li>JPEG</li>
<li>ASCII</li>
<li>TIFF</li>
<li>GIF</li>
</ul>
<h2 id="第-5-层-会话层">第 5 层 会话层</h2>
<p>会话层负责管理设备之间的会话。 会话管理包括建立会话，同步设备之间的通信以及终止会话。</p>
<p>设备在这一层上使将要进行的通信类型达成一致，包括以下内容：</p>
<ul>
<li>单工 Simplex</li>
<li>半双工 Half-duplex</li>
<li>全双工 Full-duplex</li>
</ul>
<p>该层支持的协议包括以下内容：</p>
<ul>
<li>RPC</li>
<li>SQL</li>
<li>NetBIOS</li>
<li>Point-to-Point Tunneling Protocol (PPTP)</li>
</ul>
<h2 id="第-4-层-传输层">第 4 层 传输层</h2>
<p>传输层负责主机到主机的通信并在两个设备之间创建逻辑连接。 它包括启动设备之间的连接，设备之间的流控制，相同顺序的传递以及多重通信。</p>
<p>传输层上的两个主要协议如下：</p>
<ul>
<li>传输控制协议 Transmission Control Protocol (TCP)</li>
<li>用户数据报协议 User Datagram Protocol (UDP)</li>
</ul>
<p>这两个协议有一些共同点：</p>
<p>首先，两个协议都包含一个校验和。 此校验和是错误检测的一种方式。 当处理数据以进行发送时，发送设备将执行计算，该计算会基于正在发送的数据生成一个值。 接收设备执行相同的计算。 如果值匹配，则数据正确。</p>
<p>他们的另一个共同特点是能够进行多路通信。 这只是一台机器可以与另一台机器同时进行多个对话的一种复杂的说法。</p>
<p>另一个通用特性是使用逻辑端口号。</p>
<h3 id="逻辑端口">逻辑端口</h3>
<p>在我们谈论交换机和路由器的端口时，我们讨论的是物理端口。</p>
<p>逻辑端口是软件中定义的端口。 逻辑端口的目的是允许接收设备识别数据要发送给哪个应用程序或服务。</p>
<p>TCP 和 UDP 标头均包含源端口号和目标端口号。当接收方设备接收到数据时，将检查目标端口号，然后设备会将数据传递给相关的应用程序或服务。</p>
<p>有 65,536 个逻辑端口号可用（编号为 0-65,535）。这些号码由**互联网号码分配局（IANA）**分配，并细分为多个范围：</p>
<ul>
<li>知名端口（0 - 1,023）：这些是分配给常用网络服务的端口</li>
<li>注册端口（1,024 - 49,151）：这些端口号是应开发人员的要求由 IANA 分配给应用程序或服务的</li>
<li>动态或临时端口（49,152 - 65,535）：这些端口不是 IANA 分配的，通常由客户端计算机用作源端口</li>
</ul>
<p>下表提供了一些常见端口及其端口号的详细信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">端口号</th>
<th style="text-align:left">服务/协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">FTP</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">SSH</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">Telnet</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left">SMTP</td>
</tr>
<tr>
<td style="text-align:left">53</td>
<td style="text-align:left">DNS</td>
</tr>
<tr>
<td style="text-align:left">67, 68</td>
<td style="text-align:left">动态主机配置协议（DHCP）</td>
</tr>
<tr>
<td style="text-align:left">80</td>
<td style="text-align:left">HTTP</td>
</tr>
<tr>
<td style="text-align:left">88</td>
<td style="text-align:left">Kerberos</td>
</tr>
<tr>
<td style="text-align:left">110</td>
<td style="text-align:left">邮局协议 v3（POP3）</td>
</tr>
<tr>
<td style="text-align:left">123</td>
<td style="text-align:left">网络时间协议（NTP）</td>
</tr>
<tr>
<td style="text-align:left">137-139</td>
<td style="text-align:left">NetBIOS</td>
</tr>
<tr>
<td style="text-align:left">143</td>
<td style="text-align:left">IMAP</td>
</tr>
<tr>
<td style="text-align:left">161</td>
<td style="text-align:left">简单网络管理协议（SNMP）</td>
</tr>
<tr>
<td style="text-align:left">389</td>
<td style="text-align:left">轻型目录访问协议（LDAP）</td>
</tr>
<tr>
<td style="text-align:left">443</td>
<td style="text-align:left">安全超文本传输协议（HTTPS）</td>
</tr>
<tr>
<td style="text-align:left">3389</td>
<td style="text-align:left">远程桌面协议（RDP）</td>
</tr>
</tbody>
</table>
<p>活动 1：在此活动中，你将确定 PC 所打开的端口以及目标设备所连接的端口：</p>
<ol>
<li>打开命令行</li>
<li>运行 <code>netstat -a</code> 命令（-a 开关显示已连接的端口和侦听端口。由于 UDP 端口不建立连接，因此必须使用此开关查看它们。</li>
</ol>
<p>你应该会收到与以下屏幕截图类似的输出：</p>
<p><img data-src="../../images/network/netstat-a.jpg" alt="netstat-a"></p>
<p><code>“Local Address”</code> 列详细说明了您的 IP 地址并指出了已打开的本地端口。</p>
<ol start="3">
<li><code>“Foreign Address”</code> 列详细说明了主机是通过名称还是 IP 地址连接的，并告诉我们目标设备上的端口</li>
<li>请注意，端口以数字或如果是知名端口，则以服务名称的形式详细列出。</li>
</ol>
<h3 id="TCP">TCP</h3>
<p>TCP 被称为面向连接的协议。 这意味着在设备之间传输任何数据之前，需要先建立连接。 通过这样做，<strong>双方互相确定对方有能力接收和发送数据</strong>。 为了形成此连接，TCP 执行称为三向握手的过程，如下图所示。 过程如下：</p>
<ol>
<li><code>SYN</code>：发送设备将同步请求发送到目标计算机。 该同步包括序列号。 出于说明目的，假设序列号为 101。</li>
<li><code>SYN / ACK</code>：接收设备对 SYN 请求的确认进行响应。 该确认基本上是对接收者接下来期望的序列号的确认。 在这种情况下，它是 102。它还将自己的同步请求发送到始发设备。 在此示例中，我们将使用 201。 在此阶段，设备已同意用于通信的参数。</li>
<li><code>ACK</code>：始发设备确认来自接收者设备的同步请求。 同样，这是设备期望接收的下一个序列号。 在这个例子中，这个数字是 202。</li>
</ol>
<p><img data-src="../../images/network/three-way-handshake.jpg" alt="三次握手"></p>
<p>握手完成后，数据可以在两个设备之间流动。 <strong>TCP 通过使用序号和确认的过程来保证数据的传递。</strong> 传输的数据分为多个段，每个段都包含一个序列号。 这使收件人可以在收据上重建数据。 另外，它允许接收者识别是否已接收到所有数据。 接收到数据后，接收方设备会将确认发送回接收方。 这种确认基本上是一种告诉始发设备接收者接下来希望接收哪个序列号的方法。 收到确认后，始发设备将下一批数据发送过去。</p>
<p>作为同步过程的一部分，这两个设备将在回送确认之前就将发送多少段达成一致。 通过减少发送的确认数量，这有助于减少网络开销。 这是一个称为滑动窗口的过程，非常灵活。 举例来说，假设他们同意在发送确认作为响应之前可以发送三个段。 如果接收方设备未收到所有三个段，因此未发送确认，则发送设备将在一段时间后意识到尚未收到确认，并将重新发送数据。 如果多次发生，则两个设备将同意使用一个较小的窗口来尝试减少数据丢失和重新发送的要求。</p>
<p>TCP 还包括称为流控制的功能。 此过程旨在减少拥塞。 如果接收方设备在努力跟上接收到的数据量，则可以向发送方发送“未就绪”消息。 清除网卡上的缓冲区后，设备将发送“就绪”消息，并且通信将恢复。</p>
<p>当设备希望停止通信时，它们将遵循四次握手过程，如下图所示：</p>
<ol>
<li>计算机 A 不再需要向计算机 B 发送任何数据，因此它发送 FIN 数据包。</li>
<li>计算机 B 接收 FIN 请求并作为响应发送回 ACK。</li>
<li>一旦计算机 B 没有更多数据则发送自己的 FIN 数据包到计算机 A。</li>
<li>计算机 A 接收 FIN 请求并作为响应发送回 ACK。</li>
</ol>
<p>该过程主要目的为：<code>双方互相确定对方不再需要发送数据。</code></p>
<p><img data-src="../../images/network/four-way-handshake.jpg" alt="四次握手"></p>
<ol start="5">
<li>一旦完成四次握手，设备将关闭端口。</li>
</ol>
<p>通过使用序列号，流控制和确认，TCP 的使用可确保向目标的传递（当然，只要连接基础结构正常工作）。 但是，这种保证是有代价的。 TCP 报头在发送的每个段中增加了额外的 20-60 字节数据，而确认则增加了带宽消耗，这除了等待确认之外，还导致数据传输速度变慢。 因此，当必须完全传输数据（例如文件共享或数据库事务）时，将使用 TCP。</p>
<h3 id="UDP">UDP</h3>
<p>TCP 是面向连接的协议，而 UDP 是无连接协议。 这意味着在发送数据之前不会进行三次握手。 发送设备从字面上讲是通过有线方式发送数据，并希望目标设备能够接收到它。 它通常被称为尽力而为协议； 数据是否到达那里都没有关系，因为你有时候并不需要接收所有数据，可以容忍数据部分丢失。</p>
<p>这是一个更快的协议，因为它具有较小的标头（仅 8 个字节），并且没有添加到确认信息到带宽中。</p>
<p>UDP 也用于多播和广播传输。 在如此多的设备上发送数据之前，不可能进行三向握手。</p>
<p>在某些情况下，协议会同时使用 TCP 和 UDP，这取决于当时的功能。 DNS 和 DHCP 是这方面的两个完美示例。</p>
<p>总而言之，当数据传输至关重要且时间不受限制时，则应使用 TCP。 如果数据传输不重要和/或时间很紧迫，则应使用 UDP。</p>
<h2 id="第-3-层-网络层">第 3 层 网络层</h2>
<p>OSI 模型的网络层负责通过使用 IP 地址对设备进行逻辑寻址。 它还负责为要传输的数据选择路由，即如何从计算机 A 到计算机 B。</p>
<p>路由器[^ router]以及方便的第 3 层交换机[^ switches]在该层工作。</p>
<p>就网络层上的协议而言，最常见的如下：</p>
<ul>
<li>IP</li>
<li>互联网数据包交换（IPX）</li>
</ul>
<p>IP 是两者中最常见的，并且是所有网络的核心。 IPX 不在这里陈述，因为重点是 IP 寻址。 在此层，协议数据单元称为数据包，其标头将包括源和目标 IP 地址。</p>
<h2 id="第-2-层-数据链路层">第 2 层 数据链路层</h2>
<p>数据链路层仅在你自己的子网内相关，尽管在一定程度上确实如此，但我们仍然需要它来在子网外传输数据。 数据链路层在子网上的节点之间创建逻辑连接。 如果数据以同一子网中的设备为目的地，则链接将指向该设备； 如果数据以子网外的设备为目的地，则该链接将指向默认网关。 第 2 层上的协议数据单元是帧。</p>
<p>数据链接层的职责包括将数据放置到物理介质上，错误通知和流控制。 通过使用添加到数据的预告片中包括的校验和来执行错误通知。 除预告片外，还添加了标头，其中包括源和目标 MAC 地址。 第二层交换机[^ switches]在这里工作。</p>
<p>该层分为两个子层：</p>
<ul>
<li><strong>逻辑链路控制（LLC）</strong>：LLC 的任务是充当与网络层的接口，并标识所使用的网络层协议（例如 IP 或 IPX），并将该信息存储在帧头中。 发生这种情况是为了在另一端收到数据时，设备知道将其发送到哪个网络层协议。</li>
<li><strong>媒体访问控制（MAC）</strong>：MAC 子层负责控制如何将数据放置到某些媒体上，或者我们如何控制数据对媒体的访问。 MAC 子层可以被多种协议占用； 例如，802.3 和 802.11 驻留在此层上。</li>
</ul>
<h2 id="第-1-层-物理层">第 1 层 物理层</h2>
<p>数据以位的形式在该层上进行物理传输。 根据媒体类型和所使用的网卡，发送数据的方法会有所不同。 重要的是，两端都使用相同的方法。 这些信号可以采用电压变化的形式，也可以采用透射光的模式。</p>
<p>在这一层上，没有协议，但是电缆和网卡需要遵守一些标准和准则。 这些标准包括以下内容：</p>
<ul>
<li>电压等级 Voltages</li>
<li>速度 Speeds</li>
<li>布线 Wiring</li>
</ul>
<h1>TCP / IP 模型</h1>
<p>在学习 TCP / IP 模型时，你会注意到该模型与 OSI 模型有很多相似之处。 它们都采用分层方法，每一层与目标设备上的相邻层以及它们各自的层通信。 像 OSI 模型一样，TCP / IP 模型是开放或非专有的标准，这意味着任何制造商都可以使用它。</p>
<p><img data-src="../../images/network/tcp-ip.png" alt="Tcp/Ip"></p>
<p>如上图所示，与 OSI 模型的七个层相比，TCP / IP 模型只有四个层。 这些层如下：</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ul>
<blockquote>
<p>作为一般经验法则，如果它们是按编号引用的层，例如，第1层，第2层等，而不是第一层，第二层等，则它们通常是指 OSI 模型。 TCP / IP 模型倾向于依靠单词而不是数字。</p>
</blockquote>
<p>封装和解封装也在 TCP / IP 模型中起作用。 随着数据在模型中上下移动，标头和尾部将添加到数据中。 TCP / IP模型有时称为 Internet 协议（IP）套件，因为它是用于跨 Internet 通信的协议的集合。 这些协议一起形成协议栈。 协议栈是协议的集合，这些协议一起工作以执行特定的总体功能。</p>
<h2 id="应用层">应用层</h2>
<p>类似于 OSI 模型中的名称，TCP / IP 模型的应用层充当应用程序自身和网络堆栈之间的接口，而不是应用程序实际所在的位置。 同样，这是通过使用 API 和编程库实现的。 该层执行 OSI 模型中应用层和表示层的功能，包括数据的格式化，压缩和加密。</p>
<p>在应用层上有许多协议正在使用，这些协议可以分为两个区域：</p>
<ul>
<li>用户协议 User protocols</li>
<li>支撑协议 Support protocols</li>
</ul>
<h3 id="用户协议">用户协议</h3>
<p>用户协议通常可以定义为用户与之交互的应用程序所使用的协议。 让我们看一些常见的用户协议：</p>
<h4 id="Telnet">Telnet</h4>
<p>Telnet 是一种从 CLI 远程控制设备的方法，Telnet 在端口 <code>23</code> 上工作，并提供了基于文本的低带宽与其他设备进行通信的方式。 为了使 telne t正常工作，您需要在要向其发送命令的设备上运行 telnet 服务器，并且您必须自己运行 telnet 客户端。</p>
<p>我将告诉您不要使用它，除非作为最后的手段或建立更安全的连接（如 SSH）的手段。 Telnet 开箱即用，而 SSH 需要配置。 您可能想知道为什么我会这样说。 这很简单。 Telnet 以明文形式发送所有数据，包括您的用户名和密码。 因此，攻击者可以窃听此信息。默认情况下，大多数网络设备（例如路由器和交换机）都启用了 Telnet。 尽快将其禁用。</p>
<h4 id="FTP">FTP</h4>
<p>FTP 的作用恰如其名（超文本传输）。 它使您可以使用端口 <code>20</code> 和 <code>21</code> 将文件从一台设备传输到另一台设备。不要将这种协议误认为是组织的网络共享系统，因为后者更可能是服务器消息块（SMB）。</p>
<p>要使用 FTP，我们需要在服务器上安装一个 FTP 服务器应用程序来托管我们要访问的文件，并且我们必须自己运行 FTP 客户端。 FTP 运行在 TCP 上，您可能还记得，它保证了数据的正确传递。</p>
<h4 id="简单邮件传输协议">简单邮件传输协议</h4>
<p>简单邮件传输协议（SMTP）通常提供两种功能。 它允许您从电子邮件客户端（例如 Outlook）向电子邮件服务器发送电子邮件。 它还允许您的电子邮件服务器将邮件从您的电子邮件服务器传输到另一个电子邮件服务器。 这两个功能都是通过端口 <code>25</code> 执行的。</p>
<h3 id="支撑服务">支撑服务</h3>
<p>支撑协议可以定义为系统本身使用的协议。</p>
<h4 id="主机初始化">主机初始化</h4>
<p>他提供了一种在没有安装自己的操作系统的情况下通过网络引导计算机的方法。 通过网络引导需要计算机具有支持**预引导执行环境（PXE）**的网卡。 尽管可能必须在系统的 BIOS 中启用它，但大多数现代系统都支持此功能。</p>
<h4 id="远程管理">远程管理</h4>
<p>此服务允许通过使用协议（例如在端口 <code>161</code> 上运行的<strong>简单网络管理协议（SNMP</strong>））来管理设备。SNMP 需要主机上的 SNMP 代理，该代理再与 SNMP 服务器通信。 这些通信包括属性及其值，例如可用磁盘空间，CPU 使用率等。 但是，这不是单向过程，服务器也可以将设置传达回设备以进行远程配置。</p>
<h4 id="域名系统">域名系统</h4>
<p>**域名系统（DNS）<strong>在这里它被归类为支撑服务，并将</strong>完全限定的域名（FQDN）**解析为 IP 地址。 一旦应用层履行了其职责，它将数据传递给传输层。</p>
<h2 id="传输层">传输层</h2>
<p>TCP / IP 模型的传输层执行与 OSI 模型中的对应层完全相同的角色。 即，它负责控制两个主机之间的通信。 回想一下，传输层提供了以下功能：</p>
<ul>
<li>使用校验和来确保数据完整性</li>
<li>使用序列号确保数据以正确的顺序重建</li>
<li>流量控制以确保所接收的数据不会最终堵塞收件人设备</li>
<li>多路复用以允许主机与另一个主机建立多个连接</li>
</ul>
<h2 id="网际层">网际层</h2>
<p>网际层映射到 OSI 的网络层。尽管名称不同，但这两个层执行相同的功能。它们都通过使用 IP 地址来提供逻辑寻址。 通过使用 IP 地址（和子网掩码），我们可以确定主机是发送设备的本地主机还是远程网络。 如果目标位于远程网络上，则在通过路由器，路由服务器或第 3 层交换机进行路径选择和数据转发过程中，还将使用 IP 地址。请注意，尽管 TCP / IP 模型未使用编号，但在这里我还是使用术语第3层，这纯粹是出于熟悉。</p>
<p>该层上的三个主要协议如下：</p>
<ul>
<li>IP</li>
<li>Internet 控制报文协议（ICMP）</li>
<li>Internet 组管理协议  (IGMP)</li>
</ul>
<p>设备使用 ICMP 相互发送错误和控制消息。这些消息可以指出，主机不可访问，主机可访问但主机上的端口不可访问，网络不可访问等等。 这些控制消息是通过使用类型和子类型在 ICMP 数据中标识的。<code>ping</code> 和 <code>tracert</code> 命令使用了 ICMP。</p>
<p>IGMP 用于创建设备的逻辑组。这些逻辑组将在多播传输期间和 IPv4 中使用。</p>
<h2 id="网络接口层">网络接口层</h2>
<p>TCP / IP 模型的网络层映射到 OSI 模型的数据链路层和物理层。因此，它将这两个 OSI 层的功能合并到这一 TCP / IP 层中。</p>
<p>网际层主要负责主机网络外部的通信并路由此数据，而网络接口层则负责链路（基本上是同一子网内的任何事物）上的通信。因此，有时将网络接口层称为链路层。媒体访问控制是在 TCP / IP 模型的网络接口层上执行的，因此可以在此处找到 MAC 地址。此外，物理介质的属性（例如调制和编码）也在此处。 网络接口层中有许多协议和标准。 其中包括 IEEE 802.3 以太网，IEEE 802.11，点对点协议（PPP），地址解析协议（ARP）和帧中继。</p>
<hr>
<p>[^ router]: 在这个相互连接和全球通信的时代，我们必须开始研究网络之间的通信，而不仅仅是同一个子网中的设备之间的通信。 这种通信的一个关键组成部分是路由器。 这种无处不在的网络设备允许网络之间进行有效的通信，无论这些网络是我们组织内部的网络还是世界另一端的远程网络。<br>
[^ switches]: 交换机是一种用于在本地网络中将流量从一台设备转发到另一台设备的设备。 通过将交换机引入我们的网络，我们提供了一种将网络划分为更小，更易于管理和更高效的区域的方法。第 2 层交换机仅支持使用基于 MAC 地址的转发数据，而第 3 层交换机在能够识别接口的 IP 地址方面也提供了额外的支持，并且还提供了使用 IP 地址进行流量路由的功能。 在 VLAN 之间路由流量时，这是必不可少的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>OSI</tag>
        <tag>TCP/IP</tag>
        <tag>HTTP</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC 与进程间通信</title>
    <url>/network/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8EgRPC/</url>
    <content><![CDATA[<p>随着时间的流逝，进程间通信技术已经发生了巨大的发展。出现了各种这样的技术来满足现代需求并提供更好和更有效的开发体验。让我们看一些最常用的进程间通信技术，并与 gprc 做个比较。</p>
<h2 id="常规-RPC">常规 RPC</h2>
<p>RPC 是用于构建客户服务应用程序的流行的进程间通信技术。使用 RPC，客户端可以远程调用方法，就像调用本地方法一样。早期有流行的 RPC 实现，例如通用对象请求代理体系结构（CORBA）和 Java 远程方法调用（RMI），它们用于构建和连接服务或应用程序。但是，大多数此类常规 RPC 实现极其复杂，因为它们建立在诸如 TCP 之类的通信协议之上，这阻碍了不同程序间的交互，而且各自的规范很臃肿。</p>
<p>RPC（Remote Procedure Call）—远程过程调用，是指计算机程序使过程（子程序）在不同的地址空间（通常在共享网络的另一台计算机上）执行时，其编码就像是普通的（本地）过程调用，无需程序员为远程交互明确编码细节。</p>
<span id="more"></span>
<p>RPC 是进程间通信（IPC）的一种形式，因为不同的进程具有不同的地址空间：如果在同一主机上，即使物理地址空间相同，它们也具有不同的虚拟地址空间（Java 虚拟机）；如果它们位于不同的主机上，则物理地址空间是不同的。为了让不同的客户端访问服务器，已经创建了许多标准化的 RPC 系统。其中大多数使用接口描述语言（IDL）来让各种平台调用 RPC。可以使用 IDL 文件生成代码以在客户端和服务器之间建立接口。</p>
<p>在面向对象的编程范例中，RPC 调用由远程方法调用（RMI）表示。</p>
<p>该协议介于 OSI 网络模型的应用层和传输层，这里就要说下 RPC 协议主要内容。</p>
<p>实现 RPC 主要分为 5 个部分：</p>
<ol>
<li>User</li>
<li>User-stub</li>
<li>RPCRuntime</li>
<li>Server-stub</li>
<li>Server</li>
</ol>
<p><img data-src="../../images/network/rpc-structure.png" alt="RPC结构">这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。</p>
<p>网络层传输并没有明确的规定，所以就有基于 HTTP/2 的 gRPC，但是大多数还是直接使用 TCP 协议直接传输的。传输的内容格式也没有明确规定，JSON/XML/套接字都有可能。</p>
<h2 id="SOAP">SOAP</h2>
<p>由于诸如 CORBA 之类的常规 RPC 实现的局限性，微软，IBM 等大型企业设计并大力推广了简单对象访问协议（SOAP）。SOAP 是面向服务的体系结构中的标准通信技术（SOA）以在服务（在 SOA 上下文中通常称为 Web 服务）之间交换基于 XML 的结构化数据，并通过任何基础通信协议（例如 HTTP（最常用））进行通信。使用 SOAP，您可以定义服务接口，该服务的操作以及用于调用这些操作的关联 XML 消息格式。 SOAP 是一种非常流行的技术，但是消息格式的复杂性以及围绕 SOAP 构建的规范的复杂性阻碍了构建分布式应用程序的敏捷性。 因此，在现代分布式应用程序开发的上下文中，SOAP Web 服务被认为是一种遗留技术。 现在，大多数现有的分布式应用程序都在使用 REST 体系结构样式来开发，而不是使用 SOAP。</p>
<h2 id="REST">REST</h2>
<p>表现层状态转化（REST）是一种架构风格， REST 是面向资源的体系结构（ROA）的基础，您可以在其中将分布式应用程序建模为资源的集合，访问这些资源的客户端可以更改这些资源的状态（创建，读取，更新或删除）。</p>
<p>REST 的实际实现是 HTTP，在 HTTP 中，您可以将 RESTful Web 应用建模为使用唯一标识符（URL）可访问的资源的集合。 状态更改操作以 HTTP 谓词（GET，POST，PUT，DELETE，PATCH 等）的形式应用于这些资源之上。 资源状态以文本格式表示，例如 JSON，XML，HTML，YAML 等。</p>
<p>使用具有 HTTP 和 JSON 的 REST 架构风格构建应用程序已成为构建微服务的实际方法。 但是，随着微服务及其网络交互的数量激增，RESTful 服务无法满足预期的现代要求。 RESTful 服务有几个关键限制，这些限制限制了将它们用作基于现代微服务的应用程序的消息传递协议的能力。</p>
<h3 id="低效的基于文本的消息协议">低效的基于文本的消息协议</h3>
<p>RESTful 服务本质上是建立在基于文本的传输协议（例如 HTTP 1.x）的基础之上的，并利用了人类可读的文本格式（例如 JSON）。 当涉及到服务之间的通信时，使用文本格式（例如 JSON）效率很低，因为该通信的双方都不需要使用这种人类可读的文本格式。</p>
<p>客户端应用程序（源）生成要发送到服务器的二进制内容，然后将二进制结构转换为文本（因为使用 HTTP 1.x，您必须发送文本消息）并通过网络以文本形式（通过 HTTP）发送它到一台机器，该机器在服务（目标）端解析并将其转换为二进制结构。 相反，我们可以轻松地发送二进制格式，该格式可以映射到服务和消费者的业务逻辑。 使用 JSON 的一种流行说法是，它易于使用，因为它是“人类可读的”。 这不是二进制协议的问题，而是更多的工具问题。</p>
<h3 id="应用之间缺乏强类型接口">应用之间缺乏强类型接口</h3>
<p>随着使用完全不同的多语言技术构建的通过网络进行交互的服务的数量不断增加，缺乏明确定义和强类型化的服务定义是一个主要的挫折。 我们在 RESTful 服务中拥有的大多数现有服务定义技术（例如 OpenAPI / Swagger）都是经过深思熟虑的，并未与基础架构样式或消息传递协议紧密集成。</p>
<p>在构建此类分散式应用程序时，这会导致许多不兼容性，运行时错误和互操作性问题。 例如，当您开发 RESTful 服务时，不需要具有在应用程序之间共享的信息的服务定义和类型定义。 相反，您可以在网上查看文本格式或第三方 API 定义技术（例如 OpenAPI）来开发 RESTful 应用程序。 因此，具有现代强类型服务定义技术和为多语言技术生成服务器端和客户端代码核心的框架是关键必要条件。</p>
<h3 id="REST-架构风格难以实施">REST 架构风格难以实施</h3>
<p>作为一种体系结构样式，REST 具有很多“良好实践”，您需要遵循这些“良好实践”才能提供真正的 RESTful 服务。 但是，它们不是作为实施协议（例如 HTTP）的一部分实施的，这使得在实施阶段很难实施它们。 因此，在实践中，大多数声称为 RESTful 的服务并未正确遵循 REST 风格的基础。 因此，大多数所谓的 RESTful 服务仅仅是通过网络公开的 HTTP 服务。 因此，开发团队必须花费大量时间来维护 RESTful 服务的一致性和纯度。</p>
<p>由于进程间通信技术在构建现代云本机应用程序中存在所有这些局限性，因此开始寻求发明更好的消息协议。</p>
<h2 id="gRPC-的诞生">gRPC 的诞生</h2>
<p>Google 一直在使用一种称为 Stubby 的通用 RPC 框架来连接成千上万的微服务，这些微服务跨多个数据中心运行并使用不同的技术构建，它的核心 RPC 层旨在处理每秒数百亿个请求的互联网规模。 Stubby 具有许多出色的功能，但由于它与 Google 内部基础架构紧密相关，因此尚未标准化用作通用框架。</p>
<p>2015 年，Google 发布了 gRPC 作为开源 RPC 框架； 它是一个标准化的，通用的，跨平台的 RPC 基础结构。 gRPC 旨在提供与 Stubby 相同的可伸缩性，性能和功能，但可以为整个社区提供。</p>
<p>从那时起，随着 Netflix，Square，Lyft，Docker，Cisco 和 CoreOS 等主要公司的大规模采用，gRPC 的普及在过去几年中急剧增长。 后来，gRPC 加入了 Cloud Native Computing Foundation（CNCF），这是最受欢迎的开源软件基金会之一，致力于使云原生计算具有通用性和可持续性。 gRPC 从 CNCF 生态系统项目中获得了很大的吸引力。</p>
<h2 id="为什么选择-gRPC">为什么选择 gRPC</h2>
<p>gRPC 被设计为一种互联网规模的进程间通信技术，可以克服常规进程间通信技术的大多数缺点。由于 gRPC 的优势，大多数现代应用程序和服务器越来越多地将其进程间通信协议转换为 gRPC。那么，当有很多其他选项可用时，为什么有人会选择 gRPC 作为通信协议呢？ 让我们更仔细地看一下 gRPC 带来的一些关键优势</p>
<h2 id="gRPC-的优点">gRPC 的优点</h2>
<p>gRPC 带来的优势是 gRPC 越来越被采用的关键。 这些优点包括：</p>
<ul>
<li>高效的进程间通信</li>
</ul>
<p>gRPC 不使用 JSON 或 XML 之类的文本格式，而是使用基于协议缓冲区的二进制协议与 gRPC 服务和客户端进行通信。 同样，gRPC 在 HTTP / 2 之上实现协议缓冲区，这使得进程间通信的速度甚至更快。 这使 gRPC 成为最高效的进程间通信技术之一。</p>
<ul>
<li>它具有简单，定义明确的服务接口和架构</li>
</ul>
<p>gRPC 促进了合同优先的方法来开发应用程序。 您首先定义服务接口，然后再处理实现细节。 因此，与用于 RESTful 服务定义的 OpenAPI / Swagger 和用于 SOAP Web 服务的 WSDL 不同，gRPC 提供了简单但一致，可靠，可扩展的应用程序开发体验。</p>
<ul>
<li>它是强类型的</li>
</ul>
<p>由于我们使用协议缓冲区定义 gRPC 服务，因此 gRPC 服务协定明确定义了将用于应用程序之间通信的类型。 这使分布式应用程序开发更加稳定，因为静态类型有助于克服在构建跨多个团队和技术的云本机应用程序时遇到的大多数运行时和互操作性错误。</p>
<ul>
<li>多语言支持</li>
</ul>
<p>gRPC 旨在与多种编程语言一起使用。 带有协议缓冲区的 gRPC 服务定义与语言无关。 因此，您可以选择自己喜欢的语言，但可以与任何现有的 gRPC 服务或客户端进行互操作。</p>
<ul>
<li>它具有双工流</li>
</ul>
<p>gRPC 具有对客户端或服务器端流的本机支持，该支持包含在服务定义本身中。 这使开发流服务或流客户端变得更加容易。 与传统的 RESTful 消息传递样式相比，构建常规的请求-响应样式消息传递以及客户端和服务器端流传输的能力是一个关键优势。</p>
<ul>
<li>它具有内置产品功能</li>
</ul>
<p>gRPC 为产品提供内置支持，例如身份验证，加密，弹性（最后期限和超时），元数据交换，压缩，负载平衡，服务发现等。</p>
<ul>
<li>它与云原生生态系统集成</li>
</ul>
<p>gRPC 是 CNCF 的一部分，大多数现代框架和技术都提供了对 gRPC 的本地支持。 例如，CNCF 下的许多项目（例如 Envoy）都支持 gRPC 作为通信协议。 对于指标和监控等跨领域功能，大多数此类工具都支持 gRPC（例如，使用 Prometheus 监控 gRPC 应用程序。</p>
<ul>
<li>它已经成熟并被广泛采用</li>
</ul>
<p>gRPC 通过在 Google 上进行的艰苦的测试而变得成熟，许多其他大型科技公司（例如 Square，Lyft，Netflix，Docker，Cisco 和 CoreOS）都采用了 gRPC 。</p>
<p>与任何技术一样，gRPC 也具有某些缺点。 在应用程序开发期间了解这些缺点非常有用。 因此，让我们看一下 gRPC 的一些局限性。</p>
<h2 id="gRPC-的缺点">gRPC 的缺点</h2>
<p>在选择 gRPC 来构建应用程序时，需要注意一些 gRPC 的缺点。 这些包括以下内容：</p>
<ul>
<li>它可能不适合外部服务</li>
</ul>
<p>当您想通过 Internet 向外部客户端公开应用程序或服务时，gRPC 可能不是最合适的协议，因为大多数外部使用者都刚接触 gRPC 和 REST / HTTP。合同驱动的 gRPC 服务的强类型性质可能会阻碍您向外部各方公开服务的灵活性，并且消费者获得的控制权将大大降低。</p>
<ul>
<li>彻底的服务定义更改是一个复杂的开发过程</li>
</ul>
<p>模式（Schema）修改在现代服务间通信用例中非常普遍。 当 gRPC 服务定义发生重大变化时，通常我们需要为客户端和服务器重新生成代码。 这需要合并到现有的持续集成过程中，并且可能使整个开发生命周期复杂化。 但是，大多数 gRPC 服务定义更改都可以在不破坏服务合同的情况下得到满足，并且只要不引入重大更改，gRPC 就会使用不同版本的协议与客户端和服务器愉快地进行互操作。 因此在大多数情况下不需要代码重新生成。</p>
<ul>
<li>生态系统比较小</li>
</ul>
<p>与传统的 REST / HTTP 协议相比，gRPC 生态系统仍然相对较小。 浏览器和移动应用程序中对 gRPC 的支持仍处于原始阶段。</p>
<p>在开发应用程序时，您必须注意这些限制。 因此，显然，gRPC 不是您应该用于所有进程间通信需求的技术。 相反，您需要评估业务用例和需求并选择适当的消息传递协议。</p>
<h2 id="gRPC-与其他协议：GraphQL-和-Thrift">gRPC 与其他协议：GraphQL 和 Thrift</h2>
<p>我们已经详细讨论了 REST 的一些关键限制，这些限制为 gRPC 的诞生奠定了基础。 类似地，有许多新兴的进程间通信技术可以满足相同的需求。 因此，让我们看一些流行的技术，并将其与 gRPC 进行比较。</p>
<h3 id="Apache-Thrift">Apache Thrift</h3>
<p>Apache Thrift 是一个类似于 gRPC 的 RPC 框架（最初在 Facebook 开发，后来捐赠给 Apache）。 它使用自己的接口定义语言，并支持多种编程语言。 Thrift 允许您在定义文件中定义数据类型和服务接口。 通过将服务定义作为输入，Thrift 编译器为客户端和服务器端生成代码。 Thrift 传输层为网络 I / O 提供抽象，并将 Thrift 与系统的其余部分解耦，这意味着它可以在任何传输实现（例如 TCP，HTTP 等）上运行。</p>
<p>如果将 Thrift 与 gRPC 进行比较，您会发现两者都遵循相同的设计和使用目标。 但是，两者之间有几个重要的区别：</p>
<ul>
<li>协议</li>
</ul>
<p>gRPC 比 Thrift 更超前，提供对 HTTP / 2 的一流支持。 它在 HTTP / 2 上的实现利用该协议的功能来实现效率并支持诸如流的消息传递模式。</p>
<ul>
<li>流</li>
</ul>
<p>gRPC 服务定义本身支持双向流（客户端和服务器），这是服务定义本身的一部分。</p>
<ul>
<li>采用和社区</li>
</ul>
<p>在采用方面，gRPC 似乎发展势头良好，并且已成功围绕 CNCF 项目建立了良好的生态系统。 同样，社区资源，例如良好的文档，外部演示文稿和示例用例，对于 gRPC 来说是很常见的，与 Thrift 相比，采用过程更加流畅。</p>
<h3 id="GraphQL">GraphQL</h3>
<p>GraphQL 是另一种技术（由 Facebook 发明并标准化为一种开放技术），在构建进程间通信中变得非常流行。 它是 API 的查询语言，是用于使用现有数据完成这些查询的运行时。 GraphQL 通过允许客户端确定所需的数据，所需的数据以及所需的格式，为传统的客户端-服务器通信提供了根本不同的方法。 相反，gRPC 与支持客户机和服务器之间通信的远程方法具有固定的约定。</p>
<p>GraphQL 更适合直接暴露给消费者的外部服务或 API，在这些环境中，客户端需要对来自服务器的数据进行更多控制。 例如，在我们的在线零售应用程序场景中，假设 ProductInfo 服务的使用者仅需要有关产品的特定信息，而不需要产品的整个属性集，并且使用者还需要一种方法来指定他们想要的信息。 借助 GraphQL，您可以对服务进行建模，从而使消费者可以使用 GraphQL 查询语言来查询服务并获取所需的信息。</p>
<p>在大多数 GraphQL 和 gRPC 实用的用例中，GraphQL 被用于面向外部的服务/ API，而支持 API 的内部服务是使用 gRPC 实现的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>进程通信</tag>
        <tag>gRPC</tag>
        <tag>SOAP</tag>
        <tag>Thrift</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>类型安全的异构容器</title>
    <url>/pattern/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E6%9E%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>当在 JDK5 中为 Java 添加泛型时，<a target="_blank" rel="noopener" href="http://www.gafter.com/~neal/">Neal Gafter</a> 将类 <code>java.lang.Class</code> 更改为泛型类型。例如，<code>String.class</code> 的类型现在变为 <code>Class&lt;String&gt;</code>。 <a target="_blank" rel="noopener" href="http://bracha.org/Site/Home.html">Gilad Bracha</a> 为此创造了术语 <em><code>type token</code> - 类型令牌</em>。作者的意图是启用特定样式的 API，Joshua Bloch 称之为 <code>THC</code>，或 <code>Typesafe Heterogenous Container</code> - <strong>类型安全的异构容器</strong>模式，在 Effective Java 第 33 项中详细描述了该模式。</p>
<span id="more"></span>
<h2 id="THC">THC</h2>
<p>有关使用类型令牌的一些示例，请参阅注解的 API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; A java.lang.Class.getAnnotation(Class&lt;A&gt; annotationClass)</span><br></pre></td></tr></table></figure>
<p>下面是 Effective Java 中一个简单但完整的 API 示例，该示例使用了类型令牌实现了 <code>THC</code> 模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Favorites</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> &#123;</span><br><span class="line">        favorites.put(Objects.requireNonNull(type), type.cast(instance));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Favorites</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Favorites</span>();</span><br><span class="line">        f.putFavorite(String.class, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        f.putFavorite(Integer.class, <span class="number">0xcafebabe</span>);</span><br><span class="line">        f.putFavorite(Class.class, Favorites.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">favoriteString</span> <span class="operator">=</span> f.getFavorite(String.class);</span><br><span class="line">        <span class="type">int</span> <span class="variable">favoriteInteger</span> <span class="operator">=</span> f.getFavorite(Integer.class);</span><br><span class="line">        Class&lt;?&gt; favoriteClass = f.getFavorite(Class.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getFavorite 首先从 favorites Map 中获取与给定 Class 对象相对应的值。可以返回的正确对象引用，但它具有错误的编译时类型：它是 Object(favorites map 的值类型)，我们需要返回类型 T。因此，getFavorite 实现使用 Class 的 cast 方法动态地将对象引用转换为 Class 对象表示的类型。<br>
cast 方法是 Java 的 cast 操作符的动态模拟。它只是检查它的参数是否由 Class 对象表示的类型的实例。如果是，它返回参数；否则会抛出 ClassCastException 异常。我们知道，假设客户端代码能够干净地编译，getFavorite 中的强制转换不会抛出 ClassCastException 异常。也就是说，favorites map 中的值始终与其键的类型相匹配。<br>
那么这个 cast 方法为我们做了什么，因为它只是返回它的参数？cast 的签名充分利用了 Class 类是泛型的事实。它的返回类型是 Class 对象的类型参数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">cast</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这正是 getFavorite 方法所需要的。这正是确保 Favorites 类型安全，而不用求助一个未经检查的强制转换的 T 类型。</p>
<p><code>Favorites</code> 对象充当类型安全的 map 映射类型令牌到该类型的实例。这种模式的有趣之处在于，单个 <code>Favorites</code> 对象可用于保存多种（即异构）类型的事物，但是以类型安全的方式。当你想得到其中最喜欢的 String 时，它是 String 类型，而不必强制转换它，所以称之为类型安全的异构容器。</p>
<p>这种模式有一个限制。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.6">类型擦除</a>将导致下面的代码不可编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Favorites:<span class="number">15</span>: illegal start of expression</span><br><span class="line">f.putFavorite(List&lt;String&gt;.class, Collections.emptyList());</span><br><span class="line">                          ^</span><br></pre></td></tr></table></figure>
<p>因为 Java 会在编译期间擦除范型类型信息。因此，<strong>泛型类型参数只是源代码的产物，在运行时将不存在。</strong></p>
<p>如果我们需要支持范型类型或可具体化类型，我们需要一种该模式的扩展，超级类型令牌 - Super Type Tokens。</p>
<h2 id="可具体化类型">可具体化类型</h2>
<p>由于在编译期间会擦除某些类型信息，因此在运行时并非所有类型都可用。在运行时完全可用的类型称为<strong>可具体化的类型</strong> -  <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.7"><code>Reifiable Types</code></a>。</p>
<p>当且仅当以下条件之一成立时，类型才是可具体化的：</p>
<ul>
<li>
<p>它引用的是非泛型类或接口类型声明。</p>
</li>
<li>
<p>它是一种参数化类型，其中所有类型参数都是无界通配符，例如 <em><code>List&lt;?&gt;</code></em> 或 <em><code>HashMap&lt;?, ?&gt;</code></em></p>
</li>
<li>
<p>它是基本类型，例如 <em><code>long</code></em></p>
</li>
<li>
<p>它是原始类型，例如 <em><code>List</code></em> 或 <em><code>HashMap</code></em></p>
</li>
<li>
<p>它是一种数组类型，其元素类型是可具体化的，例如 <em><code>String[]</code>、<code>int[]</code>、<code>List[]</code></em> 或 <em><code>Map&lt;?, ?&gt;[]</code></em></p>
</li>
<li>
<p>它是一个嵌套类型，其中对于每个由“.”分隔的类型 T，T 本身是可具体化的。</p>
<p>例如，如果泛型类 <code>X&lt;T&gt;</code> 具有泛型成员类 <code>Y&lt;U&gt;</code>，则类型 <code>X&lt;?&gt;.Y&lt;?&gt;</code> 是可具体化的，因为 <code>X&lt;?&gt;</code> 是可具体化的，而 <code>Y&lt;?&gt;</code> 是可具体化的。类型 <code>X&lt;?&gt;.Y&lt;Object&gt;</code> 不可具体化，因为 <code>Y&lt;Object&gt;</code> 不可具体化。</p>
</li>
</ul>
<h2 id="Super-Type-Tokens">Super Type Tokens</h2>
<p>Neal Gafter 想出了一种方法，它称之为：<a target="_blank" rel="noopener" href="https://gafter.blogspot.com/2006/12/super-type-tokens.html">Super Type Tokens</a>，该方法利用 Java 中匿名内部类的强大功能在编译时保留类型信息，它的简化形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TypeReference</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>抽象限定符是有意的。 它强制客户端将其子类化以创建 TypeReference 的新实例。 为 <code>List&lt;String&gt;</code> 制作一个超类型令牌，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TypeReference&lt;List&lt;String&gt;&gt; x = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;String&gt;&gt;() &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>事实证明，您可以使用超类型令牌来完成可以使用类型令牌完成的几乎所有事情，以及大多数您本来可以使用类型标记但需要支持泛型类型和可具体化类型的问题，等等。</p>
<p>上面创建的对象是一个匿名类，通过反射可以得到它的接口类型，包括泛型类型参数。下面是 <a target="_blank" rel="noopener" href="http://crazybob.org/">Bob Lee</a> 使用该模式的一个完整实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * References a generic type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crazybob@google.com (Bob Lee)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TypeReference</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Constructor&lt;?&gt; constructor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">TypeReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superclass</span> <span class="operator">=</span> getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superclass <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Missing type parameter.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.type = ((ParameterizedType) superclass).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用默认，无参构造实例化&#123;<span class="doctag">@code</span> T&#125;实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">()</span></span><br><span class="line">            <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException,</span><br><span class="line">                   InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; rawType = type <span class="keyword">instanceof</span> Class&lt;?&gt;</span><br><span class="line">                ? (Class&lt;?&gt;) type</span><br><span class="line">                : (Class&lt;?&gt;) ((ParameterizedType) type).getRawType();</span><br><span class="line">            constructor = rawType.getConstructor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) constructor.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取引用类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Type <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;ArrayList&lt;String&gt;&gt;() &#123;&#125;.newInstance();</span><br><span class="line">        <span class="type">List</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;ArrayList&gt;() &#123;&#125;.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Super Type Tokens 模式也被引用在多个框架中，例如：</p>
<ul>
<li>Spring 的 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/ParameterizedTypeReference.html"><code>ParameterizedTypeReference&lt;T&gt;</code></a> 捕获和传递范型 Type</li>
<li>Jackson 的 <a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-core/javadoc/2.2.0/com/fasterxml/jackson/core/type/TypeReference.html"><code>TypeReference&lt;T&gt;</code></a> 用于序列化时的捕获和传递范型 Type</li>
<li>Gson 的 <a target="_blank" rel="noopener" href="https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html"><code>TypeToken&lt;T&gt;</code></a> 用于序列化时的捕获和传递范型 Type</li>
</ul>
<h2 id="参考链接">参考链接</h2>
]]></content>
      <categories>
        <category>Pattern</category>
      </categories>
      <tags>
        <tag>TypeSafe</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 继承映射</title>
    <url>/persistence/Hibernate-%E7%BB%A7%E6%89%BF%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概述-2">概述</h2>
<p>在关系型数据库中我们没有直接的方法去映射类的继承到数据库表中。为了解决这个问题，JPA 标准提供了几种策略：</p>
<ul>
<li>MappedSuperclass - 父类，不能是实体</li>
<li>Single Table - 来自具有共同祖先的不同类的实体被放置在单个表中</li>
<li>Joined Table - 每个类都有自己的表，查询子类实体需要连接表</li>
<li>Table-Per-Class - 类的所有的属性都在一张表中，所以不需要连接<br>
每种策略都会产生不同的数据库结构。</li>
</ul>
<span id="more"></span>
<p><strong>实体查询意味着我们可以在查询父类时使用动态查询获取所有的子类。</strong><br>
由于 Hibernate 是 JPA 的一个实现，它包含上述所有内容以及一些与继承相关的特定于 Hibernate 的功能。</p>
<h2 id="映射父类策略">映射父类策略</h2>
<p>使用 MappedSuperclass 策略，继承只在类中体现，而不是实体模型。让我们从创建一个代表父类的Person类开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> personId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**请注意这里的类没有 <code>@Entity</code> 注解 ** ，所以它不会被持久化到数据库中。<br>
接着，我们添加一个 Employee 子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEmployee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="comment">// constructor, getters, setters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数据库中，这将只生成一个 “MyEmployee” 表，总共三列包含子类定义的字段以及继承而来的字段。</p>
<p>**如果我们使用此策略，祖先不能包含与其他实体的关联。<br>
该策略可以用于为相同类定义相同字段，比如创建时间，创建者等审计功能或者通用字段。 **</p>
<h2 id="单表策略">单表策略</h2>
<p><strong>单表策略为每个类层次结构创建一个表。</strong> 如果我们没有明确指定，这也是 JPA 选择的默认策略。<br>
我们可以通过将 <code>@Inheritance</code> 注释添加到父类来定义我们想要使用的策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProduct</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> productId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们添加一些子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">extends</span> <span class="title class_">MyProduct</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pen</span> <span class="keyword">extends</span> <span class="title class_">MyProduct</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将生成下面的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> MyProduct (</span><br><span class="line">  DTYPE <span class="type">varchar</span>(<span class="number">31</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  productId <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  author <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  color <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">primary</span> key (productId)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当我们向其中插入数据时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">book.setProductId(<span class="number">1L</span>);</span><br><span class="line">book.setAuthor(<span class="string">&quot;Zeral&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Pen</span> <span class="variable">pen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pen</span>();</span><br><span class="line">pen.setProductId(<span class="number">2L</span>);</span><br><span class="line">pen.setColor(<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Hibernate 将会使用子类名称填充 <code>DTYPE</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyProduct (author, DTYPE, productId) <span class="keyword">VALUES</span> (<span class="string">&#x27;Zeral&#x27;</span>, <span class="string">&#x27;Book&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyProduct (color, DTYPE, productId) <span class="keyword">VALUES</span> (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;Pen&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Discriminator-Values-鉴别器值">Discriminator Values 鉴别器值</h3>
<p>由于所有的实体记录都在同一个表中，因此 Hibernate 需要一种区分它们的方法。<br>
**默认情况下，这是通过名为 <code>DTYPE</code> 的鉴别器列完成的 ** ，该列使用实体的名称作为值。<br>
要自定义鉴别器列，我们可以使用 <code>@DiscriminatorColumn</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name=&quot;products&quot;)</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;product_type&quot;, </span></span><br><span class="line"><span class="meta">  discriminatorType = DiscriminatorType.INTEGER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProduct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们选择通过名为 product_type 的整数列来区分 MyProduct 子类实体。<br>
接下来，我们需要告诉 Hibernate 每个子类对应于 product_type 列的什么值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">extends</span> <span class="title class_">MyProduct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pen</span> <span class="keyword">extends</span> <span class="title class_">MyProduct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hibernate 添加了注解可以采用的另外两个预定义值：“null” 和 “not null”：</p>
<ul>
<li><code>@DiscriminatorValue(“null”)</code> - 当任意行没有鉴别器值时将被映射到使用此注解的实体类;这可以应用于层次结构的根类</li>
<li><code>@DiscriminatorValue(“not null”)</code> - 当任意行有鉴别器值时但是未找到该鉴别器对应的类时将被映射到使用此注解的实体类</li>
</ul>
<p><strong>这两个注解可以解决在集成遗留数据库时，鉴别器列包含 NULL 或某些与任何实体子类无关的值，如果不做该映射处理，这些异常数据在处理时会抛出异常。</strong></p>
<p>除了列，我们还可以使用特定于 Hibernate 的<code>@DiscriminatorFormula</code> 注释来确定区分值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorFormula(&quot;case when author is not null then 1 else 2 end&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProduct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>**此策略具有多态查询性能的优点，因为在查询父实体时只需要访问一个表。另一方面，这也意味着我们不能再对子类实体属性使用 NOT NULL 约束。 **</p>
<h2 id="连表策略">连表策略</h2>
<p>使用此策略，层次结构中的每个类都映射到其表。在所有表中重复出现的唯一列是标识符，将在需要时用于连接它们。<br>
让我们创建一个使用此策略的父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.JOINED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> animalId;</span><br><span class="line">    <span class="keyword">private</span> String species;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们定义一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个表都有一个 animalId 标识符列。 Pet 实体的主键还具有对其父实体的主键的外键约束。要自定义此列，我们可以添加 <code>@PrimaryKeyJoinColumn</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn(name = &quot;petId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Animal (</span><br><span class="line">  animalId <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  species <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">primary</span> key (animalId);</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Pet (</span><br><span class="line">  petId <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  <span class="keyword">primary</span> key (petId),</span><br><span class="line">  <span class="keyword">foreign</span> key(petId) <span class="keyword">references</span> Animal(animalId) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>此继承映射方法的缺点是检索实体需要表之间的连接，这可能导致大量记录的性能降低。</strong><br>
查询父类时，连接数会更高，因为它将与每个相关的子项连接 - 因此，我们想要检索记录的层次结构越高，性能就越可能受到影响。</p>
<h2 id="单类单表策略">单类单表策略</h2>
<p><strong>Table Per Class 策略将每个实体映射到一张表，该表包含实体的所有属性，包括继承的属性。</strong><br>
生成的模式类似于使用 @MappedSuperclass 的模式，但与此不同，它会为父类定义实体，从而允许关联和多态查询。<br>
要使用此策略，我们只需要将 <code>@Inheritance</code> 注解添加到基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> vehicleId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String manufacturer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为其添加一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String engine;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// standard constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 sql 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Car (</span><br><span class="line">  vehicleId <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  manufacturer <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  engine <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (vehicleId)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这与在没有继承的情况下映射每个实体没有太大区别。在查询基类时，这种区别是显而易见的，它将在后台使用 UNION 语句返回所有子类记录。<br>
<strong>在选择此策略时，使用 UNION 也会导致性能下降。另一个问题是我们不能再使用标式键密钥生成。</strong></p>
<h2 id="多态查询">多态查询</h2>
<p>我们创建两个 Book 和 Pen 对象，然后查询它们的超类 MyProduct 以验证我们将返回两个对象。<br>
<strong>Hibernate 还可以查询由实体类扩展或实现的接口或基类这些非实体类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.createQuery(</span><br><span class="line">  <span class="string">&quot;from com.baeldung.hibernate.pojo.inheritance.Person&quot;</span>)</span><br><span class="line">  .getResultList())</span><br><span class="line">  .hasSize(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，这也适用于任何父类或接口，无论它是否是 @MappedSuperclass。与通常的 HQL 查询的区别在于我们必须使用完全限定名称，因为它们不是由 Hibernate 管理的实体。<br>
如果我们不希望这种类型的查询返回特定子类，那么我们只需要在其定义中添加 Hibernate <code>@Polymorphism</code> 注释，类型为 <code>EXPLICIT</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Polymorphism(type = PolymorphismType.EXPLICIT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bag</span> <span class="keyword">implements</span> <span class="title class_">Item</span> &#123; ...&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，查询父类时，不会返回 Bag 记录。</p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>MappedSuperclass</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 与 Hibernate 命名策略</title>
    <url>/persistence/JPA-%E4%B8%8E-Hibernate-%E5%91%BD%E5%90%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>hibernate 默认的命名策略是不会将驼峰式命名 (<code>cameCase</code>) 映射到蛇形命名 (<code>snake_case</code>) 上去的，<br>
虽然可以直接在 <code>@Column</code> 上指定需要映射的 <code>name</code>，但是使用策略一致地应用命名更方便些。</p>
<p>从 Hibernate 5 开始，数据库对象命名策略由 <code>PhysicalNamingStrategy</code> 接口表示，我们可以自定义该接口以自动将数据库标识符从 cameCase 转换为 snake_case。</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CamelCaseToSnakeCaseNamingStrategy</span> </span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">PhysicalNamingStrategyStandardImpl</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CamelCaseToSnakeCaseNamingStrategy</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CamelCaseToSnakeCaseNamingStrategy</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CAMEL_CASE_REGEX</span> <span class="operator">=</span> <span class="string">&quot;([a-z]+)([A-Z]+)&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SNAKE_CASE_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;$1\\_$2&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Identifier <span class="title function_">toPhysicalCatalogName</span><span class="params">(</span></span><br><span class="line"><span class="params">            Identifier name, </span></span><br><span class="line"><span class="params">            JdbcEnvironment context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="built_in">super</span>.toPhysicalCatalogName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Identifier <span class="title function_">toPhysicalSchemaName</span><span class="params">(</span></span><br><span class="line"><span class="params">            Identifier name, </span></span><br><span class="line"><span class="params">            JdbcEnvironment context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="built_in">super</span>.toPhysicalSchemaName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Identifier <span class="title function_">toPhysicalTableName</span><span class="params">(</span></span><br><span class="line"><span class="params">            Identifier name, </span></span><br><span class="line"><span class="params">            JdbcEnvironment context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="built_in">super</span>.toPhysicalTableName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Identifier <span class="title function_">toPhysicalSequenceName</span><span class="params">(</span></span><br><span class="line"><span class="params">            Identifier name, </span></span><br><span class="line"><span class="params">            JdbcEnvironment context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="built_in">super</span>.toPhysicalSequenceName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Identifier <span class="title function_">toPhysicalColumnName</span><span class="params">(</span></span><br><span class="line"><span class="params">            Identifier name, </span></span><br><span class="line"><span class="params">            JdbcEnvironment context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="built_in">super</span>.toPhysicalColumnName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Identifier <span class="title function_">formatIdentifier</span><span class="params">(</span></span><br><span class="line"><span class="params">            Identifier identifier)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (identifier != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> identifier.getText();</span><br><span class="line"> </span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedName</span> <span class="operator">=</span> name</span><br><span class="line">        .replaceAll(</span><br><span class="line">            CAMEL_CASE_REGEX, </span><br><span class="line">            SNAKE_CASE_PATTERN)</span><br><span class="line">        .toLowerCase();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> !formattedName.equals(name) ?</span><br><span class="line">                    Identifier.toIdentifier(</span><br><span class="line">                        formattedName, </span><br><span class="line">                        identifier.isQuoted()</span><br><span class="line">                    ) :</span><br><span class="line">                    identifier;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你引用了 <code>hibernate-types</code>，则不需要该自定义策略：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vladmihalcea<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-types-52<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-types.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要使用自定义的策略类，只需要将该类配置给 <code>hibernate.physical_naming_strategy</code> 属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.physical_naming_strategy&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">&quot;com.vladmihalcea.hibernate.type.util.CamelCaseToSnakeCaseNamingStrategy&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Spring Data JPA 中该策略的默认配置为：<br>
<code>org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</code></p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否驼峰，根据 aBa 类型判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isUnderscoreRequired</span><span class="params">(<span class="type">char</span> before, <span class="type">char</span> current, <span class="type">char</span> after)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Character.isLowerCase(before) &amp;&amp; Character.isUpperCase(current)</span><br><span class="line">            &amp;&amp; Character.isLowerCase(after);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Identifier <span class="title function_">apply</span><span class="params">(Identifier name, JdbcEnvironment jdbcEnvironment)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(name.getText().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;_&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; builder.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUnderscoreRequired(builder.charAt(i - <span class="number">1</span>), builder.charAt(i),</span><br><span class="line">                builder.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">            builder.insert(i++, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getIdentifier(builder.toString(), name.isQuoted(), jdbcEnvironment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐式命名策略 (<code>ImplicitNamingStrategy</code>) 在缺省时提供相应的命名处理：</p>
<ul>
<li>实体主表： <code>@Table</code></li>
<li>连表： <code>@JoinTable</code></li>
<li>集合表： <code>@CollectionTable</code></li>
<li>列命名： <code>@Column</code></li>
</ul>
<p>Spring Data JPA 模式隐式命名策略为：<br>
<code>org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy</code></p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 快速适配多种数据库</title>
    <url>/persistence/JPA-%E5%BF%AB%E9%80%9F%E9%80%82%E9%85%8D%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>部分项目可能需要同时适配多种不同的数据库，比如常见的 Mysql、Oracle、Mssql 这几种数据库。首先我们准备测试数据库环境。</p>
<h2 id="测试数据库准备">测试数据库准备</h2>
<p>为了快速测试，我们使用 Docker 快速搭建数据库环境，对应的 Docker Compose 文件内容如下：</p>
<span id="more"></span>
<ul>
<li>
<p><strong>Mysql</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">8.0</span>.<span class="number">20</span></span><br><span class="line">    volumes:</span><br><span class="line">        - ./mysql/data/:/var/lib/mysql/</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_USER=root</span><br><span class="line">      - MYSQL_ALLOW_EMPTY_PASSWORD=yes</span><br><span class="line">      - MYSQL_DATABASE=mysql</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">3306</span>:<span class="number">3306</span></span><br><span class="line">    command: mysqld --lower_case_table_names=<span class="number">1</span> --skip-ssl --character_set_server=utf8mb4 --explicit_defaults_for_timestamp</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Oracle</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services: </span><br><span class="line">  oracle-db:</span><br><span class="line">    image: oracleinanutshell/oracle-xe-<span class="number">11</span>g:latest</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql/data/:/u01/app/oracle/</span><br><span class="line">    environment:</span><br><span class="line">      - ORACLE_PWD=oracle  <span class="comment"># DB_CONN: credentials (system/sys:oracle)</span></span><br><span class="line">      - ORACLE_ALLOW_REMOTE=true</span><br><span class="line">      - ORACLE_DISABLE_ASYNCH_IO=true</span><br><span class="line">      - ORACLE_ENABLE_XDB=true</span><br><span class="line">      - DBCA_TOTAL_MEMORY=<span class="number">1024</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">1521</span>:<span class="number">1521</span></span><br><span class="line">      - <span class="number">1522</span>:<span class="number">8080</span> <span class="comment"># for apex</span></span><br></pre></td></tr></table></figure>
<p>由于 Oracle 数据库一个用户对应一个 Schema，要创建一个数据库，我们就得先创建对应的用户，创建用户又分为以下几个步骤：</p>
<ul>
<li>
<p>使用 system 账号（DBA 角色）创建用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> &quot;username&quot; IDENTIFIED <span class="keyword">BY</span> &quot;password&quot; <span class="keyword">DEFAULT</span> TABLESPACE &quot;USERS&quot; TEMPORARY TABLESPACE &quot;TEMP&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分配空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> &quot;spc&quot; QUOTA UNLIMITED <span class="keyword">ON</span> &quot;SYSTEM&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为用户授予基本的权限，比如创建序列、创建表、建立连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>, <span class="keyword">CREATE</span> SEQUENCE, <span class="keyword">CREATE</span> SESSION, <span class="keyword">CREATE</span> SYNONYM, <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>, <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="keyword">TO</span> &quot;username&quot;;</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>Liqubibase</code>，会有下面的警告：</p>
<blockquote>
<p>Liquibase needs to access the DBA_RECYCLEBIN table so we can automatically handle the case where<br>
constraints are deleted and restored. Since Oracle doesn’t properly restore the original table names<br>
referenced in the constraint, we use the information from the DBA_RECYCLEBIN to automatically correct this<br>
issue.</p>
</blockquote>
<p>需要使用 <code>sys</code> 账号以 <code>SYSDBA</code> 角色登陆，如下面的 Oracle SQL Developer，然后执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> SYS.DBA_RECYCLEBIN <span class="keyword">TO</span> “username”;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img data-src="../../images/jpa/oracle-login-sysdba.png" alt="image-20210319212801827"></p>
<blockquote>
<p>对于正式环境的 Oracle 使用，请从 Oracle <a target="_blank" rel="noopener" href="https://container-registry.oracle.com/pls/apex/f?p=113:4:878081924406:::4:P4_REPOSITORY,AI_REPOSITORY,AI_REPOSITORY_NAME,P4_REPOSITORY_NAME,P4_EULA_ID,P4_BUSINESS_AREA_ID:9,9,Oracle%20Database%20Enterprise%20Edition,Oracle%20Database%20Enterprise%20Edition,31,0&amp;cs=301x0l2wtU24LAdobHQkwjesse7qnXICCKfQxvSwcCdgJi-R14Qvs-B9OtkSzPWfnOLTDLu3bfEsfLjsLmBYqNw">官方镜像注册中心</a>获取，强烈建议使用 19c 长期支持版本（直到 2027 年）。</p>
<p>可以在以下位置找到 Oracle 数据库 19c（EE，SE2，单实例和 RAC）Docker 镜像：<a target="_blank" rel="noopener" href="https://container-registry.oracle.com">https://container-registry.oracle.com</a></p>
<p>可以在以下位置找到 Oracle 数据库 19c Docker 构建文件：<a target="_blank" rel="noopener" href="https://github.com/oracle/docker-images/tree/master/OracleDatabase">https://github.com/oracle/docker-images/tree/master/OracleDatabase</a></p>
</blockquote>
</li>
<li>
<p><strong>Mssql</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  mssql:</span><br><span class="line">    image: mcr.microsoft.com/mssql/server:<span class="number">2017</span>-latest-ubuntu</span><br><span class="line">    <span class="comment"># volumes are not supported on macOS</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./mssql/data/:/var/opt/mssql/data/</span><br><span class="line">    environment:</span><br><span class="line">      - ACCEPT_EULA=Y</span><br><span class="line">      - MSSQL_PID=Express</span><br><span class="line">      - SA_PASSWORD=yourStrong(!)Password</span><br><span class="line">      - MSSQL_DATABASE=mssql</span><br><span class="line">      - MSSQL_SLEEP=<span class="number">60</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">1433</span>:<span class="number">1433</span></span><br><span class="line">    command: /bin/bash -c <span class="string">&#x27;/opt/mssql/bin/sqlservr &amp; echo &quot;wait $$MSSQL_SLEEP sec for DB to start &quot;; sleep $$MSSQL_SLEEP; /opt/mssql-tools/bin/sqlcmd -U sa -P $$SA_PASSWORD -d tempdb -q &quot;EXIT(CREATE DATABASE $$MSSQL_DATABASE)&quot;; wait;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="依赖引入">依赖引入</h2>
<p>这里我们以 Gradle 为例，对于不同的 profile 选择不同的依赖，由于项目使用 jhipster BOM，这里没有指明版本。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">project</span>.hasProperty(<span class="string">&quot;oracle&quot;</span>)) &#123;</span><br><span class="line">    implementation <span class="string">&quot;com.oracle.database.jdbc:ojdbc8&quot;</span></span><br><span class="line">    liquibaseRuntime <span class="string">&quot;com.oracle.database.jdbc:ojdbc8&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">project</span>.hasProperty(<span class="string">&quot;mssql&quot;</span>)) &#123;</span><br><span class="line">    implementation <span class="string">&quot;com.microsoft.sqlserver:mssql-jdbc&quot;</span></span><br><span class="line">    liquibaseRuntime  <span class="string">&quot;com.microsoft.sqlserver:mssql-jdbc&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    implementation <span class="string">&quot;mysql:mysql-connector-java&quot;</span></span><br><span class="line">    liquibaseRuntime <span class="string">&quot;mysql:mysql-connector-java&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发环境配置文件">开发环境配置文件</h2>
<p>数据库需要的库及用户名和密码都有了，对于 SpringBoot 项目可以建立不同环境的 profile 文件，这里仅说明核心的配置信息：</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<p><em><code>application-mysql.yml</code></em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">     <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">     <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">     <span class="attr">properties:</span></span><br><span class="line">       <span class="attr">hibernate.id.new_generator_mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Oralce</strong></p>
<p><em><code>application-oracle.yml</code></em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:oracle:thin:@192.168.1.194:1521:xe</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">       <span class="attr">hibernate.id.new_generator_mappings:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Mssql</strong></p>
<p><em><code>application-mssql.yml</code></em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:sqlserver://192.168.1.194:1433;database=spc</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">SA</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourStrong(!)Password</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">       <span class="attr">hibernate.id.new_generator_mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一个核心的配置项 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-auto"><code>hibernate.id.new_generator_mappings</code></a>，该属性在 5.0 之后的 hibernate 中默认为 <code>true</code>，为 <code>true</code> 时如果主键生成策略为 <code>AUTO</code>，则将处理为<strong>基于序列</strong>的 <code>SequenceStyleGenerator</code>，如果数据库支持序列，将使用序列，否则使用基于单表（<code>TABLE</code>）维护的主键生成器。这里我们为 <strong>Oracle</strong> 使用设置为 <code>true</code>。</p>
<p>为 <code>false</code> 时将回退到数据库方言中原生的主键策略，具体由 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/dialect/Dialect.html#getNativeIdentifierGeneratorStrategy--">Dialect#getNativeIdentifierGeneratorStrategy</a> 返回值决定（<code>identity</code> 或 <code>sequence</code>）。由于 <code>mysql</code>、<code>mssql</code> 本身支持自增主键，这里我们使用数据库原生的自增主键策略。</p>
<h2 id="实体配置">实体配置</h2>
<p>实体没有太多配置，只需要设置主键的策略为 <code>AUTO</code> 就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>
<p><em>下方配置可选</em></p>
<hr>
<p>由于 Oracle 使用序列作为主键生成策略，hibernate 将会在我们新增实体时获取下一个序列号，序列的名称默认为：<code>hibernate_sequence</code>。</p>
<p>我们也可以为每个表指定一个序列，或者为每个表其指定表名 + 可选后缀的序列名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.AUTO, generator = &quot;sequence-generator&quot;)</span></span><br><span class="line"><span class="meta">@GenericGenerator(</span></span><br><span class="line"><span class="meta">	name = &quot;sequence-generator&quot;,</span></span><br><span class="line"><span class="meta">  strategy = &quot;org.hibernate.id.enhanced.SequenceStyleGenerator&quot;,</span></span><br><span class="line"><span class="meta">  parameters = &#123;</span></span><br><span class="line"><span class="meta">    @Parameter(name = SEQUENCE_PARAM, value = &quot;user_sequence&quot;),  // 使用固定的序列名</span></span><br><span class="line"><span class="meta">    @Parameter(name = CONFIG_PREFER_SEQUENCE_PER_ENTITY, value = &quot;true&quot;), // 每个表一个序列，基于表名+可选后缀的形式</span></span><br><span class="line"><span class="meta">    @Parameter(name = CONFIG_SEQUENCE_PER_ENTITY_SUFFIX, value = &quot;sequence&quot;), // 可选后缀</span></span><br><span class="line"><span class="meta">    @Parameter(name = INITIAL_PARAM, value = &quot;4&quot;),</span></span><br><span class="line"><span class="meta">    @Parameter(name = INCREMENT_PARAM, value = &quot;1&quot;)</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> id;</span><br></pre></td></tr></table></figure>
<h2 id="Liquibase-或脚本配置">Liquibase 或脚本配置</h2>
<h3 id="初始化-Oracle-序列">初始化 Oracle 序列</h3>
<p>由于我们没有使用 hibernate 的自动建表，所以需要手动创建相应的序列，以默认的 <code>hibernate_sequence</code> 为例，对于 Liquibase 需要，增加如下 ChangeSet：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">&quot;00000000000000&quot;</span> <span class="attr">author</span>=<span class="string">&quot;Zeral&quot;</span> <span class="attr">dbms</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">createSequence</span> <span class="attr">sequenceName</span>=<span class="string">&quot;hibernate_sequence&quot;</span> <span class="attr">minValue</span>=<span class="string">&quot;1&quot;</span> <span class="attr">startValue</span>=<span class="string">&quot;20&quot;</span> <span class="attr">incrementBy</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbms 指这条变更集针对的数据库为 oracle。</p>
<blockquote>
<p>如果加载了带有主键的数据，请注意序列的起始值为数据中主键最大的下一个数字。</p>
</blockquote>
<h3 id="Mssql-加载带有主键的数据">Mssql 加载带有主键的数据</h3>
<p>由于 Mssql 表默认不允许带有主键的数据进行新增，要加载带有主键的数据，Liquibase 可以做如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">&quot;20191118183100&quot;</span> <span class="attr">author</span>=<span class="string">&quot;Zeral&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">dbms</span>=<span class="string">&quot;mssql&quot;</span>&gt;</span></span><br><span class="line">        SET IDENTITY_INSERT base_factor ON;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loadData</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">file</span>=<span class="string">&quot;config/liquibase/base_factor.csv&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">tableName</span>=<span class="string">&quot;base_factor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;is_auto_report_necessary&quot;</span> <span class="attr">type</span>=<span class="string">&quot;boolean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loadData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">dbms</span>=<span class="string">&quot;mssql&quot;</span>&gt;</span></span><br><span class="line">        SET IDENTITY_INSERT base_factor OFF;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>及使用 <code>SET IDENTITY_INSERT 表名 ON/OFF;</code> 包裹加载数据脚本，并设置 <code>dbms</code> 仅对 <code>mssql</code> 作用。</p>
<h3 id="数据库字段类型选择">数据库字段类型选择</h3>
<p>在用 Liquibase 创建表字段时，选择合适的类型，不要使用特定于数据库的数据类型。</p>
<p><strong>Data types mapping in Liquibase 3.6.x</strong></p>
<table>
<thead>
<tr>
<th><strong>Liquibase data type</strong></th>
<th><strong>SQL Server data type</strong></th>
<th><strong>Oracle data type</strong></th>
<th><strong>MySQL</strong></th>
<th><strong>PostgreSQL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>bigint</td>
<td>bigint</td>
<td>number(38,0)</td>
<td>bigint</td>
<td>bigint/bigserial</td>
</tr>
<tr>
<td>blob</td>
<td>varbinary(max)</td>
<td>blob</td>
<td>blob</td>
<td>oid</td>
</tr>
<tr>
<td>boolean</td>
<td>bit</td>
<td>number(1)</td>
<td>bit</td>
<td>bit</td>
</tr>
<tr>
<td>char</td>
<td>char</td>
<td>char</td>
<td>char</td>
<td>character</td>
</tr>
<tr>
<td>clob</td>
<td>nvarchar(max)</td>
<td>clob</td>
<td>longtext</td>
<td>text</td>
</tr>
<tr>
<td>currency</td>
<td>money</td>
<td>number(15,2)</td>
<td>decimal</td>
<td>decimal</td>
</tr>
<tr>
<td>datetime</td>
<td>datetime</td>
<td>timestamp</td>
<td>timestamp</td>
<td>timestamp</td>
</tr>
<tr>
<td>date</td>
<td>date</td>
<td>date</td>
<td>date</td>
<td>date</td>
</tr>
<tr>
<td>decimal</td>
<td>decimal</td>
<td>decimal</td>
<td>decimal</td>
<td>decimal</td>
</tr>
<tr>
<td>double</td>
<td>float</td>
<td>float(24)</td>
<td>double</td>
<td>double precision</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
<td>integer</td>
<td>int</td>
<td>integer/serial</td>
</tr>
<tr>
<td>mediumint</td>
<td>int</td>
<td>mediumint</td>
<td>mediumint</td>
<td>mediumint</td>
</tr>
<tr>
<td>nchar</td>
<td>nchar</td>
<td>nchar</td>
<td>nchar</td>
<td>nchar</td>
</tr>
<tr>
<td>nvarchar</td>
<td>nvarchar</td>
<td>nvarchar2</td>
<td>nvarchar</td>
<td>varchar</td>
</tr>
<tr>
<td>number</td>
<td>numeric</td>
<td>number</td>
<td>numeric</td>
<td>numeric</td>
</tr>
<tr>
<td>smallint</td>
<td>smallint</td>
<td>number(5)</td>
<td>smallint</td>
<td>smallint/smallserial</td>
</tr>
<tr>
<td>time</td>
<td>time</td>
<td>date</td>
<td>time</td>
<td>time</td>
</tr>
<tr>
<td>timestamp</td>
<td>datetime</td>
<td>timestamp</td>
<td>timestamp</td>
<td>timestamp</td>
</tr>
<tr>
<td>tinyint</td>
<td>tinyint</td>
<td>number(3)</td>
<td>tinyint</td>
<td>smallint</td>
</tr>
<tr>
<td>uuid</td>
<td>uniqueidentifier</td>
<td>raw(16)</td>
<td>char(36)</td>
<td>uuid</td>
</tr>
<tr>
<td>varchar</td>
<td>varchar</td>
<td>varchar2</td>
<td>varchar</td>
<td>varchar/character (varying)</td>
</tr>
</tbody>
</table>
<h2 id="其它注意">其它注意</h2>
<h3 id="原生语句">原生语句</h3>
<ul>
<li>
<p>尽量避免使用原生语句，如果必须使用原生语句，请保证语法相对简单，能适配不同数据库。</p>
</li>
<li>
<p>很多时候为了安全性等，登录用户和当前 schema 并不是一定保持一致，所以执行语句时必须显式指明当前操作的 schema 下的表，可以通过在要执行语句中所有表名前加上 <code>&#123;h-domain&#125;</code> 即可，详情查看<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#sql-global-catalog-schema">官方使用指南相关链接</a>，例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &#123;h<span class="operator">-</span>domain&#125;person <span class="keyword">where</span> age(hired_on) <span class="operator">&lt;</span> <span class="string">&#x27;30 days&#x27;</span>；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Oracle-长度限制">Oracle 长度限制</h3>
<p>对于 Oracle 版本 19c, 18c and 12cR2：</p>
<ul>
<li>实体名称不能超过 124 个字符，这是由于 Oracle 对对象名称的限制为 128 个字符，并且我们保留 4 个字符来为生成的表生成主键序列。</li>
<li>实体<u>字段</u>名称不能超过 128 个字符。</li>
<li>建立关系时，外键名称不能超过 128 个字符，因此，如果它们太长，将被截断。</li>
<li>在进行多对多关系时，联接表名称将遵循 JPA规范（格式为 “firstTable_secondTable”）：如果长度超过 128 个字符，则将其截断。</li>
<li>数据库索引名称不能超过 128 个字符。</li>
</ul>
<p>对于 Oracle 版本 11g，12cR1：</p>
<ul>
<li>实体名称不能超过 26 个字符，这是由于 Oracle 对对象名称的限制为 30 个字符，并且我们保留 4 个字符来为生成的表生成主键序列。</li>
<li>实体字段名称不能超过 30 个字符。</li>
<li>建立关系时，外键名称不能超过 30 个字符，因此，如果它们太长，则会被截断。</li>
<li>在进行多对多关系时，联接表名称将遵循 JPA 规范（格式为 “firstTable_secondTable”）：如果长度超过 30 个字符，则将其截断。</li>
</ul>
<h3 id="关键字使用注意">关键字使用注意</h3>
<p>在为实体或字段起名时，避免使用到相关数据库的关键字和保留关键字，可以通过加限制前缀来避免。下方罗列可能和你使用版本有差异。</p>
<p>Mysql 相关关键字链接：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">https://dev.mysql.com/doc/refman/8.0/en/keywords.html</a></p>
<p>Oracle 相关关键字链接：<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/B19306_01/em.102/b40103/app_oracle_reserved_words.htm">https://docs.oracle.com/cd/B19306_01/em.102/b40103/app_oracle_reserved_words.htm</a></p>
<p>Mssql 相关关键字链接：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sql/odbc/reference/appendixes/reserved-keywords?view=sql-server-ver15">https://docs.microsoft.com/en-us/sql/odbc/reference/appendixes/reserved-keywords?view=sql-server-ver15</a></p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
        <tag>Oracle</tag>
        <tag>Mssql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 快速入门</title>
    <url>/persistence/Mybatis-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1>概述</h1>
<p><code>MyBatis</code> 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects）为数据库中的记录。</p>
<p><code>MyBatis</code> 作为一款持久层框架，它趋向于以数据库为中心，因此主要的关注点会落在 SQL 定义、结果映射上，相对来说比较轻量，也更容易入手，对于 SQL 优化也比较容易，但也正是由于偏重 SQL，将会和使用的数据库强关联。</p>
<h1>对比 ORM 框架</h1>
<p>同时使用面向对象的软件和关系数据库既麻烦又费时。由于对象和关系数据库中的数据表示方式之间存在<strong>范式不匹配</strong>，因此开发成本要高得多。</p>
<p>相比 <code>ORM</code> 框架，<code>ORM</code> 框架更多的将关注点放在面向对象的域模型和业务逻辑层，<code>ORM</code> 框架一般会遵循 <code>JPA</code> 标准，比如最常见的实现 <code>Hibernate</code>。</p>
<p><code>ORM</code> 框架的主要目的之一是降低与特定数据库的耦合性，它抽象了数据库系统，因此在不同数据库切换、移植时会更加容易，抽象的代价是与之而来的复杂性的增加，但也提供了更多丰富的功能特性：数据变更追踪、审计、一/二级缓存、并发版本控制、数据懒加载、级联操作，以及丰富的查询方式：<code>SQL</code>、<code>HQL</code>、<code>JPQL</code>、<code>Criteria API</code>、<code>Query DSL</code> 等；</p>
<span id="more"></span>
<h1>XML or Annotation</h1>
<p>在使用 MyBatis 开发应用时，最大一部分工作是在和 <a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html"><code>Mapper（映射器）</code></a>打交道，Mapper 中主要又分为两部分：</p>
<ul>
<li>sql 语句定义（select、insert、update、delete、sql）</li>
<li>结果集映射 resultMap</li>
</ul>
<p>而这两部分既可以通过 XML 也可以通过注解来定义，同样是为代码运行提供元数据，使用哪种更好呢？</p>
<p>每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，注解在其声明时提供了大量上下文，从而导致更短更简洁的配置。但是，XML 擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将配置靠近源，而另一些开发人员则认为注解类不再是 POJO，而且配置变得分散且难以控制。</p>
<p><strong>MyBatis 的 XML 提供了全量的功能，注解受限于灵活性不能覆盖所有方面，比如嵌套结果映射等，但是能基本的满足开发使用。</strong></p>
<blockquote>
<p>个人建议：优先考虑使用 XML。</p>
</blockquote>
<h1>动态 SQL</h1>
<p>动态 SQL 定义又分为<strong>编译时定义</strong>和<strong>运行时定义</strong>。</p>
<h2 id="编译时动态-SQL-定义">编译时动态 SQL 定义</h2>
<p><strong>编译时定义</strong>通常是使用 XML 或注解提供元数据的方式提前定义好，对于 XML 通常提供以下标签：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#if"><code>if</code></a>  -  条件拼接</li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#chooseWhenOtherwise"><code>choose (when, otherwise)</code></a>  -  多条件选择，类似 switch</li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#trimWhereSet"><code>trim (where, set)</code></a>  -  动态 where 条件适配</li>
<li><code>foreach</code> - 集合遍历</li>
</ul>
<p>要在注解中使用动态元素，可以通过 <code>script</code> 标签来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;update Author&quot;,</span></span><br><span class="line"><span class="meta">  &quot;  &lt;set&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;  &lt;/set&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;where id=#&#123;id&#125;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateAuthorValues</span><span class="params">(Author author)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="运行时动态-SQL-定义">运行时动态 SQL 定义</h2>
<p>虽然通过 XML 直接注入 SQL 片段参数也能实现运行时动态定义 SQL，但 MyBatis 提供了更加安全且灵活的定义方式：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-dynamic-sql/docs/introduction.html">MyBatis Dynamic SQL</a>。</p>
<p>该库通过实现类似于 SQL 的 DSL(domain-specific language) - 领域特定语言来工作，该 DSL 创建一个包含完整 SQL 语句和该语句所需的任何参数的对象。MyBatis 可以将 SQL 语句对象直接用作映射器方法的参数。</p>
<p>该库内置了很多易用的<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-dynamic-sql/docs/conditions.html">条件方法</a>，结合 Java8 的 <code>Predicate</code>、<code>Supplier</code> 等函数，可以实现复杂的条件拼接。</p>
<p><strong>作为一个 SQL 构建器，它并没有实现所有 SQL 的语法，比如查询的 WITH、HAVING、部分子查询写法等。</strong></p>
<h1>对象关系映射</h1>
<p>对于普通的查询都能通过映射 POJO 对象或 Map 或基础类型来完成，对于存在对象关系的映射：</p>
<h2 id="一对一">一对一</h2>
<p>在 XML 中可通过 <code>association</code> 标签加载关联，在注解中使用 <code>result</code> 的 <code>one</code> 属性，加载方式分为两种：</p>
<ul>
<li>
<p>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询博客 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询博客的作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在查询完 blog 后，会通过 association 标签中定义的 column 找到结果集中的该字段结果，并使用该字段结果去调用 selectAuthor 中定义的语句，并将结果返回给 Blog 对象中 author 对象。</p>
<p>在注解中通过 result 的 one 属性定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(id=&quot;blogResult&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;blog_title&quot;, property=&quot;title&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;author_id&quot;, property=&quot;author&quot;, one=@One(select = &quot;selectAuthor&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</p>
<p>比如对该查询结果进行映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询博客及博客作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogDetails&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       A.id as author_id,</span><br><span class="line">       A.username as author_username,</span><br><span class="line">       A.password as author_password,</span><br><span class="line">       A.email as author_email,</span><br><span class="line">       A.bio as author_bio,</span><br><span class="line">       A.favourite_section as author_favourite_section</span><br><span class="line">  from Blog B</span><br><span class="line">       left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>映射关联查询中的 Blog 对象中的一对一 Author ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;favouriteSection&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_favourite_section&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@one 注解 API 不支持嵌套结果映射。这是由于 Java 注解中的限制，不允许循环引用。</strong></p>
<blockquote>
<p>对于关联表和主表字段名相同的，必须使用不同别名，否则在返回结果集时会映射出错。</p>
<p>可以使用 <code>columnPrefix</code> 指定关联表字段的统一前缀。</p>
</blockquote>
</li>
</ul>
<h2 id="一对多">一对多</h2>
<p>一对多在 XML 中使用 <code>collection</code> 标签，在注解中使用 result 的 many 标签加载关联，同样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合：</p>
<ul>
<li>
<p>嵌套 Select 查询：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 查询博客 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 查询博客下的所有文章 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostsForBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于使用注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(id=&quot;blogResult&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;blog_title&quot;, property=&quot;title&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;id&quot;, property=&quot;posts&quot;, many=@Many(select = &quot;selectPostsForBlog&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line">Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p><code>javaType</code> 是指集合的类型，一般可以推断出，不用写，<code>ofType</code> 是指集合元素的类型。</p>
</li>
<li>
<p>嵌套结果映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询博客及下面的所有文章 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogDetails&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       P.id as post_id,</span><br><span class="line">       P.blog_id as post_blog_id,</span><br><span class="line">       P.author_id as post_author_id,</span><br><span class="line">       P.created_on as post_created_on,</span><br><span class="line">       P.section as post_section,</span><br><span class="line">       P.subject as post_subject,</span><br><span class="line">       P.draft as draft,</span><br><span class="line">       P.body as post_body,</span><br><span class="line">  from Blog B</span><br><span class="line">       inner join Post p on B.id = P.blog_id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用下面的结果映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Very Complex Result Map --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@many 注解 API 不支持嵌套结果映射。这是由于 Java 注解中的限制，不允许循环引用。</strong></p>
</li>
</ul>
<h1>使用注意</h1>
<ul>
<li>XML 符号转义</li>
</ul>
<p>在 XML 中配置查询 sql 时，对于部分符号需要特殊转义</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>转义符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td><code>&amp;lt;</code></td>
<td>小于号</td>
</tr>
<tr>
<td>&lt;=</td>
<td><code> &amp;lt;=</code></td>
<td>小于等于号</td>
</tr>
<tr>
<td>&gt;</td>
<td><code>&amp;gt;</code></td>
<td>大于号</td>
</tr>
<tr>
<td>&gt;=</td>
<td><code>&amp;gt;=</code></td>
<td>大于等于号</td>
</tr>
<tr>
<td>&amp;</td>
<td><code>&amp;amp;</code></td>
<td>和</td>
</tr>
<tr>
<td>’</td>
<td><code>&amp;apos;</code></td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td><code>&amp;quot;</code></td>
<td>双引号</td>
</tr>
</tbody>
</table>
<p>或者可以将包含特殊符号的语句用 <code>CDATA</code> 包裹起来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">  sql statement </span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure>
<h1>核心处理流程</h1>
<h2 id="构建-SqlSessionFactory">构建 SqlSessionFactory</h2>
<p>每个基于 MyBatis 的应用都是以一个 <code>SqlSessionFactory</code> 的实例为核心的。SqlSessionFactory 的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 <code>Configuration</code> 实例来构建出 SqlSessionFactory 实例。</p>
<p>在 <code>MyBatis-Spring</code> 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。</p>
<h2 id="从-SqlSessionFactory-中获取-SqlSession">从 SqlSessionFactory 中获取 SqlSession</h2>
<p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 <code>SqlSession</code> 的实例，通过 SqlSessionFactory 的 <code>openSession</code> 方法。</p>
<p><strong>SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</strong></p>
<h2 id="使用-Mapper-定义语句和结果映射">使用 Mapper 定义语句和结果映射</h2>
<p>映射器主要定义了语句和结果映射。</p>
<p>通过映射器接口，我们可以与 XML 配置形成分离，使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），使我们的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<p>Mybatis 本身可以通过配置文件定义 Mapper 的位置来帮助程序定位和查找映射器。</p>
<p>在 <code>Mybatis-Spring</code> 中，最简单的方法是委托给 Spring 帮我们扫描注册 Bean，具体在下一节中详细介绍。</p>
<p>扫描到的 Mapper，语句，结果映射（ResultMap）等都会放到 <code>Configuration</code> 类中，在后面的执行中我们将会从这里查找。</p>
<h2 id="执行语句和结果映射">执行语句和结果映射</h2>
<p>通过 Mapper 的定义我们拿到了要执行的语句，也知道了结果要如何映射。在我们调用 Mapper 的接口时，会反射调用 <code>MapperProxy</code> 代理类，该代理类又委托给 <code>MapperMethod</code> 代理类，最终方法代理类将使用 <code>SqlSession</code> 实例去执行，SqlSession 使用从 <code>Configuration</code> 类拿到的语句，交给 <code>Executor</code> 执行器去执行查询，如果定义了 <code>ResultHandler</code> 则使用该处理器处理结果，否则将使用从 <code>Configuration</code> 中找到的 <code>ResultMap</code> 来处理映射，ResultMap 对不同的字段类型使用 <code>TypeHandlerRegistry</code> 查找已注册的合适的 <code>TypeHandler</code> 进行处理。</p>
<h1>Spring Mybatis Mapper 注册机制</h1>
<p><strong>Mybatis</strong> 结合 <strong>Spring</strong> 将 <strong>Mapper</strong> 注册到 <strong>Spring IoC</strong> 的机制是这样的：</p>
<p><img data-src="../../images/jpa/mybatis/640.png" alt="640"></p>
<p>其实里面涉及到 <strong>Spring</strong> 和 <strong>Mybatis</strong> 的知识点还是比较多的，但是我们只要梳理出来流程就比较容易理解和掌握。</p>
<h2 id="ImportBeanDefinitionRegistrar">ImportBeanDefinitionRegistrar</h2>
<p><code>ImportBeanDefinitionRegistrar</code> 是一个非常重要的接口，凡是要把第三方整合到 <strong>Spring</strong> 的开发者都应该掌握这个接口。这接口用来动态的注册某一些具有相同特征的一批类到 <strong>Spring IoC</strong>，借助于<code>@Import</code>注解“附着在”自定义的注解上，就像 <strong>Mybatis-Spring</strong> 的用法一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将该注解附着到标记有<code>@Configuration</code>或者具有相同功能的配置类上，Spring 会在处理配置类时处理我们的 <code>Import</code> 注解。</p>
<p><code>MapperScannerRegistrar</code> 实现了该接口，该接口只定义了一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据导入的 <span class="doctag">@Configuration</span> 类上给定的注解元数据，根据需要注册 Bean 的定义。</span></span><br><span class="line"><span class="comment"> * 请注意，由于与 <span class="doctag">@Configuration</span> 类处理相关的生命周期限制，可能无法在此处注册 BeanDefinitionRegistryPostProcessor 类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> importingClassMetadata 导入类注解的元数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry 当前的 bean 定义注册表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span>;</span><br></pre></td></tr></table></figure>
<p>其中参数 <code>importingClassMetadata</code> 包含了 <code>@Import</code> 所依附的配置类上的所有注解。这意味着我们可以拿到对应注解的元信息并作为我们动态导入的判断依据，上面就是从 <code>@MapperScan</code> 获取了 <strong>Mapper</strong> 所在的包以及其它信息。</p>
<p>在拿到 <code>MapperScan</code> 注解的元数据后，我们为 <code>MapperScannerConfigurer</code> 提供了配置信息，该配置类又实现了 <code>BeanDefinitionRegistryPostProcessor</code> ，其继承于 <code>BeanDefinitionRegistry</code>。</p>
<p><code>BeanDefinitionRegistry</code> 就是用来注册 <strong>Spring Bean</strong> 的。那么到底是如何注册的呢？这就该下一个主角登场了。</p>
<h2 id="BeanDefinitionRegistryPostProcessor">BeanDefinitionRegistryPostProcessor</h2>
<p><code>BeanDefinitionRegistryPostProcessor</code> 是 <code>BeanFactoryPostProcessor</code> 的子接口。</p>
<p><code>BeanFactoryPostProcessor</code> 的作用是在 <strong>Spring Bean</strong> 的定义信息已经加载但还没有实例化的时候执行 <code>postProcessBeanFactory()</code> 来处理一些额外的逻辑，比如对 Bean 配置元数据进行操作。也就是说，Spring IoC 容器允许 <code>BeanFactoryPostProcessor</code> 读取配置元数据，并有可能在容器实例化除 <code>BeanFactoryPostProcessor</code> 实例之外的任何 bean之前更改它。</p>
<p>而 <code>BeanDefinitionRegistryPostProcessor</code> 的作用是在 <code>BeanFactoryPostProcessor</code> 增加了一个前置处理，当一个 <strong>Bean</strong> 实现了该接口后，始化前先执行该接口的 <code>postProcessBeanDefinitionRegistry()</code> 方法，然后再执行其父类的方法 <code>postProcessBeanFactory()</code>。这样就把一个 <strong>Spring Bean</strong> 的初始化周期更加细化，让我们在各个阶段有定制它的可能。</p>
<p><code>MapperScannerRegistrar</code> 并没有在该后置处理中注册 Bean，它将注册动作委托给 <code>ClassPathMapperScanner</code> 去扫描注册。</p>
<h2 id="ClassPathBeanDefinitionScanner">ClassPathBeanDefinitionScanner</h2>
<p>从名字上来看这个类就是在类路径下扫描 <strong>Bean</strong> 定义并将符合条件的批量通过 <code>BeanDefinitionRegistry</code> 注册到 <strong>Spring IoC</strong>。</p>
<p>它提供了可配置的过滤器来检出需要被注入 <strong>Spring IoC</strong> 的 <strong>Bean</strong>，默认的过滤器包括用 Spring 的 <code>@Component</code>、<code>@Repository</code>、 <code>@Service</code>、<code>@Controller</code> 注释的类 。还支持 Java EE 6 的 <code>javax.annotation.ManagedBean</code> 和 JSR-330 的 <code>javax.inject.Named</code> 注解，如果这些注解可用。当然你可以通过 <code>addIncludeFilter</code> 来新增被包含的 <strong>Bean</strong>，或者 <code>addExcludeFilter</code> 来排除一些 Bean。然后只需要调用其 <code>scan</code> 方法对特定的包进行扫描注入。</p>
<p>Mybatis 的 <code>ClassPathMapperScanner</code> 继承于 Spring 的 <code>ClassPathBeanDefinitionScanner</code> ，它为 Mapper 提供了 Mybatis 需要的参数变量，比如：<code>SqlSessionFactory</code> 以及 封装了 <code>SqlSession</code> 后线程安全的 <code>SqlSessionTemplate</code>，<code>SqlSessionTemplate</code> 还提供与 Spring 事物管理一起工作的能力。</p>
<p>在扫描到特定包下的 Mapper 对象时，会选择用实现 <code>FactoryBean</code> 接口的 <code>MapperFactoryBean</code> 作为该 Mapper 的工厂类，工厂类对其 Mapper 的获取最终委托给 Mybatis 的 <code>Configuration</code> 类来获取，Configuration 内部维护了已找到的 Mapper、结果映射配置等，Configuration 通过使用 <code>MapperProxyFactory</code> 实例化一个该 Mapper 的 <code>MapperProxy</code> 代理类，最终在我们调用 Mapper 接口时，会通过实现了 InvokeHandler 的代理类的 Invoke 去真正执行逻辑，流程如下图：</p>
<p><img data-src="../../images/jpa/mybatis/mybatis-mapper-proxy.svg" alt="mybatis-mapper-proxy"></p>
]]></content>
      <categories>
        <category>Persistence</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 JPA 和 Hibernate 映射 @OneToMany 关系的最好方式</title>
    <url>/persistence/%E4%BD%BF%E7%94%A8-JPA-%E5%92%8C-Hibernate-%E5%A4%84%E7%90%86-OneToMany-%E6%98%A0%E5%B0%84%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/</url>
    <content><![CDATA[<h2 id="引言-3">引言</h2>
<p>在关系数据库系统中，通过外键列来链接两个表之间的一对多关联，以便子表记录引用父表的主键。</p>
<p><img data-src="../../images/jpa/many-to-one.png" alt="Many To One"></p>
<p>尽管在关系型数据库管理系统（RDBMS）中可能很简单，但在涉及 JPA 时，一对多数据库关联可以通过 <code>@ManyToOne</code> 或 <code>@OneToMany</code> 关联来表示，因为面向对象编程（OOP）的关联可以是单向的，也可以是双向的。</p>
<span id="more"></span>
<p><code>@ManyToOne</code> 注解允许您在子实体映射中映射外键列，以便子实体具有对其父实体的实体对象引用。这是映射数据库一对多数据库关联的最自然方式，通常也是最有效的替代方法。</p>
<p>为方便起见，为了利用实体状态转换和脏检查机制，许多开发人员选择将子实体映射为父对象中的集合，为此，JPA 提供 <code>@OneToMany</code> 注解。</p>
<p>很多时候，最好用查询替换集合，这在查询性能方面要灵活得多。但是，有时候映射集合是正确的事情，然后你有两个选择：</p>
<ul>
<li>单向 <code>@OneToMany</code> 关联</li>
<li>双向 <code>@OneToMany</code> 关联</li>
</ul>
<p>双向关联要求子实体映射提供 <code>@ManyToOne</code> 注解，该注解<a target="_blank" rel="noopener" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-and-hibernate-cascade-types/">负责控制关联</a>。</p>
<p>另一方面，单向 <code>@OneToMany</code> 关联更简单，因为它只是在父端定义关系。在本文中，我将解释 <code>@OneToMany</code> 关联的问题，以及如何克服它们。</p>
<p>映射 <code>@OneToMany</code> 关联的方法有很多种。我们可以使用List或Set。 我们也可以定义@JoinColumn注释。 那么，让我们看看所有这些是如何工作的。</p>
<h2 id="单向-OneToMany">单向 <code>@OneToMany</code></h2>
<p>考虑我们有以下映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Post&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">        cascade = CascadeType.ALL, </span></span><br><span class="line"><span class="meta">        orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;PostComment&gt; comments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Entity(name = &quot;PostComment&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post_comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostComment</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String review;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果我们持久化1个 Post 和3个 PostComment：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Post</span>(<span class="string">&quot;First post&quot;</span>);</span><br><span class="line"> </span><br><span class="line">post.getComments().add(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PostComment</span>(<span class="string">&quot;My first review&quot;</span>)</span><br><span class="line">);</span><br><span class="line">post.getComments().add(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PostComment</span>(<span class="string">&quot;My second review&quot;</span>)</span><br><span class="line">);</span><br><span class="line">post.getComments().add(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PostComment</span>(<span class="string">&quot;My third review&quot;</span>)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">entityManager.persist(post);</span><br></pre></td></tr></table></figure>
<p>Hibernate 将执行以下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post (title, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;First post&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My first review&#x27;</span>, <span class="number">2</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My second review&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My third review&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_post_comment (Post_id, comments_id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_post_comment (Post_id, comments_id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_post_comment (Post_id, comments_id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>那是什么！为什么执行这么多查询？无论如何，post_post_comment 表的处理是什么？</p>
<p>默认情况下，这就是单向 <code>@OneToMany</code>  关联的工作方式，这是从数据库角度看它的样子：</p>
<p><img data-src="../../images/jpa/one-to-many.png" alt="One To Many"></p>
<p>对于数据库管理员（DBA）来说，这看起来更像是多对多数据库关联而不是一对多关系，并且它也不是很有效。 我们现在有三个表，而不是两个表，所以我们使用的存储空间超过了必要的数量。本来应该只有一个外键，我们现在有两个。我们最有可能将这些外键编入索引，因此我们需要两倍的内存来缓存此关联的索引。不太好！</p>
<h2 id="使用-JoinColumn-的单向-OneToMany">使用 <code>@JoinColumn</code> 的单向 <code>@OneToMany</code></h2>
<p>要解决上述额外的连接表问题，我们只需要添加 <code>@JoinColumn</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;post_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;PostComment&gt; comments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>@JoinColumn</code> 注解帮助 Hibernate（最着名的 JPA 提供者）找出 post_comment 表中一个 post_id 外键列来定义这种关联。</p>
<p>有了这个注释，当持久化三个 PostComment 实体时，我们得到以下 SQL 输出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post (title, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;First post&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My first review&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My second review&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My third review&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span>  <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>好一点，但这三个更新语句的目的是什么？</p>
<p>如果你看一下 <a target="_blank" rel="noopener" href="https://vladmihalcea.com/hibernate-facts-knowing-flush-operations-order-matters/">Hibernate flush order</a>，你会发现在处理集合元素之前执行了持久化操作。 这样，Hibernate 首先插入子记录而不使用外键，因为子实体不存储此信息。 在集合处理阶段，外键列会相应更新。</p>
<p>相同的逻辑适用于集合状态修改，因此从子集合中删除第一项时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">post.getComments().remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>Hibernate 执行两个语句而不是一个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id <span class="operator">=</span> <span class="keyword">null</span> <span class="keyword">where</span> post_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> post_comment <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样，首先执行父实体状态更改，这将触发子实体更新。之后，当处理集​​合时，orphan removal 操作将执行子行删除语句。</p>
<h2 id="双向-OneToMany">双向 <code>@OneToMany</code></h2>
<p>映射 <code>@OneToMany</code> 关联的最佳方法是依赖 <code>@ManyToOne</code> 端传播所有实体状态更改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Post&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">        mappedBy = &quot;post&quot;, </span></span><br><span class="line"><span class="meta">        cascade = CascadeType.ALL, </span></span><br><span class="line"><span class="meta">        orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;PostComment&gt; comments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComment</span><span class="params">(PostComment comment)</span> &#123;</span><br><span class="line">        comments.add(comment);</span><br><span class="line">        comment.setPost(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComment</span><span class="params">(PostComment comment)</span> &#123;</span><br><span class="line">        comments.remove(comment);</span><br><span class="line">        comment.setPost(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Entity(name = &quot;PostComment&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post_comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostComment</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String review;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;post_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Post post;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PostComment )) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="literal">null</span> &amp;&amp; id.equals(((PostComment) o).id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于上述映射有几点需要注意：</p>
<ul>
<li><code>@ManyToOne</code> 关联使用 <code>FetchType.LAZY</code>，否则，我们将使用 <code>EAGER</code> 提取，<a target="_blank" rel="noopener" href="https://vladmihalcea.com/eager-fetching-is-a-code-smell/">这对性能有害</a>。</li>
<li>父实体 Post 有两个实用方法（例如 addComment 和 removeComment），用于同步双向关联的两端。 无论何时使用双向关联，都应始终提供这些方法，否则，您将面临<a target="_blank" rel="noopener" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-and-hibernate-cascade-types/">非常微妙的状态传播问题</a>。</li>
<li>子实体 PostComment 实现了 equals 和 hashCode 方法。 由于我们不能依赖自然标识符进行相等性检查，因此我们需要使用实体标识符。但是，您需要正确执行此操作，以使所有实体状态转换中的相等性保持一致。因为我们依赖于 removeComment 的相等性，所以在双向关联中覆盖子实体的 equals 和 hashCode 是一种好习惯。</li>
</ul>
<p>如果我们持久化3个 PostComment:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Post post <span class="operator">=</span> <span class="keyword">new</span> Post(&quot;First post&quot;);</span><br><span class="line"> </span><br><span class="line">post.addComment(</span><br><span class="line">    <span class="keyword">new</span> PostComment(&quot;My first review&quot;)</span><br><span class="line">);</span><br><span class="line">post.addComment(</span><br><span class="line">    <span class="keyword">new</span> PostComment(&quot;My second review&quot;)</span><br><span class="line">);</span><br><span class="line">post.addComment(</span><br><span class="line">    <span class="keyword">new</span> PostComment(&quot;My third review&quot;)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">entityManager.persist(post);</span><br></pre></td></tr></table></figure>
<p>Hibernate 为每个持久化的 PostComment 实体生成一个 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post (title, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;First post&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (post_id, review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;My first review&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (post_id, review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;My second review&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (post_id, review, id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;My third review&#x27;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们移除一个 PostComment:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Post</span> <span class="variable">post</span> <span class="operator">=</span> entityManager.find( Post.class, <span class="number">1L</span> );</span><br><span class="line"><span class="type">PostComment</span> <span class="variable">comment1</span> <span class="operator">=</span> post.getComments().get( <span class="number">0</span> );</span><br><span class="line"> </span><br><span class="line">post.removeComment(comment1);</span><br></pre></td></tr></table></figure>
<p>只有一个删除 SQL 语句被执行:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> post_comment <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>因此，双向 <code>@OneToMany</code> 关联是在我们真正需要在父端映射一对多关系集合时的最佳方式。</p>
<h2 id="只有-ManyToOne">只有 <code>@ManyToOne</code></h2>
<p>虽然你可以有选择的使用 <code>@OneToMany</code> 注解，但这并不意味着它应该是每个一对多数据库关系的默认选项。 集合的问题在于，当子记录的数量相当有限时，我们才使用它们。</p>
<blockquote>
<p>因此，实际上，<code>@OneToMany</code> 只有当 Many(多) 意味着 Few(一些) 时才是实用的。也许 <code>@OneToFew</code><br>
会成为这个注解的更具启发性的名称。</p>
</blockquote>
<p>正如我在此 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/26328187/is-it-possible-to-limit-the-size-of-a-onetomany-collection-with-hibernate-or-jp/26329733#26329733">StackOverflow回答</a> 中所解释的那样，您无法限制 `@OneToMany 集合的大小，就像您使用查询级别分页一样。</p>
<p>因此，大多数情况下，子项上的 <code>@ManyToOne</code> 注解就是您需要的一切。 但是，如何获得与 Post 实体关联的子实体？</p>
<p>好吧，你只需要一个JPQL查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List<span class="operator">&lt;</span>PostComment<span class="operator">&gt;</span> comments <span class="operator">=</span> entityManager.createQuery(</span><br><span class="line">    &quot;select pc &quot; <span class="operator">+</span></span><br><span class="line">    &quot;from PostComment pc &quot; <span class="operator">+</span></span><br><span class="line">    &quot;where pc.post.id = :postId&quot;, PostComment.class)</span><br><span class="line">.setParameter( &quot;postId&quot;, <span class="number">1</span>L )</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<p>这会转换为简单的 SQL 查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pc.id <span class="keyword">AS</span> id1_1_,</span><br><span class="line">       pc.post_id <span class="keyword">AS</span> post_id3_1_,</span><br><span class="line">       pc.review <span class="keyword">AS</span> review2_1_</span><br><span class="line"><span class="keyword">from</span>   post_comment pc</span><br><span class="line"><span class="keyword">where</span>  pc.post_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>即使不再管理集合，在必要时添加/删除子实体也相当简单。 至于更新子对象，即使您不使用托管集合，脏检查机制也可以正常工作。 使用查询的好处在于，您可以按照自己喜欢的方式对其进行分页，这样，如果子实体的数量随时间增长，则应用程序性能不会受到影响。</p>
<h2 id="结论-2">结论</h2>
<p>正如您将在以后的文章中看到的那样，双向集合比单向集合更好，因为它们依赖于 <code>@ManyToOne</code> 关联，它在生成的 SQL 语句方面始终是高效的。</p>
<p>但是，即使它们非常方便，您也不必总是使用集合。 <code>@ManyToOne</code> 关联是映射一对多数据库关系的最自然且最有效的方式。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://vladmihalcea.com/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/"><em>原文链接</em></a></p>
</blockquote>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 JPA 和 Hibernate 将结果映射 DTO 的最好方式（翻译）</title>
    <url>/persistence/%E4%BD%BF%E7%94%A8-JPA-%E5%92%8C-Hibernate-%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-DTO-%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="实体模型">实体模型</h2>
<p>假设我们有以下 <code>Post</code> 实体：</p>
<p><img data-src="../../images/jpa/postentityfordtoprojection.png" alt="Post Domain"><br>
如果你需要修改实体，则需要抓取整个实体；但是如果你只是对其中的几列感兴趣，则使用 DTO 会更有效。</p>
<p>如果我们只是想选择 <code>Post</code> 的 <code>id</code> 和 <code>title</code>，如果抓取整个实体会比较浪费资源，接下来我们看下 JPA 和 Hibernate 怎么实现我们的目标。</p>
<span id="more"></span>
<h2 id="使用-JPA-映射-DTO">使用 JPA 映射 DTO</h2>
<p>在使用 JPA 或 Hibernate 查询实体的时候，你可以通过执行 JPQL 或着 Criteria API 以及原生的 SQL 查询。</p>
<ul>
<li>
<h3 id="使用-Tuple-和-JPQL-映射-DTO">使用 Tuple 和 JPQL 映射 DTO</h3>
</li>
</ul>
<p>如果你不想将映射应用到 DTO，你可以使用 JPA 的 <code>Tuple</code>, 如果使用 <code>Tuple</code> 映射，你的 JPQL 查询看起来是这样的：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Tuple&gt; postDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id as id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title as title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.createdOn &gt; :fromTimestamp&quot;</span>, Tuple.class)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br><span class="line"> </span><br><span class="line">assertFalse( postDTOs.isEmpty() );</span><br><span class="line"> </span><br><span class="line"><span class="type">Tuple</span> <span class="variable">postDTO</span> <span class="operator">=</span> postDTOs.get( <span class="number">0</span> );</span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="number">1L</span>, </span><br><span class="line">    postDTO.get( <span class="string">&quot;id&quot;</span> ) </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="string">&quot;High-Performance Java Persistence&quot;</span>, </span><br><span class="line">    postDTO.get( <span class="string">&quot;title&quot;</span> ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如您所见，<code>tuple</code> 是一种获取 DTO 投影的便捷方式，因为您不需要为需要支持的每种类型的投影指定 DTO 类。</p>
</blockquote>
<ul>
<li>
<h3 id="使用构造函数和-JPQL-映射-DTO">使用构造函数和 JPQL 映射 DTO</h3>
</li>
</ul>
<p>如果你想使用特定的类来映射 DTO，你可以使用构造函数来 New 一个你想要的参数列表的对象。</p>
<blockquote>
<p>DTO 类必须提供一个全参的构造函数来映射结果</p>
</blockquote>
<p>DTO 映射如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDTO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PostDTO</span><span class="params">(Number id, String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id.longValue();</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，使用构造函数的 JPQL 查询如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;PostDTO&gt; postDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select new &quot;</span> +</span><br><span class="line">    <span class="string">&quot;   com.vladmihalcea.book.hpjp.hibernate.query.dto.projection.jpa.PostDTO(&quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;   ) &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.createdOn &gt; :fromTimestamp&quot;</span>, PostDTO.class)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="使用-Tuple-和原生-SQL-查询-映射-DTO">使用 Tuple 和原生 SQL 查询 映射 DTO</h3>
</li>
</ul>
<p>从 Hibernate ORM 5.2.11开始，由于 HHH-11897 Jira 问题得到修复，您可以使用 Tuple 进行原生 SQL 查询。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;Tuple&gt; postDTOs = entityManager</span><br><span class="line">.createNativeQuery(</span><br><span class="line">    <span class="string">&quot;SELECT &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id AS id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title AS title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;FROM Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;WHERE p.created_on &gt; :fromTimestamp&quot;</span>, Tuple.class)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br><span class="line"> </span><br><span class="line">assertFalse( postDTOs.isEmpty() );</span><br><span class="line"> </span><br><span class="line"><span class="type">Tuple</span> <span class="variable">postDTO</span> <span class="operator">=</span> postDTOs.get( <span class="number">0</span> );</span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="number">1L</span>, </span><br><span class="line">    ((Number) postDTO.get( <span class="string">&quot;id&quot;</span> )).longValue() </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="string">&quot;High-Performance Java Persistence&quot;</span>, </span><br><span class="line">    postDTO.get( <span class="string">&quot;title&quot;</span> ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="使用-ConstructorResult-映射-DTO">使用 ConstructorResult 映射 DTO</h3>
</li>
</ul>
<p>对于原生的 SQl 查询，你不能使用构造函数，所以你需要使用一个命名原生查询（NamedNativeQuery）和配置一个 <code>SqlResultSetMapping</code>，这样你就可以通过构造函数或字段来填充 DTO 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedNativeQuery(</span></span><br><span class="line"><span class="meta">    name = &quot;PostDTO&quot;,</span></span><br><span class="line"><span class="meta">    query =</span></span><br><span class="line"><span class="meta">        &quot;SELECT &quot; +</span></span><br><span class="line"><span class="meta">        &quot;       p.id AS id, &quot; +</span></span><br><span class="line"><span class="meta">        &quot;       p.title AS title &quot; +</span></span><br><span class="line"><span class="meta">        &quot;FROM Post p &quot; +</span></span><br><span class="line"><span class="meta">        &quot;WHERE p.created_on &gt; :fromTimestamp&quot;,</span></span><br><span class="line"><span class="meta">    resultSetMapping = &quot;PostDTO&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@SqlResultSetMapping(</span></span><br><span class="line"><span class="meta">    name = &quot;PostDTO&quot;,</span></span><br><span class="line"><span class="meta">    classes = @ConstructorResult(</span></span><br><span class="line"><span class="meta">        targetClass = PostDTO.class,</span></span><br><span class="line"><span class="meta">        columns = &#123;</span></span><br><span class="line"><span class="meta">            @ColumnResult(name = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @ColumnResult(name = &quot;title&quot;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<p>使用下面的代码执行 SQL 映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PostDTO&gt; postDTOs = entityManager</span><br><span class="line">.createNamedQuery(<span class="string">&quot;PostDTO&quot;</span>)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<h2 id="使用-Hibernate-映射-DTO">使用 Hibernate 映射 DTO</h2>
<p>当然您可以将所有 JPA 特性在 Hibernate 上使用，因为 Hibernate 提供的特性比标准 Java Persistence 规范要多得多。</p>
<ul>
<li>
<h3 id="使用-ResultTransformer-和-JPQL-来映射-DTO">使用 ResultTransformer 和 JPQL 来映射 DTO</h3>
</li>
</ul>
<p>如前所述，<code>ResultTransformer</code> 允许您以任何方式自定义结果集，以便您可以使用它将典型的 Object [] 数组投影转换为 DTO 结果集。</p>
<p>这次，您不需要提供构造函数来匹配查询选择的实体属性。</p>
<blockquote>
<p>虽然你甚至不需要在你的DTO类中提供 setter，但是我们需要 setter，因为 id 列在数据库映射时会返回 BigInteger，而我们需要将它强制转换为 Long。</p>
<p>Hibernate 可以使用 Reflection 设置适当的字段，因此它比以前的 JPA 构造函数替代方案更灵活。</p>
</blockquote>
<p>考虑下面的 DTO 类：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostDTO</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Number id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTitle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 Hibernate 特定 <code>org.hibernate.query.Query</code> 接口的 <code>setResultTransformer</code> 方法转换结果集，该接口可以从 JPA <code>Query</code> 解析。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PostDTO&gt; postDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id as id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title as title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.createdOn &gt; :fromTimestamp&quot;</span>)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ).toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.unwrap( org.hibernate.query.Query.class )</span><br><span class="line">.setResultTransformer( Transformers.aliasToBean( PostDTO.class ) )</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="使用-ResultTransformer-和-原生-SQL-查询映射-DTO">使用 ResultTransformer 和 原生 SQL 查询映射 DTO</h3>
</li>
</ul>
<p>如果你想用原生 SQL 查询，你不需要经历声明<code>SqlResultSetMapping</code> 的所有麻烦，因为你可以使用 <code>AliasToBeanResultTransformer</code>，就像前面提到的 JPQL 示例的情况一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">postDTOs</span> <span class="operator">=</span> entityManager</span><br><span class="line">.createNativeQuery(</span><br><span class="line">    <span class="string">&quot;select &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id as id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title as title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.created_on &gt; :fromTimestamp&quot;</span>)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ).toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.unwrap( org.hibernate.query.NativeQuery.class )</span><br><span class="line">.setResultTransformer( Transformers.aliasToBean( PostDTO.class ) )</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么需要使用 ResultTransformer 自定义结果集映射</title>
    <url>/persistence/%E4%BD%BF%E7%94%A8-ResultTransformer-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>JPA 查询允许您获取实体或 <a target="_blank" rel="noopener" href="https://zeral.top/%E4%BD%BF%E7%94%A8-JPA-%E5%92%8C-Hibernate-%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-DTO-%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/">DTO 投影</a>。但是，有时需要一个组合的结果集。</p>
<h2 id="实体模型-2">实体模型</h2>
<p>假设我们有下面两个实体：</p>
<p><img data-src="../../images/jpa/personcountry.png" alt="Person Country"><br>
这两个实体没有通过 <code>@ManyToOne</code> 进行关联。但是，两个实体共享一个 locale 属性，我们可以使用它来在两者之间形成连接。</p>
<span id="more"></span>
<h2 id="在-DTO-投影中返回实体">在 DTO 投影中返回实体</h2>
<p>考虑我们将做下面的 DTO 的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonAndCountryDTO</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Person person;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String country;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonAndCountryDTO</span><span class="params">(</span></span><br><span class="line"><span class="params">        Person person, </span></span><br><span class="line"><span class="params">        String country)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">        <span class="built_in">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPerson</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCountry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 JPQL 查询大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PersonAndCountryDTO&gt; personAndAddressDTOs = entityManager.createQuery(</span><br><span class="line">    <span class="string">&quot;select new &quot;</span> +</span><br><span class="line">    <span class="string">&quot;   com.vladmihalcea.book.hpjp.hibernate.query.dto.PersonAndCountryDTO(&quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       c.name&quot;</span> +</span><br><span class="line">    <span class="string">&quot;   ) &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Person p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;join Country c on p.locale = c.locale &quot;</span> +</span><br><span class="line">    <span class="string">&quot;order by p.id&quot;</span>, PersonAndCountryDTO.class)</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<p>hibernate 生成的 sql 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> col_0_0_,</span><br><span class="line">       c.name <span class="keyword">AS</span> col_1_0_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">       Country c </span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">       ( p.locale <span class="operator">=</span> c.locale )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">       p.id</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> id1_1_0_,</span><br><span class="line">       p.locale <span class="keyword">AS</span> locale2_1_0_,</span><br><span class="line">       p.name <span class="keyword">AS</span> name3_1_0_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">WHERE</span>  p.id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> id1_1_0_,</span><br><span class="line">       p.locale <span class="keyword">AS</span> locale2_1_0_,</span><br><span class="line">       p.name <span class="keyword">AS</span> name3_1_0_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">WHERE</span>  p.id <span class="operator">=</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>Hibernate 5.2 实现的 DTO 投影无法在不执行辅助查询的情况下实现 <code>ResultSet</code> 中的 DTO 投影。但是，这对性能非常不利，因为它可能导致 N + 1 查询问题。</p>
<pre><code>Hibernate 6.0 新的 SQM 解析器可能会解决这个问题，
</code></pre>
<h2 id="ResultTransformer">ResultTransformer</h2>
<p>但是，您不仅限于使用 JPA。 Hibernate 提供了许多在标准中没有直接定义的增强功能。其中一个增强功能是 <code>ResultTransformer</code> 机制，它允许您以任何方式自定义<code>ResultSet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PersonAndCountryDTO&gt; personAndAddressDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select p, c.name &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Person p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;join Country c on p.locale = c.locale &quot;</span> +</span><br><span class="line">    <span class="string">&quot;order by p.id&quot;</span>)</span><br><span class="line">.unwrap( org.hibernate.query.Query.class )</span><br><span class="line">.setResultTransformer( </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ResultTransformer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">transformTuple</span><span class="params">(</span></span><br><span class="line"><span class="params">            Object[] tuple, </span></span><br><span class="line"><span class="params">            String[] aliases)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PersonAndCountryDTO</span>(</span><br><span class="line">                (Person) tuple[<span class="number">0</span>],</span><br><span class="line">                (String) tuple[<span class="number">1</span>]</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List <span class="title function_">transformList</span><span class="params">(List collection)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> collection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">)</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<p>此查询需要思考两件事：</p>
<ol>
<li><code>unwrap</code> 方法用于将 JPA <code>javax.persistence.Query</code> 转换为特定于 Hibernate 的 <code>org.hibernate.query.Query</code>，以便我们可以访问 <code>setResultTransformer</code> 方法。</li>
<li><code>ResultTransformer</code> 附带一个未遵循函数接口语法的旧定义。因此，在这个例子中我们不能使用 lambda。Hibernate 6.0 旨在克服这个问题，因此不推荐使用Hibernate ORM 5.2 <code>ResultTransformer</code>。尽管如此，还是会提供一种替代方案。</li>
</ol>
<p>运行上述 Hibernate ResultTransformer 查询时，Hibernate 会生成以下输出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> col_0_0_,</span><br><span class="line">       c.name <span class="keyword">AS</span> col_1_0_,</span><br><span class="line">       p.id <span class="keyword">AS</span> id1_1_,</span><br><span class="line">       p.locale <span class="keyword">AS</span> locale2_1_,</span><br><span class="line">       p.name <span class="keyword">AS</span> name3_1_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">       Country c </span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">       ( p.locale <span class="operator">=</span> c.locale )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">       p.id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ResultTransformer</tag>
      </tags>
  </entry>
  <entry>
    <title>双向关联最佳实践</title>
    <url>/persistence/%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>下面的最佳实践都是从性能角度证明双向关联的正确性。</p>
<h1>映射 @OneToMany 双向关联</h1>
<p><img data-src="../../images/jpa/one-to-many-author-book.png" alt="one-to-many-author-book"></p>
<p>一个作者对应多本发行书，<code>Parent</code> 端 为 <code>Author</code>，<code>Child</code> 端为 <code>Book</code>。</p>
<span id="more"></span>
<p>关键点：</p>
<h2 id="总是从-Parent-端到-Child-端级联操作">总是从 Parent 端到 Child 端级联操作</h2>
<p>父对象都不存在的情况下操作子，显然不合理。</p>
<ul>
<li>对于<strong>新增操作</strong>，如果 Parent 和 Child 的都是瞬时状态的数据调用级联新增（<code>CascadeType.PERSIST</code>）则没有问题。</li>
</ul>
<blockquote>
<p>如果传递的 Child 包含具有 ID 的分离（<code>Detached</code>）对象，persist 方法会抛出 <code>EntityExistsException</code>，因为（参见 <a target="_blank" rel="noopener" href="http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html">JPA 1.0 规范</a>的第 3.2.1 节）明确指出，传入的对象不能是分离的实体。</p>
</blockquote>
<p>对于一对多关联我们一般也不会传入已有的 Child。</p>
<ul>
<li>对于<strong>修改操作</strong>。</li>
</ul>
<p>首先明确一点，Spring Data JPA 对有标识符的对象调用 <code>save</code> 时，其实是调用的 JPA 的 <code>EntityManager.merge</code> 合并操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public &lt;S extends T&gt; S save(S entity) &#123;</span><br><span class="line">    if (entityInformation.isNew(entity)) &#123;</span><br><span class="line">        em.persist(entity);</span><br><span class="line">        return entity;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return em.merge(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>merge</code> 操作会先根据分离的实体的唯一标识查询出该实体的持久态，再去合并每一个字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Author <span class="title function_">merge</span><span class="params">(Author detached)</span> &#123;</span><br><span class="line">	<span class="type">Author</span> <span class="variable">newReference</span> <span class="operator">=</span> session.byId( Author.class ).load( detached.getId() );</span><br><span class="line">	<span class="comment">// 复制所有分离的对象属性到持久化的实体中</span></span><br><span class="line">	newReference.setName( detached.getName() );</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> newReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果启用了级联合并（<code>CascadeType.MERGE</code>），则会级联合并 Child 的字段，这要求我们传入的瞬时状态的数据得是完整的（级联合并下也包括 Child），否则就会被级联修改掉。</p>
<blockquote>
<p><strong>所以尽量不要使用 merge 操作，也不要使用级联合并，除非你知道他如何工作</strong></p>
</blockquote>
<p><strong>如果我们只是想修改 Author 的信息</strong>：</p>
<p>为了更好的控制要更新的字段，最好的方法是直接使用 HQL 或 JPQL 进行更新 update 语句操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;UPDATE Author SET name = :name WHERE id =:authorId&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">updateName</span><span class="params">(String name, Long authorId)</span>;</span><br></pre></td></tr></table></figure>
<p>或者先查询对象，对查询出的持久化状态实体进行字段修改，在会话结束时或手动 flush 时会自动更新到数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authorRepository.findById(<span class="number">1L</span>).ifPresent(author -&gt; &#123;</span><br><span class="line">    author.setAge(<span class="number">38</span>);</span><br><span class="line">    author.setName(<span class="string">&quot;Zeral&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>如果需要同步数据库持久化的 Author、Children 和传入的分离的 Author、Children 的状态。这里分两种情况讨论：</strong></p>
<ol>
<li>传入的数据是完整的，不管是要修改的 Author 部分变更字段还是无需变更字段，或者 Child 的变更字段和无需变更字段，即使我们只是想同步 Child 的关联状态。</li>
</ol>
<p>比如原始的数据为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mark Janel&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anthology&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A History of Ancient Prague&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;001-JN&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A People&#x27;s History&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;002-JN&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Beatles Anthology&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;001-MJ&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>想要修改为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alicia Tom&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anthology&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">38</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;001-JN&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A History of Ancient Prague&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;004-ZH&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Zeral&#x27;s Life&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们既要修改 Author 的信息，也要修改 Book ID 为 1 的信息，然后新增一个 Child，并移除缺失的 ID 为 2、3 的 Book。</p>
<p>可以直接使用 JPA <code>EntityManager.merge</code> 即可，通过级联修改（<code>CascadeType.MERGE</code>）操作，状态会正确被同步。</p>
<blockquote>
<p>在合并期间，实体的当前状态被复制到刚刚从数据库中获取的持久态实体版本上。这就是 Hibernate 会执行 SELECT 语句的原因，该语句获取 Author 实体及其子实体，和刚才描述的一样。</p>
<p>如果查询不是发起抓取 Author 及其子实体的查询，则可能发生 N+1 查询，则最好自己调用查询抓取所有。</p>
</blockquote>
<ol start="2">
<li>如果数据不完整，我们只想修改传入的变更字段。</li>
</ol>
<p>如果需要同步状态，并且保留已有的关联，可以先通过 <code>Fetch JOIN</code> 或 <code>EntityGraph</code> 操作将 Author 及其子实体查询出来，再去手动同步合并变更状态，<strong>这时不需要依赖级联合并操作。</strong></p>
<p>修改 Author 的信息如之前所述，对于一对多的 Child 集合的手动合并分为三步：</p>
<p><code>detachedBooks</code> 为传入的分离的 Author 的 Books。</p>
<ul>
<li>
<p>删除在数据库中存在但在传入的集合中已经不存在的数据行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">author.getBooks.removeIf(b -&gt; !detachedBooks.contains(b));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新数据库中和传入集合 ID 相同的数据行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Book&gt; newBooks = detachedBooks.stream()</span><br><span class="line">        .filter(b -&gt; !author.getBooks().contains(b))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他分离的实体</span></span><br><span class="line">detachedBooks.stream().filter(b -&gt; !newBooks.contains(b)).forEach((b) -&gt; &#123;</span><br><span class="line">        b.setAuthor(author);</span><br><span class="line">        <span class="type">Book</span> <span class="variable">mergedBook</span> <span class="operator">=</span> bookRepository.save(b);</span><br><span class="line">        author.getBooks().set(author.getBooks().indexOf(mergedBook), mergedBook);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加传入集合新增的数据到数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newBooks.forEach(b -&gt; author.addBook(b));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>更多方法详情见：<a target="_blank" rel="noopener" href="https://vladmihalcea.com/merge-entity-collections-jpa-hibernate/">https://vladmihalcea.com/merge-entity-collections-jpa-hibernate/</a></p>
<h2 id="在-Parent-方使用-mappedBy">在 Parent 方使用 <code>mappedBy</code></h2>
<p><code>mappedBy</code> 指向 Child 端的 <code>@ManyToOne</code> 对象字段的名称，它表示双向 <code>@OneToMany</code> 其实是数据库维护方 <code>@ManyToOne</code> 子端的镜像。</p>
<h2 id="在-Parent-方使用-orphanRemoval-以删除失去引用的-Child">在 Parent 方使用 <code>orphanRemoval</code> 以删除失去引用的 Child</h2>
<p><code>orphanRemoval</code> 表明如果将 Child 从 Parent 中移除，该 Child 将成为孤子，失去了 Parent 的引用，这时候将会被删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany(cascade = CascadeType.ALL, mappedBy = &quot;post&quot;, orphanRemoval = true)</span></span><br></pre></td></tr></table></figure>
<h2 id="在-Parent-端使用工具方法保持两边关联同步">在 Parent 端使用工具方法保持两边关联同步</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.books.add(book);</span><br><span class="line">    book.setAuthor(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    book.setAuthor(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">this</span>.books.remove(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBooks</span><span class="params">()</span> &#123;</span><br><span class="line">    Iterator&lt;Book&gt; iterator = <span class="built_in">this</span>.books.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">        book.setAuthor(<span class="literal">null</span>);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止前端传过来的数据没有设置 Child 对 Parent 的关联，可以将 Setter 方法设置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBooks</span><span class="params">(List&lt;Book&gt; books)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (books != <span class="literal">null</span> &amp;&amp; !books.isEmpty()) &#123;</span><br><span class="line">        books.forEach(book -&gt; book.setAuthor(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.books = books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在关联的两边都使用懒加载">在关联的两边都使用懒加载</h2>
<p>Parent 端 <code>@OneToMany</code> 默认为懒加载，但是在 <code>@ManyToOne</code> 端使用懒加载可以获得比较好的性能，比如我们在获取 Parent 的 Childs 时可以防止 N+1 查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br></pre></td></tr></table></figure>
<h2 id="正确实现-equals-和-hashcode">正确实现 <code>equals</code> 和 <code>hashcode</code></h2>
<p><code>equals</code> 和 <code>hashCode</code> 必须在所有<a target="_blank" rel="noopener" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-hibernate-entity-state-transitions/">实体状态转换中</a>表现一致。所以不管是瞬时状态还是持久化状态，对象的比较总是一致的。</p>
<p>因此，我们需要通过标识符来去比较对象，标识符分两种类型：</p>
<ul>
<li>分配的标识符</li>
<li>数据库生成的标识符</li>
</ul>
<h3 id="分配的标识符">分配的标识符</h3>
<p>在刷新 Persistence Context 之前分配分配的标识符，使用 <code>@NaturalId</code> 标识，我们可以进一步将它们分为两个子类别：</p>
<ul>
<li>
<p>自然标识符</p>
<p>比如 Book 的 ISBN。</p>
</li>
<li>
<p>与数据库无关的 UUID</p>
<p>与数据库无关的 UUID 编号是在数据库之外生成的，就像调用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html#randomUUID()"><code>java.util.UUID#randomUUID</code></a> 方法一样。</p>
</li>
</ul>
<p>自然标识符和与数据库无关的 UUID 都可以在实体被持久化前被知道。因此，在 <code>equals</code> 和 <code>hashCode</code> 实现中使用它们是安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Book&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Identifiable</span>&lt;Long&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NaturalId</span></span><br><span class="line">    <span class="keyword">private</span> String isbn;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Book)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> (Book) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(getIsbn(), book.getIsbn());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getIsbn());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库生成的标识符">数据库生成的标识符</h3>
<p>数据库生成的标识符是另一回事。因为标识符是在刷新时由数据库分配的，所以如果我们像分配标识符一样基于标识符实现 <code>equals</code> 和 <code>hashCode</code>，一致性保证就会中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Post&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Post</span> <span class="keyword">implements</span> <span class="title class_">Identifiable</span>&lt;Long&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Post</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Post))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Post</span> <span class="variable">other</span> <span class="operator">=</span> (Post) o;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> id != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">               id.equals(other.getId());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正确重写-toString">正确重写 <code>toString</code></h2>
<p>如果 <code>toString()</code> 需要被覆盖，那么注意只涉及从数据库加载实体时获取的<strong>基本属性</strong>。</p>
<h2 id="移除大量-Child-时使用批量操作">移除大量 Child 时使用批量操作</h2>
<p>注意移除操作，尤其是移除子实体。 <code>CascadeType.REMOVE</code> 和 <code>orphanRemoval=true</code> 可能会产生过多的查询。在这种情况下，依赖批量操作在大多数情况下是删除的最佳方式。</p>
<h1>映射 @ManyToMany 双向关联</h1>
<p><img data-src="../../images/jpa/many-to-many.png" alt="image-005"></p>
<h2 id="选择关系的所有者">选择关系的所有者</h2>
<p>使用默认的 <code>@ManyToMany</code> 映射需要开发人员选择关系的所有者和 <code>mappedBy</code> 端（也称为反向端）。只有一侧可以是所有者，连接表在拥有方指定，并且更改仅从这一特定侧传播到数据库，则非拥有方必须使用 <code>@ManyToMany</code> 注释的 <code>mappedBy</code> 元素来指定拥有方的关系字段或属性。例如，<code>Author</code>  可以是所有者，而 <code>Book</code> 端添加了 <code>mappingBy</code> 指定拥有方 <code>Author</code> 的 <code>books</code> 字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(mappedBy = &quot;books&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;Author&gt; authors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="总是使用-Set-而不是-List">总是使用 Set 而不是 List</h2>
<p>特别是如果涉及删除操作，建议依赖于 Set 而不是 List，因为 Set 的性能高于 List。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Book&gt; books = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();     <span class="comment">// in Author </span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Author&gt; authors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// in Book</span></span><br></pre></td></tr></table></figure>
<p>Hibernate 将 @ManyToMany 操作当作两个单向的 @OneToMany 操作处理，在此语句的上下文中，实体删除（或重新排序）导致从结表中删除所有关联条目，并重新插入它们以对照内存内容（当前持久性上下文内容）。</p>
<p>如果是 Set 集合的话只会删除单个条目，因为它不保证顺序。</p>
<p>要保留顺序可以使用 <code>@OrderBy</code> 语句，例如使用多个字段排序 ：<code>@OrderBy(&quot;age DESC, name ASC&quot;)</code>。</p>
<h2 id="保持两边关联同步">保持两边关联同步</h2>
<p>同样，我们可以使用之前提及的 <code>addBook</code>、<code>removeBook</code>、<code>removeBooks</code>、<code>setBooks</code> 工具方法保持两边同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.books.add(book);</span><br><span class="line">    book.getAuthors().add(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.books.remove(book);</span><br><span class="line">    book.getAuthors().remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBooks</span><span class="params">()</span> &#123;</span><br><span class="line">    Iterator&lt;Book&gt; iterator = <span class="built_in">this</span>.books.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">        book.getAuthors().remove(<span class="built_in">this</span>);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBooks</span><span class="params">(Set&lt;Book&gt; books)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(books)) &#123;</span><br><span class="line">        books.forEach(book -&gt; book.getAuthors().add(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.books = books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免-CascadeType-ALL-和-CascadeType-REMOVE">避免 CascadeType.ALL 和 CascadeType.REMOVE</h2>
<p>在大多数情况下，级联删除是糟糕的想法。 例如，删除 <code>Author</code> 实体不应触发 <code>Book</code> 删除，因为这本书也可以由其他作者引用（一本书可以由几位作者编写）。所以，避免 <code>CascadeType.ALL</code> 和 <code>CascadeType.REMOVE</code> 并依赖于显式 <code>CascadeType.PERSIST</code> 和 <code>CascadeType.MERGE</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;Book&gt; books = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>对于<strong>新增操作</strong>。这里分两种情况：</p>
<ol>
<li>
<p>如果 Parent 和 Child 的都是瞬时状态的数据使用级联新增（<code>CascadeType.PERSIST</code>）则没有问题，比如下面的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Alicia Tom&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">38</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;genre&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anthology&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;003-OG&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Zeral&#x27;s Life&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;004-MJ&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A People&#x27;s Life&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行 persist 会执行如下语句，级联新增会帮我们新增 Author 和两个 Book 及其关联。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author (age, genre, name) <span class="keyword">values</span> (?, ?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (isbn, title) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (isbn, title) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果我们的 Book 已存在，我们想在新增 Author 时让它帮我们绑定关系，使用级联新增会因为有分离的对象而报错。</p>
<ul>
<li>
<p>如果我们只是绑定关系，并且传递的值只包含关联 Author 的 ID，例如：<code>[&#123;id: 1&#125;, &#123;id: 2&#125;]</code>，<strong>则不需要任何级联操作</strong>。</p>
</li>
<li>
<p>如果需要在绑定关系的同时修改 Author，这时则可以<strong>只使用</strong> <code>CascadeType.MERGE</code> 来完成。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(cascade = &#123;CascadeType.MERGE&#125;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;Book&gt; books = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>执行 <strong>persist</strong> 会执行如下语句，级联修改会帮我们新增 Author 和两个 Book 的关联。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author (age, genre, name) <span class="keyword">values</span> (?, ?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>对于<strong>修改操作</strong>：</p>
<p>对于 Parent 字段的修改和之前描述的一样，多对多的关系我们一般只修改关联，无需额外的设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authorRepository.findById(detachedAuthor.getId()).ifPresent(author -&gt; &#123;</span><br><span class="line">    <span class="comment">// 修改 Parent 字段</span></span><br><span class="line">    author.setName(detachedAuthor.getName());</span><br><span class="line">    author.setAge(detachedAuthor.getAge());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只同步关系，不去新增修改 Book 的信息，这里传入的分离的 books 只包含 Id</span></span><br><span class="line">    author.setBooks(detachedAuthor.getBooks());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置关联表">设置关联表</h2>
<p>显式设置关联表名称和列名称允许开发人员在引用它们时避免混淆。 这可以通过 <code>@JoinTable</code> 完成，如下例所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JoinTable(name = &quot;author_book&quot;,           </span></span><br><span class="line"><span class="meta">					joinColumns = @JoinColumn(name = &quot;author_id&quot;, referencedColumnName = &quot;id&quot;),          // 当前实体连接字段</span></span><br><span class="line"><span class="meta">					inverseJoinColumns = @JoinColumn(name = &quot;book_id&quot;, referencedColumnName = &quot;id&quot;)      // 反向实体连接字段</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<h2 id="在关联两边都使用懒加载">在关联两边都使用懒加载</h2>
<p>ManyToMany 也支持双向关联，同样在非关系维护端可以使用 mappedBy 来映射维护方的关联数据；</p>
<p>默认情况下，@ManyToMany 关联是惰性加载的，不要给他使用立即加载。</p>
<h2 id="正确实现-equals-和-hashcode-2">正确实现 <code>equals</code> 和 <code>hashcode</code></h2>
<p>如上所述</p>
<h2 id="正确重写-toString-2">正确重写 <code>toString</code></h2>
<p>如上所述</p>
<h2 id="需要时使用两个双向的-OneToMany">需要时使用两个双向的 @OneToMany</h2>
<p>如果双向 <code>@OneToMany</code> 关联在删除或更改子元素的顺序时表现更好，或者需要直接操作关联表，则没必要使用 <code>@ManyToMany</code> 关系，因为外键端不受控制。为了克服这个限制，必须直接公开关联表并将 <code>@ManyToMany</code> 关联拆分为两个双向的 <code>@OneToMany</code> 关系。</p>
<p>最自然的 <code>@ManyToMany</code> 关联遵循数据库模式采用的相同逻辑，并且关联表的关联实体控制需要联接的双方的关系。</p>
<p>在这里 Author 和 Book 都使用 @OneToMany mappedBy 到关系维护方中间表 AuthorBook，AuthorBook 使用 Author_Id 和 Book_Id 作为联合主键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String genre;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">            mappedBy = &quot;author&quot;,</span></span><br><span class="line"><span class="meta">            cascade = CascadeType.ALL,</span></span><br><span class="line"><span class="meta">            orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AuthorBook&gt; books = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了简洁期间省略 Getter 和 Setter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="type">AuthorBook</span> <span class="variable">AuthorBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorBook</span>( <span class="built_in">this</span>, book );</span><br><span class="line">        books.add( AuthorBook );</span><br><span class="line">        book.getAuthors().add( AuthorBook );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        <span class="type">AuthorBook</span> <span class="variable">AuthorBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorBook</span>( <span class="built_in">this</span>, book );</span><br><span class="line">        book.getAuthors().remove( AuthorBook );</span><br><span class="line">        books.remove( AuthorBook );</span><br><span class="line">        AuthorBook.setAuthor( <span class="literal">null</span> );</span><br><span class="line">        AuthorBook.setBook( <span class="literal">null</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;     </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id != <span class="literal">null</span> &amp;&amp; id.equals(((Author) obj).id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2021</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Author&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name</span><br><span class="line">                + <span class="string">&quot;, genre=&quot;</span> + genre + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorBook</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@ManyToOne</span></span><br><span class="line">	<span class="keyword">private</span> Author author;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@ManyToOne</span></span><br><span class="line">	<span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了简洁期间省略 Getter 和 Setter</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">this</span> == o ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( o == <span class="literal">null</span> || getClass() != o.getClass() ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">AuthorBook</span> <span class="variable">that</span> <span class="operator">=</span> (AuthorBook) o;</span><br><span class="line">		<span class="keyword">return</span> Objects.equals(author, that.author) &amp;&amp;</span><br><span class="line">				Objects.equals(book, that.book);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hash(author, book);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JPA 不允许使用多个 Id 注解，可以使用组合 Id：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorBookId</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Column(name = &quot;author_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long authorId;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Column(name = &quot;book_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bookId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorBookId</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorBookId</span><span class="params">(Long authorId, Long bookId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authorId = authorId;</span><br><span class="line">        <span class="built_in">this</span>.bookId = bookId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了简洁省略 getter、setter、hashcode、equals...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorBook</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@EmbeddedId</span></span><br><span class="line">    <span class="keyword">private</span> AuthorBookId id;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@MapsId(&quot;authorId&quot;)</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Author author;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@MapsId(&quot;bookId&quot;)</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorBook</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthorBook</span><span class="params">(Author author, Book book)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.book = book;</span><br><span class="line">        <span class="built_in">this</span>.id = <span class="keyword">new</span> <span class="title class_">AuthorBookId</span>(author.getId(), book.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了简洁省略 getter、setter、hashcode、equals...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String isbn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">            mappedBy = &quot;book&quot;,</span></span><br><span class="line"><span class="meta">            cascade = CascadeType.ALL,</span></span><br><span class="line"><span class="meta">            orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;AuthorBook&gt; authors = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了简洁期间省略 Getter 和 Setter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> id != <span class="literal">null</span> &amp;&amp; id.equals(((Book) obj).id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2021</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, title=&quot;</span> + title + <span class="string">&quot;, isbn=&quot;</span> + isbn + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ManyToMany</tag>
        <tag>OneToMany</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 Spring Data JPA</title>
    <url>/persistence/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Spring%20Data%20JPA/</url>
    <content><![CDATA[<h2 id="整体流程">整体流程</h2>
<p>创建过程：</p>
<ul>
<li>
<p>Spring 刷新上下文 -&gt; 实例化 Bean -&gt;  调用初始化 Hook</p>
<ul>
<li>
<p>使用 <code>JpaRepositoryFactoryBean</code> 构建仓库工厂 Bean</p>
<p>默认非 Lazy 启动模式下创建仓库实例 -&gt; 创建代理工厂代理该实例 -&gt; 代理工厂使用切面添加多个 Advice：比如方法调用校验器、接口默认方法拦截器、自定义方法实现拦截器、自定义接口实现拦截器</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="../../images/jpa/spring-data-jpa/core-sequence-diagram.svg" alt="core-sequence-diagram"></p>
<span id="more"></span>
<h2 id="自定义方法实现拦截器">自定义方法实现拦截器</h2>
<p>针对自定义方法实现拦截器：<code>QueryExecutorMethodInterceptor</code></p>
<p>在创建该拦截器时，会使用 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-lookup-strategies">Query Lookup Strategy</a> 来查找合适的查询实现，查询实现负责基于该方法使用其参数查询并返回结果，该策略默认值为 <strong><code>CREATE_IF_NOT_FOUND</code></strong>，会先去找定义的查询：比如先使用基于 <code>@Query</code> 的注解来构建查询，如果不存在则使用 <code>@Procedure</code> 注解构建存储过程查询，最后再尝试查找命名查询，如果都不存在，则使用 <code>PartTreeJpaQuery</code> 构建基于方法名的查询。</p>
<p><code>PartTreeJpaQuery</code> 将方法名根据前缀模版正则分隔成 <strong><code>主体-Subject</code></strong> 和 <strong><code>谓词-Predicate</code></strong> 两部分，谓词又使用 <code>Or</code> 划分成多个 <code>OrPart</code>，<code>OrPart</code> 又由 <code>And</code> 拆分为多个 <code>Part</code>，<code>Part</code> 包含两部分：根据关键字判定为不同的查询条件的类型和该条件对应的实体属性，有了这些 <code>Part</code> 就可以用来构建 <code>javax.criteria.Predicate</code> 并最终构建出 <code>javax.criteria.CriteriaQuery</code>，这是 JAVAEE/Jakarta 的标准动态查询接口。</p>
<p>该拦截器被作为 Spring AOP 动态代理实现的仓库实例方法的切面通知（Advice）（由于我们是基于接口的代理，内部使用的是 <code>JdkDynamicAopProxy</code>），当我们调用仓库接口方法时，会通过 AOP 的调用链调用到我们的方法拦截器。</p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Hibernate N+1 问题</title>
    <url>/persistence/%E8%A7%A3%E5%86%B3-Hibernate-N+1-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1>问题</h1>
<p>作为一个例子，我将使用在线图书订购应用程序的简化版本。在这样的应用程序中，我可能会创建一个如下所示的实体来代表采购订单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String customerId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(cascade = ALL, fetch = EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;purchase_order_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;PurchaseOrderItem&gt; purchaseOrderItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>采购订单包括订单 ID，客户 ID 以及正在购买的一个或多个商品。 PurchaseOrderItem 实体可能具有以下结构 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseOrderItem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bookId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设我们需要查找客户的订单以在其采购订单历史记录中显示它们。以下查询将用于此目的 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    P</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    PurchaseOrder P</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    P.customerId <span class="operator">=</span> :customerId</span><br></pre></td></tr></table></figure>
<p>转换为 SQL 时看起来如下所示 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    purchaseor0_.id <span class="keyword">as</span> id1_1_,</span><br><span class="line">    purchaseor0_.customer_id <span class="keyword">as</span> customer2_1_ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    purchase_order purchaseor0_ </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    purchaseor0_.customer_id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>
<p>这一个查询将返回客户拥有的所有采购订单。但是，为了获取订单商品，在我们遍历订单商品时，JPA 将为每个订单发出单独的查询。例如，如果客户有 5 个订单，那么 JPA 将发出 5 个额外的查询来获取这些订单中包含的订单商品。这就是 <code>N + 1</code> 问题 - 每个订单的查询导致 N 个订单商品的查询。</p>
<h1>抓取</h1>
<p>在理解问题和探索解决方法之前，我们先理解下 JPA 的抓取操作。</p>
<p>抓取本质上讲是从数据库中获取数据并将其提供给应用程序的过程。调整应用程序的抓取方式将决定应用程序如何执行，就宽度（值/列）和/或深度（结果/行）而言，获取太多数据会增加 JDBC 通信和 ResultSet 处理方面的不必要开销。抓取的数据太少可能会导致需要进行额外的抓取。调整应用程序获取数据的方式可以影响整体应用程序性能。</p>
<p>抓取的概念主要分为两个问题：</p>
<ul>
<li>什么时候数据需要被抓取？立即还是延迟？</li>
<li>数据以何种方式被抓取？</li>
</ul>
<p>hibernate 在不同的范围定义了抓取，通过 hibernate 的 <code>Fetch</code> 注解我们可以定义如何抓取数据，通过 <code>javax.persistence</code> 中 <code>@Baisc</code>、<code>@ManyToOne</code>、<code>@OneToMany</code> 等注解上的 <code>fetch</code> 属性 <code>javax.persistence.FetchType</code> 定义何时抓取数据。</p>
<p><strong><em>静态</em>（编译时）</strong></p>
<p>我们可以在定义映射时静态定义抓取策略。</p>
<ul>
<li><code>SELECT</code></li>
</ul>
<p>执行单独的 SQL 查询以加载数据。可以是 EAGER（立即发出第二个查询）或 LAZY（延迟第二个查询直到需要数据）。这就是通常所说的 N + 1 策略。</p>
<ul>
<li><code>JOIN</code></li>
</ul>
<p>通过使用 SQL 外部联接 (OUTER JOIN) 抓取要获取的数据。使用该类型时数据以 EAGER 形式加载，即使指明了 LAZY。</p>
<blockquote>
<p>当使用主键查询单个实体时，该注解正常工作。例如 Spring Data JPA 中的 findOne、findById，当使用 findAll 时，会继续使用 N+1 查询。</p>
<p>Join 查询会产生重复的结果，需要使用 Set 存储结果集等其它方式去重。</p>
</blockquote>
<ul>
<li><code>BATCH</code></li>
</ul>
<p>根据批次大小，使用 IN 限制作为 SQL WHERE 子句的一部分，执行单独的 SQL 查询以加载相关数据项。同样可以和 EAGER 或 LAZY 一起使用。</p>
<ul>
<li><code>SUBSELECT</code></li>
</ul>
<p>根据集合所有者构建单独的 SQL 查询加载关联的数据。同样可以和 EAGER 或 LAZY 一起使用。</p>
<blockquote>
<p>子查询会将所有关联的数据全部加载到内存中，例如用在 @OneToMany 上时，如果关联数据不多时可以使用。</p>
</blockquote>
<p><em><strong>动态（运行时）</strong></em></p>
<p>动态提供了更加灵活的运行时抓取策略定义方式。</p>
<ul>
<li><em>fetch profiles</em></li>
</ul>
<p>在映射中定义，但可以在会话上启用/禁用。</p>
<ul>
<li>HQL/JPQL</li>
</ul>
<p>Hibernate 和 JPA Criteria 查询都可以指定特定于该查询的抓取定义。</p>
<ul>
<li>entity graphs</li>
</ul>
<p>从 Hibernate 4.2（JPA 2.1）开始，实体图为我们提供了更加详细的抓取方案定义。</p>
<p>了解了抓取之后，我们就可以找到解决问题的方法。</p>
<h1>解决方法</h1>
<h2 id="避免使用立即抓取（Eager-Fetching）">避免使用立即抓取（Eager Fetching）</h2>
<p>这是问题背后的主要原因。我们应该从我们的映射中摆脱所有立即抓取。它们几乎没有任何好处可以证明它们在生产级应用中的使用。我们应该将所有关系标记为懒惰。</p>
<h2 id="只抓取你真实需要的数据">只抓取你真实需要的数据</h2>
<p>有时候我们并不想在查询订单时关联出所有的订单记录，我们可以将订单记录设为懒加载，在自己真实需要时再去查询对应的数据。</p>
<h2 id="在-JPQL-中使用-Fetch-Join">在 JPQL 中使用 Fetch Join</h2>
<p>初始化延迟关联的更好选择是使用带有抓取连接的 JPQL 查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Query</span> <span class="variable">q</span> <span class="operator">=</span> <span class="built_in">this</span>.em.createQuery(<span class="string">&quot;SELECT o FROM Order o JOIN FETCH o.items i WHERE o.id = :id&quot;</span>);</span><br><span class="line">q.setParameter(<span class="string">&quot;id&quot;</span>, orderId);</span><br><span class="line">newOrder = (Order) q.getSingleResult();</span><br></pre></td></tr></table></figure>
<p>这告诉实体管理器在同一查询中加载所选实体和关系。</p>
<h2 id="使用-BatchSize-批量抓取">使用 BatchSize 批量抓取</h2>
<p>批量抓取是惰性选择抓取策略的优化。假设该订单的商品条目有 25 个，当配置了 BatchSize 后，在请求订单时，查询将变为 3 条，每条语句使用 In 查询 5 个商品条目。</p>
<p>使用 <code>@BatchSize</code> 注解可以配置到懒加载的集合或对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@BatchSize(size=100)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PurchaseOrderItem</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@BatchSize(size = 5)</span> /</span><br><span class="line"><span class="keyword">private</span> List&lt;PurchaseOrderItem&gt; <span class="title function_">purchaseOrderItems</span><span class="params">()</span> = &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实体图（Entity-Graph）">实体图（Entity Graph）</h2>
<p>实体图是特定化查询或操作的模板。它们在创建**抓取方案（fetch plans）**时使用。应用程序开发人员使用抓取方案将相关的持久字段组合在一起以提高运行时性能。</p>
<p>默认情况下，实体字段或属性是**懒抓取（lazy fetch）**的。开发人员将字段或属性指定为抓取方案的一部分，持久性 provider 将立即抓取（eager fetch）它们。</p>
<p>我们可以使用<strong>注解</strong>或<strong>部署描述符(比如 web.xml)<strong>静态创建实体图，也可以使用</strong>标准接口动态创建</strong>实体图。</p>
<p>实体图定义了在查找或查询操作期间需要立即抓取的字段。</p>
<p>默认，实体的所有字段都是懒抓取，除非指定了实体元数据的 <code>fetch</code> 属性为 <code>javax.persistence.FetchType.EAGER</code>。但是主键和版本字段始终是立即抓取的，不需要将其显式添加到实体图中。</p>
<p>创建的实体图可以是 <code>fetch graph(抓取图)</code> 或 <code>load graph(加载图)</code>。</p>
<h3 id="Fetch-Graphs（抓取图）">Fetch Graphs（抓取图）</h3>
<p>当 <code>javax.persistence.fetchgraph</code> 属性用于指定实体图时，实体图的属性节点指定的属性将被视为 <code>FetchType.EAGER</code>，未指定的属性将被视为 <code>FetchType.LAZY</code>。 以下规则适用，具体取决于属性类型。</p>
<h3 id="Load-Graphs（加载图）">Load Graphs（加载图）</h3>
<p>当 <code>javax.persistence.loadgraph</code> 属性用于指定实体图时，实体图的属性节点指定的属性将被视为 <code>FetchType.EAGER</code>，未指定的属性将根据其指定的或默认的<code>FetchType</code> 进行处理。</p>
<h3 id="命名实体图（Named-Entity-Graph）">命名实体图（Named Entity Graph）</h3>
<p>命名实体图是由应用于实体类的 <code>@NamedEntityGraph</code> 注解定义的实体图，或应用程序部署描述符中的 <code>named-entity-graph</code> 元素。部署描述符中定义的命名实体图覆盖任何具有相同名称的基于注解的实体图。</p>
<p>通过使用 <code>javax.persistence.NamedAttributeNode</code> 注解在 <code>@NamedEntityGraph</code> 的 <code>attributeNodes</code> 元素中指定字段，将字段添加到实体图中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedEntityGraph(name=&quot;emailEntityGraph&quot;, attributeNodes=&#123;</span></span><br><span class="line"><span class="meta">    @NamedAttributeNode(&quot;subject&quot;),</span></span><br><span class="line"><span class="meta">    @NamedAttributeNode(&quot;sender&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailMessage</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    String messageId;</span><br><span class="line">    String subject;</span><br><span class="line">    String body;</span><br><span class="line">    String sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在 <code>@NamedEntityGraphs</code> 注解中对多个 <code>@NamedEntityGraph</code> 定义进行分组，可以将多个 <code>@NamedEntityGraph</code> 定义应用于类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedEntityGraphs(&#123;</span></span><br><span class="line"><span class="meta">    @NamedEntityGraph(name=&quot;previewEmailEntityGraph&quot;, attributeNodes=&#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;subject&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;sender&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;body&quot;)</span></span><br><span class="line"><span class="meta">    &#125;),</span></span><br><span class="line"><span class="meta">    @NamedEntityGraph(name=&quot;fullEmailEntityGraph&quot;, attributeNodes=&#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;sender&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;subject&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;body&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;attachments&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailMessage</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>通过为命名实体图调用 <code>EntityManager.getEntityGraph</code> 来获取定义的命名实体图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph&lt;EmailMessage&gt; eg = em.getEntityGraph(<span class="string">&quot;emailEntityGraph&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="在查询操作中使用-Entity-Graphs">在查询操作中使用 Entity Graphs</h3>
<p>要为有类型和无类型查询指定实体图，请在查询对象上调用 <code>setHint</code> 方法，并指定 <code>javax.persistence.loadgraph</code> 或 <code>javax.persistence.fetchgraph</code> 作为属性名称，并将 <code>EntityGraph</code> 实例指定为值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph&lt;EmailMessage&gt; eg = em.getEntityGraph(<span class="string">&quot;previewEmailEntityGraph&quot;</span>);</span><br><span class="line">List&lt;EmailMessage&gt; messages = em.createNamedQuery(<span class="string">&quot;findAllEmailMessages&quot;</span>)</span><br><span class="line">        .setParameter(<span class="string">&quot;mailbox&quot;</span>, <span class="string">&quot;inbox&quot;</span>)</span><br><span class="line">        .setHint(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>, eg)</span><br><span class="line">        .getResultList();</span><br></pre></td></tr></table></figure>
<p>有类型的查询使用相同的技术：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph&lt;EmailMessage&gt; eg = em.getEntityGraph(<span class="string">&quot;previewEmailEntityGraph&quot;</span>);</span><br><span class="line"></span><br><span class="line">CriteriaQuery&lt;EmailMessage&gt; cq = cb.createQuery(EmailMessage.class);</span><br><span class="line">Root&lt;EmailMessage&gt; message = cq.from(EmailMessage.class);</span><br><span class="line">TypedQuery&lt;EmailMessage&gt; q = em.createQuery(cq);</span><br><span class="line">q.setHint(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>, eg);</span><br><span class="line">List&lt;EmailMessage&gt; messages = q.getResultList();</span><br></pre></td></tr></table></figure>
<h3 id="动态实体图（Dynamic-Entity-Graph）">动态实体图（Dynamic Entity Graph）</h3>
<p>创建动态实体图可以使用：<code>EntityManager.createEntityGraph</code></p>
<p>动态实体图 类似于命名的 entity graph。唯一的区别是，entity graph 是通过 Java API 定义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EntityGraph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="built_in">this</span>.em.createEntityGraph(Order.class);</span><br><span class="line"><span class="type">Subgraph</span> <span class="variable">itemGraph</span> <span class="operator">=</span> graph.addSubgraph(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="type">Map</span> <span class="variable">hints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">hints.put(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>, graph);</span><br><span class="line">  </span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="built_in">this</span>.em.find(Order.class, orderId, hints);</span><br></pre></td></tr></table></figure>
<p>使用代码动态创建 entity graph 允许我们可以不使用实体上的注解。因此，如果您需要创建一个不会重复使用的特定于用例的图表，我建议使用动态实体图。如果要重用实体图，则更容易注释命名实体图。</p>
<h3 id="Spring-Data-JPA-中使用-Entity-Graph">Spring Data JPA 中使用 Entity Graph</h3>
<p>在 Spring Data JPA 中，我们可以通过在查询接口方法上使用注解 <code>org.springframework.data.jpa.repository.EntityGraph</code> 来定义命名实体图或动态实体图：</p>
<ul>
<li>
<p>通过指定 <code>value</code> 属性指定命名实体图</p>
</li>
<li>
<p>通过指定 <code>attributePaths</code> 属性动态定义实体图</p>
<p>该属性为数组类型，我们可以定义多个 <code>attribute</code>，也可以通过 <code>property.nestedProperty</code> 形式来定义实体对象字段嵌套的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EntityGraph(attributePaths = &#123;&quot;questions&quot;, &quot;questions.questionOptions&quot;, &quot;questions.answers&quot;&#125;)</span></span><br><span class="line">    Optional&lt;Questionnaire&gt; <span class="title function_">findOneByProject_Id</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="存在问题">存在问题</h3>
<ol>
<li>
<p>从理论上讲，抓取类型为 fetch 时，只有指定的属性会被立即加载，但是在 Hibernate <code>5.4.11</code> 之前，它还会读取实体映射属性上定义的抓取时机为 Eager 的属性，<a target="_blank" rel="noopener" href="https://hibernate.atlassian.net/browse/HHH-8776">该问题（HHH-8776）</a>已被修复。对应于 <code>spring-boot-starter-data-jpa</code> 版本 <code>2.2.5.RELEASE+</code> 都可以正常使用。</p>
</li>
<li>
<p><strong>JPA 图抓取规范不适用于 Hibernate 中的 basic（<code>@Basic</code>）属性。</strong> 换句话说，默认情况下，<code>@Basic</code> 这些属性依赖于默认的提取策略。默认的提取策略为 <code>FetchType.EAGER</code>。即使未明确指定这些属性，在使用实体图抓取的情况下也会加载这些属性。<strong>除非我们开启了字节码增强功能，基本属性使用 <code>@Basic(fetch = FetchType.LAZY)</code> 才会起作用。</strong></p>
</li>
<li>
<p>Spring Data JPA 暂只支持在注解中定义抓取属性，不能运行时动态指定。我们可以借助 <a target="_blank" rel="noopener" href="https://github.com/Cosium/spring-data-jpa-entity-graph">https://github.com/Cosium/spring-data-jpa-entity-graph</a> 该库弥补这个问题，或者自己拓展一个基础仓库类。</p>
</li>
</ol>
<p>如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseRepository</span>&lt;T, ID&gt; <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">		Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Predicate predicate, Pageable pageable, JpaEntityGraph jpaEntityGraph)</span>;</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Predicate predicate, JpaEntityGraph jpaEntityGraph)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseRepositoryImpl</span>&lt;T, ID <span class="keyword">extends</span> <span class="title class_">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title class_">SimpleJpaRepository</span>&lt;T, ID&gt; <span class="keyword">implements</span> <span class="title class_">BaseRepository</span>&lt;T, ID&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BaseRepositoryImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JpaEntityInformation&lt;T, ID&gt; entityInformation;</span><br><span class="line">    <span class="keyword">private</span> EntityPath&lt;T&gt; path;</span><br><span class="line">    <span class="keyword">private</span> Querydsl querydsl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JPAQueryFactory jpaQueryFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseRepositoryImpl</span><span class="params">(JpaEntityInformation&lt;T, ID&gt; entityInformation, EntityManager entityManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(entityInformation, entityManager);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.entityManager = entityManager;</span><br><span class="line">        <span class="built_in">this</span>.entityInformation = entityInformation;</span><br><span class="line">        <span class="built_in">this</span>.jpaQueryFactory = <span class="keyword">new</span> <span class="title class_">JPAQueryFactory</span>(entityManager);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.path = SimpleEntityPathResolver.INSTANCE.createPath(entityInformation.getJavaType());</span><br><span class="line">            <span class="built_in">this</span>.querydsl = <span class="keyword">new</span> <span class="title class_">Querydsl</span>(entityManager, <span class="keyword">new</span> <span class="title class_">PathBuilder</span>&lt;T&gt;(path.getType(), path.getMetadata()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125; 未找到 Q 生成文件，请检查代码&quot;</span>, entityInformation.getJavaType().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Predicate predicate, Pageable pageable, JpaEntityGraph jpaEntityGraph)</span> &#123;</span><br><span class="line">        Assert.notNull(pageable, <span class="string">&quot;Pageable must not be null!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免内存分页，修复 HHH000104: firstResult/maxResults specified with collection fetch; applying in memory! 警告</span></span><br><span class="line">        <span class="comment">// 解决方法如该文章描述分两步查：https://vladmihalcea.com/fix-hibernate-hhh000104-entity-fetch-pagination-warning-message/</span></span><br><span class="line">        SingularAttribute&lt;? <span class="built_in">super</span> T, ?&gt; idAttribute = entityInformation.getIdAttribute();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> idAttribute != <span class="literal">null</span>;</span><br><span class="line">        JPQLQuery&lt;T&gt; query = querydsl.applyPagination(pageable, doCreateQuery(<span class="literal">null</span>, predicate).select(ExpressionUtils.path(getDomainClass(), path, idAttribute.getName())));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> QueryResults&lt;T&gt; results = query.fetchResults();</span><br><span class="line"></span><br><span class="line">        <span class="type">Predicate</span> <span class="variable">pagePredicate</span> <span class="operator">=</span> ExpressionUtils.in(ExpressionUtils.path(<span class="built_in">this</span>.path.getClass(), idAttribute.getName()), results.getResults());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> AbstractJPAQuery&lt;Object, JPAQuery&lt;Object&gt;&gt; domainContentQuery = doCreateQuery(jpaEntityGraph, pagePredicate);</span><br><span class="line">        <span class="keyword">for</span> (Sort.Order o : pageable.getSort()) &#123;</span><br><span class="line">            domainContentQuery.orderBy(<span class="keyword">new</span> <span class="title class_">OrderSpecifier</span>&lt;&gt;(o.isAscending() ? Order.ASC : Order.DESC, Expressions.stringPath(o.getProperty())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PageableExecutionUtils.getPage(domainContentQuery.select(path).fetch(), pageable, results::getTotal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;T&gt; <span class="title function_">findAll</span><span class="params">(Predicate predicate, JpaEntityGraph jpaEntityGraph)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doCreateQuery(jpaEntityGraph, predicate).select(path).fetch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> JPQLQuery&#125; count query for the given &#123;<span class="doctag">@link</span> Predicate&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> predicate, can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the Querydsl count &#123;<span class="doctag">@link</span> JPQLQuery&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> JPQLQuery&lt;?&gt; createCountQuery(<span class="meta">@Nullable</span> Predicate... predicate) &#123;</span><br><span class="line">        <span class="keyword">return</span> doCreateQuery(<span class="literal">null</span>, predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractJPAQuery&lt;?, ?&gt; doCreateQuery(JpaEntityGraph jpaEntityGraph, <span class="meta">@Nullable</span> Predicate... predicate) &#123;</span><br><span class="line"></span><br><span class="line">        AbstractJPAQuery&lt;?, ?&gt; query = querydsl.createQuery(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (predicate != <span class="literal">null</span>) &#123;</span><br><span class="line">            query = query.where(predicate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; hints = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Jpa21Utils.tryGetFetchGraphHints(entityManager, jpaEntityGraph, entityInformation.getJavaType()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; hint : hints.entrySet()) &#123;</span><br><span class="line">            query.setHint(hint.getKey(), hint.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>N+1 Problem</tag>
        <tag>Entity Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Starter 简介</title>
    <url>/spring/Spring-Boot-Starter-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1>概述</h1>
<p>Spring Boot Starters 是一系列为我们提供方便的依赖项描述符，通过在应用中加入这些依赖项描述符，我们就可以很方便的集齐所有需要的依赖和相关技术，不用再为解决依赖问题而浪费时间。比如你想使用 Spring 和 JPA 访问数据，在你的依赖管理文件中加入 <code>spring-boot-starter-data-jpa</code> 就好了，<code>starter</code> 就如它的名字一样 —— 快速启动。</p>
<p>官方的依赖一般遵循 <code>spring-boot-starter-*</code> 模式，<code>*</code> 为一种特定的技术或程序。详细的清单列表见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter">链接</a>。</p>
<span id="more"></span>
<h1>开发自己的 Starter</h1>
<p>一个典型的 Spring Boot Starter 包含用于自动配置和自定义特定技术的基础架构的代码，为了使其易于扩展，可以将专用命名空间中的许多配置密钥公开给环境。最后，提供了一个 “starter” 依赖项，以帮助用户尽可能轻松地入门。</p>
<p>这里我们就以 “acme” 这个自定义启动器为例：</p>
<p>具体而言，自定义启动器可以包含以下内容：</p>
<ul>
<li>包含 “acme” 的自动配置代码的 <code>autoconfigure</code> 模块。</li>
<li><code>starter</code> 模块，它提供对 <code>autoconfigure</code> 模块的依赖以及 “acme” 和通常有用的任何其他依赖。简而言之，starter 应提供开始使用该库所需的一切。</li>
</ul>
<p>完全没有必要将这两个模块分开。如果 “acme” 具有多种风格，选项或可选功能，则最好将自动配置分开，因为您可以清楚地表示某些功能是可选的。此外，您还可以制作一个启动器，以提供有关那些可选依赖项的意见。同时，其他人只能依靠自动配置模块并以不同的意见来制作自己的启动器。</p>
<p>完整的项目见这两个 Demo： <a target="_blank" rel="noopener" href="https://github.com/snicoll/spring-boot-master-auto-configuration">Demo1</a>、<a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/spring-boot-modules/spring-boot-custom-starter">Demo2</a>。</p>
<h2 id="命名">命名</h2>
<p>我们应该确保为启动器提供适当的名称空间。不要使用以 spring-boot 起始的 Maven groupId 命名，因为这是官方标准命名，将来，可能会为您自动配置的内容提供官方支持。</p>
<p>经验而言，你可以使用自己的模块加 spring-boot-starter 来命名。例如，假设您要为 “acme” 创建启动程序，并命名自动配置模块 <code>acme-spring-boot-autoconfigure</code> 和启动器 <code>acme-spring-boot-starter</code>。如果您只有一个将两者结合的模块，请将其命名为 <code>acme-spring-boot-starter</code>。</p>
<h2 id="配置属性">配置属性</h2>
<p>如果你的 starter 提供了配置，请为其使用唯一的名称空间。特别是，不要将配置键包含在 Spring Boot 使用的名称空间中（例如 <code>server</code>，<code>management</code>，<code>spring</code> 等）。</p>
<p>确保为键字段提供 javadoc 文档说明，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcmeProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether to check the location of acme resources.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">checkLocation</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timeout for establishing a connection to the acme server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Duration</span> <span class="variable">loginTimeout</span> <span class="operator">=</span> Duration.ofSeconds(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters &amp; setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动配置（autoconnfigure）模块">自动配置（autoconnfigure）模块</h2>
<p>自动配置模块包含开始使用该库所需的所有内容。它还可能包含配置属性键定义（例如 <code>@ConfigurationProperties</code>）和可用于进一步自定义组件初始化方式的任何回调接口。</p>
<p>一般会在启动器的依赖文件中包含自动配置模块及其相关使用的特定的库。</p>
<h3 id="自动配置-bean-如何工作">自动配置 bean 如何工作</h3>
<p>在后台，自动配置是通过标准 <code>@Configuration</code> 类实现的。其他 <code>@Conditional</code> 注解用于约束何时应应用自动配置。通常，自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解。这样可以确保仅当找到相关的类并且没有声明自己的 <code>@Configuration</code> 时，才应用自动配置。</p>
<p>您可以浏览 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.4.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a> 的源代码以查看 Spring 提供的 <code>@Configuration</code> 类（请参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.4.4/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a> 文件）。</p>
<h4 id="定位自动配置候选人">定位自动配置候选人</h4>
<p>这是一种 <code>SPI</code>（Service Provider Interface-服务提供接口）机制。spring.factories 和原生 Java SPI 的 service 服务文件提供机制类似。</p>
<p>Spring Boot 检查发布的 jar 中是否存在 <code>META-INF/spring.factories</code> 文件。该文件应在 <code>EnableAutoConfiguration</code> 键下列出您的自动配置类，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动配置只能以这种方式加载。确保在特定的程序包空间中定义它们，并且决不要将它们作为组件扫描的目标。此外，自动配置类不应启用组件扫描以查找其他组件。应使用特定的 <code>@Import</code>s 代替。</p>
</blockquote>
<p>如果需要按特定顺序应用配置，则可以使用 <code>@AutoConfigureAfter</code> 或 <code>@AutoConfigureBefore</code> 注解。如果要排序某些彼此之间不具有直接了解的自动配置，则也可以使用 <code>@AutoConfigureOrder</code>。该注解与常规 <code>@Order</code> 注解具有相同的语义，但为自动配置类提供了专用的顺序。</p>
<p>与标准 <code>@Configuration</code> 类一样，自动配置类的应用顺序仅会影响其 bean 的<em><strong>定义</strong></em>顺序。随后创建这些 bean 的顺序不受影响，而是由每个  bean 的依赖关系以及任何 <code>@DependsOn</code> 关系确定。</p>
<h4 id="Condition-注解">Condition 注解</h4>
<p>一般在自动配置类中会包含一个或多个 <code>@Conditional</code> 注解。<code>@ConditionalOnMissingBean</code> 注解最为常见，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
<p><img data-src="../../images/spring/spring-boot/ConfigurationClassRegistry.svg" alt="ConfigurationClassRegistry"></p>
<p>从上图的时序图我们可以看到 <code>@Conditional</code> 注解是在 <code>ConditionEvaluator</code> 的 <code>shouldSkip</code> 中调用，只有满足条件的类<strong>才会被加载并注入</strong>，其它的 Condition 注解都是基于该注解的。</p>
<p>Spring Boot 包含许多 <code>@Conditional</code> 注解，你可以通过在自己的代码的 <code>@Configuration</code> 类或单个 <code>@Bean</code> 方法中使用这些注解。这些注解包括：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-class-conditions">Class Conditions</a></p>
<p>通过 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解，可以根据是否存在特定类来包含 <code>@Configuration</code> 类。由于注解元数据是通过使用 <a target="_blank" rel="noopener" href="https://asm.ow2.io/">ASM</a> 进行解析的，因此即使该类可能实际上没有出现在正在运行的应用程序类路径上，您也可以使用 value 属性来引用真实的类。如果您更喜欢通过使用 String 值来指定类名称，则也可以使用 name 属性，这里需使用完全限定名称。</p>
<blockquote>
<p>具体是 <code>MetadataReader</code> 的实现类 <code>SimpleMetadataReader</code> 使用 ASM 的 <code>ClassReader</code> 调用 <code>AnnotationMetadataReadingVisitor</code> 来获取注解元数据的。</p>
</blockquote>
<p>这种机制不适用于 @Bean 方法，后者通常将返回类型作为条件的目标：在方法的条件适用之前，JVM 将加载该类和可能处理的方法引用，如果该类不存在，则该引用将失败。</p>
<p>要处理这种情况，可以使用单独的 @Configuration 类隔离条件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// Some conditions</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Auto-configured beans</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(EmbeddedAcmeService.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="keyword">public</span> EmbeddedAcmeService <span class="title function_">embeddedAcmeService</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-bean-conditions">Bean Conditions</a></p>
<p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据是否存在特定 bean 来包含 bean。你可以使用 <code>value</code> 属性按类型指定 bean 或使用名称按名称指定 bean。<code>search</code> 属性使你可以限制在搜索 bean 时应考虑的 ApplicationContext 层次结构。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-property-conditions">Property Conditions</a></p>
<p><code>@ConditionalOnProperty</code> 注解允许基于 Spring Environment 属性包含配置。使用 <code>prefix</code> 和 <code>name</code> 属性指定应检查的属性。默认情况下，匹配存在且不等于 false 的任何属性。您也可以使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性来创建更高级的检查。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-resource-conditions">Resource Conditions</a></p>
<p><code>@ConditionalOnResource</code> 注解仅在存在特定资源时才包括配置。可以使用通常的 Spring 约定来指定资源，如以下示例所示：<code>file:/home/user/test.dat</code>。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-web-application-conditions">Web Application Conditions</a></p>
<p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为 “Web 应用程序” 来包含配置。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spel-conditions">SpEL Expression Conditions</a></p>
<p><code>@ConditionalOnExpression</code> 注解允许基于 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.3.5/reference/html/core.html#expressions">SpEL 表达式</a>的结果包括配置。</p>
</li>
</ul>
<h2 id="Starter-模块">Starter 模块</h2>
<p>Starter 其实是一个空 jar 包。其唯一目的是<strong>提供必要的依赖关系</strong>以使用库，我们需要的只是仓库中管理依赖的 pom 文件或 build.gradle 文件。</p>
<p>你唯一需要做的就是创建依赖管理文件，并包含你的自动配置模块及改 Starter 特定的依赖。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot Starter</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 架构初谈</title>
    <url>/spring/Spring-MVC-%E6%9E%B6%E6%9E%84%E5%88%9D%E8%B0%88/</url>
    <content><![CDATA[<p>在学习 Spring MVC 之前，我们先快速回顾下 Spring，Spring 是 Java 企业软件开发的长期实际标准。它向我们中的许多人介绍了很多概念，例如依赖项注入，面向切面的编程（AOP）以及使用普通的 Java 对象（POJO）进行编程。</p>
<p>Spring 框架是由 Rod Johnson为《Expert One-on-One J2EE Design and Development》一书编写的代码演变而来。编写这本书是为了解释 JEE 中的一些复杂性以及如何克服它们。尽管在新的 JEE 规范中（特别是从 JEE 6 开始）已经解决了 JEE 的许多复杂性和问题，但 Spring 框架仍然非常流行。</p>
<span id="more"></span>
<p>该框架由几个模块组成（参见下图），这些模块可以协同工作并相互构建。我们可以选择我们要使用的模块。</p>
<p><img data-src="../../images/spring-mvc/spring-module.jpg" alt="Spring Module"></p>
<p>大多数模块都依赖于 Spring Framework 中的某些其他模块。 核心模块是该规则的例外。下图概述了常用模块及其对其他模块的依赖性。</p>
<p><img data-src="../../images/spring-mvc/spring-module-dependencies.jpg" alt="Spring Module Dependencies"></p>
<p>Spring Web MVC 是基于 Servlet API 构建的原始 Web 框架，正式名称 “ Spring Web MVC” 来自上述模块中的（spring-webmvc），但通常称为 “ Spring MVC”。</p>
<p>Spring MVC 本质上就是一个 Servlet，这里我们就不得不提一下 Servlet。</p>
<h2 id="Servlet">Servlet</h2>
<p><code>Servlet</code> 是 <code>Server + Applet</code> 的缩写，表示一个服务器应用。<code>Servlet</code> 其实是一套规范，按这套规范编写的代码就可以运行在 Java Servlet 容器中，比如最常见的 <code>Tomcat</code> 容器。</p>
<p><code>Servlet</code> 的结构如图：</p>
<p><img data-src="../../images/spring-mvc/servlet-structure.png" alt="Servlet Structure"></p>
<h3 id="GenricServlet">GenricServlet</h3>
<p><code>GenricServlet</code> 抽象类是与具体协议无关的，它是 Servlet 的默认实现，它主要做了三件事：</p>
<ol>
<li>实现了 <code>ServletConfig</code> 接口，我们可以直接调用 ServletConfig 里面的方法；</li>
<li>提供了无参的 <code>init</code> 方法；</li>
<li>提供了 <code>log</code> 方法。</li>
</ol>
<p>Servlet 容器初始化时会调用 Servlet 的 <code>init(ServletConfig)</code> 方法，该抽象类接受配置类，并调用自身空实现的无参 <code>init</code> 方法。</p>
<h3 id="HttpServlet">HttpServlet</h3>
<p><code>HttpServlet</code> 是用 HTTP 协议[^ HTTP 协议]实现的 Servlet 的基类，Spring MVC 的 <code>DispatcherServlet</code> 就是继承自该类。既然 HttpServlet 是跟协议相关的，当然主要关心的是如何处理请求了，所以 HttpServlet 主要重写了 <code>service</code> 方法。在 service 方法中首先将 <code>ServletRequest</code> 和 <code>ServletResponse</code> 转换为了 <code>HttpServletRequest</code>  和 <code>HttpServletResponse</code>，然后根据 Http 请求的类型不同将请求路由到了不同的处理方法。</p>
<h2 id="Spring-MVC-架构">Spring MVC 架构</h2>
<p>Spring MVC 中核心 Servlet 继承结构如下图所示。</p>
<p><img data-src="../../images/spring-mvc/DispatcherServlet.png" alt="DispatcherServlet"></p>
<p><code>GenericServlet、HttpServlet</code> 在前面已经介绍过。</p>
<p><code>XXXAware</code> 接口在 Spring 表示对 XXX 的感知，通俗点解释就是：如果在某个类里面想要使用 Spring 的一些东西,就可以通过实现 <code>XXXAware</code> 接口告诉 Spring，Spring 看到后就会给你送过来，而接收的方式是通过实现接口唯一的方法 set-XXX。</p>
<p><code>EnvironmentCapable</code>，顾名思义，就是具有 Environment 的能力，也就是可以提供 Environment，所以 EnvironmentCapable 唯一的方法是 <code>Environment getEnvironment()</code>，用于实现 EnvironmentCapable 接口的类，就是告诉 Spring 它可以提供 Environment，当 Spring 需要 Environment 的时候就会调用其 <code>getEnvironment</code> 方法跟它要，该类封装了 <code>ServletContext</code>、<code>ServletConfig</code>、<code>JndiProperty</code>、<code>系统环境变量</code>和<code>系统属性</code>。<code>HttpServletBean</code> 抽象类在 <code>init</code> 方法中将配置参数设置到该 servlet 的 Bean 属性中。</p>
<h3 id="HttpServletBean">HttpServletBean</h3>
<p>HttpServletBean 主要参与了创建工作，并没有涉及请求的处理。</p>
<p>该抽象类重写了无参 <code>init</code> 方法，在该实现中首先将 Servlet 中配置的参数使用 BeanWrapper 设置到 Dispatcherservlet 中的相关属性，然后调用模板方法 <code>initservletBean</code>，子类就通过这个方法初始化。</p>
<h3 id="FrameworkServlet">FrameworkServlet</h3>
<p><code>FrameworkServlet</code> 抽象类主要提供了与 Spring <code>ApplicationContext</code> 的集成，该类重写 <code>initservletBean</code> 并在其中初始化了 <code>WebApplicationContext</code>；</p>
<p>该类重写了除 <code>doHead</code> 外各种请求的处理方法，并将处理都交给 <code>processRequest</code> 方法具体处理，在该处理中初始化了 <code>LocaleContextHolder</code> 和 <code>RequestContextHolder</code> 持有对象，以便我们可以轻松获取区域信息和请求信息，然后调用 <code>doService</code> 方法交给子类真正处理，在请求处理完时发布 <code>ServletRequestHandledEvent</code> 事件，不管请求是成功还是失败；</p>
<p>在 ApplicationContext 初始完毕或刷新时会调用 <code>onRefresh</code> 方法，该方法由子类实现。</p>
<blockquote>
<p>在 FrameServlet 初始化 WebApplicationContext 时，会将 ServletContext 设置其中，监听 ContextRefreshedEvent 事件调用 OnRefresh 方法刷新 web 上下文。</p>
</blockquote>
<h3 id="DispatchServlet">DispatchServlet</h3>
<p><code>Dispatcherservlet</code> 是 Spring MVC 最核心的类，整个处理过程的顶层设计都在这里面，它是 <code>FrameworkServlet</code> 的默认实现。</p>
<p>其实现的 <code>OnRefresh</code> 方法主要初始化了 Servlet 需要用到的策略对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 initStrategies 作为实现。</span></span><br><span class="line"><span class="comment"> * 分开写的好处在于职责分离，以便子类可以选择性的覆盖和重用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化这个 servlet 使用的策略对象。</span></span><br><span class="line"><span class="comment"> * 可以在子类中被覆盖，以便进一步初始化策略对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在各自的初始化方法中，都会先从 ApplicationContext 寻找相应 BeanName 的 Bean 实现类，找不到时会从 <code>DispatcherServlet</code> 相对路径的 <code>DispatcherServlet.properties</code> 配置文件中找到默认定义的实现类完全限定名称并加载。</p>
<h4 id="请求处理">请求处理</h4>
<p>通过之前的分析我们知道，Dispatcherservlet 里面执行处理的人口方法应该是 <code>doService</code>, 不过 doService 并没有直接进行处理，而是交给了 <code>doDispatch</code> 进行具体的处理，在 doDispatch 处理前 doService 做了一些事情：</p>
<ul>
<li>首先判断是不是 <code>include</code> 请求，如果是则对 request 的 Attribute 做个快照备份，等 dispatch 处理完之后（如果不是异步调用且未完成）进行还原；</li>
<li>在做完快照后又对 request 设置了一些属性：<code>webApplicationContext</code>，<code>localResolver</code>，<code>themeResolver</code>，<code>themeSource</code> 等</li>
</ul>
<p><code>doDispatch</code> 方法也非常简洁，从顶层设计了整个请求处理的过程。doDispatch 中最核心的代码只要4句，它们的任务分别是：</p>
<ol>
<li>根据 <code>request</code> 从 <code>HandlerMapping</code> 中找到 <code>Handler</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> getHandler(processedRequest);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据 <code>Handler</code> 找到对应的 <code>HandlerAdapter</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用 <code>HandlerAdapter</code> 处理 <code>Handler</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>调用 <code>processDispatchResult</code> 方法处理上面处理之后的结果（包含找到 View 并渲染输出给用户）</li>
</ol>
<p>对应的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br></pre></td></tr></table></figure>
<p>doDispatch 请求的流程如下：</p>
<p><img data-src="../../images/spring-mvc/doDispatch.png" alt="doDispatch"></p>
<p>这里需要解释三个概念：HandlerMapping、 Handler 和 HandlerAdapter。这三个概念的准确理解对于 Spring MVC 的学习非常重要。如果对这三个概念理解得不够透彻，将会严重影响对 Spring MVC 的理解：</p>
<h4 id="Handler">Handler</h4>
<p>也就是处理器，它直接对应着 MVC 中的 C 也就是 Controller 层，它的具体表现形式有很多，可以是类,也可以是方法，如果你能想到别的表现形式也可以使用，它的类型是 Object。例如标注了<code>@RequestMapping</code> 的所有方法都可以看成一个 Handler。只要可以实际处理请求就可以是 Handler。</p>
<h4 id="HandlerMapping">HandlerMapping</h4>
<p>是用来查找 Handler 的，在 Spring MVC 中会处理很多请求，每个请求都需要一个 Handler 来处理，具体接收到一个请求后使用哪个 Handler 来处理呢？这就是 HandlerMapping 要做的事情。</p>
<p>标注了 <code>RequestMapping</code> 的方法，<code>GetMapping、PostMapping、PutMapping、DeleteMapping</code> 是 <code>RequestMapping</code> 的复合注解，就会使用 <code>RequestMappingHandlerMapping</code> 从扫描到的注释方法的地址中查找满足条件的 Handler。</p>
<p>这里的请求也可能是 websocket 请求，所以就会有 <code>WebSocketHandlerMapping</code>。</p>
<h4 id="HandlerAdapter">HandlerAdapter</h4>
<p>从名字上就可以看出它是一个 Adapter，也就是适配器。因为 Spring MVC 中的 Handler 可以是任意的形式，只要能处理请求就 OK，但是 Servlet 需要的处理方法的结构却是固定的，都是以 request 和 response 为参数的方法（如 doService方法）。怎么让固定的 Servlet 处理方法调用灵活的 Handler 来进行处理呢？这就是 HandlerAdapter 要做的事情。</p>
<p>标注了 <code>RequestMapping</code> 的 <code>HandlerMethod</code> 就会使用 <code>RequestMappingHandlerAdapter</code> 来处理 Handler。</p>
<p><code>RequestMappingHandlerAdapter</code> 内部使用 <code>HandlerMethodArgumentResolver</code> 集合处理传入参数，<code>HandlerMethodReturnValueHandler</code> 处理返回结果，<code>HandlerMethodReturnValueHandler</code> 会根据返回资源的类型找到合适的响应体，比如媒体文件会使用渐进式下载形式返回，对象会找到合适的 mediaType 类型，并使用 <code>MessageConvter</code> 处理并返回。我们的 JSON 形式返回就是在这里处理的。</p>
<p>我们也可以调用 <code>setCustomArgumentResolvers</code> 来自定义参数解析，比如解析字符串到日期类，<code>setCustomReturnValueHandlers</code> 来自定义返回值处理。</p>
<hr>
<p>其它组件如下：</p>
<h4 id="HandlerExceptionResolver">HandlerExceptionResolver</h4>
<p>別的组件都是在正常情况下用来干活的，不过干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在 Spring MVC 中就是 <code>HandlerExceptionresolver</code>。具体来说，此组件的作用是根据异常设置 <code>ModelAndView</code>，之后再交给 <code>render</code> 方法进行渲染。 render 只负责将 ModelAndView 渲染成页面，具体 ModelAndView 是怎么来 render 的并不关心。这也是 Spring MVC 设计优秀的一个表现一一分工明确互不干涉。通过前面 doDispatch 的分析可以知道 HandlerExceptionResolver 只是用于解析对请求做处理的过程中产生的异常，而渲染环节产生的异常不归它管，现在我们就知道原因了：它是在 render 之前工作的，先解析出  ModelAndView 之后 render 才去渲染，当然它就不能处理 render 过程中的异常了。</p>
<h4 id="ViewResolver">ViewResolver</h4>
<p>ViewResolver 用来将 String 类型的视图名（有的地方也叫逻辑视图，都指同一个东西）和 <code>Locale</code> 解析为 <code>View</code> 类型的视图。</p>
<p>View 是用来渲染页面的，通俗点说就是要将程序返回的参数填入模板里，生成html（也可能是其他类型）文件。这里有两个关键的问题：</p>
<ul>
<li>使用哪个模板？</li>
<li>用什么技术（或者规则）填入参数？</li>
</ul>
<p>这其实就是 ViewResolver 主要要做的工作, ViewResolver 需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交给不同的视图自己完成。最常使用的 <code>UrlBasedViewResolver</code> 都是针对单一类型试图进行解析，只需要找到使用的模版就可以了。比如，<code>InternalResourceViewResolver</code> 只针对 jsp 类型的视图，<code>FreeMarkerViewResolver</code> 只针对 FreeMarker 视图。</p>
<blockquote>
<p>使用 ResponseBody 注解以 JSON 形式返回会在 Adapter 的 handle 中处理，并不会使用 ViewResolver。</p>
</blockquote>
<h4 id="RequestToViewNameTranslator">RequestToViewNameTranslator</h4>
<p><code>ViewResolver</code> 是根据 <code>ViewName</code> 査找 <code>View</code>，但有的 Handler 处理完后并没有设置 View 也没有设置 ViewName，这时就需要从 <code>request</code> 获取 <code>ViewName</code> 了，而如何从 request 获取 ViewName 就是 RequestToViewTranslator 要做的事情。</p>
<h4 id="LocaleResolver">LocaleResolver</h4>
<p>解析视图需要两个参数：一个是视图名，另一个是 <code>Locale</code>。视图名是处理器返回的（或者使用 RequestTo NameTranslator 解析的默认视图名），Locale 是从哪里来的呢？这就是 LocaleResolver 要做的事情。<br>
LocaleResolver 用于从 request 解析出 Locale。 Locale 是用来做 il8n（国际化）的基础。</p>
<h4 id="ThemeResolver">ThemeResolver</h4>
<p>解析主题使用，也就是配置不同的样式文件切换不同的主题。</p>
<h4 id="MultiPartResolver">MultiPartResolver</h4>
<p>用于处理上传请求，处理方法是将普通的 <code>request</code> 包装成 <code>MultipartHttpServletRequest</code>，后者可以直接调用 <code>getFile</code> 方法获取到 <code>File</code>，如果上传多个文件，还可以调用 <code>getFileMap</code> 得到 <code>Filename → File</code> 结构的 Map，这样就使得上传请求的处理变得非常简单。</p>
<p>[^ HTTP 协议]: HTTP 协议是应用层协议，在 TCP/IP 协议接收到数据之后到达应用层。该协议中的报文结构非常重要。分为请求报文（request message）和响应报文（response message）。这两种类型都包括三部分：首行，头部和主体。请求报文的首行是请求行，包括请求类型、URL 和 HTTP 版本三项内容，响应请求的首行是状态行，包括 HTTP 版本、状态码和简短原因三项内容。™</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 架构初谈</title>
    <url>/spring/Spring-Security-%E6%9E%B6%E6%9E%84%E5%88%9D%E8%B0%88/</url>
    <content><![CDATA[<h2 id="身份验证和访问控制">身份验证和访问控制</h2>
<p>应用程序安全性归结为或多或少的两个独立问题：</p>
<p><code>authentication/认证</code>（你是谁？）和 <code>authorization/授权</code>（你可以做什么？）。</p>
<p>有时人们会说“访问控制”而不是“授权”，这可能会造成混淆，但是以这种方式思考可能会有所帮助，因为“授权”在其他地方可能有点言过其重。Spring Security 的体系结构旨在将认证与授权分开，并各自具有策略和扩展点。</p>
<h3 id="Authentication（身份验证-认证）">Authentication（身份验证/认证）</h3>
<p>身份验证的主要策略接口是 <code>AuthenticationManager</code>，它只有一个方法：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">  Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">    <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AuthenticationManager</code> 可以在 <code>authenticate()</code> 方法中执行以下三项操作之一：</p>
<ol>
<li>如果它可以验证输入是否代表有效的主体，则返回 <code>Authentication</code>（通常使用 <code>authenticated = true</code>）。</li>
<li>如果认为输入代表无效的主体，则抛出 <code>AuthenticationException</code>。</li>
<li>如果无法决策，则返回 <code>null</code>。</li>
</ol>
<p><code>AuthenticationException</code> 是运行时异常。它通常由应用程序以通用方式处理，具体取决于应用程序的用例或目的。换句话说，通常不希望用户代码捕获并处理它。例如，web 程序将呈现一个页面，指出认证失败，后端 HTTP服务将发送401响应，取决于上下文，带有或不带有 <code>WWW-Authenticate</code> 标头。</p>
<p><code>AuthenticationManager</code> 最常用的实现是 <code>ProviderManager</code>，它委派了 <code>AuthenticationProvider</code> 实例链。<code>AuthenticationProvider</code> 有点像 <code>AuthenticationManager</code>，但是它还有一个额外的方法，允许调用者查询是否支持给定的 <code>Authentication</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">	Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">			<span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>supports()</code> 方法中的 <code>Class &lt;?&gt;</code> 参数实际上是 <code>Class &lt;? extends Authentication&gt;</code>（仅会询问它是否支持将内容传递到 <code>authenticate()</code> 方法中）。通过委托给 <code>AuthenticationProviders</code> 链，<code>ProviderManager</code> 可以在同一应用程序中支持多种不同的身份验证机制。如果 <code>ProviderManager</code> 无法识别特定的身份验证实例类型，则将跳过该类型。</p>
<p><code>ProviderManager</code> 具有可选的父级，如果所有提供程序都返回 <code>null</code>，则可以咨询该父级。如果父级不可用，则 <code>null</code> 身份验证将导致 <code>AuthenticationException</code>。</p>
<p>有时，应用程序具有逻辑组的受保护资源（例如，与路径模式 <code>/api/**</code> 匹配的所有 Web 资源），并且每个组可以具有自己的专用 <code>AuthenticationManager</code>。通常，每一个都是 <code>ProviderManager</code>，它们共享一个父级。因此，父级是一种“全局”资源，充当所有提供程序的后备。</p>
<p><img data-src="../../images/spring-security/authentication.png" alt="ProviderManagers with a common parent"></p>
<p>图1.使用 <code>ProviderManager</code> 的 <code>AuthenticationManager</code> 层次结构</p>
<h2 id="自定义身份验证管理器">自定义身份验证管理器</h2>
<p>Spring Security 提供了一些配置帮助类，可以在自己的应用程序中便捷的得到通用身份验证管理器功能。最常用的帮助类是 <code>AuthenticationManagerBuilder</code>，它非常适合配置内存中的 JDBC 或 LDAP 用户详情，或者用于添加自定义 <code>UserDetailsService</code>。这是配置全局（父）<code>AuthenticationManager</code> 的应用程序的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationSecurity</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">   ... <span class="comment">// web stuff here</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(AuthenticationManagerBuilder builder, DataSource dataSource)</span> &#123;</span><br><span class="line">    builder.jdbcAuthentication().dataSource(dataSource).withUser(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">      .password(<span class="string">&quot;secret&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例与 Web 应用程序有关，但是 <code>AuthenticationManagerBuilder</code> 的用法更为广泛（有关如何实现 Web 应用程序安全性的详细信息，请参见下文）。请注意，<code>AuthenticationManagerBuilder</code> 使用 <code>@Autowired</code> 注入到<code>@Bean</code> 的方法中-这就是使它构建全局（父）<code>AuthenticationManager</code> 的 原因。相反，如果我们这样做的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationSecurity</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   ... <span class="comment">// web stuff here</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> &#123;</span><br><span class="line">    builder.jdbcAuthentication().dataSource(dataSource).withUser(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">      .password(<span class="string">&quot;secret&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（在配置类中使用方法的 <code>@Override</code>），那么 <code>AuthenticationManagerBuilder</code> 仅用于构建“本地” <code>AuthenticationManager</code>，这是全局的一个子类。在 Spring Boot 应用程序中，您可以将全局变量 <code>@Autowired</code>连接到另一个 <code>bean</code> 中，但是除非你自己明确暴漏出它，否则不能对本地对象执行此操作。</p>
<p>Spring Boot 提供了一个默认的全局 <code>AuthenticationManager</code>（只有一个用户），除非你通过提供自己的<code>AuthenticationManager</code> 类型的 bean 来抢占它。除非你需要自定义全局 <code>AuthenticationManager</code>，否则默认值本身就足够安全，你不必担心太多。</p>
<h2 id="授权或访问控制">授权或访问控制</h2>
<p>身份验证成功后，我们可以继续进行授权，这里的核心策略是 <code>AccessDecisionManager</code>。框架提供了三种实现方式，所有这三种实现都委托给 <code>AccessDecisionVoter</code> 链，有点像 <code>ProviderManager</code> 委托给<code>AuthenticationProviders</code>。</p>
<p><code>AccessDecisionVoter</code> 使用 <code>ConfigAttributes</code> 修饰的身份验证主体和安全 <code>Object</code> 进行投票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(ConfigAttribute attribute)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vote</span><span class="params">(Authentication authentication, S object,</span></span><br><span class="line"><span class="params">        Collection&lt;ConfigAttribute&gt; attributes)</span>;</span><br></pre></td></tr></table></figure>
<p>该 <code>Object</code> 在 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的签名中是完全通用的-它表示用户可能要访问的任何内容（Web 资源或 Java 类中的方法是两种最常见的情况）。<code>ConfigAttributes</code> 也相当通用，用一些元数据来表示安全 <code>Object</code> 的修饰，这些元数据确定访问它所需的权限级别。<code>ConfigAttribute</code> 是一个接口，但是它只有一个通用的方法并返回 <code>String</code>，这些字符串以某种方式编码资源所有者的意图，表明有关允许谁访问它的规则。典型的 <code>ConfigAttribute</code> 是用户角色的名称（如 <code>ROLE_ADMIN</code> 或 <code>ROLE_AUDIT</code>），并且它们通常具有特殊的格式（如 <code>ROLE_</code> 前缀）或表示需要求值的表达式。</p>
<p>大多数人只使用默认的 <code>AccessDecisionManager</code>，它是 <code>AffirmativeBased</code> 的（如果任何选民投票通过，则允许授予访问权限）。任何定制都倾向于在选民中发生，要么添加新选民，要么修改现有选民的投票方式。</p>
<p>使用作为 Spring 表达式语言（SpEL）表达式的 <code>ConfigAttributes</code> 非常常见，例如 <code>isFullyAuthenticated() &amp;&amp; hasRole(‘FOO')</code>。<code>AccessDecisionVoter</code> 支持此功能，可以处理表达式并为其创建上下文。为了扩展可以处理的表达式的范围，需要 <code>SecurityExpressionRoot</code> 的自定义实现，有时还需要 <code>SecurityExpressionHandler</code>。</p>
<h2 id="网络安全">网络安全</h2>
<p>Web 层（用于 UI 和 HTTP 后端）中的 Spring Security 基于 <code>Servlet</code> 过滤器，因此通常首先了解过滤器的作用会很有帮助。下图显示了单个 HTTP 请求的处理程序的典型分层。</p>
<p><img data-src="../../images/spring-security/filters.png" alt="Filter chain delegating to a Servlet"></p>
<p>客户端向应用程序发送请求，然后容器根据请求 URI 的路径确定对它应用哪些过滤器和哪个 servlet。一个 servlet 最多只能处理一个请求，但是过滤器形成一个链，因此它们是有序的，实际上，如果过滤器要处理请求本身，则可以否决链的其余部分。过滤器还可以修改下游过滤器和 Servlet 中使用的请求和/或响应。过滤器链的顺序非常重要，Spring Boot 通过两种机制对其进行管理：一种是 <code>Filter</code> 类型的 <code>@Bean</code> 可以具有 <code>@Order</code> 或实现 <code>Ordered</code>，另一个是它们可以成为 <code>FilterRegistrationBean</code> 的一部分，而 FilterRegistrationBean 本身也将顺序作为其 API 的一部分。一些现成的过滤器定义了自己的常量，以帮助表示它们希望相对于彼此的顺序（例如，Spring Session 中的 <code>SessionRepositoryFilter</code> 的 <code>DEFAULT_ORDER</code> 为 <code>Integer.MIN_VALUE + 50</code>，它告诉我们，它喜欢处于过滤器链的前端，但并不排除其他过滤器的出现。</p>
<p>Spring Security 作为链中的单个 <code>Filter</code> 安装，其具体类型为 <code>FilterChainProxy</code>，原因很快就会变得显而易见。在 Spring Boot 应用程序中，安全过滤器是 <code>ApplicationContext</code> 中的 <code> @Bean</code>，默认情况下会安装该过滤器，以便将其应用于每个请求。它安装在 <code>SecurityProperties.DEFAULT_FILTER_ORDER</code> 定义的位置，反过来由 <code>FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 锚定（Spring Boot 应用程序希望过滤器包装请求并修改其行为时期望的最大顺序）。但是，还有更多的功能：从容器的角度来看，Spring Security 是一个过滤器，但是在内部有其他过滤器，每个过滤器都扮演着特殊的角色。如图：</p>
<p><img data-src="../../images/spring-security/security-filters.png" alt="Spring Security Filter"></p>
<p>图2. Spring Security 是单个真实的过滤器，但是将处理委托给一系列内部过滤器。实际上，安全性过滤器中甚至还有一层间接层：通常作为 <code>DelegatingFilterProxy</code> 安装在容器中，而不必是 Spring <code>@Bean</code>，该代理类是 Spring Web 提供的 servlet 过滤器，它将所有工作委托给根 ApplicationContext 中的 Spring bean。该代理委托给一个始终为 <code>@Bean</code> 的 <code>FilterChainProxy</code>，通常使用固定名称 <code>springSecurityFilterChain</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingFilterProxy</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(request, response, filterChain)</span> &#123;</span><br><span class="line">        <span class="type">Filter</span> <span class="variable">delegate</span> <span class="operator">=</span> applicationContet.getBean(<span class="string">&quot;springSecurityFilterChain&quot;</span>)</span><br><span class="line">            delegate.doFilter(request, response, filterChain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个被委托的 Bean 就是 <code>FilterChainProxy</code>，它里面包含所有内部安全性逻辑，这些安全性逻辑在内部排列为一个或多个过滤器链，它们全部由 Spring Security 在同一顶级 <code>FilterChainProxy</code> 中管理，而对于容器来说都是未知的，该类的主要逻辑如下伪代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterChainProxy</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(request, response, filterChain)</span> &#123;</span><br><span class="line">        <span class="comment">// 查找此请求的所有过滤器</span></span><br><span class="line">        List&lt;Filter&gt; delegates = lookupDelegates(request, response)</span><br><span class="line">            <span class="comment">// 除非委托过滤器类决定停止，否则调用每个筛选器</span></span><br><span class="line">            <span class="keyword">for</span> delegate in delegates &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">continue</span> processing </span><br><span class="line">                    delegate.doFilter(request, response, filterChain)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果所有过滤器都认为ok，则允许应用程序的其余部分运行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">continue</span> processing</span><br><span class="line">            filterChain.doFilter(request, response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Security 过滤器包含一个过滤器链列表，并向与其匹配的第一个链发送请求。下图显示了基于匹配请求路径（<code>/foo/**</code> 在 <code>/**</code> 之前匹配）发生的调度。这是很常见的，但不是匹配请求的唯一方法。此调度过程的最重要特征是，只有一个链处理过请求。</p>
<p><img data-src="../../images/spring-security/security-filters-dispatch.png" alt="Security Filter Dispatch"></p>
<p>图3. Spring Security <code>FilterChainProxy</code> 将请求分派到匹配的第一个链。 没有自定义安全配置的普通 Spring Boot 应用程序具有多个（称为n）过滤器链，通常 n = 6。前 (n-1) 个链只是忽略静态资源匹配模式，像 <code>/css/**</code> 和 <code>/images/**</code>，以及错误视图 <code>/error</code>（路径可以由用户通过 <code>SecurityProperties</code> 配置 bean 中 <code>security.ignored </code> 控制）。最后一条链与捕获所有路径<code> /**</code> 相匹配，并且更活跃，包含用于身份验证，授权，异常处理的逻辑，会话处理，请求写入等。默认情况下，此链中总共有11个过滤器，但通常用户不必担心使用什么过滤器以及何时使用。</p>
<blockquote>
<p>容器不知道 Spring Security 内部的所有过滤器这一事实非常重要，尤其是在 Spring Boo t应用程序中，默认情况下，所有 <code>Filter</code> 类型的 <code>@Bean</code> 都会自动向容器注册。因此，如果要向安全链中添加自定义过滤器，则无需将其设置为 <code>@Bean</code> 或将其包装在明确禁用容器注册的 <code>FilterRegistrationBean</code> 中。</p>
</blockquote>
<h2 id="创建和定制过滤器链">创建和定制过滤器链</h2>
<p>Spring Boot 应用程序（带有 <code>/**</code> 请求匹配器的应用程序）中的默认后备过滤器链具有 <code>SecurityProperties.BASIC_AUTH_ORDER</code> 的预定义顺序。您可以通过设置 <code>security.basic.enabled = false</code> 完全关闭它，也可以将其用作后备并仅以较低的顺序定义其他规则。为此，只需添加类型为 <code>WebSecurityConfigurerAdapter</code>（或 <code>WebSecurityConfigurer</code>）的 <code>@Bean</code> 并使用 <code>@Order</code> 装饰类。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">     ...;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 bean 将导致 Spring Security 添加一个新的过滤器链并在回退之前对其进行排序。</p>
<p>许多应用程序对两套资源的访问规则完全不同。例如，承载 UI 和支持 API 的应用程序可能支持基于 cookie 的身份验证以及对 UI 部件的登录页面的重定向，而基于令牌的身份验证则具有针对 API 部件的未经身份验证的请求的 401 响应。 每组资源都有其自己的 <code>WebSecurityConfigurerAdapter</code> 以及唯一的顺序和自己的请求匹配器。 如果匹配规则重叠，则最早的有序过滤器链将获胜。</p>
<h2 id="请求匹配以进行调度和授权">请求匹配以进行调度和授权</h2>
<p>安全过滤器链（或等效的 <code>WebSecurityConfigurerAdapter</code>）具有请求匹配器，该请求匹配器用于确定是否将其应用于 HTTP 请求。一旦决定应用特定的过滤器链，就不再应用其他过滤器链。但是在过滤器链中，可以通过在<code>HttpSecurity</code> 配置器中设置其他匹配器来对授权进行更细粒度的控制。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">      .authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/foo/bar&quot;</span>).hasRole(<span class="string">&quot;BAR&quot;</span>)</span><br><span class="line">        .antMatchers(<span class="string">&quot;/foo/spam&quot;</span>).hasRole(<span class="string">&quot;SPAM&quot;</span>)</span><br><span class="line">        .anyRequest().isAuthenticated();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置 Spring Security 时最容易犯的一个错误是忘记这些匹配器适用于不同的流程，一个是整个过滤器链的请求匹配器，另一个是仅选择要应用的访问规则。</p>
<h2 id="将应用程序安全规则与执行器规则相结合">将应用程序安全规则与执行器规则相结合</h2>
<p>如果您将 Spring Boot Actuator 用于管理端点，则可能希望它们是安全的，默认情况下它们将是安全的。实际上，将执行器添加到安全应用程序后，您会获得一条仅适用于执行器端点的附加过滤器链。它由仅匹配执行器端点的请求匹配器定义，并且其顺序为 <code>ManagementServerProperties.BASIC_AUTH_ORDER</code>，该顺序比默认的SecurityProperties 回退过滤器少 5 个，因此在进行回退处理之前会经过它。</p>
<p>如果您希望将应用程序安全规则应用于执行器端点，则可以添加一个比执行器顺序更早顺序的过滤器链，并带有一个包括所有执行器端点的请求匹配器。如果您喜欢执行器端点的默认安全性设置，那么最简单的方法是在执行器端点之后但在回退之前（例如 <code>ManagementServerProperties.BASIC_AUTH_ORDER + 1</code>）添加自己的过滤器。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(ManagementServerProperties.BASIC_AUTH_ORDER + 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">     ...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Web 层中的 Spring Security 当前与 Servlet API 绑定在一起，因此，它仅在以嵌入式或其他方式在 Servlet 容器中运行应用程序时才真正适用。但是，它不依赖于 Spring MVC 或 Spring Web 堆栈的其余部分，因此可以在任何 servlet 应用程序中使用，例如使用 JAX-RS 的 servlet 应用程序。</p>
</blockquote>
<h2 id="方法安全">方法安全</h2>
<p>除了保护 Web 应用程序安全外，Spring Security 还提供了将访问规则应用于 Java 方法执行的支持。对于 Spring Security，这只是“保护资源”的另一种类型。对于用户而言，这意味着使用相同的 ConfigAttribute 字符串格式（例如角色或表达式）声明访问规则，但在代码中的其他位置。第一步是启用方法安全性，例如在应用程序的顶级配置中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleSecureApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以直接修饰方法资源，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Secured(&quot;ROLE_USER&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">secure</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello Security&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例是一种使用安全方法的服务。如果 Spring 创建了这种类型的 <code>@Bean</code>，则它将被代理，并且在实际执行该方法之前，调用者将必须通过安全拦截器。如果访问被拒绝，则调用者将获得 <code>AccessDeniedException</code> 而不是实际的方法结果。</p>
<p>方法上还可以使用其他注释来强制执行安全性约束，尤其是 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code>，它们可以使您编写分别包含对方法参数和返回值的引用的表达式。</p>
<blockquote>
<p>结合使用 Web 安全性和方法安全性并不少见。过滤器链提供了用户体验功能，例如身份验证和重定向到登录页面等，并且方法安全性在更精细的级别上提供了保护。</p>
</blockquote>
<h2 id="使用线程">使用线程</h2>
<p>Spring Security 从根本上讲是线程绑定的，因为它需要使当前经过身份验证的主体可供各种下游使用者使用。基本构件是 <code>SecurityContext</code>，它可以包含一个 <code>Authentication</code>（当用户登录时，它将是经过显式身份验证的<code>Authentication</code>）。您始终可以通过 <code>SecurityContextHolder</code> 中的静态便捷方法来访问和操作 <code>SecurityContext</code>，而该方法又可以简单地操作 <code>TheadLocal</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.getContext();</span><br><span class="line"><span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> context.getAuthentication();</span><br><span class="line"><span class="keyword">assert</span>(authentication.isAuthenticated);</span><br></pre></td></tr></table></figure>
<p>用户应用程序代码执行此操作并不常见，但是，如果你需要编写一个自定义的身份验证过滤器，它会很有用（尽管即使如此，Spring Security 中也可以使用基类来避免使用 SecurityContextHolder）。</p>
<p>如果需要访问 Web 端点中当前已认证的用户，则可以在 <code>@RequestMapping</code> 中使用方法参数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">foo</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> User user)</span> &#123;</span><br><span class="line">  ... <span class="comment">// do stuff with user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注释将当前的身份验证 (<code>Authentication</code>) 从 <code>SecurityContext</code> 中拉出，并对其调用 <code>getPrincipal()</code> 方法以产生方法参数。身份验证中的主体类型取决于用于验证身份验证的 <code>AuthenticationManager</code>，因此这是获得对用户数据的类型安全引用的有用的小技巧。</p>
<p>如果使用 Spring Security，则 <code>HttpServletRequest</code> 中的 <code>Principal</code> 将为 <code>Authentication</code> 类型，因此您也可以直接使用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/foo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">foo</span><span class="params">(Principal principal)</span> &#123;</span><br><span class="line">  <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> (Authentication) principal;</span><br><span class="line">  User = (User) authentication.getPrincipal();</span><br><span class="line">  ... <span class="comment">// do stuff with user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要编写在不使用 Spring Security 时可以工作的代码，那么这有时会很有用（您在加载 Authentication 类时需要更加谨慎）。</p>
<h2 id="异步处理安全方法">异步处理安全方法</h2>
<p>由于 <code>SecurityContext</code> 是线程绑定的，因此，如果要执行任何调用安全方法的后台处理，例如使用 <code>@Async</code>，您需要确保传播上下文。</p>
<p>这归结为将 <code>SecurityContext</code> 包装为在后台执行的任务（<code>Runnable</code>，<code>Callable</code> 等）。Spring Security 提供了一些帮助程序，例如 <code>Runnable</code> 和 <code>Callable</code> 的包装器。要将 <code>SecurityContext</code> 传播到 <code>@Async</code> 方法，您需要提供 <code>AsyncConfigurer</code> 并确保 <code>Executor</code> 具有正确的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationConfiguration</span> <span class="keyword">extends</span> <span class="title class_">AsyncConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatingSecurityContextExecutorService</span>(Executors.newFixedThreadPool(<span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 备忘录</title>
    <url>/web/CSS-%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h1>盒模型（Box Model）</h1>
<p>盒模型的主要区域：内容盒子（Content Box）、内边距盒子（Padding Box）、边框盒子（Border Box）、外边距盒子（Margin Box）。</p>
<p><img data-src="../../images/web/box-model.svg" alt="Box-Model"></p>
<p>Content Box：这是内容所在的区域。此内容可以控制其父级的大小，因此通常是最可变大小的区域。</p>
<p>Padding Box：内边距盒子围绕内容盒子，是由 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/CSS/padding"><code>padding</code></a> 属性创建的空间。如果我们的盒子设置了溢出规则，比如 <code>overflow:auto</code> 或者 <code>overflow:scroll</code>，滚动条也会占用这个空间。</p>
<p>Border Box：边框盒子围绕着内边距盒子，其空间被 <code>border</code> 值占用。边框是盒子的边界。</p>
<p>Margin Box：最后一个区域，即外边距盒子，是盒子周围的空间，由盒子上的 <code>margin</code> 规则定义。轮廓 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/CSS/outline"><code>outline</code></a> 和盒子阴影 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/CSS/box-shadow"><code>box-shadow</code></a> 等属性也占据了这个空间，因为它们被绘制在顶部，<strong>所以它们不会影响我们盒子的大小</strong>。你可以在盒子上有一个 <code>200px</code> 的 <code>outline-width</code>，并且包括边框在内的所有内容都将是完全相同的大小。</p>
<span id="more"></span>
<h2 id="内容和大小">内容和大小</h2>
<p>盒子根据其 <code>display</code> 值、设置的尺寸和其中的内容具有不同的行为。</p>
<p>你可以通过使用外部大小来控制盒模型内容大小：<code>width：50px;</code></p>
<p>或者，也可以继续让浏览器根据内容大小为您做出决定，使用内部大小：<code>width: min-width;</code> 浏览器默认行为；</p>
<p>当我们显式的设置宽度 <code>width</code> 时，由于 CSS 使用默认的 <code>box-sizing: content-box</code>，<strong>宽度只会作用于内容盒子</strong>。我们也可以使用 <code>border-box</code> 让盒子大小为：Border Box + Padding Box + Content Box。</p>
<h2 id="JS-获取盒模型大小">JS 获取盒模型大小</h2>
<h3 id="Content-Box">Content Box</h3>
<p>JS 无法直接获取内容盒子的大小，但是可以通过 Padding Box 的大小 - Padding 得到，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getContentWidth</span> (element) &#123;</span><br><span class="line">  <span class="keyword">const</span> styles = <span class="title function_">getComputedStyle</span>(element)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element.<span class="property">clientWidth</span></span><br><span class="line">    - <span class="built_in">parseFloat</span>(styles.<span class="property">paddingLeft</span>)</span><br><span class="line">    - <span class="built_in">parseFloat</span>(styles.<span class="property">paddingRight</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Padding-Box">Padding Box</h3>
<p>内边距盒子可以通过元素的 <code>clientWidth</code> 只读属性获取，<strong><code>Element.clientWidth</code></strong> 可以用来获取非内联元素的内边距盒子宽度，以像素计。该属性包括内边距 padding，但不包括边框 border、外边距 margin 和垂直滚动条（如果有的话）。</p>
<p>如果元素超出了指定大小并设置了溢出规则，此时如果要获取元素的实际内边距盒子，可以通过 <strong><code>Element.scrollWidth</code></strong> 只读属性来度量包括由于溢出而在屏幕上不可见的内容的宽度。宽度的测量方式与 clientWidth 相同，如果没有溢出，则 clientWidth 和 scrollWidth 相同。</p>
<h3 id="Border-Box">Border Box</h3>
<p>要获取包括边框在内的宽度，可以使用元素的 <code>offsetWidth</code> 只读属性。<strong><code>HTMLElement.offsetWidth</code></strong>  包括任何边框、内边距和垂直滚动条（如果有的话）。它不包括伪元素的宽度，例如 <code>::before</code> 或 <code>::after</code>。</p>
<p>也可以使用元素的 <strong>getBoundingClientRect()</strong> 属性，绝大多数情况下两者是相等的。除了在有 <strong><code>变换 - transform</code></strong> 的情况下，offsetWidth 和 offsetHeight 返回元素的布局宽度和高度，而 getBoundingClientRect() 返回渲染的宽度和高度。</p>
<p>例如，如果元素有 width: 100px; 和 transform: scale(0.5); getBoundingClientRect() 将返回 50 作为宽度，而 offsetWidth 将返回 100。</p>
<hr>
<p>它们的关系如下图：</p>
<p><img data-src="../../images/web/js-doc-width.png" alt="js-doc-width"></p>
<h1>选择器（CSS Selector）</h1>
<p>要将 CSS 应用于元素，需要先选择元素。CSS 为我们提供了许多不同的方法来执行此操作。这些选择器可以<strong>多个任意组合</strong>形成一个 CSS 规则。这些选择器包括：</p>
<h2 id="基本选择器">基本选择器</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">通用选择器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors">Universal selector</a>）</p>
<p>选择所有元素。（可选）可以将其限制为特定的名称空间或所有名称空间。<br>
<strong>语法：</strong><code>*</code> <code>ns|*</code> <code>*|*</code><br>
<strong>例子：</strong><code>*</code> 将匹配文档的所有元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">元素选择器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Type_selectors">Type selector</a>）</p>
<p>按照给定的节点名称，选择所有匹配的元素。<br>
<strong>语法：</strong><code>elementname</code><br>
<strong>例子：</strong><code>input</code> 匹配任何 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">``</a> 元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">类选择器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Class_selectors">Class selector</a>）</p>
<p>按照给定的 <code>class</code> 属性的值，选择所有匹配的元素。<br>
<strong>语法</strong>：<code>.classname</code><br>
<strong>例子</strong>：<code>.index</code> 匹配任何 <code>class</code> 属性中含有 “index” 类的元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID 选择器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/ID_selectors">ID selector</a>）</p>
<p>按照 <code>id</code> 属性选择一个与之匹配的元素。需要注意的是，一个文档中，每个 ID 属性都应当是唯一的。<br>
<strong>语法：</strong><code>#idname</code><br>
<strong>例子：</strong><code>#toc</code> 匹配 ID 为 “toc” 的元素。</p>
</li>
</ul>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">属性选择器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors">Attribute selector</a>）</p>
<p>按照给定的属性，选择所有匹配的元素。<br>
<strong>语法：</strong><code>[attr]</code> <code>[attr=value]</code> <code>[attr~=value]</code> <code>[attr|=value]</code> <code>[attr^=value]</code> <code>[attr$=value]</code> <code>[attr*=value]</code><br>
<strong>例子：</strong><code>[autoplay]</code> 选择所有具有 <code>autoplay</code> 属性的元素（不论这个属性的值是什么）。</p>
</li>
</ul>
<h2 id="分组选择器（Grouping-selectors）">分组选择器（Grouping selectors）</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Selector_list">选择器列表</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Selector_list">Selector list</a>）</p>
<p><code>,</code> 是将不同的选择器组合在一起的方法，它选择所有能被列表中的任意一个选择器选中的节点。<br>
<strong>语法</strong>：<code>A, B</code><br>
<strong>示例</strong>：<code>div, span</code> 会同时匹配 <span> 元素和 <div> 元素。</p>
</li>
</ul>
<h2 id="组合器（Combinators）">组合器（Combinators）</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">后代组合器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Descendant_combinator">Descendant combinator</a>）</p>
<p><code> </code>（空格）组合器选择前一个元素的所有后代节点。<br>
<strong>语法：</strong><code>A B</code><br>
<strong>例子：</strong><code>div span</code> 递归匹配所有位于任意 <div> 元素之内的 <span> 元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">直接子代组合器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Child_combinator">Child combinator</a>）</p>
<p><code>&gt;</code> 组合器选择前一个元素的直接子代的节点。<br>
<strong>语法</strong>：<code>A &gt; B</code><br>
<strong>例子</strong>：<code>ul &gt; li</code> 匹配直接嵌套在 <ul> 元素内的所有 <li> 元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">一般兄弟组合器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/General_sibling_combinator">General sibling combinator</a>）</p>
<p><code>~</code> 组合器选择兄弟元素，也就是说，后一个节点在前一个节点后面的任意位置，并且共享同一个父节点。<br>
<strong>语法</strong>：<code>A ~ B</code><br>
<strong>例子</strong>：<code>p ~ span</code> 匹配同一父元素下，<p> 元素后的所有 <span> 元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">紧邻兄弟组合器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Adjacent_sibling_combinator">Adjacent sibling combinator</a>）</p>
<p><code>+</code> 组合器选择相邻元素，即后一个元素紧跟在前一个之后，并且共享同一个父节点。<br>
<strong>语法：</strong><code>A + B</code><br>
<strong>例子：</strong><code>h2 + p</code> 会匹配所有紧邻在 <he> 元素后的 <p> 元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Column_combinator">列组合器</a>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Column_combinator">Column combinator</a>）</p>
<p><code>||</code> 组合器选择属于某个表格行的节点。<br>
<strong>语法：</strong> <code>A || B</code><br>
<strong>例子：</strong> <code>col || td</code> 会匹配所有 <col> 作用域内的 <td> 元素。</p>
</li>
</ul>
<h2 id="伪选择器（Pseudo）">伪选择器（Pseudo）</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes">伪类</a></p>
<p><code>:</code> 伪选择器支持按照未被包含在文档树中的状态信息来选择元素。<br>
<strong>例子：</strong><code>a:visited</code> 匹配所有曾被访问过的 <a> 元素。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-elements">伪元素</a></p>
<p><code>::</code> 伪选择器用于表示无法用 HTML 语义表达的实体。<br>
<strong>例子：</strong><code>p::first-line</code> 匹配所有 <p> 元素的第一行。</p>
</li>
</ul>
<h2 id="使用技巧">使用技巧</h2>
<ul>
<li>使用紧邻兄弟组合器为堆叠元素之间添加间隙。<code>&gt; * + *</code></li>
</ul>
<p class="codepen" data-height="521" data-default-tab="css,result" data-slug-hash="ZEaqxjz" data-user="Zeral-Zhang" style="height: 521px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a target="_blank" rel="noopener" href="https://codepen.io/Zeral-Zhang/pen/ZEaqxjz">
  Learn CSS - Next sibling selector</a> by Zeral (<a target="_blank" rel="noopener" href="https://codepen.io/Zeral-Zhang">@Zeral-Zhang</a>)
  on <a target="_blank" rel="noopener" href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<p>仅当元素是 <code>.top</code> 的子元素的下一个兄弟元素时，才使用紧邻兄弟组合器添加间隙，并使用伪元素为间隙添加背景色。</p>
<blockquote>
<p>也可以使用 <code>column-gap</code>、<code>row-gap</code> 为 Multi-column（多列布局）、Flexible Box（弹性盒子）以及 Grid layouts（网格布局）中的列或行之间添加间隙。</p>
</blockquote>
<ul>
<li>使用 Emmet 类 CSS 选择器语法快速书写结构化代码块</li>
</ul>
<p>例如使用下面的缩写：</p>
<figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line"><span class="symbol">#page</span>&gt;div.logo+ul<span class="symbol">#navigation</span>&gt;li*<span class="number">5</span>&gt;a&#123;<span class="type">Item</span> <span class="string">$&#125;</span></span><br></pre></td></tr></table></figure>
<p>将转换为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;page&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;navigation&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大多数编辑器都支持 Emmet 缩写 Tab 键快速展开代码块，它的语法不限于 HTML，详情查看官方文档：<a target="_blank" rel="noopener" href="https://docs.emmet.io/">Emmet Documentation</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Box Model</tag>
        <tag>CSS Selector</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux bindActionCreators 使用</title>
    <url>/web/Redux-bindActionCreators-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>总结下 <code>bindActionCreators(actionCreators, dispatch)</code> 的用法：</p>
<hr>
<h2 id="ActionCreator">ActionCreator</h2>
<h3 id="为什么需要-actionCreator">为什么需要 <code>actionCreator</code>:</h3>
<p>如果我们的 action 直接可以拿到的，当然就不需要 actionCreator，我们可以直接 <code>store.dispatch(&#123;'INCREMENT'&#125;)</code></p>
<p>但是如果我们的 action 信息是异步获取的，或者其它方法获取的话，就需要 actionCreator，感觉是废话。</p>
<h3 id="actionCreator-是什么"><code>actionCreator</code> 是什么</h3>
<p>我们直接复制文档中的概念：</p>
<blockquote>
<p>一个 <strong>action creator</strong> 就是一个创建 action 的函数。action 是信息的载体，action creator 是用来创建 action 的工厂。</p>
<p>调用 action creator 只会产生一个 action，但是不会分发（dispatch）它。需要调用 store 的  <code>dispatch</code> 方法去完成分发。平时我们所说的 <strong>bound action creator</strong>(绑定行为创建器) 其实是说 <strong>调用 action   creator 并立即将结果分发给特定的 store 实例</strong> 的方法。</p>
</blockquote>
<span id="more"></span>
<p>下面就是一个最简单的例子：</p>
<p>action:</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>	</span><br><span class="line">   type<span class="punctuation">:</span> ADD_TODO<span class="punctuation">,</span></span><br><span class="line">   text</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>action creator:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">addTodo</span> = (<span class="params">text=<span class="string">&#x27;default text&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">ADD_TODO</span>,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分发-dispatch-action">分发(dispatch) action</h3>
<p>正常的，我们分发 action 是这样的，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(data));</span><br></pre></td></tr></table></figure>
<p>或者，可以创建一个自动调度的 <strong>bound action creator</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">boundAddTodo</span> = text =&gt; <span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(text))</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">boundCompleteTodo</span> = index =&gt; <span class="title function_">dispatch</span>(<span class="title function_">completeTodo</span>(index))</span><br></pre></td></tr></table></figure>
<p>现在，我们就可以直接调用了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">boundAddTodo</span>(text)</span><br><span class="line"><span class="title function_">boundCompleteTodo</span>(index)</span><br></pre></td></tr></table></figure>
<h3 id="使用-bindActionCreators-创建可直接调用的-ActionCreator">使用 bindActionCreators 创建可直接调用的 ActionCreator</h3>
<p>通常，你应该直接在 Store 实例上调用 dispatch。如果你将 Redux 与 React 一起使用，react-redux 将为你提供调度功能，你也可以直接调用它。</p>
<p>bindActionCreators 的唯一用例是当你想将一些动作创建者传递给一个不知道 Redux 的组件时，你不想将 dispatch 或 Redux store 传递给它。</p>
<p>比如上面的两个 actionCreator，我们想在组件外直接调用它，我们可以先定义：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = <span class="title function_">bindActionCreators</span>(&#123;</span><br><span class="line">                           <span class="attr">addTodo</span>: boundAddTodo,</span><br><span class="line">                           <span class="attr">completeTodo</span>: boundCompleteTodo</span><br><span class="line">                       &#125;, store.<span class="property">dispatch</span>)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以直接在其它地方调用：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions.<span class="title function_">addTodo</span>(<span class="string">&#x27;N个BUG待处理&#x27;</span>)</span><br><span class="line">actions.<span class="title function_">completeTodo</span>(<span class="string">&#x27;已处理1个，剩余N-1个&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Redux</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 过滤器</title>
    <url>/spring/Spring-Security-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>Spring Security 的 Web 基础结构完全基于标准的 servlet 过滤器。Spring Security 在内部维护一个过滤器链，其中每个过滤器都有特定的责任，过滤器的顺序很重要，因为它们之间存在依赖关系。</p>
<span id="more"></span>
<h2 id="过滤器链">过滤器链</h2>
<ul>
<li>
<h2 id="DelegatingFilterProxy"><code>DelegatingFilterProxy</code></h2>
<p>使用 servlet 过滤器时，显然需要在 <code>web.xml</code> 中声明它们，否则 servlet 容器将忽略它们。在 Spring Security 中，过滤器类也是在应用程序上下文中定义的 Spring bean，因此能够利用 Spring 丰富的依赖注入工具和生命周期接口。Spring 的 <code>DelegatingFilterProxy</code> 提供了 <code>web.xml</code> 和应用程序上下文之间的链接。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，过滤器实际上是 <code>DelegatingFilterProxy</code>，而不是实际实现过滤器逻辑的类。DelegatingFilterProxy 所做的是将 <code>Filter</code> 的方法委托给从 Spring 应用程序上下文中获取的 bean。bean 必须实现 <code>javax.servlet.Filter</code>，它必须与 <code>filter-name</code> 元素中的名称相同。<br>
<code>DelegatingFilterProxy</code> 继承 <code>GenericFilterBean</code>，该抽象类实现 <code>Filter</code> 接口，并提供 Spring 的管理。但是委托类自己不去实现安全过滤，而是将过滤方法委托给 <code>FilterChainProxy</code> 代理类去做。</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">    <span class="type">Filter</span> <span class="variable">delegateToUse</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">    <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.delegateMonitor) &#123;</span><br><span class="line">            delegateToUse = <span class="built_in">this</span>.delegate;</span><br><span class="line">            <span class="keyword">if</span> (delegateToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> findWebApplicationContext();</span><br><span class="line">                <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No WebApplicationContext found: &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;no ContextLoaderListener or DispatcherServlet registered?&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                delegateToUse = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.delegate = delegateToUse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the delegate perform the actual doFilter operation.</span></span><br><span class="line">    invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>delegateToUse</code> 就是 <code>FilterChainProxy</code>,代理类调用自己的 <code>Filter</code> 实现。</p>
<ul>
<li>
<h2 id="FilterChainProxy"><code>FilterChainProxy</code></h2>
<p>Spring Security 的 Web 基础结构只能通过委托 FilterChainProxy 实例来实现。安全过滤器不应该使用自身。FilterChainProxy 允许我们向 web.xml 添加一个条目，并完全处理应用程序上下文文件以管理我们的 Web 安全 bean。</p>
<p>该类同样继承自 <code>GenericFilterBean</code>，<code>Filter</code> 实现如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">clearContext</span> <span class="operator">=</span> request.getAttribute(FILTER_APPLIED) == <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (clearContext) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">            doFilterInternal(request, response, chain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            SecurityContextHolder.clearContext();</span><br><span class="line">            request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        doFilterInternal(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FirewalledRequest</span> <span class="variable">fwRequest</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">fwResponse</span> <span class="operator">=</span> firewall</span><br><span class="line">            .getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line"></span><br><span class="line">    List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filters == <span class="literal">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(UrlUtils.buildRequestUrl(fwRequest)</span><br><span class="line">                    + (filters == <span class="literal">null</span> ? <span class="string">&quot; has no matching filters&quot;</span></span><br><span class="line">                            : <span class="string">&quot; has an empty filter list&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fwRequest.reset();</span><br><span class="line"></span><br><span class="line">        chain.doFilter(fwRequest, fwResponse);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">VirtualFilterChain</span> <span class="variable">vfc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VirtualFilterChain</span>(fwRequest, chain, filters);</span><br><span class="line">    vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 firewall 就实现了安全字符过滤，Url编码解码配置，访问方法配置等等安全策略。<br>
真正执行安全过滤的是在其内部类 <code>VirtualFilterChain</code> 中，在该类中依次调用各个安全过滤器。</p>
<h2 id="后处理配置实体-ObjectPostProcessor">后处理配置实体 - <code>ObjectPostProcessor</code></h2>
<p>Spring Security 的 Java 配置不会公开它配置的每个对象的每个属性。这简化了大多数用户的配置。毕竟，如果每个属性都被暴露，用户可以使用标准 bean 配置。</p>
<p>虽然有充分的理由不直接公开每个属性，但用户可能仍需要更高级的配置选项。为了解决这个问题，Spring Security 引入了 <code>ObjectPostProcessor</code> 的概念，可用于修改或替换 Java Configuration 创建的许多 Object 实例。例如，如果要在 FilterSecurityInterceptor 上配置 filterSecurityPublishAuthorizationSuccess 属性，可以使用以下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">http</span><br><span class="line">    .authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O fsi)</span> &#123;</span><br><span class="line">                <span class="comment">// 默认只会广播 AuthorizationFailureEvent 事件，如果设置为 true，则同时也会广播 AuthorizedEvent</span></span><br><span class="line">                fsi.setPublishAuthorizationSuccess(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> fsi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤器顺序">过滤器顺序</h2>
<p>过滤器在链中定义的顺序非常重要：</p>
<ul>
<li><code>ChannelProcessingFilter</code>：因为它可能需要重定向到不同的协议</li>
<li><code>SecurityContextPersistenceFilter</code>: 因此，可以在 Web 请求开始时在 SecurityContextHolder 中设置 SecurityContext，并且当 Web 请求结束时（可以使用下一个 Web 请求准备好），可以将对 SecurityContext 的任何更改复制到 HttpSession。</li>
<li><code>ConcurrentSessionFilter</code>： 因为它需要使用 SecurityContextHolder 的功能，而且更新对应 session 的最后更新时间，以及通过 SessionRegistry 获取当前的 SessionInformation 以检查当前的 session 是否已经过期，过期则会调用 LogoutHandler。</li>
<li>身份验证处理机制 - <code>UsernamePasswordAuthenticationFilter</code>，<code>CasAuthenticationFilter</code>，<code>BasicAuthenticationFilter</code> 等 - 以便可以修改 SecurityContextHolder 以包含有效的身份验证请求令牌。</li>
<li><code>SecurityContextHolderAwareRequestFilter</code>：使用它将 Spring Security 感知  HttpServletRequestWrapper 安装到您的 servlet 容器中。</li>
<li><code>JaasApiIntegrationFilter</code>：如果 JaasAuthenticationToken 位于SecurityContextHolder 中，则会将 FilterChain 作为 JaasAuthenticationToken 中的 Subject 进行处理。</li>
<li><code>RememberMeAuthenticationFilter</code>: 如果没有更早的身份验证处理机制更新 SecurityContextHolder，并且该请求提供了一个 cookie，使我能够记住我的服务，一个合适的 remembered Authentication 验证对象将会设给 SecurityContextHolder。</li>
<li><code>AnonymousAuthenticationFilter</code>，这样如果没有早期的身份验证处理机制更新 SecurityContextHolder，那么该安全上下文将被匿名身份验证对象填充。</li>
<li><code>ExceptionTranslationFilter</code>，用于捕获任何 Spring Security 异常，以便可以返回 HTTP 错误响应或启动相应的 AuthenticationEntryPoint。</li>
<li><code>FilterSecurityInterceptor</code>，用于保护 Web URI 并在访问被拒绝时引发异常。</li>
</ul>
<h2 id="核心过滤器">核心过滤器</h2>
<ul>
<li>
<h3 id="FilterSecurityInterceptor"><code>FilterSecurityInterceptor</code></h3>
</li>
</ul>
<p>该过滤器负责处理 HTTP 资源的安全性，它需要一个 <code>AuthenticationManager</code> 和 <code>AccessDecisionManager</code> 的引用。它还提供了适用于不同 HTTP URL 请求的配置属性。<br>
<code>FilterSecurityInterceptor</code> 可以通过两种方式配置配置属性。第一种，是使用命名空间元素 <filter-security-metadata-source>，这里不再说明。第二个选项是编写自己的 <code>SecurityMetadataSource</code>，无论使用何种方法。SecurityMetadataSource 负责返回 List<ConfigAttribute>，其中包含与单个安全 HTTP URL 关联的所有配置属性。<br>
应该注意的是，FilterSecurityInterceptor.setSecurityMetadataSource() 方法实际上需要 FilterInvocationSecurityMetadataSource 的实例。它是一个标记接口，表示它是 <code>SecurityMetadataSource</code> 的子类。它只是表示 SecurityMetadataSource 了解 FilterInvocation。为了简单起见，我们将继续将 FilterInvocationSecurityMetadataSource 称为 SecurityMetadataSource，因为这种区别与大多数用户没什么关系。<br>
由命名空间语法创建的 SecurityMetadataSource 通过将请求 URL 与配置的 pattern 属性相匹配来获取特定 FilterInvocation 的配置属性。这与命名空间配置的行为方式相同。缺省情况是将所有表达式视为 Apache Ant 路径，并且对于更复杂的情况也支持正则表达式。request-matcher 属性用于指定正在使用的模式的类型。在同一定义中无法混合表达式语法。<br>
始终按照定义的顺序评估模式。因此，在列表中定义的更具体的模式比不太具体的模式更高这一点很重要。</p>
<ul>
<li>
<h3 id="ExceptionTranslationFilter"><code>ExceptionTranslationFilter</code></h3>
<code>ExceptionTranslationFilter</code> 位于安全过滤器堆栈中的 <code>FilterSecurityInterceptor</code> 之上。它不执行任何实际的安全实施，但处理安全拦截器抛出的异常并提供合适的 HTTP 响应。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;exceptionTranslationFilter&quot;</span></span><br><span class="line">class=<span class="string">&quot;org.springframework.security.web.access.ExceptionTranslationFilter&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;authenticationEntryPoint&quot;</span> ref=<span class="string">&quot;authenticationEntryPoint&quot;</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;accessDeniedHandler&quot;</span> ref=<span class="string">&quot;accessDeniedHandler&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;authenticationEntryPoint&quot;</span></span><br><span class="line">class=<span class="string">&quot;org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;loginFormUrl&quot;</span> value=<span class="string">&quot;/login.jsp&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;accessDeniedHandler&quot;</span></span><br><span class="line">    class=<span class="string">&quot;org.springframework.security.web.access.AccessDeniedHandlerImpl&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;errorPage&quot;</span> value=<span class="string">&quot;/accessDenied.htm&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h4 id="AuthenticationEntryPoint"><code>AuthenticationEntryPoint</code></h4>
</li>
</ul>
<p>用户未进行身份验证时请求安全的 HTTP 资源时，会调用 <code>AuthenticationEntryPoint</code>。安全拦截器将在调用堆栈的下方抛出适当的 <code>AuthenticationException</code> 或 <code>AccessDeniedException</code>，触发入口点的 <code>commence</code> 方法。这样做的目的是向用户提供适当的响应，以便开始身份验证。我们在这里使用的是 <code>LoginUrlAuthenticationEntryPoint</code>，它将请求重定向到不同的URL（通常是登录页面）。使用的实际实现将取决于您希望在应用程序中使用的身份验证机制。</p>
<ul>
<li>
<h4 id="AccessDeniedHandler"><code>AccessDeniedHandler</code></h4>
如果抛出 <code> AccessDeniedException</code> 并且用户已经过身份验证，则这意味着此操作没有足够权限。在这种情况下，<code>ExceptionTranslationFilter</code> 将调用第二个策略 <code>AccessDeniedHandler</code>。默认情况下，使用 <code>AccessDeniedHandlerImpl</code>，它只向客户端发送 403（Forbidden）响应。你也可以实现自己的处理。</li>
<li>
<h4 id="SavedRequest-和-RequestCache-接口"><code>SavedRequest </code>和 <code>RequestCache</code> 接口</h4>
</li>
</ul>
<p><code>ExceptionTranslationFilter</code> 职责的另一个职责是在调用 <code>AuthenticationEntryPoint</code> 之前保存当前请求。这允许在用户进行身份验证后恢复请求，一个典型的例子是用户使用表单登录，然后通过默认的 <code>SavedRequestAwareAuthenticationSuccessHandler</code> 重定向到原始 URL。<br>
<code>RequestCache</code> 封装了存储和检索 <code>HttpServletRequest</code> 实例所需的功能。默认使用 <code>HttpSessionRequestCache</code>，它将请求存储在 <code>HttpSession</code> 中。当用户被重定向到原始 URL 时，<code>RequestCacheFilter</code> 的作用是实际从缓存中恢复已保存的请求。</p>
<ul>
<li>
<h3 id="SecurityContextPersistenceFilter"><code>SecurityContextPersistenceFilter</code></h3>
<p>根据应用程序的类型，可能需要采用策略来在用户操作之间存储安全上下文。在典型的Web应用程序中，用户登录一次，然后由其 session Id 标识。服务器在会话期间缓存主体信息。在 Spring Security 中，在请求之间存储 <code>SecurityContext</code> 的责任属于<code>SecurityContextPersistenceFilter</code>，它默认将上下文存储为HTTP请求之间的 <code>HttpSession</code> 属性。它为每个请求恢复 <code>SecurityContextHolder</code> 的上下文，并且至关重要的是，在请求完成时清除 <code>SecurityContextHolder</code>。出于安全目的，您不应直接与 <code>HttpSession</code> 交互，使用 SecurityContextHolder 即可。<br>
许多其他类型的应用程序（例如，无状态 RESTful Web 服务）不使用 HTTP 会话，并将在每个请求上重新进行身份验证。但是，在链中包含 <code>SecurityContextPersistenceFilter</code> 以确保在每次请求后清除 <code>SecurityContextHolder</code> 仍然很重要。<br>
如前所述，此过滤器有两个主要任务。它负责在 HTTP 请求之间存储 <code>SecurityContext</code> 内容，并在请求完成时清除 <code>SecurityContextHolder</code>。清除存储上下文的 <code>ThreadLocal</code> 是必不可少的，因为否则可能会将一个线程替换为 servlet 容器的线程池，与特定用户的安全上下文仍然附加。然后可以在稍后阶段使用该线程，使用错误的凭证执行操作。<br>
从 Spring Security 3.0 开始，加载和存储安全上下文的工作现在被委托给一个单独的策略接口 <code>SecurityContextRepository</code>。</p>
</li>
<li>
<h3 id="UsernamePasswordAuthenticationFilter"><code>UsernamePasswordAuthenticationFilter</code></h3>
<p>我们现在已经看到了 Spring Security Web 配置中始终存在的三个主要过滤器。现在唯一缺少的是实际的身份验证机制，允许用户进行身份验证。此过滤器是最常用的身份验证过滤器，也是最常定制的过滤器。配置它需要三个阶段。</p>
<ul>
<li>使用登录页面的URL来配 <code>LoginUrlAuthenticationEntryPoint</code>，就像我们上面所做的那样，并在 <code>ExceptionTranslationFilter</code> 上设置它。</li>
<li>实现登录页面（使用 JSP 或 MVC 控制器）。</li>
<li>在应用程序上下文中配置 <code>UsernamePasswordAuthenticationFilter</code> 的实例。</li>
<li>将过滤器 bean 添加到过滤器链代理（确保您注意顺序）。</li>
</ul>
</li>
</ul>
<h4 id="认证成功与失败的应用流程">认证成功与失败的应用流程</h4>
<p>过滤器调用配置 <code>AuthenticationManager</code> 来处理每个身份验证请求。身份验证成功或身份验证失败后的目标分别由 <code>AuthenticationSuccessHandler</code> 和 <code>AuthenticationFailureHandler</code> 策略接口控制。分别的，过滤器具有这些属性以便您可以完全自定义行为。提供了一些标准实现，如 <code>SimpleUrlAuthenticationSuccessHandler</code>, <code>SavedRequestAwareAuthenticationSuccessHandler</code>, <code>SimpleUrlAuthenticationFailureHandler</code>, <code>ExceptionMappingAuthenticationFailureHandler</code> and <code>DelegatingAuthenticationFailureHandler</code>。查看这些类的 Javadoc 以及 <code>AbstractAuthenticationProcessingFilter</code>，以了解它们的工作原理和支持的功能。</p>
<p>如果认证成功后，创建的 <code>Authentication</code> 对象将被放入 <code>SecurityContextHolder</code>中。然后将调用配置的 <code>AuthenticationSuccessHandler</code>，以将用户重定向或转发到适当的目标。默认情况下，使用 <code>SavedRequestAwareAuthenticationSuccessHandler</code>，这意味着在要求用户登录之前，用户将被重定向到他们请求的原始目标。</p>
<p>如果身份验证失败，将调用配置的 <code>AuthenticationFailureHandler</code>。</p>
<h2 id="请求匹配和-HttpFirewall">请求匹配和 HttpFirewall</h2>
<p>Servlet 规约为 HttpServletRequest 定义了一些属性，我们可能希望与之匹配来验证安全。这些是 <code>contextPath</code>，<code>servletPath</code>，<code>pathinfo</code> 和 <code>queryString</code>。Spring Security 只对保护应用程序中的路径感兴趣，因此将忽略 contextPath。但是 serveltPath 和 pathInfo 没有明确规范路径如何定义，比如每段地址是否都可以包含参数。为了防止这些问题， <code>FilterChainProxy</code> 使用 <code>HttpFirewall</code> 策略去检查和包裹请求。默认情况下，未规范化的请求会自动被拒绝，删除路径参数和重复斜杠以进行匹配。因此，必须使用 FilterChainProxy 来管理安全过滤器链。<br>
如上所述，默认策略是使用 <code>Ant-style</code> 路径进行匹配，这可能是大多数用户的最佳选择。该策略在 <code>AntPathRequestMatcher</code> 类中实现，该类使用 Spring 的 AntPathMatcher 对 servletPath 和 pathInfo 执行不区分大小写的模式匹配，忽略 queryString。<br>
如果你需要一个更加强大的模式匹配，你可以使用正则表达式。这种策略的实现是 <code>RegexRequestMatcher</code>。<br>
<code>HttpFirewall</code> 还通过拒绝 HTTP 响应标头中的换行字符来阻止 <a target="_blank" rel="noopener" href="https://www.owasp.org/index.php/HTTP_Response_Splitting">HTTP 响应拆分</a>。<br>
默认情况下使用 <code>StrictHttpFirewall</code>。此实现拒绝看似恶意的请求。你也可以自定义那些类型的请求应该被拒绝。比如，如果你希望利用 Spring MVC 的矩阵变量，你可以这样配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> StrictHttpFirewall <span class="title function_">httpFirewall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StrictHttpFirewall</span> <span class="variable">firewall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrictHttpFirewall</span>();</span><br><span class="line">    firewall.setAllowSemicolon(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StrictHttpFirewall 提供有效 HTTP 方法的白名单，允许防止跨站点跟踪（XST）和 HTTP 动词篡改。默认有效的方法是&quot;DELETE&quot;，“GET”， “HEAD”，“OPTIONS”，“PATCH”，“POST”，and “PUT”。如果你希望修改有效的有效方法，可以这样配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> StrictHttpFirewall <span class="title function_">httpFirewall</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StrictHttpFirewall</span> <span class="variable">firewall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrictHttpFirewall</span>();</span><br><span class="line">    firewall.setAllowedHttpMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果必须允许任何 HTTP 方法（不推荐），则可以使用 StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)。这将完全禁用 HTTP 方法的验证。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符整理</title>
    <url>/web/%E8%BF%90%E7%AE%97%E7%AC%A6%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>在 JavaScript 或等语言中会出现很多运算符，对于有些运算符不明白看别人代码就有些懵，学习并整理一下它们的功能及用法。</p>
<p>这些运算符主要包括：双叹号 <code>!!</code>，短路或 <code>||</code>，短路与 <code>&amp;&amp;</code>，按位非 <code>~</code>，按位与 <code>&amp;</code>，异或 <code>^</code>，双波浪号 <code>~~</code>，可选链式操作符(Optional Chaining Operator) <code>?.</code></p>
<p>有些运算符是某些语言特有的，但大多具有普遍性，代表的含义和语法也不尽相同。</p>
<p>可能还会有一些运算符比如：可选参数 <code>?:</code> 非空断言 <code>!.</code> 这些包含在某个特定语言，例如：TypeScript 中的运算符在此不再解释。</p>
<hr>
<span id="more"></span>
<h2 id="双叹号">双叹号 <code>!!</code></h2>
<ul>
<li>
<h3 id="作用">作用</h3>
<p>将不同类型的值转换为 boolean 类型</p>
<p>如果该类型的值为真，则返回 true，在 JS 中被认为是真的值包括：</p>
</li>
<li>
<p>对象：<code>&#123;&#125;、new Date()</code></p>
</li>
<li>
<p>数组：<code>[]</code></p>
</li>
<li>
<p>非空字符串：<code>“str”</code></p>
</li>
<li>
<p>非 0 数字：<code>-1</code></p>
</li>
</ul>
<p>如果该类型的值为假，则返回 false，在 JS 中被认为是假的值包括：</p>
<ul>
<li>
<p>零长度空字符串：<code>&quot;&quot;</code></p>
</li>
<li>
<p>0</p>
</li>
<li>
<p>null</p>
</li>
<li>
<p>undefined</p>
</li>
<li>
<p>Nan</p>
</li>
<li>
<h3 id="用法">用法</h3>
<ol>
<li>在需要传入 boolean 类型的地方，比如字符串判空的条件表达式等</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!!str) &#123;</span><br><span class="line">  <span class="keyword">return</span> test.<span class="title function_">endsWith</span>(<span class="string">&#x27;.png&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="短路或">短路或 <code>||</code></h2>
<ul>
<li>
<h3 id="作用-2">作用</h3>
<p>左边的表达式为 true 则不执行右边的表达式，为 false 则执行右边的表达式</p>
</li>
<li>
<h3 id="用法-2">用法</h3>
<pre><code>1. 默认值处理  
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> param = object || <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>逻辑运算</li>
</ol>
</li>
</ul>
<h2 id="短路与">短路与 <code>&amp;&amp;</code></h2>
<ul>
<li>
<h3 id="作用-3">作用</h3>
<p>左边的表达式为 false 则不执行右边的表达式，为 true 则执行右边的表达式</p>
</li>
<li>
<h3 id="用法-3">用法</h3>
<ol>
<li>访问对象属性时，检测对象是否存在<br>
<code>object &amp;&amp; object.getName()</code></li>
<li>逻辑运算</li>
<li>虽然 <code>||</code> 和 <code>&amp;&amp;</code> 配合可以做 <code>if/else</code> 判断，<code>object &amp;&amp; object.getName() || ''</code>，但是建议使用三目运算符</li>
</ol>
</li>
</ul>
<h2 id="按位非">按位非 <code>~</code></h2>
<ul>
<li>
<h3 id="作用-4">作用</h3>
<p>可以简单的理解为该值取负值后减 1：<code>~N = -(N+1)</code></p>
<blockquote>
<p>按位运算符会将其操作数隐式转换为带符号的 32 位整数。</p>
</blockquote>
</li>
<li>
<h3 id="用法-4">用法</h3>
<ol>
<li>
<p>判断数组或者字符串中是否存在某个元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.<span class="title function_">indexOf</span>(subStr) != -<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="title function_">indexOf</span>(subStr) &gt;= <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以简写为： <code>if(~str.indexOf(subStr)) &#123;&#125;</code></p>
<p>原理：不存在返回 -1，~-1 = 0，大于 -1 的值，0，1，2，3 … 按位非的值 1，2，3，4…都大于 0</p>
<blockquote>
<p>ES6 中引入了新的方法 <code>includes()</code>，可以用来检测一个字符串是否包含另外一个字符串。</p>
</blockquote>
</li>
<li>
<p>位掩码（Bitmasking）：单用单一字段存储多个值时撤销某个值</p>
<p>位掩码经常被用做单个 int 字段储存多个配置项的情景，这些配置项一般会用做 2 进制的不同位置的值表示其掩码，例如使用左移运算符 <code>1 &lt;&lt; this.ordinal()</code>，如果我们要根据状态设置或取消配置项则可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    CONFIG_A,</span><br><span class="line">    CONFIG_B,</span><br><span class="line">    CONFIG_C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="built_in">this</span>.ordinal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getMask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用该配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">(<span class="type">int</span> configs, Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (configs &amp; config.mask) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置/取消该配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">config</span><span class="params">(<span class="type">int</span> configs, Config config, <span class="type">boolean</span> state)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state) &#123;</span><br><span class="line">            configs |= config.mask;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            configs &amp;= ~config.mask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> configs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="按位与">按位与 <code>&amp;</code></h2>
<ul>
<li>
<h3 id="作用-5">作用</h3>
<p>按位操作，同时为 1 则为 1，否则为 0</p>
</li>
<li>
<h3 id="用法-5">用法</h3>
<ol>
<li>
<p>位掩码：权限管理的权限判断</p>
<p>一个用户对文件或目录所拥有的权限分为三种：”可读”、”可写”和”可执行”，分别用 1(001) 、2(010) 和 4(100) 来表示，它们之间可以任意组合：有“可读”、“可写”权限就用 3 来表示（1 + 2 = 3）；有”可读“、”可执行“权限就用 5 来表示（1 + 4 = 5），三种权限全部拥有就用 7 表示（1 + 2 + 4 = 7）。</p>
<p>判断用户是否有可写权限 <code>if (role &amp; 2 === 2)</code></p>
<p>假设用户权限为 5(101) &amp; 2(010) = 1(001) !== 2(010)，则该用户不包含可写权限</p>
<p>用户权限为 3(011) &amp; 2(010) = 2(010) === 2(010)，则该用户包含可写权限</p>
</li>
</ol>
</li>
</ul>
<h2 id="位异或">位异或 <code>^</code></h2>
<ul>
<li>
<h3 id="作用-6">作用</h3>
<p>如果 a、b 两个值不相同，则异或结果为 1。如果 a、b 两个值相同，异或结果为 0。</p>
<p>异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用 1 表示真，0 表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。</p>
<p>异或的符号为 XOR、⊕。</p>
</li>
<li>
<h3 id="用法-6">用法</h3>
<ol>
<li>
<p>不引入中间数，交换两个整形数字</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span>(<span class="params">int a, int b</span>)</span><br><span class="line">&#123;</span><br><span class="line">  a=a^b;</span><br><span class="line">  b=b^a;</span><br><span class="line">  a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结果取反</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">boolean <span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">isNegated</span>() ^ expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>isNegated</code> 为 <code>true</code>，则结果为 <code>expression</code> 的取反，否则为表达式的结果。</p>
</li>
</ol>
</li>
</ul>
<h2 id="双波浪号">双波浪号 <code>~~</code></h2>
<ul>
<li>
<h3 id="作用-7">作用</h3>
<p>可以将浮点数或者字符串数值删除小数点后的所有内容并转换为整形,</p>
<p>对于小于 0 的数字向上转型，大于 0 的数字向下转型，相当于：</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(x);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>x 只能位于 -(2^31) 和 2^31 - 1 之间，否则会溢出</p>
</blockquote>
</li>
</ul>
<h2 id="可选链式操作符-Optional-Chaining-Operator">可选链式操作符(Optional Chaining Operator) <code>?.</code></h2>
<ul>
<li>
<h3 id="作用-8">作用</h3>
<p>确保在取对象属性时不用做不必要的前置对象存在的判断，以及避免抛出 undefined 异常</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Zeral&#x27;</span> &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 不会抛出异常</span></span><br><span class="line"><span class="keyword">const</span> city = user?.<span class="property">address</span>?.<span class="property">city</span></span><br><span class="line">   </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(city) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>之前我们可能会这样写：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Zeral&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> city = user</span><br><span class="line">      &amp;&amp; user.<span class="property">address</span></span><br><span class="line">      &amp;&amp; user.<span class="property">address</span>.<span class="property">city</span></span><br></pre></td></tr></table></figure>
<p>该语法也支持 function 和 constructor 的调用</p>
<p><code>const address = getAddressById?.(123)</code></p>
<p>如果 <code>getAddressById</code> 是个函数则会被调用，否则返回 undefined</p>
<blockquote>
<p>该语法暂未被浏览器广泛支持，使用时请配置<code>babel-plugin-transform-optional-chaining</code></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>运算符</tag>
        <tag>位权限</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2 和 OpenID Connect</title>
    <url>/security/OAuth2-%E5%92%8C-OpenID/</url>
    <content><![CDATA[<h1>OAuth 是什么</h1>
<p>OAuth 2.0 是一个授权协议，它允许软件应用代表（而不是充当）资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求授权，然后取得<strong>令牌（token）</strong>，并用它来访问资源。</p>
<p>虽然 OAuth 基本上不关心它所保护的资源类型，但它确实很适合当今的 RESTful Web 服务，也适用于 Web 应用和原生应用。</p>
<p>OAtuth <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6749">协议规范</a>是这样定义的：</p>
<blockquote>
<p>OAuth 2.0 框架能让第三方应用以有限的权限访问 HTTP 服务，可以通过构建资源拥有者与 HTTP 服务间的许可交互机制，让第三方应用代表资源拥有者访问服务，或者授予权限给第三方应用，让其代表自己访问服务。</p>
</blockquote>
<p>其中需要关心的组件角色如下：</p>
<ul>
<li><strong>资源拥有者</strong>有权访问受保护资源，并能将受保护资源的访问权限委托出去。与 OAuth 系统中的其他组件不同，资源拥有者不是软件。在<em>大多数</em>情况下，资源拥有者是一个人，他使用客户端软件访问受他控制的资源。至少在部分过程中，资源拥有者要使用 Web 浏览器（通常称为用户代理）与授权服务器 交互。资源拥有者可能还会使用浏览器与客户端交互。</li>
<li><strong>受保护资源</strong>是资源拥有者有权访问的组件，在访问时需要 OAuth 访问令牌。这样的组件有多种形式，但大多数情况下是某种形式的 Web API。受保护资源需要验证收到的令牌，并决定是否响应以及如何响应请求。在 OAuth 架构中，受保护资源对是否认可令牌拥有最终决定权。</li>
<li><strong>客户端</strong>是代表资源拥有者访问受保护资源的软件。在 OAuth 中，只要软件使用了受保护资源上的 API，他就是客户端。它使用 OAuth 来获取访问权限。得益于 OAuth 的设计，客户端通常是 OAuth 系统中最简单的组件，它的职责主要是从授权服务器获取令牌以及在受保护资源上使用令牌。客户端不需要理解令牌，也不需要查看令牌的内容。相 反，客户端只需要将令牌视为一个不透明的字符串即可。OAuth 客户端可以是 Web 应用、原生应用，甚至浏览器内的 JavaScript 应用。</li>
<li><strong>授权服务器</strong>是一个 HTTP 服务器，它在 OAuth 系统中充当中央组件。提供了一种机制来弥补客户端与受保护资源之间的间隙。授权服务器对资源拥有者和客户端进行身份认证，让资源拥有者向客户端授权、为客户端颁发令牌。某些授权服务器还会提供额外的功能，例如令牌内省、记忆授权决策。</li>
</ul>
<p>整个系统的目标是：让客户端代表资源拥有者访问受保护资源。</p>
<span id="more"></span>
<p><img data-src="../../images/security/oauth-components.png" alt="OAuth Components"></p>
<h1>OAuth 的优缺点</h1>
<p>OAuth 中假设不受控的客户端总是比授权服务器或者受保护资源多出好几个数量级。这样架构决策导致的结果就是，尽可能将复杂性从客户端转移到服务端。对于客户端开发人员是好事，因为客户端成了系统中最简单的部分。客户端开发人员不需要和别的安全协议那样，处理签名规范化以及解析复杂的安全策略文档，也不需要担心处理敏感的用户凭据。OAuth 令牌提供了一种比密码略复杂的机制，比旧时代的凭据共享和凭据盗用更加细粒度，安全和可控，使用得当，其安全性比密码高得多。</p>
<p>另一方面，授权服务器和受保护资源要承担更多的复杂性和安全性方面的责任。即使单个客户端被攻破，也不会泄漏受保护资源的凭据，因为客户端根本没有机会接触受保护资源的凭据。然而，授权服务器则需要管理和保护系统中所有客户端和用户的凭据和令牌。虽然这确实使它更容易成为攻击目标，但是保护单个授权服务器要比保护上千台由不同开发人员开发的客户端要容器得多。</p>
<p>OAuth 2.0 的可扩展性和模块化是其最大的优势之一，因为这使得该协议适用于各种环境。这种灵活性也导致不同的实现之间存在的兼容性问题。当开发人员想在不同的系统上实现 OAuth 时，它提供的众多自定义选项容易使人困惑。</p>
<p>更糟糕的是，OAuth 的某些自定义选项可能会被用在错误的地方或者实施不当，进而导致不安全的实现。这些漏洞在 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc6819">OAuth 威胁模型文档 - RFC 6819</a> 有详细的讨论。</p>
<h1>OAuth 不能做什么</h1>
<ul>
<li><strong>OAuth 没有定义 HTTP 协议之外的情形</strong>。由于使用 bearer 令牌的 OAuth 2.0 并不提供消息签名，因此不应脱离 <code>HTTPS</code>（TLS 上的 HTTP）使用。</li>
<li><strong>OAuth 不是身份认证协议</strong>。虽然可以用它构建一个，比如 <code>OpenID Connect</code>。但 OAuth 事物本事并不透露关于用户的信息。</li>
<li><strong>OAuth 没有定义用户对用户的授权机制</strong>，尽管它在根本上是一个用户向软件授权的协议。OAuth 假设资源拥有者能够控制客户端。要使资源拥有者向另一个用户授权，仅使用 OAuth 是不行的。但这种授权并不罕见，<code>User Mananged Access</code> 协议就是为此而生的，它规定了如何使用 OAuth 构建一个支持用户对用户授权的系统。</li>
<li><strong>OAuth 没有定义授权处理机制</strong>，OAuth 提供了一种方法来传达授权委托已发生这一事实，但是它并不定义授权的内容。相反，由服务 API 定义使用权限范围、令牌之类的 OAuth 组件来定义一个给定的令牌适用于哪些操作。</li>
<li><strong>OAuth 没有定义令牌格式</strong>。实际上，OAuth 协议明确声明了令牌的内容对客户端是完全不透明的。但是，颁发令牌的授权服务器和接收令牌的受保护资源仍然需要理解令牌。这个层面的互操作性要求催生了 <code>JSON Web Token（JWT）</code> 格式和令牌内省协议。</li>
<li><strong>OAuth 2.0 没有定义加密方法</strong>。OAuth 2.0 没有定义新的加密机制，而是允许借用通用的加密机制，这种加密机制不止适用于 OAuth。这种有意的遗漏催生了 JSON 对象签名和加密（<code>JOSE</code>）规范套件。该套件提供了一系列通用的加密机制，可以配合 OAuth 使用，也可以脱离 OAuth 使用。该套件也可以用于一种消息级的加密协议，该协议使用了 <code>OAuth PoP</code> 令牌。</li>
<li><strong>OAuth 2.0 不是单体协议</strong>。该规范被分成了多个定义和流程，每个定义和流程都有各自的使用场景。</li>
</ul>
<h1>OAuth 2.0 授权许可的完整过程</h1>
<p>我们将展示一个基于 Web 的客户端应用的<strong>授权码许可机制</strong>。该客户端将以交互方式得到资源拥有者的直接授权。</p>
<p><strong>授权码许可</strong>中用到了一个临时凭据 —— 授权码，来表示资源拥有者同意向客户端授权，如图所示。</p>
<img data-src="../../images/security/oauth-code-flow.png" alt="OAuth Code Flow" style="zoom:33%;" />
<p>首先，资源拥有者访问客户端应用，并表明他希望客户端代表自己去使用某一受保护资源。</p>
<p>当客户端发现需要获取一个新的的 OAuth 访问令牌时，它会将资源拥有者重定向至授权服务器，并附带一个授权请求，表示它要向资源拥有者请求一些权限。</p>
<img data-src="../../images/security/oauth-client-redirect.png" alt="image-028" style="zoom: 33%;" />
<p>由于我们使用的是 Web 客户端，因此采用 HTTP 重定向的方式将用户代理重定向至授权服务器的授权端点。客户端应用的响应如下所示：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Moved Temporarily </span><br><span class="line"><span class="attribute">x-powered-by</span><span class="punctuation">: </span>Express </span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client _id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 </span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>444</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 31 Jul 2015 20:50:19 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
<p>这个重定向响应导致浏览器向授权服务器发送一个 <code>GET</code> 请求。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client -1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9001 </span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0) Gecko/20100101 Firefox/39.0 </span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 </span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:9000/ </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive </span><br></pre></td></tr></table></figure>
<p>客户端通过在发送给用户的 URL 中包含查询参数，来标识自己的身份和要请求的授权详情，如授权范围等。</p>
<p>然后，授权服务器会要求用户进行身份认证。这一步对确认资源拥有者的身份已经能向客户端授予哪些权限来说至关重要。</p>
<img data-src="../../images/security/oauth-owner-authenticate.png" alt="OAuth Owner Authenticate"  />
<p>用户身份认证直接在用户（和用户的浏览器）与授权服务器之间进行，这个过程对客户端应用不可见。这一重要特性避免了用户将自己的凭据透露给客户端应用，对抗这种反模式正是发明 OAuth 的原因。</p>
<p>另外，因为资源拥有者通过浏览器与授权端点交互，所以也要通过浏览器来完成身份认证。 因此，有很多身份认证技术可以用于用户身份认证流程。OAuth 没有规定应该使用哪种身份认证 技术，授权服务器可以自由选择，例如用户名/密码、加密证书、安全令牌、联合单点登录或者 其他方式。在此我们不得不在一定程度上信任 Web 浏览器，特别是当资源拥有者使用像用户名 和密码这样的简单身份认证方式时。但是 OAuth 的设计已经考虑了如何防止多种基于浏览器的攻击。</p>
<p>这种隔离方案还使得客户端不会因用户身份认证方式发生变化而受到影响, 让简单的客户端应用也能受益于授权服务器使用的一些新兴技术，例如基于风险的启发式认证(risk-based heuristic authentication)技术。然而，这种做法并没有向客户端传递任何有关认证用户的信息，在将 OAuth 2.0 用于用户身份认证一章将深入讨论这个话题。</p>
<p>然后，用户向客户端应用授权。在这一步，资源拥有者选择将一部分权限授予客户端应用，授权服务器提供了许多不同的选项来实现这一点。 客户端可以在授权请求中指明其想要获得哪些权限(称为 OAuth 权限范围) 。授权服务器可以允许用户拒绝一部分或者全部权限范围，也可以让用户批准或者拒绝整个授权请求。</p>
<img data-src="../../images/security/oauth-owner-authorization.png" alt="OAuth Owner Authorization" style="zoom:33%;" />
<p>此外，很多授权服务器允许将授权决策保存下来，以便以后使用。如果使用了这种方式，那么未来同一个客户端请求同样的授权时，用户将不会得到提示。 用户仍然会被重定向到授权端点，并且仍然需要登录，但是会跳过批准授权环节而沿用前一次的授权决策。 授权服务器甚至可以通过像客户端白名单或黑名单这样的内部策略来否决用户的决策。</p>
<p>然后，授权服务器将用户重定向回客户端应用。</p>
<img data-src="../../images/security/oauth-redirect-to-client.png" alt="OAuth Server Redirect To Client" style="zoom: 33%;" />
<p>这一步采用 <code>HTTP</code> 重定向的方式，回到客户端的 <code>redirect_uri</code>。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP 302 Found </span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://localhost:9000/oauth_callback?code=8V1pr0rJ&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 </span><br></pre></td></tr></table></figure>
<p>这又会导致浏览器向客户端发出如下请求。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /callback?code=8V1pr0rJ&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9000 </span><br></pre></td></tr></table></figure>
<p>请注意，这个 HTTP 请求是发送给<strong>客户端</strong>而不是<strong>授权服务器</strong>的。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0) Gecko/20100101 Firefox/39.0 </span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 </span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1 </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>
<p>由于使用的是<strong>授权码</strong>许可类型，因此该重定向链接中包含一个特殊的查询参数 <code>code</code>。这个参数的值被称为<strong>授权码</strong>，<strong>它是一次性的凭据，表示用户授权决策的结果</strong>。客户端会在接收到请求之后解析该参数以获取授权码，并在下一步使用该授权码。客户端还会检查 state 参数值是否与它在前一个步骤中发送的值匹配。</p>
<p>现在客户端已经得到授权码，它可以将其发送给授权服务器的令牌端点。</p>
<img data-src="../../images/security/oauth-client-request-token.png" alt="OAuth Request Token By Code" style="zoom: 33%;" />
<p>客户端发送一个 <strong>POST</strong> 请求，在 HTTP 主体中以表单格式传递参数，并在 HTTP 基本认证头部中设置 <code>client_id</code> 和 <code>client_secret</code>。这个 HTTP 请求由客户端直接发送给授权服务器，浏览器或者资源拥有者不参与此过程。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /token</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9001</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>application/x-www-form-encoded</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Basic b2F1dGgtY2xpZW50LTE6b2F1dGgtY2xpZW50LXNlY3JldC0xgrant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;code=8V1pr0rJ</span><br></pre></td></tr></table></figure>
<p>这种将不同的 HTTP 连接分开的做法保证了客户端能够直接进行身份认证，让其他组件无法查看或者操作令牌请求。</p>
<p>授权服务器接收该请求，如果请求有效，则颁发令牌。授权服务器需要执行多个步骤以确保请求是合法的。首先，它要验证客户端凭据（通过 Authorization 头部传递）以确定是哪个客户端请求授权。然后，从请求主体中读取 code 参数的值，并从中获取关于该授权码的信息，包括发起初始授权请求的是哪个客户端，执行授权的是哪个用户，授权的内容是什么。如果授权码有效且尚未使用过，而且发起该请求的客户端与最初发起授权请求的客户端相同，则授权服务器会生成一个新的访问令牌并返回给客户端。</p>
<img data-src="../../images/security/oauth-server-response-token.png" alt="Server Response Token" style="zoom:33%;" />
<p>该令牌以 JSON 对象的格式通过 HTTP 响应返回给客户端。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP 200 OK Date: Fri, 31 Jul 2015 21:19:03 GMT </span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>application/json </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  &quot;access_token&quot;: &quot;987tghjkiu6trfghjuytrghj&quot;, </span><br><span class="line">  &quot;token_type&quot;: &quot;Bearer&quot; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>然后客户端可以解析令牌响应并从中获取令牌的值来访问受保护资源。在这个案例中，我们使用了 OAuth bearer 令牌，这是通过响应中的 token_type 字段描述的。令牌响应中还可以包含一个刷新令牌（用于获取新的访问令牌而不必重新请求授权），以及一些关于访问令牌的附加信息，比如令牌的权限范围和过期时间。客户端可以将访问令牌存储在一个安全的地方，以便以后在用户不在场时也能够随时使用。</p>
<p>有了令牌，客户端就可以在访问受保护资源时出示令牌。</p>
<img data-src="../../images/security/oauth-client-request-resource-server.png" alt="OAuth request OAuth Resource Server" style="zoom: 50%;" />
<p>客户端出示令牌的方式有多种，本例中将使用备受推荐的方式：使用 Authorization 头部。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /resource HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9002 </span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive </span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer 987tghjkiu6trfghjuytrghj</span><br></pre></td></tr></table></figure>
<p>受保护资源可以从头部中解析出令牌，判断它是否有效，从中得知授权者是谁以及授权内容，然后返回响应。受保护资源检查令牌的方式有多种。最简单的方式是让授权服务器和资源服务器共享存储令牌信息的数据库。授权服务器在生成新的令牌时将其写入数据库，资源服务器在收到令牌时从数据库中读取它们。</p>
<h1>授权许可类型</h1>
<p><strong>授权许可</strong>是 OAuth 协议中的权限获取方法，OAuth 客户端用它来获取受保护资源的访问权限，成功之后客户端会得到一个令牌。这可能是 OAuth 2.0 中最令人困惑的术语之一，因为它既表示用户授权所用的特定方式，也表示授权这个行为本身。前面详细介绍过的授权码许可类型加剧了这种困惑，因为开发人员有时候会看见传回给客户端的授权码，并误以为这个授权码（仅授权码）就是授权许可。虽然授权码确实代表用户的授权决策，但它不是授权许可本身。相反，整个 OAuth 流程才是授权许可：客户端将用户重定向至授权端点，然后接收授权码，最后用授权码换取令牌。</p>
<p>换句话说，<strong>授权许可就是获取令牌的方式</strong>。就像在 OAuth 社区中一样，会偶尔将其称为 OAuth 协议的一个流程（<strong>OAuth flow</strong>）。OAuth 协议中有多种授权许可方法，并且各有特点。</p>
<h2 id="授权码许可机制-authorization-code">授权码许可机制 - authorization_code</h2>
<p>授权码许可机制在上一节已经详细描述过，它是最复杂也是最安全的授权许可类型。</p>
<h2 id="隐式许可类型-implicit">隐式许可类型 - implicit</h2>
<p>授权码许可流程中各个步骤的关键是不同组件之间保持信息隔离。通过这种方式，浏览器接触不到只应由客户端掌握的信息，客户端也无法得知浏览器的状态。但是如果把客户端放在浏览器<strong>内部</strong>运行，会怎么样呢？</p>
<img data-src="../../images/security/oauth-implicit-flow.png" alt="OAuth Implicit Flow" style="zoom:33%;" />
<p>完全运行在浏览器中的 JavaScript 应用就属于这种情况。客户端无法对浏览器隐藏任何秘密， 因为浏览器对客户端的任何动作都了如指掌。在这种情况下，通过浏览器向客户端传递仅用于换 取令牌的授权码就没有任何实际意义了，因为这个额外的保密层没有起到任何作用。</p>
<p><strong>隐式许可类型</strong>没有使用这个额外的保密层，而是直接从授权端点返回令牌。</p>
<p>在使用隐式许可类型时需要对它严苛的局限性有所认识。首先，使用这种许可流程的客户端 无法持有客户端密钥，因为无法对浏览器隐藏密钥。但由于这种许可流程只使用授权端点而不使 用令牌端点，因此这个限制不会影响其功能，因为不要求客户端在授权端点上进行身份认证。然 而，由于缺少对客户端进行身份认证的手段，确实会影响这种许可类型的安全等级，因此要谨慎 使用。另外，隐式许可流程不可用于获取刷新令牌。因为浏览器内的应用具有短暂运行的特点，只会在被加载到浏览器的期间保持会话，所以刷新令牌在这里的作用非常有限。而且，和其他许 可类型不同，这种许可类型会假设资源拥有者一直在场，必要时可以对客户端重新授权。</p>
<p>客户端向授权服务器的授权端点发送请求时，使用的方式与授权码流程相同，只不过 <code>response_type</code> 参数的值为 <code>token</code>，而不是 <code>code</code>。这样会通知授权服务器直接生成令牌，而不是生成一个用于换取令牌的授权码。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Moved Temporarily</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://localhost:9001/authorize?response_type=token&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>444</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 31 Jul 2015 20:50:19 GMT</span><br></pre></td></tr></table></figure>
<p>客户端通过页面跳转或者在页面内使用内联框架（iframe）来执行这个请求。无论使用哪种方式，浏览器都会向授权服务器的授权端点发送请求。和授权码许可流程一样，资源拥有者自行进行身份认证，然后对客户端授权。但是，这一次授权服务器会直接生成令牌，并在授权端点响应中将令牌附在 URI 片段中。不要忘了，由于这是前端信道，对客户端的响应是通过重定向来完成的，重定向地址是客户端的重定向 URI。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /callback#access_token=987tghjkiu6trfghjuytrghj&amp;token_type=Bearer</span><br><span class="line">HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9000</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:39.0) Gecko/20100101 Firefox/39.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:9001/authorize?response_type=code&amp;scope=foo&amp;client_id=oauth-client-1&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9000%2Fcallback&amp;state=Lwt50DDQKUB8U7jtfLQCVGDL9cnmwHH1</span><br></pre></td></tr></table></figure>
<p>URI 中的片段部分通常不会发送至服务器，这样令牌就只能在浏览器内使用。但请注意，这一行为会因浏览器的实现和版本而异。</p>
<h2 id="客户端凭据许可类型-client-credentials">客户端凭据许可类型 - client_credentials</h2>
<p>如果没有明确的资源拥有者，或对于客户端软件来说资源拥有者不可区分，该怎么办？这是 一种相当常见的场景，比如后端系统之间需要直接通信，但是它们并不一定代表某个特定用户。 没有用户对客户端授权，还能使用 OAuth 吗？</p>
<img data-src="../../images/security/oauth-client-credentials.png" alt="OAuth Client Credentials" style="zoom:33%;" />
<p>OAuth 2.0 增加了<strong>客户端凭据许可类型</strong>，可用于这种场景。在隐式许可流程中，客户端被置于浏览器中，也就是在前端信道上；而在这种许可流程中，资源拥有者被塞进客户端，也就没有用户代理存在了。因此，这种许可流程只使用后端信道，客户端代表自己（它自己就是资源拥有者）从令牌端点获取令牌。</p>
<p>客户端向授权服务器的令牌端点发出令牌请求，这与授权码流程是一样的，只不过这一次使用 <code>client_credentials</code> 作为 <code>grant_type</code> 参数的值，而且没有授权码或者其他用于换取令牌的临时凭据。相反，客户端直接向授权服务器进行身份认证，而授权服务器给客户端颁发访问令牌。客户端也可以使用 <code>scope</code> 参数指定请求的权限范围，其用法与授权码和隐式许可流程中在授权端点上使用的 <code>scope</code> 参数一样。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /token</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9001</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>application/x-www-form-encoded</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Basic b2F1dGgtY2xpZW50LTE6b2F1dGgtY2xpZW50LXNlY3JldC0x</span><br><span class="line">grant_type=client_credentials&amp;scope=foo%20bar</span><br></pre></td></tr></table></figure>
<p>授权服务器返回的响应就是一个普通的 OAuth 令牌端点响应：一个包含令牌信息的 JSON 对象。在客户端凭据许可流程中不会颁发刷新令牌，因为我们认为客户端能够随时获取新令牌，无须单独的资源拥有者参与，因此在这种情况下没有必要使用刷新令牌。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">HTTP 200 OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 31 Jul 2015 21:19:03 GMT</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line"> &quot;access_token&quot;: &quot;987tghjkiu6trfghjuytrghj&quot;,</span><br><span class="line"> &quot;scope&quot;: &quot;foo bar&quot;,</span><br><span class="line"> &quot;token_type&quot;: &quot;Bearer&quot;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="资源拥有者凭据许可类型-password">资源拥有者凭据许可类型 - password</h2>
<p>如果资源拥有者在授权服务器上有纯文本的用户名和密码，那么客户端可以向用户索取用户的凭据，然后用这个凭据换取令牌。支持客户端这样做的是<strong>资源拥有者凭据许可类型</strong>，也叫作<strong>密码流程</strong>。资源拥有者与之直接交互的是客户端，而不是授权服务器。这种许可类型只使用令牌端点，并且只通过后端信道通信。</p>
<img data-src="../../images/security/oauth-password.png" alt="image-20210816104833232" style="zoom:33%;" />
<blockquote>
<p>为什么将这一反模式编入规范？</p>
<p>当有其他选择的时候，这种许可类型确实是一个坏主意，但并不总是有其他选择。这种许可类型是为那些通常要求资源拥有者输入 用户名和密码，然后向所有受保护资源使用这些凭据的客户端而准备的。</p>
<p>一方面，受保护资源无须再查看用户密码，而只需要处理 OAuth 令牌。 这立马缩小了用户凭据在网络上的暴露面，也减少了需要查看用户凭据的组件数量。另一方面， 对这一许可类型运用得当的客户端应用不再需要存储用户密码，也无须向资源服务器发送密 码。客户端使用用户凭据换取访问令牌，用于访问不同的受保护资源。结合刷新令牌的使用， 用户体验没有变化，但安全等级相对于之前的方案有了很大提高。虽然授权码许可类型是首选， 但这种许可类型有时也比在每个请求中使用用户密码好得多。</p>
</blockquote>
<p>这种许可类型的工作方式很简单。客户端收集用户的用户名和密码（使用什么样的交互接口 由客户端决定），然后将它们发送至授权服务器。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /token</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:9001 </span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json </span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>application/x-www-form-encoded </span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Basic b2F1dGgtY2xpZW50LTE6b2F1dGgtY2xpZW50LXNlY3JldC0x grant_type=password&amp;scope=foo%20bar&amp;username=alice&amp;password=secret</span><br></pre></td></tr></table></figure>
<p>授权服务器从收到的请求中取出用户名和密码，并与本地存储的用户信息对比。如果匹配， 则授权服务器向客户端颁发令牌。</p>
<h2 id="断言许可类型-assertion">断言许可类型 - assertion</h2>
<p>断言许可类型是由 OAuth 工作组发布的第一个官方扩展许可类型<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。在这种许可类型下，客 户端会得到一条结构化的且被加密保护的信息，叫作断言，使用断言向授权服务器换取令牌。可以把断言想象为某种经过认证的文档，例如文凭或者许可证。只要你信任认证机构能确保声明的真实性，就可以相信文档中的内容也是真实的。</p>
<p><img data-src="../../images/security/oauth-assertion.png" alt="OAuth Assertion"></p>
<p>目前有两种标准化的断言格式：一种使用安全断言标记语言（SAML）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，另一种使用 JSON Web Token（JWT<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>）。这种许可类型只使用后端信道，与客户端凭据许可类型很相似，没有明确的资源拥有者参与。与客户端凭据流程不同的是，由此颁发的令牌所关联的权限取决于所出示的断言，而不仅仅取决于客户端本身。由于断言一般来自于客户端之外的第三方， 因此客户端可以不知道断言本身的含义。 与其他后端信道流程类似，客户端要向授权服务器的令牌端点发送一个 HTTP POST 请求。 客户端需要像往常一样进行身份认证，还要将断言作为参数传递给授权服务器。客户端获取断言的方式多种多样，而且很多关联协议没有涵盖这方面的内容。客户端可以从用户那里获得断言， 也可以从某个配置系统或者通过其他非 OAuth 协议获得断言。与访问令牌一样，最终只要客户端能向授权服务器出示断言即可，至于客户端如何获得断言则不是该许可类型所关心的。</p>
<p>这种许可类型在实现上与其他只使用后端信道的流程类似，都是由客户端向令牌端点出示信息，然后授权服务器直接颁发令牌。在现实世界中，你可能会发现断言许可类型仅用于有限的环境中，通常是企业。</p>
<h2 id="选择合适的许可类型">选择合适的许可类型</h2>
<p>有这么多的许可类型，似乎很难判定到底哪一个才最合适。所幸，有一些好用的基本法则能 够指导你做出正确的选择。</p>
<p>**客户端是否代表特定的资源拥有者？**你是否可以通过用户的 Web 浏览器将其引导至一个网页？如果可以，就使用基于重定向的许可流程：授权码或者隐式许可流程。至于使用哪个，取决于客户端。</p>
<p>**客户端是否完全运行在浏览器内？**这不包括在服务器上运行但用户界面需要通过浏览器访问的应用，只有从启动到消亡都完全在浏览器内执行的应用才算。如果是这样，则应该使用隐式许可类型，因为它就是专门针对此情况而做的优化。如果不是，则要么运行在 Web 服务器上， 要么原生运行在用户的计算机上，这种情况下应该使用授权码许可类型，因为这种类型具有最强的安全性和灵活性。</p>
<p>**客户端是原生应用吗？**你应该已经在使用授权码许可流程了，还应该在授权码许可类型的基础上使用特定的安全扩展，比如动态注册 （DynReg）或者代码交换证明密钥（PKCE）。</p>
<p>**客户端代表自身吗？**这种情况包括不针对单个用户的 API 访问，比如大批量数据传输。如果是这样，则应该使用客户端凭据许可流程。如果你使用的 API 需要通过参数指定作用于哪个用户， 则应该考虑使用基于重定向的许可流程，因为这样才能实现个性化的审核和同意。 **客户端是否在权威性第三方的指示下运行？**这个第三方是否能直接提供一些证明，让你能够代表它执行任务？如果是这样，则应该使用断言许可流程。使用哪种断言许可则取决于授权服务 器和颁发断言的第三方。客户端是否无法在浏览器中对用户重定向？用户是否具有能够提供给你的简单用户凭据？ 是否没有其他选择？如果是这样，那么可以使用资源拥有者凭据许可流程，但要注意它的局限性。 别说我们没提醒过你。</p>
<p><img data-src="../../images/security/oauth-choose-flow.png" alt="OAuth Choose Flow"></p>
<h1>OAuth 令牌</h1>
<p>令牌是所有 OAuth 事务的核心。客户端从授权服务器获取令牌，然后出示给受保护资源。 授权服务器生成令牌并发送给客户端，将资源拥有者的授权与客户端权限信息一起关联到令牌。 受保护资源从客户端接收令牌并对其进行验证，将其关联的权限与客户端发出的请求进行匹配。</p>
<p>令牌表示的是授权行为的结果：一个信息元组，包括资源拥有者、客户端、授权服务器、受 保护资源、权限范围以及其他与授权决策有关的信息。如果客户端需要更新访问令牌却不想再次 打扰资源拥有者，则要使用另一种令牌：刷新令牌。令牌是位于 OAuth 生态系统中心的关键机制， 可以说没有令牌就没有 OAuth。所以，OAuth 的非官方标志很像一枚公共汽车乘车币（bus token）。</p>
<p>一切聚焦于令牌，然而 OAuth 规范完全没有提及令牌所包含的内容。之前已经讨论过，OAuth 系统中的客户端无须了解令牌本身的任何信息。客户端需要知道的就是如何从授权 服务器获取令牌以及如何在资源服务器上使用令牌。但是，授权服务器和资源服务器需要了解令牌的内容。授权服务器要知道如何生成令牌来颁发给客户端，资源服务器要知道如何识别并验证客户端发送过来的令牌。</p>
<p>为什么 OAuth 核心规范会将如此重要的内容省略呢？<strong>不对令牌本身做出规定，使得 OAuth 能够广泛适用于各种部署场景，它们的特性、风险状况以及要求各不相同</strong>。OAuth 令牌可以具有有效期，可以支持撤回，也可以永久有效，或者根据情况将这些特性组合。令牌可以代表特定的用户或者系统中所有的用户，也可以不代表任何用户。令牌可以具有内部结构，可以是随机的无意义字符串，也可以被加密保护，甚至可以将这几项结合起来。这种灵活性和模块化特性使 OAuth 具备了良好的适应性，而这是那些更全面的安全协议（比如 WS-*、SAML 和 Kerberos）无法做到的，它们都对令牌格式做出了规定，并且要求系统的所有部件都能理解令牌格式。</p>
<p>不过，还有几种常用的创建和验证令牌的技术，它们都有各自的优缺点，能够适用于不同的场景。</p>
<p>授权服务器生成令牌之后，会将令牌值存储在磁盘上的共享数据库中。当受保护资源从客户 端收到令牌之后，它会在同一个数据库中查找令牌值，以确定令牌有效。这种令牌不携带任何信息，只是充当数据库查询的检索值。这种创建和管理令牌的方法非常有效且常见，而且它的优势是在保持令牌本身短小的同时满足较大的信息熵。 在授权服务器和受保护资源间共享数据库并不总是实际可行，特别是在一个授权服务器需要保护下游的多个资源服务器的情况下。该如何解决这个问题呢？本章将讨论另外两种常见的方案：结构化令牌和令牌内省。</p>
<h2 id="结构化令牌：JWT">结构化令牌：JWT</h2>
<p>如果不向共享数据库查询，是否可以将所有必要的信息放在令牌内部？这种方式使授权服务器可以通过令牌本身间接地与受保护资源沟通，而不需要调用任何网络 API。 通过这种方式，授权服务器可以将受保护资源需要知道的信息全部打包，比如令牌的过期时间戳以及授权用户是谁。这些信息都会被发送给客户端，但是客户端并不关心，因为令牌在所有 OAuth 2.0 系统中对客户端都不透明。只要客户端得到令牌，就可以将其当作一个随机字符串发送给受保护资源。受保护资源需要理解令牌，并解析令牌内包含的信息，然后基于这些信息做出授权决策。</p>
<h3 id="JWT-的结构">JWT 的结构</h3>
<p>完整的 JSON Web 令牌的紧凑形式由三个部分组成，由点（<code>.</code>）分隔，它们是：</p>
<ul>
<li>Header - 头部</li>
<li>Payload - 荷载</li>
<li>Signature - 签名</li>
</ul>
<p>整个 JWT 都是经过 Base64URL 编码过的字符串，便于传输。</p>
<p>为了构建这样的令牌，需要一种方法来组织并序列化所要携带的信息。JSON Web Token 令牌格式， 或者叫作 JWT，提供了一种在令牌中携带信息的简单方法。JWT 的核心是将一个 JSON 对象封装为一种用于网络传输的格式。JWT 最简单的形式是一个未签名的令牌，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9. </span><br></pre></td></tr></table></figure>
<p>这种令牌看起来与之前使用的随机字符串令牌很相似，但事实并非如此。首先，请注意其中有一个句点符号将字符串分割成了两部分。以句点符号将令牌字符串分解，让我们可以对令牌的不同部分分别进行处理理（示例中最后一个句点符号后面还有隐含的第三部分，在令牌加密保护会进行讨论）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0 </span><br><span class="line">. </span><br><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 </span><br><span class="line">. </span><br></pre></td></tr></table></figure>
<p>句点符号之间的值并不是随机的，而是一个经过 <strong>Base64URL 编码</strong>的 JSON 对象。如果对第一部分进行 Base64 解码并解析出 JSON 对象，会得到一个简单的对象。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span> </span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么选择 Base64？</p>
<p>看一下 JWT 通常会出现在什么环境中就能得出部分答案，它一般会出现在 HTTP 头部、Query 参数、表单参数、各种数据库的字符串以及编程语言中。若无须进行额外的编码处理，这些环境中可用的字符集都有所限制。</p>
<p>采用 Base64URL 编码方案是顺理成章的，它可以让 JWT 安全地出现在任何环节而无须额外的编码处理。</p>
</blockquote>
<p>这是 JWT 的头部，它是一个 JSON 对象，用于描述与令牌剩余部分有关的信息。其中的 <code>typ</code> 头告诉处理程序令牌的第二部分（载荷）是何种类型。在我们的示例中，它是一个 JWT。虽然 还有其他的数据容器可以使用与此相同的结构，但是无疑 JWT 是最常用的，并且也最适合作为 OAuth 令牌使用。还有一个 <code>alg</code> 头，它的值是 none，表示这是一个未签名的令牌。</p>
<p>第二部分是令牌的载荷，它的序列化方式与 JWT 头部相同：对 JSON 对象进行 Base64URL 编码。由于它是 JWT，因此其载荷可以是任意的 JSON 对象，在前面的示例中，它是一组简单的用户数据。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span> </span><br></pre></td></tr></table></figure>
<h3 id="JWT-声明-JWT-Claims">JWT 声明 - JWT Claims</h3>
<p>除了一般的数据结构之外，JWT 还提供了一组声明，可以在不同的应用中通用。虽然 JWT 内可以包含任何合法的 JSON 数据，但这些声明支持应用的常规操作。所有这些字段在 JWT 中都是可选的，但允许特定服务定义自己的内部标准。</p>
<table>
<thead>
<tr>
<th>声明名称</th>
<th>声明描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>iss</td>
<td>Issuer - 令牌颁发者。它表示该令牌是由谁创建的，在很多 OAuth 部署中会将它设为授权服务器的 URL。该声明是一个字符串</td>
</tr>
<tr>
<td>sub</td>
<td>Subject - 令牌的主体。它表示该令牌是关于谁的，在很多 OAuth 部署中会将它设为资源拥有者的唯一标识。在大多数情况下，主体在同一个颁发者的范围内必须是唯一的。该声明是一个字符串</td>
</tr>
<tr>
<td>aud</td>
<td>Audience - 令牌的受众。它表示令牌的接收者，在很多 OAuth 部署中，它包含受保护资源的 URI 或者能够接收该 令牌的受保护资源。该声明可以是一个字符串数组，如果只有一个值，也可以是一个不用数组包装的单个字符串</td>
</tr>
<tr>
<td>exp</td>
<td>Expiration Time - 令牌的过期时间戳。它表示令牌将在何时过期，以便部署应用让令牌自行失效。该声明是一个整数，表 示自 UNIX 新纪元（即格林威治标准时间 GMT，1970 年 1 月 1 日零点）以来的秒数</td>
</tr>
<tr>
<td>nbf</td>
<td>Not Before - 令牌生效时的时间戳。它表示令牌从什么时候开始生效，以便部署应用可以在令牌生效之前颁发令牌。 该声明是一个整数，表示自 UNIX 新纪元（即格林威治标准时间 GMT，1970 年 1 月 1 日零点）以来的秒数</td>
</tr>
<tr>
<td>iat</td>
<td>Issued At - 令牌颁发时的时间戳。它表示令牌是何时被创建的，它通常是颁发者在生成令牌时的系统时间戳。该声 明是一个整数，表示自 UNIX 新纪元（即格林尼治时间 GMT，1970 年 1 月 1 日零点）以来的秒数</td>
</tr>
<tr>
<td>jti</td>
<td>JWT ID - 令牌的唯一标识符。该声明的值在令牌颁发者创建的每一个令牌中都是唯一的，为了防止冲突，它通常 是一个密码学随机值。这个值相当于向结构化令牌中加入了一个攻击者无法获得的随机熵组件，有利于防止令牌猜测攻击和重放攻击</td>
</tr>
</tbody>
</table>
<p>仍然可以为特定的应用新增其他所需的字段。这些字段的字段名可以是任何有效的 JSON 字符串，这对于其他 JSON 对象也是一样，但尽 管如此，为避免不同的实现之间不兼容，JWT 规范在这一点上给出了一些指导意见。</p>
<h2 id="令牌的加密保护">令牌的加密保护</h2>
<p>如果授权服务器发出的令牌是不经过任何保护的，并且受保护资源不进行任何其他检查就相信令牌中的内容，那么对于以明文形式接收令牌的客户端来说，很容易就能在向受保护资源出示令牌之前篡改令牌内容。客户端甚至可以在不与授权服务器通信的情况下就自行伪造一个令牌出来，而资源服务器还是会天真地接受并处理。</p>
<p>所幸，恰好有一套规范可以解决这个问题：JSON 对象的签名和加密标准 <a target="_blank" rel="noopener" href="https://jose.readthedocs.io/en/latest/">Javascript Object Signing and Encryption (JOSE)</a>。这套规范以 JSON 为基础数据模型，提供了签名（JSON Web Signing 签名，或称 JWS）、加密（JSON Web Encryption 加密，或称 JWE）以及密钥存储格式（JSON Web Key 密钥，或称 JWK）的标准。上一节手动创建的未签名的 JWT，只不过是一个带有 JSON 载荷的未签名 JWS 对象的特例。</p>
<h3 id="签名">签名</h3>
<p>签名的目的是用于验证消息的数据完整性和真实性，它生成 JWT 的“Signature”部分，令牌的接收者可以验证该签名，以确保令牌没有被篡改。</p>
<p>虽然将 JOSE 的细节展开来讲可以单独写一本书，但我们着眼于它的两项内容：使用 HMAC 签名方案的对称签名和验证，以及使用 RSA 签名方案的非对称签名和验证。</p>
<h4 id="使用-HS256-的对称签名">使用 HS256 的对称签名</h4>
<p>HS256（使用 SHA-256 的 HMAC）是一种对称算法，双方之间共享一个密钥。由于同一密钥用于生成签名和验证签名，因此必须注意确保密钥不会被盗用。</p>
<p>HS256 为令牌签名计算 256 字节的散列，JOSE 还定义了 HS384 和 HS512，它们计算的散列长度更长，从而换取更高的安全性。</p>
<p>如果您将开发使用 JWT 的应用程序，您可以安全地使用 HS256，因为您将控制谁使用密钥。另一方面，如果您无法控制客户端，或者您无法保护密钥，RS256 将更合适，因为消费者只需要知道共享的公钥。</p>
<blockquote>
<p>在加密技术中，HMAC（ <strong>hash-based message authentication code - 基于散列的消息认证码</strong>）是一种特定类型的消息认证码（message authentication code - MAC），包含加密散列函数和密钥两部分。与任何 MAC 一样，它可用于同时验证消息的数据完整性和真实性。</p>
<p>HMAC 可以使用共享密钥提供消息身份验证，而不是使用非对称加密的数字签名。它通过将密钥交换委托给通信各方来权衡对复杂公钥基础设施的需求，通信各方负责在通信前建立和使用受信任的渠道就密钥达成一致。</p>
<p>HMAC 可以包含任意的加密散列函数算法，比如常见的 MD5、SHA256、SHA512 等。</p>
</blockquote>
<h4 id="使用-RS256-的非对称签名">使用 RS256 的非对称签名</h4>
<p>RS256 签名方法，它在底层使用 RSA 非对称加密算法。它对 RSA 签名结果计算 256 字节的散列。 JOSE 同样也定义了 RS384 和 RS512，与对应的对称签名方法一样，它们提供不同的折中选择。JOSE 还定义了 PS256、PS384 和 PS512，它们都基于另一种 RSA 签名和散列机制。</p>
<p>使用公钥加密的话，授权服务器拥有公钥和私钥，可用于生成令牌，而受保护资源则只能访问授权服务器的公钥，用于验证令牌。与使用共享密钥不同的是，受保护资源虽然能够很容易地验证令牌，但它无法自己生成有效的令牌。</p>
<h3 id="加密">加密</h3>
<p>然而，有时候仅签名是不够的。对于仅被签名的令牌，客户端还是可以偷窥令牌本身，从中获取它本无权知道的信息，比如 sub 字段中的用户标识符。令人欣慰的是，除了签名之外，JOSE 还提供了一个叫作 JWE 的加密机制，包含几种不同的选项和算法。经过 JWE 加密的 JWT 不再只由 3 部分组成，而是由 5 部分组成的结构。各个部分仍然使用 Base64URL 编码，只是载荷现在变成了一个经过加密的对象，没有正确的密钥无法读取其内容。</p>
<p>首先，为资源服务器设置一个密钥对，并将密钥对中的公钥提供给授权服务器。然后，授权服务器使用 JWE 以及密钥对中的公钥对令牌内容加密。最后，资源服务器使用它自己的私钥解密令牌内容，并将令牌载荷交给应用。</p>
<h1>OpenID Connect</h1>
<p>OAuth 2.0 规范定义了一个授权协议，用于在 Web 应用以及 API 之间传递授权决策。因为 OAuth 2.0 用于获取已通过身份认证的最终用户的许可，所以很多开发人员和 API 服务商认为 OAuth 2.0 是一种让用户安全登录的身份认证协议。然而，尽管 OAuth 2.0 是一个需要用户交互的安全协议，<strong>但并不是身份认证协议</strong>。</p>
<p>但是在 OAuth 之上构建身份认证协议是可行的。</p>
<p>OpenID Connect 是一个开放标准，由 OpenID 基金会于 2014 年 2 月发布。它定义了一种使用 OAuth 2.0 执行用户身份认证的互通方式。由于该协议的设计具有互通性，一个 OpenID 客户端应用可以使用同一套协议语言与不同的身份提供者交互，而不需要为每一个身份提供者实现一套有细微差别的协议。</p>
<p>OpenID Connect 直接基于 OAuth 2.0 构建，并保持与它兼容。</p>
<hr>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>RFC 7521：<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7521">https://tools.ietf.org/html/rfc7521</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>RFC 7522：<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7522">https://tools.ietf.org/html/rfc7522</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>RFC 7523：<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7523">https://tools.ietf.org/html/rfc7523</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>OAuth2</tag>
        <tag>OpenID</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类加载器</title>
    <url>/java/jvm/Java-Class-Loaders/</url>
    <content><![CDATA[<h2 id="类加载">类加载</h2>
<p>在 Java 类或接口编译为 Class 二进制字节码后，当我们用到该类或接口时，虚拟机就会将描述类的数据加载到<strong>方法区内存</strong>中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<p><strong>类型的加载、连接和初始化过程发生在程序运行期间。</strong></p>
<p>Java 虚拟机中类加载的全过程包含：加载、验证、准备、解析和初始化，这里我们只介绍加载一个阶段。</p>
<p><img data-src="../../../images/java/java_execute.gif" alt="字节码验证器"></p>
<h2 id="加载">加载</h2>
<p>加载阶段，虚拟机规范要求虚拟机主要完成一下 3 件事情：</p>
<ol>
<li>通过一个类的完全限定名称来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</li>
<li>在内存中生成一个代表类的 <code>java.lang.Class</code> 对象，作为方法区的这个类的各种数据的访问入口。</li>
</ol>
<blockquote>
<p><strong>HotSpot 虚拟机是将生成的该 Class 对象放在了方法区中，而不是堆中。</strong></p>
</blockquote>
<span id="more"></span>
<p>虚拟机规范并未指明二进制字节流要从一个 Class 文件中获取，准确说根本没有指明从哪里获取、怎样获取，我们可以从：</p>
<ul>
<li>从 ZIP 包中读取，比如 JAR、EAR、WAR。</li>
<li>从网络中获取，比如 Applet。</li>
<li>运行时计算生成，这种场景使用最多的就是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，使用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 “*$Proxy” 的代理类二进制字节流。</li>
<li>由其它文件生成，典型场景就是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库中读取…</li>
</ul>
<h2 id="类加载器简介">类加载器简介</h2>
<p>类加载用于实现类的加载动作，虚拟机把这个加载动态交给外部去实现，以便应用程序自己决定如何获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>对于任意一个类，都需要加载它的类和这个类本身一同确立在 Java 虚拟机中的唯一性，每个类加载，都拥有一个独立的类名称空间。对于不同类加载器加载的同一个 Class 文件，这两个类也必定不相等。这里的相等是指 Class 对象的 equals、 isAssignableFrom、isInstance 方法返回的结果。</p>
<p>每个 Class 对象都包含对定义它的 ClassLoader 的引用。</p>
<p>数组类的类对象不是由类加载器创建的，而是由 Java 虚拟机直接创建的。<strong>Class.getClassLoader()</strong> 返回的数组类的类加载器与其元素类型的类加载器相同；如果元素类型是基本类型，则数组类与引导类加载器关联。</p>
<p>支持并发加载类的类加载器称为并行加载类加载器，需要通过调用 <code>ClassLoader.registerAsParallelCapable</code> 方法在类初始化时注册自己。请注意，ClassLoader 类默认注册为并行。但是，它的子类如果具有并行能力，仍然需要注册自己。</p>
<p>在委托模型不是严格分层的环境中，类加载器需要具有并行能力，否则类加载会导致死锁，因为加载器锁在类加载过程的持续时间内保持不变（请参阅 <code>loadClass</code> 方法）。</p>
<p>通常，Java 虚拟机以与平台相关的方式从本地文件系统加载类。例如，在 UNIX 系统上，虚拟机从 <a href="#CLASSPATH"><code>CLASSPATH</code></a>   环境变量定义的目录中加载类。</p>
<p>但是，某些类可能不是源自文件；它们可能来自其他来源，例如网络，或者它们可以由应用程序构建。方法 <code>defineClass</code> 将字节数组转换为类 Class 的实例，可以使用 <code>Class.newInstance</code> 创建此新定义的类的实例。</p>
<p>例如，应用程序可以创建网络类加载器以从服务器下载类文件。示例代码可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NetworkClassLoader</span>(host, port);</span><br><span class="line"><span class="type">Object</span> <span class="variable">main</span> <span class="operator">=</span> loader.loadClass(<span class="string">&quot;Main&quot;</span>, <span class="literal">true</span>).newInstance();</span><br><span class="line">			. . .</span><br></pre></td></tr></table></figure>
<p>网络类加载器子类必须定义方法 <code>findClass</code> 和 <code>loadClassData</code> 以从网络加载类。一旦下载了构成类的字节，就应该使用 <code>defineClass</code> 方法创建一个类实例。示例实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    String host;</span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class <span class="title function_">findClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">      <span class="type">byte</span>[] b = loadClassData(name);</span><br><span class="line">      <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">      <span class="comment">// load the class data from the connection</span></span><br><span class="line">      . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载器类型">类加载器类型</h2>
<p>让我们首先学习如何使用各种类加载器使用一个简单示例加载不同的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printClassLoaders</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Classloader of this class:&quot;</span></span><br><span class="line">       + PrintClassLoader.class.getClassLoader());</span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">&quot;Classloader of Logging:&quot;</span></span><br><span class="line">       + Logging.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Classloader of ArrayList:&quot;</span></span><br><span class="line">       + ArrayList.class.getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时，上面的方法打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class loader of <span class="built_in">this</span> class:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Class loader of Logging:sun.misc.Launcher$ExtClassLoader@3caeaf62</span><br><span class="line">Class loader of ArrayList:<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里有三种不同的类加载器：应用程序，扩展和引导程序（显示为 null）。</p>
<p>应用程序类加载器加载包含示例方法的类。<strong>应用程序或系统类加载器在类路径中加载我们自己的文件</strong>。</p>
<p>接下来，扩展程序加载 Logging 类。<strong>扩展类加载器加载类，它们是标准核心 Java 类的扩展</strong>。</p>
<p>最后，bootstrap 加载 ArrayList 类。<strong>引导或原始类加载器是所有其他加载器的父级。</strong></p>
<p>我们可以看到最后输出，对于 ArrayList，它在输出中显示为 null。<strong>这是因为对于 HotSpot 虚拟机的引导类加载器是用本地代码（native code）而不是 Java 编写的 - 因此它不会显示为 Java 类。</strong></p>
<p>现在让我们更详细地讨论每个类加载器。</p>
<h3 id="引导（Bootstrap）类加载器">引导（Bootstrap）类加载器</h3>
<p>Java 类由 <code>java.lang.ClassLoader</code> 的实例加载。但是，类加载器本身就是类。因此，问题是，谁加载 <code>java.lang.ClassLoader</code> 本身？</p>
<p>这就需要介绍到 引导或原始类加载器。它主要负责加载 JDK 内部类，通常是 <code>rt.jar</code> 和位于<code>$JAVA_HOME/jre/lib</code> 目录中的其他核心库。此外，<strong>引导类加载器充当所有其他 ClassLoader 实例的父级。</strong></p>
<p><strong>此引导类加载器是核心 JVM 的一部分，并使用本地代码（native code）编写</strong>，如上说述，不同的 JVM 平台可能具有此特定类加载器的不同实现。</p>
<h3 id="扩展类加载器">扩展类加载器</h3>
<p>**扩展类加载器是引导类加载器的子类，负责加载标准核心 Java 类的扩展，**以便它可供平台上运行的所有应用程序使用。</p>
<p>扩展类加载器从 JDK 扩展目录加载，通常是 <code>$JAVA_HOME/lib/ext</code> 目录或 <code>java.ext.dirs</code> 系统属性中提到的任何其他目录。</p>
<h3 id="应用程序类加载器">应用程序类加载器</h3>
<p>应用程序类加载器负责将所有应用程序级别的类加载到 JVM 中，由于这个类加载器是 ClassLoader 中的 getSystemClassLoader 方法的返回值，所以一般也称为系统类加载器。</p>
<p>**它负责加载在用户类路径环境变量 - classpath 或 -cp 命令行选项中找到的文件。**开发者可以直接使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h2 id="类加载机如何工作？">类加载机如何工作？</h2>
<p>类加载器是 Java 运行时环境的一部分。当 JVM 请求类时，类加载器会尝试使用完全限定的类名来定位类并将类定义加载到运行时。</p>
<p><code>java.lang.ClassLoader.loadClass()</code> 方法负责将类定义加载到运行时。它尝试基于完全限定名称加载类。</p>
<p>如果尚未加载该类，它会将请求委托给父类加载器。此过程以递归方式发生。</p>
<p>最终，如果父类加载器没有找到该类，则子类将调用 <code>java.net.URLClassLoader.findClass()</code> 方法来查找文件系统本身中的类。</p>
<p>如果最后一个子类加载器也无法加载该类，则会抛出 <code>java.lang.NoClassDefFoundError</code> 或 <code>java.lang.ClassNotFoundException</code>。</p>
<p>如下代码说述：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span> throws ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先检查请求的类是否已经被加载过</span></span><br><span class="line">    Class c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != null) &#123;</span><br><span class="line">                c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = find<span class="constructor">BootstrapClassOrNull(<span class="params">name</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出 ClassNotFoundException</span></span><br><span class="line">            <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// 在父类加载器无法加载的时候</span></span><br><span class="line">            <span class="comment">// 再调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">            c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双亲委派模型">双亲委派模型</h3>
<p>类加载器遵循委托模型，<strong>在请求查找类或资源时，<code>ClassLoader</code> 实例将类或资源的搜索委托给父类加载器，父类则委托给引导类加载器。</strong></p>
<p>只有当引导类加载器和扩展类加载器在加载类时不成功时，系统类加载器才会尝试加载类本身。</p>
<p>类加载器双亲委派模型如下图所示：</p>
<p><img data-src="../../../images/java/jvm/parents-delegation-model.png" alt="Parents Delegation Model"></p>
<h2 id="上下文类加载器">上下文类加载器</h2>
<p>就像我们之前学到的一样，<strong>JVM 中的类加载器遵循层次模型，这样每个类加载器都有一个父级，除了引导类加载器。</strong></p>
<p>但是，有时当 JVM 核心类需要动态加载应用程序开发人员提供的类或资源时，我们可能会遇到问题。</p>
<p>例如，JNDI 服务，JNDI 现在已经是 Java 的标准服务，核心功能由 rt.jar 中的引导类加载。但 JNDI 的目的就是对资源进行集中管理和查找，这些 JNDI 类可能会加载由独立供应商实现的 JNDI 接口提供者（部署在应用程序类路径中）SPI 的代码。此方案要求引导类加载器（父类加载器）加载应用程序加载器（子类加载器）可见的类，但启动类不可能“认识”这些代码，怎么办？</p>
<p>为了解决该问题，Java 设计团队引出了一个不太优雅的实现；线程上下文类加载器（Thread Context ClassLoader）。</p>
<p><code>java.lang.Thread</code> 类有一个方法 <code>getContextClassLoader()</code>，**它返回特定线程的 <code>ContextClassLoader</code>。**在加载资源和类时，<code>ContextClassLoader</code> 由线程的创建者提供。</p>
<p>如果创建线程时未设置该值，则默认从父线程的类加载器上下文继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，JNDI 服务就可以使用这个线程上下文加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载器的动作。</p>
<p>Java 中所有设计 SPI 的加载动作基本上都采用这种方式，例如 JNDI，JDBC，JAXB 和 JBI 等。</p>
<h2 id="非标准的加载模型">非标准的加载模型</h2>
<p>Sun 公司所提出的模块化规范在与 JCP 组织的模块化之争中落败给 JSR-291（OSGI R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGI 已经成为业界“事实上”的 Java 模块化标准，而 OSGI 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGI 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。</p>
<p><strong>OSGi 中，类加载器不再是双亲委派模型下的树状结构，而是进一步发展为更加复杂的网状结构。</strong></p>
<hr>
<h2 id="二进制名称（完全限定名称）">二进制名称（完全限定名称）</h2>
<p>作为 ClassLoader 中的方法的 String 参数提供的任何类名必须是由 <strong>Java™ 语言规范</strong>定义的二进制名称。 有效类名的示例包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;java.lang.String&quot;</span></span><br><span class="line"><span class="string">&quot;javax.swing.JSpinner$DefaultEditor&quot;</span></span><br><span class="line"><span class="string">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot;</span></span><br><span class="line"><span class="string">&quot;java.net.URLClassLoader$3$1&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="CLASSPATH">CLASSPATH</h2>
<p>就像为系统配置 <code>PATH</code> 属性定义可执行文件的目录一样，<code>CLASSPATH</code> 就是为程序，包括 JDK 定义类的路径，就像它的字面意思 PATH of Class。</p>
<p>一般项目 CLASSPATH 可能包含两部分：</p>
<ul>
<li>Jar 包依赖文件（依赖的 CLASS 文件位置）</li>
<li>当前代码包的顶层路径（当前 CLASS 文件位置）</li>
</ul>
<p>使用 maven 时，默认会将代码构建到 <code>target/classes</code>，同时也会包含依赖包的代码，它可能看起来如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-classpath &quot;/Users/zeral/Program/spring/spring-boot/smart-train-api/target/classes:/Users/zeral/Program/spring/spring-boot/smart-train-api/libs/CimLog.jar:/Users/zeral/Program/spring/spring-boot/smart-train-api/libs/ojdbc6.jar:/Users/zeral/.m2/repository/cglib/cglib/3.1/cglib-3.1.jar:/Users/zeral/.m2/repository/org/ow2/asm/asm/4.2/asm-4.2.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>ClassLoader</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 调优指南</title>
    <url>/java/jvm/JVM-%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>从桌面上的小 applet 到大型服务器上的 Web 服务，各种各样的应用程序都使用 Java。为了支持这种多样化的部署场景，Java HotSpot VM 提供了多个垃圾收集器，每个垃圾收集器旨在满足不同的需求。Java 根据运行应用程序的计算机的类别选择最合适的垃圾收集器。但是，此选择可能并非对每个应用程序都是最佳的。具有严格性能目标或其他要求的用户，开发人员和管理员可能需要明确选择垃圾回收器并调整某些参数以实现所需的性能水平。本文档提供了有助于完成这些任务的信息。</p>
<p>首先，在串行，stop-the-world 收集器的上下文中描述了垃圾收集器的一般功能和基本的调整选项。然后介绍了其他收集器的特定功能以及选择收集器时要考虑的因素。</p>
<span id="more"></span>
<h1>什么是垃圾收集器？</h1>
<p>垃圾收集器（GC）自动管理应用程序的动态内存分配请求。</p>
<p>垃圾收集器通过以下操作执行自动动态内存管理：</p>
<ul>
<li>从操作系统分配内存并将其还给操作系统。</li>
<li>根据请求将内存分发给应用程序。</li>
<li>确定应用程序仍在使用该内存的哪些部分。</li>
<li>回收未使用的内存，以供应用程序重新使用。</li>
</ul>
<p>Java HotSpot 垃圾收集器采用了各种技术来提高这些操作的效率：</p>
<ul>
<li>将分代清理与老化结合使用，可以将精力集中在堆中最有可能包含大量可回收内存区域的区域上。</li>
<li>使用多个线程积极地使操作并行化，或者在后台与应用程序并发执行一些长时间运行的操作。</li>
<li>尝试通过压缩活动对象来恢复较大的连续可用内存。</li>
</ul>
<h1>为什么选择垃圾收集器很重要？</h1>
<p>垃圾收集器的目的是使应用程序开发人员从手动动态内存管理中解放出来。开发人员摆脱了将分配与释放分配相匹配的要求，并密切注意分配的动态内存的生命周期。这完全消除了一些与内存管理有关的错误操作，但付出了一些额外的运行时开销。 Java HotSpot VM 提供了一系列垃圾回收算法供您选择。</p>
<p>什么时候选择垃圾收集器很重要？对于某些应用程序，答案永远是不重要。也就是说，在存在垃圾收集的情况下，应用程序可以很好地执行，并具有适度的收集频率和持续暂停时间。但是，对于大型应用程序却不是这种情况，特别是那些具有大量数据（数 GB），许多线程和高事务处理率的应用程序。</p>
<p>阿姆达尔（Amdahl）定律（给定问题中的可并行加速部分受到问题的可顺序部分的限制）意味着大多数工作负载无法完美并行化。某些部分始终是顺序的，不能从并行性中受益。在 Java 平台中，当前有四种受支持的垃圾收集替代方案，除了其中一种（串行 GC），并行化工作以提高性能。尽可能减少垃圾收集的开销非常重要。</p>
<h1>人机工程学</h1>
<p>人机工程学是 Java 虚拟机（JVM）和垃圾收集启发法（例如基于行为的启发法）提高应用程序性能的过程。</p>
<p>JVM 作为垃圾收集器，堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择可满足不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调整可动态优化堆的大小，以满足应用程序的指定行为。</p>
<p>本节描述了这些默认选择和基于行为的调整。在使用后续各节中介绍的更详细的控件之前，请使用这些默认值。</p>
<h2 id="垃圾收集器，堆和运行时编译器的默认选择">垃圾收集器，堆和运行时编译器的默认选择</h2>
<p>这些是垃圾收集器，堆大小和运行时编译器的默认选择：</p>
<h3 id="Java-8">Java 8</h3>
<p>具有以下属性的机器被认为是服务器类型机器：</p>
<ul>
<li>2 个或更多物理处理器</li>
<li>2 GB 或更多的物理内存</li>
</ul>
<p>在服务器级计算机上，默认情况下选择以下内容：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html">吞吐量垃圾收集器</a>（并行垃圾收集器 - Parallel Collector）</li>
<li>初始堆大小为 1/64 的物理内存，最大为 1 GB</li>
<li>最大堆大小为物理内存的 1/4，最大为 1 GB</li>
<li>服务器运行时编译器</li>
</ul>
<h3 id="Java-11">Java 11</h3>
<ul>
<li>Garbage-First (G1) 收集器</li>
<li>GC 线程的最大数量受堆大小和可用 CPU 资源的限制</li>
<li>初始堆大小为物理内存的 1/64</li>
<li>最大堆大小为物理内存的 1/4</li>
<li>分层编译器，同时使用 C1 和 C2</li>
</ul>
<blockquote>
<p><strong>C1 compiler</strong></p>
<p>快速，轻度优化的字节码编译器。执行一些值编号，内联和类分析。使用简单的面向 CFG 的 SSA “high” IR，面向机器的 “low” IR，线性扫描寄存器分配以及模板样式的代码生成器。</p>
<p><strong>C2 compiler</strong></p>
<p>高度优化的字节码编译器，也称为 “opto”。使用 “sea of nodes” SSA “ideal” IR，它降低为同类机器特定的 IR。具有图形着色寄存器分配器；为所有机器状态上色，包括局部，全局和参数寄存器以及堆栈。</p>
</blockquote>
<h3 id="查看当前运行-JVM-收集器">查看当前运行 JVM 收集器</h3>
<ul>
<li>
<p>Java &lt;= 8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -heap &lt;pid&gt; | grep GC</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java &gt; 9</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jhsdb jmap --heap --pid &lt;pid&gt; | grep GC</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基于行为的调整">基于行为的调整</h2>
<p>可以将 Java HotSpot VM 垃圾收集器配置为优先满足以下两个目标之一：<strong>最大暂停时间</strong>和<strong>应用程序吞吐量</strong>。如果达到了首选目标，则收集器将尝试使其他目标最大化。自然地，这些目标并不总是能够满足的：应用程序需要最小的堆来容纳至少所有实时数据，而其他配置可能会阻止达到某些或所有期望的目标。</p>
<p>下面的配置适用于吞吐量并行收集器和 G1 收集器。</p>
<h3 id="最大暂停时间目标">最大暂停时间目标</h3>
<p>暂停时间是垃圾收集器停止应用程序并恢复不再使用的空间的持续时间。最大暂停时间目标的目的是限制这些暂停中的最长时间。</p>
<p>垃圾回收器会保持平均的停顿时间和该平均值的方差。平均值是从执行开始时获取的，但会对其进行加权，以使最近的暂停次数变得更多。如果平均时间加上暂停时间的方差大于最大暂停时间目标，则垃圾收集器认为未达到目标。</p>
<p>最大暂停时间目标是通过命令行选项 <code>-XX:MaxGCPauseMillis=&lt;nnn&gt;</code>  指定的。这被解释为向垃圾收集器的提示，要求暂停时间为 &lt;<em>nnn</em>&gt; 毫秒或更短。垃圾收集器会调整 Java 堆大小和与垃圾收集相关的其他参数，以使垃圾收集的暂停时间短于 &lt;<em>nnn</em>&gt; 毫秒。最大暂停时间目标的默认值因收集器而异。<strong>这些调整可能导致垃圾回收更加频繁地发生，从而降低了应用程序的整体吞吐量</strong>。</p>
<h3 id="吞吐量目标">吞吐量目标</h3>
<p>吞吐量目标是根据收集垃圾所花费的时间来衡量的，而在垃圾收集之外所花费的时间就是应用时间。</p>
<p>该目标由命令行选项 <code>-XX:GCTimeRatio=&lt;nnn&gt;</code> 指定。垃圾收集时间与应用程序时间的比率为 1/(1 + <em><nnn></em>)。例如，<code>-XX:GCTimeRatio=19</code> 设置目标垃圾收集的时间占总时间的 1/20 或 5％。</p>
<p>垃圾收集所花费的时间是所有垃圾收集引起的暂停的总时间。<strong>如果未达到吞吐量目标，那么垃圾收集器可能采取的一种措施是增加堆的大小，以便在两次收集暂停之间花费在应用程序中的时间可以更长。</strong></p>
<h3 id="占用空间">占用空间</h3>
<p>如果已满足吞吐量和最大暂停时间目标，则垃圾收集器会减小堆的大小，直到无法满足其中一个目标（始终是吞吐量目标）。可以分别使用 <code>-Xms=&lt;nnn&gt;</code> 和 <code>-Xmx=&lt;mmm&gt;</code> 分别设置垃圾收集器可以使用的最小和最大堆大小。</p>
<h2 id="调整策略">调整策略</h2>
<p>堆增大或缩小到支持所选吞吐量目标的大小。了解有关堆调整策略的信息，例如选择最大堆大小和选择最大暂停时间目标。</p>
<p>除非您知道需要的堆大于默认的最大堆大小，否则不要为堆选择最大值。选择足以满足您的应用程序的吞吐量目标。</p>
<p>应用程序行为的更改可能导致堆增大或缩小。例如，如果应用程序开始以更高的速率分配，则堆会增长以保持相同的吞吐量。</p>
<p>如果堆增长到最大大小，并且无法满足吞吐量目标，则最大堆大小对于吞吐量目标而言太小。将最大堆大小设置为接近平台上总物理内存的值，再次执行该应用程序。如果仍然没有达到吞吐量目标，那么对于平台上的可用内存来说，应用程序时间目标就太高了。</p>
<p>如果可以满足吞吐量目标，但是暂停时间太长，则选择最大暂停时间目标。选择最大暂停时间目标可能意味着您的吞吐量目标将无法实现，因此请选择对应用程序可接受的折衷值。</p>
<p>当垃圾收集器试图满足竞争目标时，堆的大小通常会发生波动。即使应用程序已达到稳定状态，也是如此。达到吞吐量目标（可能需要更大的堆）的压力与以获得最大的暂停时间和最小的占用空间（这两者都可能需要一个小堆）的目标相互竞争。</p>
<h1>垃圾收集器实现</h1>
<p>Java 平台的优势之一在于，它使开发人员免受内存分配和垃圾回收的复杂性的困扰。</p>
<p>但是，当垃圾收集是主要瓶颈时，了解实现的某些方面很有用。垃圾收集器对应用程序使用对象的方式进行了假设，并且这些反映在可调整的参数中，可以调整这些参数以提高性能而不会牺牲抽象的能力。</p>
<h3 id="分代垃圾收集器">分代垃圾收集器</h3>
<p>当无法从正在运行的程序中任何其他活动对象的任何引用中访问该对象时，该对象被视为垃圾，并且 VM 可以重用其内存。</p>
<p>一种理论上最直接的垃圾回收算法，每次运行时都会遍历每个可到达的对象。任何剩余的对象都被视为垃圾。这种方法花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序是不允许的。</p>
<p>Java HotSpot VM 包含许多不同的垃圾收集算法，这些算法均使用称为分代收集的技术。天真的垃圾收集每次都会检查堆中的每个活动对象，而分代收集则利用大多数应用程序的一些经验观察到的属性，以最大程度地减少回收未使用的（垃圾）对象所需的工作。这些观察到的特性中最重要的是<em>弱分代假设（weak generational hypothesis）</em>，该假设指出大多数物体只能存活很短的时间。</p>
<p>下图中的蓝色区域是对象生命周期的典型分布。 x 轴显示以分配的字节为单位的对象生存期。 y 轴上的字节数是具有相应生存期的对象中的总字节数。左侧的尖峰表示分配后可以回收的对象（换句话说，已“死亡”）。例如，迭代器对象通常仅在单个循环期间才处于活动状态。</p>
<p><img data-src="../../../images/java/jvm/jsgct_dt_003_alc_vs_srvng.png" alt="Typical Distribution for Lifetimes of Objects"></p>
<p>有些对象的寿命更长，因此分布向右延伸。例如，通常在初始化时分配一些对象，这些对象一直存在直到 VM 退出。在这两个极端之间是在某些中间计算期间仍处于活动状态的对象，在此处被视为初始峰值右侧的区域。一些应用程序的外观分布非常不同，但是令人惊讶的是，大量应用程序具有这种总体形状。通过关注大多数对象“早逝”这一事实，可以进行有效的收集。</p>
<h3 id="分代">分代</h3>
<p>为了针对这种情况进行优化，内存是分代管理的（存储着不同年龄对象的内存池）。当一分代填满时，垃圾收集会发生在每一代中。</p>
<p>绝大多数对象分配在专用于年轻对象（<em>新生代</em>）的池中，并且大多数对象都死在那里。当新生代填满时，将导致<em><strong>次要收集（Minor GC）</strong></em>  ，其中仅收集新生代，不会回收其他代的垃圾。首先，这种收集的费用与所收集的存活对象的数量成正比；新生代中死亡对象的收集非常快。通常，在每个 Minor GC 期间，来自新生代的幸存对象中有一部分会转移到老年代。最终，因为老年代填满并必须被收集，从而导致一个  <em><strong>主要收集（Major GC）</strong></em>，整个堆都会被收集。Major GC 的持续时间通常比 Minor GC 的持续时间长得多，因为涉及的对象数量很多。下图显示了串行垃圾收集器中各代的默认排列：</p>
<p><img data-src="../../../images/java/jvm/jsgct_dt_001_armgnt_gn_new.png" alt="Default Arrangement of Generations in the Serial Collector"></p>
<p>启动时，Java HotSpot VM 会在地址空间中保留整个 Java 堆，但除非需要，否则不会为其分配任何物理内存。覆盖 Java 堆的整个地址空间被逻辑分为新生代和老年代。</p>
<p>新生代由 <code>伊甸园（eden）</code> 和两个 <code>幸存者（survivor）</code> 空间组成。大多数对象最初是在 eden 中分配的。在垃圾收集期间，一个 survivor 空间可能随时被清空用作 eden 和其他 survivor 空间中活动对象的目的地，而另一个幸存者空间则用作垃圾收集者的目的地；垃圾回收后，eden 和源 survivor 空间被清空。在下一次垃圾收集中，将交换两个幸存者空间。最近填充满的一个空间中的活动对象是将要复制到的另一个幸存者的来源。以这种方式在幸存者空间之间复制对象，直到它们被复制了一定次数或空间不足为止，这些对象将被复制到老年代中，此过程也称为<em>老化｜晋升（aging</em>）。</p>
<h3 id="性能考量">性能考量</h3>
<p>垃圾收集的主要衡量指标是吞吐量和延迟。</p>
<ul>
<li>
<p>吞吐量是长时间内未花费在垃圾回收上的总时间的百分比。吞吐量包括分配所花费的时间（但是通常不需要调整分配速度）。</p>
</li>
<li>
<p>延迟是应用程序的响应能力。垃圾回收暂停会影响应用程序的响应速度。</p>
</li>
</ul>
<p>用户对垃圾回收有不同的要求。例如，有些人认为 Web 服务器的正确度量标准是吞吐量，因为垃圾回收期间的暂停可能是可以容忍的，或者可能被网络延迟所掩盖。但是，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。</p>
<p>一些用户对其他注意事项敏感。占用空间是进程的工作集，以页和缓存行计算而来。在物理内存有限或有许多进程的系统上，占用空间可能决定可伸缩性。*即时性（Promptness）*是指对象死掉到内存可用之间的时间，这是分布式系统（包括远程方法调用（RMI））的重要考虑因素。</p>
<p>通常，为特定分代选择大小是这些考虑之间的权衡。例如，一个非常大的新生代可以使吞吐量最大化，但是这样做会占用空间，及时性和暂停时间。也可以通过使用少量的新生代来最小化新生代停顿，但会降低吞吐量。一个分代的大小不会影响另一分代的收集频率和暂停时间。</p>
<p>没有选择分代大小的绝对的正确方法。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并非总是最佳选择，并且可能会被命令行选项所替代。请参阅影响垃圾收集性能的因素。</p>
<h3 id="吞吐量和空间占用测量">吞吐量和空间占用测量</h3>
<p>吞吐量和占用空间最好使用特定于应用程序的指标来衡量。</p>
<p>通过检查虚拟机本身的诊断输出，很容易估计由于垃圾收集而引起的暂停。</p>
<p>命令行选项 <code>-verbose:gc</code> 在每次收集中输出有关堆和垃圾回收的信息。这是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M-&gt;57M(307M) (15,646s, 15,651s) 5,048ms</span><br><span class="line">[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M-&gt;57M(307M) (16,146s, 16,162s) 16,565ms</span><br><span class="line">[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M-&gt;31M(104M) (16,202s, 16,367s) 164,581ms</span><br></pre></td></tr></table></figure>
<p>输出显示了两个新生代的收集，然后是由应用程序调用 System.gc() 启动的完整收集。这些行以一个时间戳开始，该时间戳指示从应用程序启动开始的时间。接下来是有关此行的日志级别（info）和标签（gc）的信息。其后是 GC 标识号。在这种情况下，存在三个 GC，其编号分别为 36、37 和 38。然后记录 GC 的类型和说明 GC 的原因。此后，将记录有关内存消耗的一些信息。该日志使用格式 “GC 之前使用情况”-&gt;“ GC 之后使用情况”（“堆总大小”）。</p>
<p>在示例的第一行中，239M-&gt;57M(307M)，这意味着在 GC 之前该区域使用了 239 MB，GC 清除了大部分内存，但仍有 57 MB 存活。堆总大小为 307 MB。请注意，在此示例中，完整的 GC 将堆从 307 MB 减小到 104 MB。在内存使用情况信息之后，将记录 GC 的开始和结束时间以及持续时间（结束-开始）。</p>
<p><code>-verbose:gc</code> 命令是 <code>-Xlog:gc</code> 的别名。 -Xlog 是用于 HotSpot JVM 的常规日志记录配置选项。这是一个基于标签的系统，其中 gc 是标签之一。要获取有关 GC 正在执行的操作的更多信息，您可以配置日志记录以打印具有 gc 标记和任何其他标记的任何消息。命令行选项是 <code>-Xlog:gc*</code>。</p>
<p>这是一个用 <code>-Xlog:gc*</code> 记录的 G1 新生代收集的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause) </span><br><span class="line">[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation </span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms </span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms </span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Other: 0.2ms </span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Eden regions: 286-&gt;0(276) </span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Survivor regions: 15-&gt;26(38)</span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Old regions: 88-&gt;88 </span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Humongous regions: 3-&gt;1 </span><br><span class="line">[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K-&gt;8152K(1056768K)</span><br><span class="line">[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M-&gt;114M(508M) 13.075ms </span><br><span class="line">[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s</span><br></pre></td></tr></table></figure>
<h1>影响垃圾收集性能的因素</h1>
<h2 id="总堆大小">总堆大小</h2>
<p>影响垃圾收集性能的最重要因素是总可用内存。由于收集是在分代填满时发生的，因此吞吐量与可用内存量成反比。</p>
<blockquote>
<p>以下有关堆的增长和收缩，堆布局和默认值的讨论以串行收集器为例。尽管其他收集器使用类似的机制，但此处介绍的详细信息可能不适用于其他收集器。有关其他收集器的类似信息，请参阅相应主题。</p>
</blockquote>
<h3 id="影响分代大小的堆选项">影响分代大小的堆选项</h3>
<p>许多选项会影响分代大小。下图说明了堆中已提交空间和虚拟空间之间的区别。在虚拟机初始化时，将保留堆的整个空间。可以使用 <code>-Xmx</code> 选项指定保留空间的大小。如果 <code>-Xms</code> 参数的值小于 <code>-Xmx</code> 参数的值，则并非所有保留的空间都会立即提交给虚拟机。在此图中，未使用的空间标记为 “virtual”。堆的不同部分，即老年代和新生代，可以根据需要增长到虚拟空间的极限。</p>
<p>一些参数是堆的一部分与另一部分的比率。例如，参数 <code>–XX:NewRatio</code> 表示老年代与新生代的相对大小。</p>
<p><img data-src="../../../images/java/jvm/jsgct_dt_006_prm_gn_sz_new.png" alt="Heap Options"></p>
<h3 id="堆大小的默认选项值">堆大小的默认选项值</h3>
<p>默认情况下，虚拟机会在每次收集增加或缩小堆，以尝试将每次收集中活动对象的可用空间比例保持在特定范围内。</p>
<p>该目标范围由 <code>-XX:MinHeapFreeRatio=</code>&lt;<em>minimum</em>&gt; 和 <code>-XX:MaxHeapFreeRatio</code>=&lt;<em>maximum</em>&gt; 选项设置为百分比，总大小的下限为 <code>–Xms&lt;min&gt;</code>，上限为 <code>–Xmx&lt;max&gt;</code> 。下表中显示了 64 位 Solaris 操作系统（SPARC 平台版本）的默认选项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Option</th>
<th style="text-align:left">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:MinHeapFreeRatio</code></td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:MaxHeapFreeRatio</code></td>
<td style="text-align:left">70</td>
</tr>
<tr>
<td style="text-align:left"><code>-Xms</code></td>
<td style="text-align:left">6656 KB</td>
</tr>
<tr>
<td style="text-align:left"><code>-Xmx</code></td>
<td style="text-align:left">calculated</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其他参数和选项可能会影响这些默认值。要验证默认值，请使用 <code>-XX:+PrintFlagsFinal</code> 选项。</p>
</blockquote>
<p>使用这些选项，如果某代中的可用空间百分比降到 40％ 以下，则该代将扩展以维持 40％ 的可用空间，直到该代最大允许的大小。同样，如果可用空间超过 70％，则分代会收缩，因此只有 70％ 的空间可用，这取决于分代的最小大小。</p>
<p>如表所述，默认的最大堆大小是由 JVM 计算的值。 Java SE 中为 Parallel 收集器使用的计算方式现在已用于所有垃圾收集器。计算的一部分因素是 64 位平台的最大堆大小的上限。请参见<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/parallel-collector1.html#GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4">并行收集器默认堆大小</a>。客户端 JVM 的计算与此类似，这导致最大堆大小小于服务器 JVM。</p>
<p>以下是有关服务器应用程序堆大小的一般准则：</p>
<ul>
<li>除非您在暂停方面遇到问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常太小。</li>
<li>将 <code>-Xms</code> 和 <code>-Xmx</code> 设置为相同的值可以提高可预测性，因为消除了虚拟机最重要的确定大小的决策。但是，如果选择不当，虚拟机将无法补偿。</li>
<li>通常，随着处理器数量的增加，内存也会增加，因为分配可以并行进行。</li>
</ul>
<h2 id="新生代">新生代</h2>
<p>在总可用内存之后，影响垃圾收集性能的第二大影响因素是专用于新生代的堆的比例。</p>
<p>**新生代越大，Minor-次要 收集的次数就越少。**但是，对于有限的堆大小，较大的新生代意味着较小的老年代，<strong>这将增加 Major-主要 收集的频率</strong>。最佳选择取决于应用程序分配的对象的生命周期分布。</p>
<h3 id="新生代大小选项">新生代大小选项</h3>
<p>通常，新生代的大小受 <code>-XX:NewRatio</code> 该选项控制。</p>
<p>比如，设置 <code>-XX:NewRatio=3</code> 表示新生代与老年代之间的比率为 1:3。换句话说，伊甸园-eden 空间和 幸存者-survivor 空间的总大小将是堆总大小的四分之一。</p>
<p>选项 <code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code> 从下方和上方限制了新生代的大小。将这些值设置为相同的值可以修复新生代，就像将 <code>-Xms</code> 和 <code>-Xmx</code> 设置为相同的值可以修复总堆大小一样。与 <code>-XX:NewRatio</code> 允许的整数倍相比，这对于以更精细的粒度调整新生代很有用。</p>
<h3 id="幸存者-Survivor-空间大小">幸存者-Survivor 空间大小</h3>
<p>您可以使用选项 <code>-XX:SurvivorRatio</code> 来调整幸存者空间的大小，但这通常对性能并不重要。</p>
<p>例如，<code>-XX:SurvivorRatio=6</code> 将伊甸园和幸存空间之间的比率设置为 6:1。换句话说，每个幸存者空间将是伊甸园大小的六分之一，因此是新生代的八分之一（而不是七分之一，因为有两个幸存者空间）。</p>
<p>如果幸存者空间太小，那么收集时复制将直接溢出到老年代中。如果幸存者空间太大，那么它们将毫无用处。在每次垃圾回收时，虚拟机都会选择一个阈值数，该阈值是对象在变旧之前可以复制的次数。选择该阈值可使幸存者半满。您可以使用日志配置 <code>-Xlog:gc,age</code> 可用于显示此阈值和新生代对象的寿命。</p>
<p><strong>64 位 Solaris 幸存者空间大小的默认选项值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Option</th>
<th style="text-align:left">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:NewRatio</code></td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:NewSize</code></td>
<td style="text-align:left">1310 MB</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:MaxNewSize</code></td>
<td style="text-align:left">not limited</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:SurvivorRatio</code></td>
<td style="text-align:left">8</td>
</tr>
</tbody>
</table>
<p>从总堆的最大大小和 <code>-XX:NewRatio</code> 参数的值计算出新生代的最大大小。</p>
<p><code>-XX:MaxNewSize</code> 参数的 “not limited” 默认值意味着，除非在命令行上指定了 <code>-XX:MaxNewSize</code> 的值，否则计算所得值不受 <code>-XX:MaxNewSize</code> 的限制。</p>
<p>以下是服务器应用程序的一般准则：</p>
<ul>
<li>首先确定您可以负担得起的虚拟机的最大堆大小。然后，针对新生代绘制性能指标，以找到最佳设置。
<ul>
<li>请注意，最大堆大小应始终小于计算机上安装的内存量，以避免过多的页面错误和崩溃。</li>
</ul>
</li>
<li>如果总堆大小是固定的，则增加新生代大小需求减少老年代大小。保留足够大的老年代以容纳应用程序在任何给定时间使用的所有存活对象，以及一定数量的空闲空间（10％ 到 20％ 或更多）。</li>
<li>遵循先前对老年代的约束：
<ul>
<li>为新生代留出充裕的内存。</li>
<li>随着处理器数量的增加，可以增加新生代的大小，因为分配动作可以并行化。</li>
</ul>
</li>
</ul>
<h1>可用的收集器</h1>
<p>到目前为止，讨论的都是串行收集器。 Java HotSpot VM 包括三种不同类型的收集器，每种收集器具有不同的性能特征。</p>
<h2 id="串行收集器">串行收集器</h2>
<p>串行收集器使用单个线程来执行所有垃圾收集工作，这使之相对高效，因为线程之间没有通信开销。</p>
<p>它最适合单处理器计算机，因为它不能利用多处理器硬件，尽管它在多处理器上对于数据量较小（最大约 100 MB）的应用程序很有用。默认情况下，在某些硬件和操作系统配置上选择了串行收集器，或者可以通过选项 <code>-XX:+UseSerialGC</code> 显式启用串行收集器。</p>
<h2 id="并行收集器">并行收集器</h2>
<p>并行收集器也称为吞吐量收集器，它是类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器具有多个线程，这些线程用于加速垃圾收集。</p>
<p>并行收集器旨在用于具有在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。您可以使用 <code>-XX:+UseParallelGC</code> 选项启用它。</p>
<p>并行压缩是使并行收集器能够并行执行 Major-主要 收集的功能。如果没有并行压缩，则使用单个线程执行 Major 收集，这会大大限制可伸缩性。如果已指定选项 <code>-XX:+UseParallelGC</code>，则默认情况下启用并行压缩。您可以使用 <code>-XX:-UseParallelOldGC</code> 选项禁用并行压缩。</p>
<h2 id="最主要的大部分并发收集器">最主要的大部分并发收集器</h2>
<p>并发标记清除（CMS）收集器和 Garbage-First（G1）垃圾收集器是两个最主要的大部分并发收集器。通常，并发收集器会与应用程序同时执行一些昂贵的工作。</p>
<ul>
<li>
<p>G1 垃圾收集器：<strong>此服务器形式的收集器用于具有大量内存的多处理器计算机。它极有可能满足垃圾收集暂停时间目标，同时实现高吞吐量。</strong></p>
<p>G1 在某些硬件和操作系统配置上默认为选中，或者可以使用 <code>-XX:+UseG1GC</code> 明确启用。</p>
</li>
<li>
<p>CMS 收集器：<strong>此收集器适用于那些希望更短的垃圾收集暂停时间并能够与垃圾收集共享处理器资源的应用程序。</strong></p>
<p>使用选项 <code>-XX:+UseConcMarkSweepGC</code> 启用 CMS 收集器。</p>
</li>
</ul>
<p><strong>从 JDK 9 开始不推荐使用 CMS 收集器。</strong></p>
<h3 id="Z-垃圾收集器">Z 垃圾收集器</h3>
<p>Z 垃圾收集器（ZGC）是可伸缩的低延迟垃圾收集器。 ZGC 同时执行所有昂贵的工作，而不会停止执行应用程序线程。</p>
<p>ZGC <strong>适用于需要低延迟（少于 10 毫秒的暂停）和/或使用非常大的堆（数 TB）的应用程序</strong>。您可以通过使用 <code>-XX:+UseZGC</code> 选项来启用。</p>
<p><strong>从 JDK 11 开始，ZGC 可以作为实验功能使用。</strong></p>
<h2 id="选择收集器">选择收集器</h2>
<p>除非您的应用程序有非常严格的暂停时间要求，否则请先运行您的应用程序并允许 VM 选择收集器。</p>
<p>如有必要，请调整堆大小以提高性能。如果性能仍然不能满足您的目标，请使用以下准则作为选择收集器的开始：</p>
<ul>
<li>
<p>如果应用程序的数据集较小（最大约 100 MB），则选择带有选项 <code>-XX:+UseSerialGC</code> 的串行收集器。</p>
</li>
<li>
<p>如果应用程序将在单个处理器上运行并且没有暂停时间要求，则选择带有选项 <code>-XX:+UseSerialGC</code> 的串行收集器。</p>
</li>
<li>
<p>如果（a）应用程序性能峰值是第一优先级，并且（b）没有暂停时间要求或一秒钟或更长时间的暂停是可接受的，则让 VM 选择收集器或使用 <code>-XX:+UseParallelGC</code> 选择并行收集器。</p>
</li>
<li>
<p>如果响应时间比总体吞吐量更重要，并且垃圾收集暂停时间必须短于大约一秒钟，则选择带有 <code>-XX:+UseG1GC</code> 或 <code>-XX:+UseConcMarkSweepGC</code> 的并发收集器。</p>
</li>
<li>
<p>如果响应时间是高优先级，和/或您使用的堆非常大，请使用 <code>-XX:UseZGC</code> 选择完全并发的收集器。</p>
</li>
</ul>
<p>这些准则只是选择收集器的开始，因为性能<strong>取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度</strong>。</p>
<p>如果推荐的收集器没有达到所需的性能，则首先尝试调整堆和分代大小以满足所需的目标。如果性能仍然不足，请尝试使用其他收集器：<strong>使用并发收集器可以减少暂停时间，并可以使用并行收集器来提高多处理器硬件上的总体吞吐量</strong>。</p>
<h1>Garbage-First 垃圾收集器</h1>
<h2 id="G1-收集器简介">G1 收集器简介</h2>
<p>Garbage-First（G1）垃圾收集器的目标是具有大量内存的多处理器计算机。它试图以极高的可能性满足垃圾收集暂停时间的目标，同时在几乎不需要配置的情况下实现高吞吐量。G1 的目标是使用当前目标应用程序和环境在延迟和吞吐量之间达到最佳平衡，其特点包括：</p>
<ul>
<li>堆大小最大为 10 GB 或更大，其中超过 50％ 的 Java 堆被存活数据占用。</li>
<li>对象分配和晋升的速率可能会随时间而显著变化。</li>
<li>堆中有大量碎片。</li>
<li>可预测的暂停时间目标目标不超过几百毫秒，避免了长时间的垃圾收集暂停。</li>
</ul>
<p>G1 替代了并发标记清除（CMS）收集器。它也是 Java 11 默认的收集器。</p>
<p>G1 收集器可实现高性能，并尝试通过以下各节中描述的几种方式满足暂停时间目标。</p>
<h2 id="启用-G1">启用 G1</h2>
<p>Garbage-First 垃圾收集器是 Java 11 默认的收集器，因此通常不必执行任何其他操作。您可以通过在命令行上提供 <code>-XX:+UseG1GC</code> 来显式启用它。</p>
<h2 id="基本概念">基本概念</h2>
<p>G1是分代，增量，并行，大部分并发的，stop-the-world 的并且 evacuating（撤离） 的垃圾收集器，它在每次 stop-the-world 暂停中监视暂停时间为目标。与其他收集器类似，G1 将堆分成（虚拟的）新生代和老年代。空间回收工作主要集中在最有效的新生代，而老年代则偶尔进行空间回收。</p>
<p>某些操作总是在 stop-the-world 的暂停中执行，以提高吞吐量。在应用程序停止时会花费更多时间在其他操作（例如整个堆的全局标记之类的操作）但是与应用程序并行并发执行的。为了使 stop-the-world 停顿的时间足够短来做空间回收，G1 分步并行执行。G1 通过跟踪有关先前应用程序的行为和垃圾收集暂停的信息来建立可关联性模型，从而实现可预测性。它使用此信息来确定暂停中要完成的工作。例如，G1 首先回收最高效区域中的空间（也就是大部分被垃圾填充的区域）。</p>
<p>G1 主要通过撤离（evacuating）来回收空间：将在选定存储区域中收集的活动对象复制到新的存储区域，并在此过程中对其进行压缩。evacuating 完成后，活动对象先前占用的空间将重新用于应用程序分配。</p>
<p>G1 收集器不是实时收集器。它会尝试在更长的时间内以较高的概率达到设定的暂停时间目标，但对于给定的暂停时间却并非总是绝对有把握。</p>
<h3 id="堆布局">堆布局</h3>
<p>G1 将堆划分为一组大小相等的堆区域，每个堆区域都有一个连续的虚拟内存范围，如图所示。区域是内存分配和回收的单位。在任何给定时间，这些区域中的每个区域都可以为空（浅灰色），或分配给特定的年龄段（新生或老年）。随着内存请求的到来，内存管理器将释放可用区域。内存管理器将它们分配给一个分代，然后将它们作为可分配自身的可用空间返回给应用程序。</p>
<p><img data-src="../../../images/java/jvm/jsgct_dt_004_grbg_frst_hp.png" alt="G1 Garbage Collector Heap Layout"></p>
<p>新生代包含 伊甸园-eden 区域（红色）和 幸存者-survivor 区域（红色带有“ S”）。这些区域提供的功能与其他收集器中相应的连续空间相同，不同的是，在 G1 中，这些区域通常以不连续的模式布置在内存中。浅蓝色区域构成了老年代。对于跨越多个区域的对象，老年代区域可能是巨大的（浅蓝色，带有“ H”）。</p>
<p>应用程序总是分配给新生代，即伊甸园区域，但庞大对象将直接分配为老年代。</p>
<p>G1 垃圾收集暂停时可以回收整个新生代中的空间，并且可以在任何收集暂停时回收任何其他老年代区域。在暂停期间，G1 将对象从该次收集批次中复制到堆中的一个或多个不同区域。对象的目标区域取决于该对象的源区域：整个新生代都被复制到幸存者或老年代区域中，并通过老化将对象从老年代区域复制到其他不同的老年代区域。</p>
<h3 id="垃圾回收周期">垃圾回收周期</h3>
<p>在较高级别上，G1 收集器在两个阶段之间交替。Young-only 阶段包含垃圾回收，这些垃圾回收逐渐将老年代中的对象填充到当前可用的内存中。在空间回收（Space Reclamation）阶段，G1 除了处理新生代外，还逐步回收老年代的空间。然后，循环以仅年轻阶段重新开始。</p>
<p>下图给出了有关此循环的概述，并举例说明了可能发生的垃圾收集暂停的顺序：</p>
<p><img data-src="../../../images/java/jvm/jsgct_dt_001_grbgcltncyl.png" alt="Garbage Collection Cycle Overview"></p>
<p>以下列表详细描述了 G1 垃圾回收周期的各个阶段，它们的暂停以及各阶段之间的过渡：</p>
<ol>
<li>仅新生代（Young-only）阶段：这个阶段从一些普通的新生代收集开始，这些收集将对象晋升到老年代。当新生代的占用率达到某个阈值（初始堆占用阈值）时，Young-only 阶段和空间回收阶段之间的过渡开始。此时，G1 开始并发收集新生代，而不是普通收集。</li>
</ol>
<ul>
<li>并发开始：这种类型的收集除了执行“正常”收集新生代外，还会启动标记过程。并发标记确定了在下一个空间回收阶段中要保留的老年代区域中所有当前可到达的（活动）对象。尽管收集标记尚未完全完成，但可能会出现正常的新生代收集。标记结束时有两个特殊的 stop-the-world 暂停：“标记-Remark” 和 “清除-Cleanup”。</li>
<li>Remark：此<strong>暂停</strong>将最终完成标记本身，执行全局引用处理和类卸载，回收完全为空的区域并清理内部数据结构。在“标记-Remark”和“清除-Cleanup”之间，G1 计算信息以便以后能够同时回收选定的老年代区域中的可用空间，这些信息将在清除暂停中最终确定。</li>
<li>Cleanup：此<strong>暂停</strong>确定是否将实际进行空间回收阶段。如果随后进行空间回收阶段，则 Young-only 阶段将以单个预混合（Prepare Mixed）新生代收集结束。</li>
</ul>
<ol start="2">
<li>空间回收阶段：此阶段包括多个混合收集，这些收集除了新生代区域外，还 evacuating-撤离 了老年代区域中的活动对象。当 G1 确定撤离更多老年代区域不会产生值得努力的足够自由空间时，空间回收阶段结束。</li>
</ol>
<p>在进行空间回收之后，收集周期会从另一个 Young-only 阶段开始重新启动。作为备份，如果应用程序在收集活动信息时内存不足，则 G1 会像其他收集器一样执行 in-place stop-the-world 的全堆压缩（Full GC）。</p>
<h2 id="G1-内部">G1 内部</h2>
<p>本节描述了垃圾优先（G1）垃圾收集器的一些重要细节。</p>
<h3 id="确定初始堆占用率">确定初始堆占用率</h3>
<p><em>初始堆占用率</em>（<em>Initiating Heap Occupancy Percent</em> - IHOP）定义为老年代大小的百分比，它是触发初始标记收集的阈值。</p>
<p>默认情况下，G1 通过观察<strong>标记所需的时间</strong>以及<strong>标记周期内老年代分配的内存量</strong>来自动确定最佳的 IHOP。此功能称为自适应 IHOP。如果启用此功能，就会将 <code>-XX:InitiatingHeapOccupancyPercent</code> 选项初始值确定为当前老年代大小的百分比，直到没有足够的观测值可以很好地预测初始堆占用阈值。使用选项 <code>-XX:-G1UseAdaptiveIHOP</code> 关闭 G1 的这种行为。在这种情况下，<code>-XX:InitiatingHeapOccupancyPercent</code> 的值将会确定此阈值。</p>
<p>在内部，当老年代占用率为当前最大的老年代大小减去 <code>-XX:G1HeapReservePercent</code> 作为额外的缓冲区值时，自适应 IHOP 尝试设置初始堆占用率，以便开始空间回收阶段的第一个混合垃圾收集。</p>
<h3 id="标记">标记</h3>
<p>G1 标记使用称为<em>开始时快照</em>（<em>Snapshot-At-The-Beginning</em> - SATB）的算法。当初始标记暂停时，它会为堆创建虚拟快照，此时在标记开始时所有处于活动状态的对象都被认为在其余标记时间也处于活动状态。这意味着出于空间回收的目的（在某些情况下例外），在标记过程中变成死（不可到达）的对象仍被认为是活动的。与其他收集器相比，这可能导致错误地保留了一些额外的内存。但是，这也潜在的使 SATB 在 Remark 暂停期间提供了更好的延迟。在该标记过程中过于保守地认为存活的对象将在下一次标记期间回收。有关标记问题的更多信息，请参见 G1 垃圾收集器优化主题。</p>
<h3 id="堆非常紧张时的行为">堆非常紧张时的行为</h3>
<p>当应用程序了保留大量内存导致撤离（evacuation）无法找到足够的空间复制到该空间时，就会发生撤离失败。撤离失败意味着 G1 通过将所有已移动的对象保留在新位置，并且不复制任何尚未移动的对象，仅调整对象之间的引用的方式来尝试完成当前的垃圾收集，撤离失败可能会产生一些额外的开销，但通常应与其他新生代收集一样快。在撤离失败的垃圾收集之后，G1 将正常恢复应用程序，而无需采取任何其他措施。G1 假定撤离失败发生在垃圾收集即将结束时； 也就是说，大多数对象已被移动，并且剩余空间足以继续运行应用程序，直到标记完成并开始空间回收。</p>
<p>如果这种假设不成立，那么 G1 最终将安排一个完全 GC。这种类型的收集执行整个堆的  in-place 压缩。这可能很慢。</p>
<p>有关在内存不足之前发出分配失败或完整GC的问题的更多信息，请参见 G1 垃圾收集器优化。</p>
<h3 id="大型对象">大型对象</h3>
<p>大型对象是大于或等于一半区域大小的对象。除非使用 <code>-XX:G1HeapRegionSize</code> 选项进行设置，否则当前区域的大小将按照 G1 GC 的<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016">人机工程学默认值</a>中的说明按人机工程学确定。</p>
<p>这些大型对象有时会以特殊方式处理：</p>
<ul>
<li>在老年代中，每个大型对象都被分配为一系列连续的区域。对象本身的起点始终按该顺序位于第一个区域的起点。最后一个区域中的所有剩余空间都将浪费，直到回收整个对象时才会进行分配。</li>
<li>通常，大型对象只能在 清理-Cleanup 暂停期间的标记结束时回收，或者如果变得无法访问，则可以在完整 GC 期间回收。但是，对于大型对象有特殊的规定，用于原始类型的数组，例如 bool，各种整数和浮点值，如果在任何类型的垃圾回收暂停中许多对象都未引用大型对象，则 G1 机会尝试回收大型对象。默认情况下启用此行为，但是您可以使用选项 <code>-XX:G1EagerReclaimHumongousObjects</code> 禁用它。</li>
<li>分配大型对象可能会导致垃圾回收暂停提前发生。 G1 会在每次大型对象分配时检查“初始堆占用”阈值，如果当前占用量超过该阈值，则可能会立即强制执行初始标记新生代收集。</li>
<li>大型永远不会移动，即使在 Full GC 期间也不会移动。这可能会导致 Full GC 提前到来，或者由于区域空间因大量浪费的空间碎片而导致意外内存不足情况。</li>
</ul>
<h3 id="Young-Only-阶段分代大小确定">Young-Only 阶段分代大小确定</h3>
<p><strong>在仅新生代阶段，要收集的区域批次（收集批次）仅由新生代区域组成。</strong> G1 总是在正常的新生代收集结束时为下一个阶段确定新生代大小。这样，G1 可以通过使用 <code>-XX:MaxGCPauseTimeMillis</code> 和 <code>-XX:PauseTimeIntervalMillis</code> 基于对实际暂停时间的长期观察来达成暂停时间目标。它考虑了撤离规模相似的新生代需要多长时间。这包括诸如在收集过程中必须复制多少个对象以及这些对象之间关联的信息。</p>
<p>如果没有其他限制，则 G1 在 <code>-XX:G1NewSizePercent</code> 和 <code>-XX:G1MaxNewSizePercent</code> 确定满足暂停时间的值之间自适应地调整新生代大小。有关如何解决长时间停顿的更多信息，请参见 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">G1 垃圾收集器优化</a>。</p>
<h3 id="空间回收阶段分代大小确定">空间回收阶段分代大小确定</h3>
<p>在空间回收阶段，G1 尝试在单个垃圾收集暂停中最大化老年代中回收的空间量。它会将新生代的大小设置为允许的最小值（通常由 <code>-XX:G1NewSizePercent</code> 确定），并将任何老年区域添加到回收空间，直到 G1 确定添加更多区域将超过暂停时间目标为止。在特定的垃圾收集暂停中，G1 按照回收效率的顺序添加老年代区域，回收效率高的优先，然后用剩余可用时间来获取最终的收集批次。</p>
<p>每次垃圾收集所能使用的老年代区域的数量受到要收集的潜在候选老年代区域（收集批次候选区域）的数量除以 <code>-XX:G1MixedGCCountTarget</code> 确定的空间回收阶段的长度的限制。<em>收集批次候选区域</em>是该阶段开始时占用率低于 -<code>XX:G1MixedGCLiveThresholdPercent</code> 的所有老年代区域。</p>
<p>当可在收集批次候选区域中回收的剩余空间量小于 <code>-XX:G1HeapWastePercent</code> 设置的百分比时，该阶段结束。</p>
<p>有关 G1 将使用多少个老年代区域以及如何避免长时间的混合收集暂停的更多信息，请参见 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">G1 的垃圾收集器优化。</a></p>
<h2 id="G1-GC-的人机工程学默认值">G1 GC 的人机工程学默认值</h2>
<p>本主题概述了特定于 G1 的最重要参数及其默认值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项和默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:MaxGCPauseMillis=200</code></td>
<td style="text-align:left">最大暂停时间的目标。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:GCPauseTimeInterval</code>=<em><ergo></em></td>
<td style="text-align:left">最大暂停时间间隔的目标。默认情况下，G1 不设置任何目标，允许 G1 在极端情况下连续执行垃圾收集。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:ParallelGCThreads</code>=<em><ergo></em></td>
<td style="text-align:left">垃圾回收暂停期间用于并行工作的最大线程数。这是通过以下方式从运行 VM 的计算机的可用线程数得出的：如果该进程可用的 CPU 线程数小于或等于 8，则使用该数量。否则，将线程数的八分之五增加到最终线程数。<br />在每次暂停开始时，使用的最大线程数进一步受最大总堆大小的限制：对于配置了每个线程能使用的最大堆内存 <code>-XX:HeapSizePerGCThread</code>，达到内存要求时 G1 不会使用多个线程。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:ConcGCThreads</code>=<em><ergo></em></td>
<td style="text-align:left">用于并发工作的最大线程数。默认情况下，此值为 <code>-XX:ParallelGCThreads</code> 除以 4。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:+G1UseAdaptiveIHOP</code><br /><code>-XX:InitiatingHeapOccupancyPercent=45</code></td>
<td style="text-align:left">用于控制初始堆占用率的默认值，以及指示自适应 IHOP 为启用，并且对于前几个收集周期，G1 将使用老年代占用率的 45％ 作为标记开始阈值。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1HeapRegionSize=&lt;ergo&gt; </code></td>
<td style="text-align:left">基于初始堆大小和最大堆大小确定的堆区域大小。因此，该堆包含大约 2048 个堆区域。堆区域的大小可以从 1 到 32 MB 不等，并且必须为 2 的幂。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1NewSizePercent=5</code><br /><code>-XX:G1MaxNewSizePercent=60</code></td>
<td style="text-align:left">总体上，新生代的大小在这两个值之间变化，以当前使用的 Java 堆的百分比表示。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1HeapWastePercent=5</code></td>
<td style="text-align:left">集合中允许的候选未回收空间百分比。如果收集批次候选中的可用空间低于该比值，则 G1 停止空间回收阶段。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1MixedGCCountTarget=8</code></td>
<td style="text-align:left">预期空间回收阶段收集的次数。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1MixedGCLiveThresholdPercent=85</code></td>
<td style="text-align:left">在此空间回收阶段，高于该老年代存活对象占比时将不会被收集。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：<ergo> 表示实际值是根据环境和人机工程学确定的。</p>
</blockquote>
<h2 id="与其他收集器的比较">与其他收集器的比较</h2>
<p>这是 G1 与其他收集器之间主要区别的摘要：</p>
<ul>
<li>并行 GC 只能从整体上压缩和回收老年代中的空间。 G1 将这项工作逐步分配到多个较短的收集中。这大大缩短了暂停时间也潜在的提高了吞吐量。</li>
<li>与 CMS 相似，G1 并发执行部分老年代空间回收。但是，CMS 无法对老年代的堆进行碎片整理，最终会遇到较长的 Full GC。</li>
<li>G1 可能表现出比其他收集器更高的开销，由于其并发性而影响吞吐量。</li>
</ul>
<p>由于其工作方式，G1 具有一些独特的机制来提高垃圾收集效率：</p>
<ul>
<li>G1 可以在任何收集过程中回收一些老年代的完全空的，较大的区域。这样可以避免许多其他不必要的垃圾收集，而无需付出很多努力即可释放大量空间。</li>
<li>G1 可以选择尝试并发的对 Java 堆上的重复字符串进行重复数据删除。</li>
</ul>
<p>始终启用从老年代中回收空的大型对象的功能。您可以使用选项 <code>-XX:-G1EagerReclaimHumongousObjects</code> 禁用此功能。默认情况下，字符串重复数据删除功能处于禁用状态。您可以使用选项 <code>-XX:+G1EnableStringDeduplication</code> 启用它。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>G1</tag>
        <tag>CMG</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的 lambda 表达式如何工作？</title>
    <url>/java/jvm/java-%E4%B8%AD%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>lambda 表达式在 Java 代码和 JVM 内部是什么样的？显然，它是某种类型的值，而 Java 只允许两种类型的值：原始类型和对象引用。lambda 显然不是原始类型，因此 Lambda 表达式必须是某种返回对象引用的表达式。</p>
<p>让我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLO</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; System.out.println(HELLO);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉内部类的程序员可能会猜测 lambda 实际上只是 <code>Runnable</code> 匿名内部类的语法糖。但是，编译以上类将生成一个文件：<code>LambdaExample.class</code>。该类中并没有其他类文件。</p>
<span id="more"></span>
<p>这意味着 lambda 不是内部类。相反，它们必须是其他某种机制。实际上，通过 <code>javap -c -p</code> 反编译字节码揭示了两件事。</p>
<p>首先是以下事实：lambda 主体已被编译为私有的静态方法，该方法出现在主类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">9</span>                  <span class="comment">// String Hello World!</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>关于字节码的第二件事要注意的是 main 方法的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span> <span class="keyword">throws</span> java.lang.Exception;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/Thread</span></span><br><span class="line">       <span class="number">9</span>: dup</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      <span class="number">11</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line">      <span class="number">14</span>: astore_2</span><br><span class="line">      <span class="number">15</span>: aload_2</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Thread.start:()V</span></span><br><span class="line">      <span class="number">19</span>: aload_2</span><br><span class="line">      <span class="number">20</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/Thread.join:()V</span></span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>请注意，字节码以 <code>invokedynamic</code> 调用开始。此操作码已添加到版本 7 的 Java 中（这是有史以来唯一添加到 JVM 字节码的操作码）。我在“<a target="_blank" rel="noopener" href="https://blogs.oracle.com/javamagazine/real-world-bytecode-handling-with-asm?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991">使用 ASM 的操作字节码</a>”和“<a target="_blank" rel="noopener" href="https://www.oracle.com/a/ocom/docs/corporate/java-magazine-nov-dec-2017.pdf#page=67?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991">了解使用 invokedynamic 进行 Java 方法调用</a>”中讨论了方法调用，您可以将其作为本文的附带内容阅读。</p>
<p>理解此代码中的 <code>invokedynamic</code> 调用的最直接方法是将其视为对某种特殊形式的 factory 方法的调用。方法调用返回实现 <code>Runnable</code> 的某种类型的实例。确切的类型没有在字节码中指定，从根本上来说也没什么关系。</p>
<p>实际类型在编译时不存在，将在运行时按需创建。为了更好地说明这一点，我将讨论三种结合使用以实现该效果的机制：<strong>调用站点(call sites)</strong>，<strong>方法句柄(method handles)<strong>和</strong>引导程序(bootstrapping)</strong>。</p>
<blockquote>
<p>🤔 <strong>句柄</strong>这个翻译有点生涩，直接理解 Handle 即可。</p>
</blockquote>
<h2 id="Call-sites">Call sites</h2>
<p>字节码中方法调用指令发生的位置称为调用站点。</p>
<p>调用站点持有一个 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html"><code>MethodHandle</code></a> 变量，作为它的调用目标，链接到调用站点的 <code>invokedynamic</code> 调用将会全部委托给 <code>MethodHandle</code>。调用站点可能和多个 <code>invokedynamic</code> 关联，也可能是“自由浮动”的，没有任何关联。无论哪种情况，它都可以通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html#:~:text=handle%20called%20its-,dynamic%20invoker,-.">dynamic Invoker</a> 方法来调用。</p>
<p>传统上，Java 字节码具有四个处理不同方法调用情况的操作码：</p>
<ul>
<li><strong>(invokestatic)</strong> 静态方法，用于调用类方法</li>
<li><strong>(invokevirtual)</strong> “常规”调用，用于调用对象的实例方法（可能涉及方法重写的虚拟调用）</li>
<li><strong>(invokeinterface)</strong> 接口查找，用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li><strong>(invokespecial)</strong> “特殊”调用，用于调用一些需要特殊处理的实例方法（对于不需要重写解析的情况，例如超类调用和私有方法）。</li>
</ul>
<p><strong>(invokedynamic)</strong> 相比于之前的四条指令，他们的分派逻辑都是固化在 JVM 内部，而 invokedynamic 则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断，从而达到动态语言的支持。</p>
<p>在这里，<code>invokedynamic</code> 调用站点在 Java 堆中表示为 <code>CallSite</code> 对象。这并不奇怪：自 Java 1.1 开始，Java 就使用了反射 API 做类似的事情，其中包含诸如 <code>Method</code> 之类的类型，Java 在运行时具有许多动态行为，因此 Java 现在正在对调用站点以及其他运行时类型信息进行建模的想法应该就不足为奇了。</p>
<p>每个 <code>invokedynamic</code> 指令的调用被称为<em>动态调用站点（dynamic call site）</em>，动态调用站点最开始是未链接的状态，在这种状态下，调用站点没有要调用的目标方法。在 JVM 可以执行动态调用站点（<code>invokedynamic</code> 指令）之前，必须首先链接调用站点。链接是通过调用 <code>bootstrap</code> 方法来完成的，该方法获得调用站点的静态信息内容，并且必须生成一个提供调用站点行为的方法句柄（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html"><code>method handle</code></a>）。</p>
<p>当执行到 <code>invokedynamic</code> 指令时，JVM 会找到相应的调用站点对象（或者，如果以前从未执行过此调用站点，它将创建一个新对象）。</p>
<p>调用站点对象是必要的间接级别，允许关联的调用目标（即方法句柄）随时间变化。</p>
<p><code>CallSite</code>（抽象类）有三个可用的子类：<code>ConstantCallSite</code>，<code>MutableCallSite</code> 和 <code>VolatileCallSite</code>。基类仅具有包访问权限构造函数，而三个子类型具有公共构造函数。这意味着 <code>CallSite</code> 不能由用户代码直接子类化，但是可以继承其子类。例如，<code>JRuby</code> 语言使用 <code>invokedynamic</code> 作为其实现的一部分，并继承了 <code>MutableCallSite</code> 子类。</p>
<p><strong>注意</strong>：某些 <code>invokedynamic</code> 调用站点实际上只是延迟计算，并且目标对象的方法在第一次执行后就不会改变。这是 <code>ConstantCallSite</code> 的非常常见的用例，其中包括 lambda 表达式。</p>
<p>这意味着在程序的整个生命周期中，非常量调用站点可以改变不同的方法句柄作为其目标 <code>setTarget(MethodHandle newTarget)</code>，新目标必须与前一个目标具有相同的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html#type--">方法类型（MethodType）</a>。</p>
<h2 id="Method-handles">Method handles</h2>
<p>反射是一种用于执行运行时技巧的强大技术，但它具有许多设计缺陷。反射的一个关键问题是性能，尤其是因为即时调用（JIT）编译器难以内联（<code>inlining</code>）反射调用。</p>
<p>这很不好，因为内联在几种方面对 JIT 编译非常重要，其中最重要的一点是因为内联通常是首次应用优化，并且为其他技术打开了大门（例如转义分析和无效代码消除）。</p>
<p>第二个问题是，每次遇到 <code>Method.invoke()</code> 的调用站点时，都会链接反射调用。例如，这意味着执行安全访问检查。这是非常浪费的，因为在第一次调用时检查通常会成功还是失败，并且如果成功，它将在程序的整个生命周期中继续这样做。然而，反射却又一次又一次地链接调用。因此，反射通过重新链接和浪费 CPU 时间而导致许多不必要的成本。</p>
<p>为了解决这些问题（以及其他问题），Java 7 引入了一个新的 API，即 <code>java.lang.invoke</code>，由于它引入的主类的名称，通常将其称为<em>方法句柄 (method handles)</em>。</p>
<p>方法句柄（MH）是 Java 版本的类型安全的函数指针。类似于 Java 反射中的 Method 对象。MH 具有实际上与反射执行底层方法相同的 <code>invoke()</code> 方法。</p>
<p>一方面，MH 实际上只是一种更有效的反射机制，它更接近本质。反射 API 中由对象表示的任何内容都可以转换为等效的 MH。例如，可以使用 <code>Lookup.unreflect(Method m)</code> 将反射方法对象转换为 MH。创建的 MH 通常是访问基础方法的更有效方法。</p>
<p>可以通过 <code>MethodHandles</code> 类中的静态辅助方法以多种方式来修改 MH，例如通过组合和方法参数的部分绑定（柯理化），它还提供了一个静态的查询工厂类用于构建方法句柄。</p>
<p>通常，方法链接需要类型描述符的精确匹配。但是，MH 上 的 <code>invoke()</code> 方法具有特殊的多态签名，无论调用的方法的签名如何，都允许进行链接。</p>
<p>在运行时，<code>invoke()</code> 调用站点上的签名应该看起来和你正在直接调用引用的方法一样，这避免了反射调用通常会发生的类型转换和自动装箱成本。</p>
<p>由于 Java 是一种静态类型的语言，因此出现了一个问题，即当使用这种动态的机制时，可以保留多少类型安全性。MH API 通过使用一种称为 <code>MethodType</code> 的类型来解决此问题，该类型是方法采用的参数的不可变表示：<strong>方法的签名</strong>。</p>
<p>MH 的内部实现在 Java 8 的生命周期内进行了更改。新的实现称为 lambda 形式，<strong>它提供了显着的性能提升，现在 MH 在许多用例中都比反射更好。</strong></p>
<h2 id="Bootstrapping">Bootstrapping</h2>
<p>字节码指令流中<strong>第一次</strong>遇到每个特定的 <code>invokedynamic</code> 调用站点时，JVM 不知道它的目标是哪个方法。实际上，没有与该指令关联的调用站点对象。</p>
<p>调用站点需要被*引导（bootstrapped）*来完成链接，并且 JVM 通过运行引导方法 <code>bootstrap method（BSM）</code>生成并返回调用站点对象来实现此目的。</p>
<p>每个 <code>invokedynamic</code> 调用站点都有与其关联的 BSM，该 BSM 存储在类文件的单独区域中。这些方法允许用户代码在运行时以编程方式确定链接。</p>
<p>链接首先解析引导方法的常量池条目，并解析动态调用站点的类型描述符的 <code>MethodType</code> 对象。此解析过程可能会触发类加载。因此，如果类加载失败，它可能会引发错误。链接不会触发类初始化。</p>
<p>反编译 <code>invokedynamic</code> 调用（例如我在 Runnable 的原始示例中的调用）表明它具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: invokedynamic #2,  0</span><br></pre></td></tr></table></figure>
<p>在类文件的常量池中，请注意，条目 <code>#2</code> 是类型 <code>CONSTANT_InvokeDynamic</code> 的常量。常量池的相关部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#2 = InvokeDynamic      #0:#31</span><br><span class="line">   ...</span><br><span class="line">  #31 = NameAndType        #46:#47        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #46 = Utf8               run</span><br><span class="line">  #47 = Utf8               ()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure>
<p>常数中存在 0 是一个提示。常量池条目从 1 开始编号，因此 0 会提醒您实际的 BSM 位于类文件的另一部分。</p>
<p>对于 lambda，<code>NameAndType</code> 条目采用特殊形式。名称是任意的，但是类型签名包含一些有用的信息。</p>
<p>返回类型对应于 <code>invokedynamic</code> 工厂的返回类型。它是 lambda 表达式的目标类型。同样，参数列表由 lambda 捕获的元素类型组成。对于无状态 lambda，返回类型将始终为空。只有 Java 闭包才会有参数存在。</p>
<p>BSM 至少需要接受三个参数并返回 <code>CallSite</code>。标准参数是以下类型：</p>
<ul>
<li><code>MethodHandles.Lookup</code>：发生调用站点的类上的查找对象</li>
<li><code>String</code>: <code>NameAndType</code> 中提到的名称</li>
<li><code>MethodType</code>：<code>NameAndType</code> 中的已解析类型描述符</li>
</ul>
<p>除了这几个参数，后面的参数是 BSM 所需的任何其他参数。这些在文档中称为附加静态参数。</p>
<p>BSM 的普遍用例允许一种非常灵活的机制，非 Java 语言实现者可以使用这种机制。但是，Java 语言没有提供用于生成任意 <code>invokedynamic</code> 调用站点的语言级别的构造。</p>
<p>对于 lambda 表达式，BSM 采用一种特殊形式，为了充分理解该机制的工作原理，我将对其进行更仔细的研究。</p>
<h2 id="解码-lambda-的-bootstrap-方法">解码 lambda 的 bootstrap 方法</h2>
<p>对 <code>javap</code> 使用 <code>-v</code> 参数可查看引导程序方法。这是必需的，因为引导程序方法位于类文件的特殊部分中，并且将引用返回到主常量池中。对于这个简单的 <code>Runnable</code> 示例，它有一个引导程序方法（BSM）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line">  0: #28 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:</span><br><span class="line">        (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;</span><br><span class="line">         Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;</span><br><span class="line">         Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #29 ()V</span><br><span class="line">      #30 REF_invokeStatic LambdaExample.lambda$main$0:()V</span><br><span class="line">      #29 ()V</span><br></pre></td></tr></table></figure>
<p>有点难以理解，所以让我们对其进行解码。</p>
<p>此调用站点的引导方法是常量池中的条目 <code>#28</code>。这是 <code>MethodHandle</code> 类型的条目（一种常量池类型，已在 Java 7 中添加到标准中）。现在，将其与字符串函数示例的情况进行比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: #27 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:</span><br><span class="line">        (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;</span><br><span class="line">         Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;</span><br><span class="line">         Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #28 (Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      #29 REF_invokeStatic StringFunction.lambda$static$0:(Ljava/lang/String;)Ljava/lang/Integer;</span><br><span class="line">      #30 (Ljava/lang/String;)Ljava/lang/Integer;</span><br></pre></td></tr></table></figure>
<p>将用作 BSM 的方法句柄与静态方法 <code>LambdaMetafactory.metafactory(...)</code> 相同。</p>
<p>更改的部分是方法参数。这些是 lambda 表达式的附加静态参数，其中有三个。它们代表了 lambda 的签名以及 lambda 实际最终调用目标的方法句柄：lambda 主体。第三个静态参数是签名的擦除形式。</p>
<p>让我们将代码跟随到 <code>java.lang.invoke</code> 中，看看平台如何使用 <em>metafactories</em> 来动态实际实现 lambda 表达式目标类型的类。</p>
<h2 id="The-lambda-metafactories">The lambda metafactories</h2>
<p>在 lambda 表达式将被捕获的点上，它会生成一个 <code>invokedynamic</code> 调用站点，该站点在被调用时返回 lambda 正在转换为的函数接口的实例。此调用站点称为给定 lambda 的 <em>lambda 工厂</em>。lambda 工厂的动态参数是从词法作用域中捕获的值。lambda 工厂的 bootstrap 方法是 Java 语言运行库中的标准化方法，称为 <em>lambda 元工厂</em>。静态引导程序参数在编译时捕获有关 lambda 的已知信息（它将被转换为的功能接口、脱糖 lambda 主体的方法句柄、有关 SAM 类型是否可序列化的信息等）。</p>
<p>BSM 对此静态方法进行调用，该方法最终<strong>返回调用站点对象</strong>。当执行 <code>invokedynamic</code> 指令时，调用站点（Call Site）中包含的方法句柄（Method Handle）将返回一个实现 lambda 目标类型的类的实例。</p>
<p>lambda 元工厂 metafactory 方法的源代码相对简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title function_">metafactory</span><span class="params">(MethodHandles.Lookup caller,</span></span><br><span class="line"><span class="params">                                       String invokedName,</span></span><br><span class="line"><span class="params">                                       MethodType invokedType,</span></span><br><span class="line"><span class="params">                                       MethodType samMethodType,</span></span><br><span class="line"><span class="params">                                       MethodHandle implMethod,</span></span><br><span class="line"><span class="params">                                       MethodType instantiatedMethodType)</span></span><br><span class="line">            <span class="keyword">throws</span> LambdaConversionException &#123;</span><br><span class="line">        AbstractValidatingLambdaMetafactory mf;</span><br><span class="line">        mf = <span class="keyword">new</span> <span class="title class_">InnerClassLambdaMetafactory</span>(caller, invokedType,</span><br><span class="line">                                             invokedName, samMethodType,</span><br><span class="line">                                             implMethod, instantiatedMethodType,</span><br><span class="line">                                             <span class="literal">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class="line">        mf.validateMetafactoryArgs();</span><br><span class="line">        <span class="keyword">return</span> mf.buildCallSite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找对象对应于 <code>invokedynamic</code> 指令所在的上下文。在这种情况下，就是定义 lambda 的同一个类，因此查找上下文将具有访问 lambda 主体编译成的私有方法的正确权限。</p>
<p>调用的名称和类型由 VM 提供，并且是实现的详细信息。最后三个参数是 BSM 的其他静态参数。</p>
<p>在当前的实现中，<code>metafactory</code> 将代码委派给使用 <a target="_blank" rel="noopener" href="https://asm.ow2.io/?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991">ASM 字节码库</a>的内部拷贝的代码，以编织实现目标类型的内部类。</p>
<p>如果 lambda 没有从其封闭范围中捕获任何参数，则结果对象是无状态的，因此该实现可通过预先计算单个实例来进行优化 - 有效地将 lambda 的实现类设为单例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">jshell&gt; </span><span class="language-bash">Function&lt;String, Integer&gt; <span class="function"><span class="title">makeFn</span></span>() &#123;</span></span><br><span class="line">   ...&gt;   return s -&gt; s.length();</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  created method makeFn()</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">jshell&gt; </span><span class="language-bash">var f1 = makeFn();</span></span><br><span class="line">f1 ==&gt; $Lambda$27/0x0000000800b8f440@533ddba</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">jshell&gt; </span><span class="language-bash">var f2 = makeFn();</span></span><br><span class="line">f2 ==&gt; $Lambda$27/0x0000000800b8f440@533ddba</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">jshell&gt; </span><span class="language-bash">var f3 = makeFn();</span></span><br><span class="line">f3 ==&gt; $Lambda$27/0x0000000800b8f440@533ddba</span><br></pre></td></tr></table></figure>
<p>这是文档强烈劝阻 Java 程序员不要依赖任何形式的 lambda 身份语义的原因之一。</p>
<h2 id="翻译策略">翻译策略</h2>
<p>我们可以通过多种方式在字节码中表示 lambda 表达式，例如内部类、方法句柄、动态代理等。这些方法中的每一种都有优点和缺点。在选择策略时，有两个相互竞争的目标：通过不承诺特定策略来最大化未来优化的灵活性，以及在类文件表示中提供稳定性。我们可以通过使用 <a target="_blank" rel="noopener" href="http://jcp.org/en/jsr/detail?id=292">JSR 292</a> 的 <code>invokedynamic</code> 特性来实现这两个目标将字节码中 lambda 创建的二进制表示与在运行时评估 lambda 表达式的机制分开。我们没有生成字节码来创建实现 lambda 表达式的对象（例如调用内部类的构造函数），而是描述了构造 lambda 的方法，并将实际构造委托给语言运行时。该配方被编码在 <code>invokedynamic</code> 指令的静态和动态参数列表中。</p>
<p><code>invokedynamic</code> 的使用让我们将翻译策略的选择推迟到运行时。运行时实现可以自由地动态选择策略来评估 lambda 表达式。运行时实现选择隐藏在用于 lambda 构造的标准化（即平台规范的一部分）API 之后，以便静态编译器可以发出对该 API 的调用，并且 JRE 实现可以选择其首选的实现策略。该 <code>invokedynamic</code> 机制允许在没有这种后期绑定方法可能强加的性能成本的情况下完成此操作。</p>
<h2 id="总结-7">总结</h2>
<p>一旦 JVM 第一次看到 <code>invokedynamic</code>，它就会调用 <code>bootstrap</code> 引导方法，该引导方法告诉调用指令真正调用的方法类型是什么，如何查找该方法等。有了这些信息，我们就可以在<strong>运行时</strong>动态的链接到该调用方法，链接行为发生在 <code>CallSite</code> 上，并返回去做真正调用处理的 <code>MH</code>。</p>
<p>在撰写本文时，lambda bootstrap 方法将使用 <code>metafactory</code> 的 <code>InnerClassLambdaMetafactory</code> 在运行时使用 <code>ASM</code> 字节码操作库为 lambda 生成内部类，然后 <code>bootstrap</code> 方法将生成的内部类封装在称为 <code>ConstantCallSite</code> 的特殊类型的 <code>CallSite</code> 中，<code>CallSite</code> 的 target <code>MethodHandle</code> 将返回一个实现 lambda 目标类型的类的实例。这种类型的 <code>CallSite</code> 在设置后永远不会改变。因此，在对每个 lambda 进行首次链接后，JVM 将始终使用快速路径直接调用 lambda 实例逻辑。</p>
<p><img data-src="../../../images/java/stream/lambda-invokedynamic.svg" alt="img"></p>
<p>尽管这是最有效的 <code>invokedynamic</code> 类型，但它肯定不是唯一可用的选项。事实上，Java 提供了 <code>MutableCallSite</code> 和 <code>VolatileCallSite</code> 来适应更多的动态需求。</p>
<h2 id="结束">结束</h2>
<p>本文探讨了 JVM 如何实现对 lambda 表达式的支持的详细细节。这是您将要遇到的更复杂的平台功能之一，因为它深入到语言实现者的领域。</p>
<p>一路上，我讨论了 <code>invokedynamic</code> 和方法句柄 API。这是现代 JVM 平台的主要部分的两项关键技术。这两种机制都在整个生态系统中得到了越来越多的使用。例如，在 Java 9 及更高版本中，<code>invokedynamic</code> 已用于实现新形式的字符串连接。</p>
<p>了解这些功能可以使您深入了解 Java 应用程序所依赖的平台和现代框架的最深层运作。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blogs.oracle.com/javamagazine/behind-the-scenes-how-do-lambda-expressions-really-work-in-java?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991&amp;elq_mid=178066&amp;sh=01220926150119261320312809260905&amp;cmid=WWMK200429P00043C0012">Behind the scenes: How do lambda expressions really work in Java?</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lambda</tag>
        <tag>invokedynamic</tag>
        <tag>CallSite</tag>
        <tag>MethodHandle</tag>
        <tag>BootstrapMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Object 由内及外</title>
    <url>/java/jvm/Java-Object-%E7%94%B1%E5%86%85%E5%8F%8A%E5%A4%96/</url>
    <content><![CDATA[<h2 id="1-引言">1. 引言</h2>
<p>Java 对象需要占用多少内存，这是一个经常被提及的问题。在缺少 <code>sizeof</code> 运算符的情况下，人们不禁想知道代码对其占用空间的影响。在本文中，我们将尝试窥视 Java 对象内部并查看其背后的内容。</p>
<h2 id="2-探讨更深入的设计与实现方面的问题">2. 探讨更深入的设计与实现方面的问题</h2>
<p>Deeper Design and Implementation Questions (DDIQ)，在某些章节中，您可能会看到其中包含有关设计/实现问题的更多讨论。这些并不能保证回答所有问题，但他们确实尝试回答最常见的问题。答案基于个人的理解，因此可能是不准确，不完整或两者兼而有之。</p>
<span id="more"></span>
<h2 id="3-方法论考虑">3. 方法论考虑</h2>
<p>这篇文章针对 <code>Hotspot JVM</code>，OpenJDK 及其衍生版本的默认 JVM。如果你不知道运行的是哪种 JVM，则很可能就是 <code>Hotspot</code>。</p>
<h3 id="3-1-工具">3.1 工具</h3>
<p>为了正确地做到这一点，我们需要工具。当我们分析工具时，重要的是要了解工具可以做什么和不能做什么。</p>
<ol>
<li>
<p><strong>堆转储</strong>。转储 Java 堆并检查它可能很诱人。这似乎取决于以下信念：堆转储是运行时堆的低级表示。不幸的是，事实并非如此：它是从实际的 Java 堆重构而来的幻视。如果查看 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF 数据格式</a>，您将看到它实际上是多么高级：它没有谈论字段偏移，也没有直接告诉标头任何东西，唯一的安慰就是那里的对象大小，<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8005604">这也是一个谎言</a>。堆转储非常适合检查对象的整个视图及其内部连接，但用来检查对象本身太粗略了。</p>
</li>
<li>
<p><strong>通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/ThreadMXBean.html"><code>MXBeans</code></a> 测量可用或已分配的内存</strong>。我们当然可以分配多个对象，并查看它们占用了多少内存。分配足够的对象后，我们可以消除由 <code>TLAB 分配</code>（及其退役），后台线程中的虚假分配等导致的异常值。但是，这并不能使我们在查看对象内部时有任何保真度：我们只能观察到对象的外观大小。这是进行研究的一种好方法，但是您需要正确地制定和测试假设，以得出能够解释每个结果的明智的对象模型。</p>
</li>
<li>
<p><strong>诊断 JVM 标志</strong>。因为 JVM 本身负责创建对象，所以可以肯定它知道对象的布局，而且我们“仅”需要从那里得到它。 <code>-XX：+ PrintFieldLayout</code> 可以很容易的实现。不幸的是，该标志仅在 <code>debug JVM 版本</code>下可用。</p>
</li>
<li>
<p><strong>深入对象内部的工具</strong>。幸运的是，使用 <code>Class.getDeclaredFields</code> 并询问 <code>Unsafe.objectFieldOffset</code> 可以使您知道字段所在的位置。这涉及到多个注意事项：首先，它使用反射功能侵入了大多数类，可能会被禁止使用；第二，<code>Unsafe.objectFieldOffset</code> 不会正式回答偏移量，而是一些 “cookie”，可以将其传递给其他 Unsafe 方法来使用。也就是说，它“通常是有效的”，因此，除非我们做至关重要的事情时才可以使用它侵入代码。某些工具（尤其是 <a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/code-tools/jol/"><code>JOL</code></a> ）可以为我们做到这一点。</p>
</li>
</ol>
<p>在本文中，我们将使用 <code>JOL</code>，因为我们希望看到 Java 对象的更精细的结构。对于我们的需求，使用 <code>JOL-CLI</code> 可执行 jar 包更合适，可以在这里找到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">wget https://repo.maven.apache.org/maven2/org/openjdk/jol/jol-cli/0.10/jol-cli-0.10-full.jar -O jol-cli.jar</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">java -jar jol-cli.jar</span></span><br><span class="line">Usage: jol-cli.jar &lt;mode&gt; [optional arguments]*</span><br><span class="line"></span><br><span class="line">Available modes:</span><br><span class="line">   internals: Show the object internals: field layout and default contents, object header</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对于对象目标，我们将尽可能尝试使用各种 JDK 类本身。这样可以轻松验证整个过程，因为您只需要 JOL CLI JAR 和您喜欢的 JDK 安装即可运行测试。在更复杂的情况下，我们将转到 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/">JOL 示例</a>，其中涵盖了此处的一些内容。作为最后的说明手段，我们将使用其它示例类。</p>
<blockquote>
<p>JOL 实例中的代码已经演示了大部分情景，可以自己动手运行并查看这些代码。</p>
</blockquote>
<h3 id="3-2-JDKs">3.2 JDKs</h3>
<p>JDK 8 仍然是世界上部署最广泛的 JDK 版本。因此，我们也会在这里使用它。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">java -version</span></span><br><span class="line">openjdk version &quot;1.8.0_252&quot;</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_252-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.252-b09, mixed mode)</span><br></pre></td></tr></table></figure>
<h2 id="4-数据类型及其表示">4. 数据类型及其表示</h2>
<p>我们需要从一些基础知识开始。在几乎每个 JOL “内部”运行中，您都会看到以下输出（为简便起见，在以后的调用中将省略此输出）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -jar jol-cli.jar internals java.lang.Object</span></span><br><span class="line">...</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Field sizes by <span class="built_in">type</span>: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br></pre></td></tr></table></figure>
<p>这意味着 Java 引用占用 4 个字节（启用<a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/23-compressed-references/">指针压缩</a>），<code>boolean</code> / <code>byte</code> 占用 1 个字节，<code>char</code> / <code>short</code> 占用 2 个字节，<code>int</code> / <code>float</code> 占用 4 个字节，<code>double</code> / <code>long</code> 占用 8 个字节。当作为数组元素呈现时，它们占据相同的空间。</p>
<p>为什么这很重要？因为 Java 语言规范没有说明有关数据表示的任何内容，仅说明了这些类型接受的值。原则上，可以为所有原语分配 8 个字节，只要对它们的存储范围超过其规范即可。在当前的 Hotspot 中，除 <code>boolean</code> 外，几乎所有数据类型都与它们的值域完全匹配。例如，指定为支持 <code>int</code> 从 <code>-2147483648</code> 到 <code>2147483647</code> 的值，该值正好适合 4 字节带符号的表示形式。</p>
<p>如上所述，有一个奇怪的地方，那就是 <code>boolean</code>。原则上，其值域仅包含两个值：<code>true</code> 和 <code>false</code>，因此可以用 1 位表示。所有 <code>boolean</code> 字段和数组元素仍然占据 1 个完整字节，这有两个原因：Java 内存模型保证了对于单个字段/元素不存在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.6">单词撕裂</a>的情况，这对于 1 位布尔字段来说很难做到，并且字段偏移量以字节为单位进行内存寻址，这使得寻址布尔型字段很尴尬。因此，这里每个布尔值占用 1 个字节是一个实际的折衷方案。</p>
<h2 id="5-Mark-Word（标记信息）">5. Mark Word（标记信息）</h2>
<p>回到实际的对象结构。让我们从最基本的 <code>java.lang.Object</code> 示例开始。 JOL 将打印此：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/java -jar jol-cli.jar internals java.lang.Object</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Objects are 8 bytes aligned.</span></span><br><span class="line"></span><br><span class="line">Instantiated the sample instance via default constructor.</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      0     4        (object header)              01 00 00 00 # Mark word</span><br><span class="line">      4     4        (object header)              00 00 00 00 # Mark word</span><br><span class="line">      8     4        (object header)              00 10 00 00 # (not mark word)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>它显示前 12 个字节是对象头。不幸的是，它没有更详细地解析其内部结构，因此，我们需要深入研究 Hotspot 源代码以弄清楚这一点。在这里，你会注意到对象头<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/oop.hpp#l52">包括两部分</a>：<em><code>mark word</code> 和 <code>class word</code></em>。Class word 包含对象类型的信息：它链接到描述该类的本机结构。我们将在下一节中讨论这一部分。其余的元数据保存在 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/markWord.hpp#l33">mark word</a> 中。</p>
<p><img data-src="../../../images/java/jvm/object-memory-layout.png" alt="Object Memory Layout"></p>
<p>mark word 有多种用途：</p>
<ol>
<li>存储用于 GC 的元数据（分代年龄和转发数据）</li>
<li>存储身份标识 hash code</li>
<li>存储锁标志位信息</li>
</ol>
<p>请注意，每个对象都必须有一个 mark word，因为它处理每个 Java 对象特有的事物。</p>
<h3 id="5-1-存储用于-GC-的转发数据">5.1 存储用于 GC 的转发数据</h3>
<p>GC 需要移动对象时，它们至少需要临时记录对象的新位置。mark word 将对此进行编码，以用于 GC 代码，以协调重定位和更新引用工作。这会将 mark word 锁定为与 Java 引用一样宽。GC 转发数据在 mark word 中实现所需要的最小内存量：32 位平台为 4 字节，而 64 位平台为 8 字节。</p>
<p>不幸的是，我们无法显示展示来自 Java 应用程序（而 JOL 是 Java 应用程序）进行 GC 转发的 mark word，因为要么在我们取消阻止 full GC 时就已经消失了。要么并发 GC 障碍阻止我们看到旧对象。</p>
<h3 id="5-2-存储-GC-分代年龄">5.2 存储 GC 分代年龄</h3>
<p>但是，我们可以演示对象分代年龄位！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-32/bin/java -<span class="built_in">cp</span> jol-samples.jar org.openjdk.jol.samples.JOLSample_19_Promotion</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 32-bit HotSpot VM.</span></span><br><span class="line"></span><br><span class="line">Fresh object is at d2d6c0f8</span><br><span class="line">*** Move  1, object is at d31104a0</span><br><span class="line">  (object header)  09 00 00 00 (00001001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  2, object is at d3398028</span><br><span class="line">  (object header)  11 00 00 00 (00010001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  3, object is at d3109688</span><br><span class="line">  (object header)  19 00 00 00 (00011001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  4, object is at d43c9250</span><br><span class="line">  (object header)  21 00 00 00 (00100001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  5, object is at d41453f0</span><br><span class="line">  (object header)  29 00 00 00 (00101001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  6, object is at d6350028</span><br><span class="line">  (object header)  31 00 00 00 (00110001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  7, object is at a760b638</span><br><span class="line">  (object header)  31 00 00 00 (00110001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br></pre></td></tr></table></figure>
<p>请注意，每一步移动都是如何向上计数的。那就是记录的对象年龄。奇怪的是，经过 7 次移动后，它在第 6 次停止。这是由于 <code>InitialTenuringThreshold = 7</code> 的默认设置。如果增加该值，则该对象将经历更多的移动，直到到达老年代为止。默认最多移动 15 次（1111），可以修改参数 <code>-XX:MaxTenuringThreshold</code> 调小。</p>
<h3 id="5-3-身份标识信息">5.3 身份标识信息</h3>
<p>每个 Java 对象都有一个<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--">哈希码</a>。如果用户没有为其定义，则使用*<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#identityHashCode-java.lang.Object-">身份哈希码</a>*。由于身份哈希码在为给定对象计算后不应更改，因此我们需要将其存储在某个位置。在 Hotspot 中，它直接存储在目标对象的 <code>mark word</code> 中。根据身份哈希码接受的精度，可能需要多达 4 个字节来存储。</p>
<blockquote>
<p><strong>DDIQ：当我们也需要存储 GC 转发数据时，该如何工作？</strong></p>
<p>答案很狡猾：当 GC 移动对象时，它实际上处理对象的两个副本，一个在旧位置，一个在新位置。新对象带有所有原始头信息。旧对象仅用于满足 GC 需求，因此我们可以使用 GC 元数据覆盖旧对象头信息。</p>
</blockquote>
<blockquote>
<p><strong>DDIQ：为什么我们需要存储身份哈希码？这如何影响用户指定的哈希码？</strong></p>
<p>哈希码应该具有两个属性：a) 良好的散列分布，这意味着不同对象的值或多或少是不同的；b) 幂等，意味着具有相同关键对象组件的对象具有相同的哈希码。注意后者暗示如果对象没有更改那些关键对象组件，则其哈希码也不应更改。</p>
<p>对于身份哈希码，无法保证是否<em>存在</em>用于计算哈希码的字段，即使我们有一些字段，也无法得知这些字段的实际稳定性。考虑一下没有字段的 <code>java.lang.Object</code>：它的哈希码是什么？分配的两个对象几乎是彼此的镜像：它们具有相同的元数据，它们具有相同（即空）的内容。关于它们的唯一区别是分配的地址，但是即使那样，仍然有两个麻烦。第一，地址具有非常低的熵，尤其是像大多数 Java GC 所采用的那样，是来自 bump-ptr 分配器，因此它的分布不均。其次，GC 会移动对象，因此地址不是幂等的。从性能的角度来看，返回恒定值也是行不通的。</p>
<p>因此，当前的实现从内部 PRNG（“良好分布”）计算身份哈希码，并为每个对象存储它（“幂等”）。</p>
</blockquote>
<p>可以通过相关的 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_15_IdentityHashCode.java#l41">JOLSample_15_IdentityHashCode</a> 清楚地看到由身份哈希码引起的 mark word 变化。使用 64 位 VM 运行它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -<span class="built_in">cp</span> jol-samples.jar org.openjdk.jol.samples.JOLSample_15_IdentityHashCode</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_15_IdentityHashCode$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION              VALUE</span><br><span class="line">      0     4        (object header)          01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)          00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)          97 ef 00 f8 (10010111 11101111 00000000 11111000) (-134156393)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">hashCode: 2f333739</span><br><span class="line"></span><br><span class="line">**** After identityHashCode()</span><br><span class="line">org.openjdk.jol.samples.JOLSample_15_IdentityHashCode$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION              VALUE</span><br><span class="line">      0     4        (object header)          01 39 37 33 (00000001 00111001 00110111 00110011) (859257089)</span><br><span class="line">      4     4        (object header)          2f 00 00 00 (00101111 00000000 00000000 00000000) (47)</span><br><span class="line">      8     4        (object header)          97 ef 00 f8 (10010111 11101111 00000000 11111000) (-134156393)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>请注意，哈希码值为 <code>2f333739</code>。计算机内部为小端字节序，<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html">低位字节在前，高位字节在后</a>，可以使用代码 <code>ByteOrder.nativeOrder()</code> 查看系统机器字节序。你现在可以在对象头中找到它的十六进制：<code>01 39 37 33 2f</code>。 <code>01</code> 是 mark word 标记，其余是用 little-endian 小端字节序编写的身份哈希码。而且，我们还有 3 个字节的备用空间！</p>
<h3 id="5-4-锁信息">5.4 锁信息</h3>
<p>Java 同步采用了<a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">复杂的状态机</a>。由于每个 Java 对象都可以使用 <code>synchronized</code>，因此锁定状态应与任何 Java 对象相关联。mark word 维护了大部分状态。</p>
<p>这些锁定转换的不同部分可以在对象头中看到。例如，当 Java 锁定偏向特定线程时，我们需要在相关对象附近记录有关该偏向锁 (Biased Lock) 的信息。这由相关的 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_13_BiasedLocking.java#l41">JOLSample_13_BiasedLocking</a> 示例演示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -<span class="built_in">cp</span> jol-samples.jar org.openjdk.jol.samples.JOLSample_13_BiasedLocking</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_13_BiasedLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           05 00 00 00 (00000101 00000000 00000000 00000000)  # 无锁</span><br><span class="line">      4     4        (object header)           00 00 00 00</span><br><span class="line">      8     4        (object header)           c0 07 08 00</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_13_BiasedLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           05 b0 00 80 (00000101 11010000 00000000 01111011) # 偏向锁</span><br><span class="line">      4     4        (object header)           b8 7f 00 00  # 偏向锁</span><br><span class="line">      8     4        (object header)           c0 07 08 00</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_13_BiasedLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           05 b0 00 80 (00000101 11010000 00000000 01111011) # 偏向锁</span><br><span class="line">      4     4        (object header)           b8 7f 00 00 # 偏向锁</span><br><span class="line">      8     4        (object header)           c0 07 08 00</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>偏向锁指向线程的本地指针：<code>b0 00 80 b8 7f</code>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://openjdk.java.net/jeps/374">JEP 374</a> 提案废除和禁用偏向锁，该提案在 JDK 15 及后续版本已经生效。</p>
<p>偏置锁定是 HotSpot 虚拟机中使用的一种优化技术，用于减少无竞争锁定的开销。它旨在避免在获取监视器时执行比较和交换原子操作，方法是假设监视器一直归给定线程所有，直到不同的线程尝试获取它。监视器的初始锁定使监视器<em>偏向</em>该线程，从而避免在对同一对象的后续同步操作中需要原子指令。当许多线程对以单线程方式使用的对象执行许多同步操作时，与常规锁定技术相比，偏置锁历来会导致显着的性能改进。</p>
<p>过去看到的性能提升今天远没有那么明显。许多受益于偏向锁定的应用程序是使用早期 Java 集合 API 的较旧的遗留应用程序，这些 API 在每次访问时使用同步（例如，<code>Hashtable</code> 和 <code>Vector</code>）。较新的应用程序通常使用非同步集合（例如，<code>HashMap</code> 和 <code>ArrayList</code>)，在  Java 1.2 中引入用于单线程场景，或者在 Java 5 中引入用于多线程场景的更高性能的并发数据结构。这意味着如果更新代码以使用这些较新的类，由于不必要的同步而受益于偏向锁定的应用程序可能会看到性能改进。此外，围绕线程池队列和工作线程构建的应用程序通常在禁用偏置锁定的情况下性能更好。偏向锁定带来了在争用情况下需要昂贵的撤销操作的成本。因此，受益于它的应用程序只有那些表现出大量无竞争同步操作的应用程序，如上面提到的那些。</p>
<p>偏向锁定在同步子系统中引入了大量复杂的代码，并且对其他 HotSpot 组件也有侵入性。这种复杂性是理解代码各个部分的障碍，也是在同步子系统内进行重大设计更改的障碍。为此，我们希望禁用、弃用并最终删除对偏向锁定的支持。</p>
</blockquote>
<p>没有偏向的情况下锁定时，会发生 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_14_FatLocking.java#l41">JOLSample_14_FatLocking</a> 如下锁升级情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -<span class="built_in">cp</span> jol-samples.jar org.openjdk.jol.samples.JOLSample_14_FatLocking</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        01 00 00 00 (00000001 00000000 00000000 00000000) # 无锁</span><br><span class="line">      4     4        (object header)        00 00 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** Before the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        58 29 ad 04 (01011000 00101001 10101101 00000100) # 轻量级锁</span><br><span class="line">      4     4        (object header)        00 70 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        4a c1 80 e1 (01001010 11000001 10000000 11100001) # 重量级锁</span><br><span class="line">      4     4        (object header)        f6 7f 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        4a c1 80 e1 (01001010 11000001 10000000 11100001) # 重量级锁</span><br><span class="line">      4     4        (object header)        f6 7f 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After System.gc()</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION             VALUE</span><br><span class="line">      0     4        (object header)         09 00 00 00 (00001001 00000000 00000000 00000000) # 锁释放</span><br><span class="line">      4     4        (object header)         00 00 00 00</span><br><span class="line">      8     4        (object header)         5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>各种情况下锁结构如下：</p>
<p><img data-src="../../../images/java/jvm/lock.png" alt="Mark Word Lock"></p>
<p>在这里，我们看到了锁的通常升级过程：首先对象未记录任何锁信息，然后被其他线程获取，并升级为轻量级锁，然后主线程争用它，锁发生膨胀，升级为重量级锁，<strong>然后在线程释放锁后，锁定信息仍保持为重量级锁。最后，在 GC 时的安全点后，对象恢复为无锁状态。</strong></p>
<p><img data-src="../../../images/java/jvm/lock-upgrade.png" alt="Java 锁升级"></p>
<h3 id="5-5-观察：身份-Hashcode-禁用偏向锁">5.5 观察：身份 Hashcode 禁用偏向锁</h3>
<p>但是，如果我们需要在偏向锁定生效时存储身份哈希码，该怎么办？很简单：身份哈希码优先，并且对该对象/类的偏向锁定被禁用。可以从相关示例 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_26_IHC_BL_Conflict.java">JOLSample_26_IHC_BL_Conflict</a> 中看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -<span class="built_in">cp</span> jol-samples.jar org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                 VALUE</span><br><span class="line">      0     4        (object header)             05 00 00 00 (00000101 00000000 00000000 00000000) # No lock</span><br><span class="line">      4     4        (object header)             00 00 00 00 (00000000 00000000 00000000 00000000)</span><br><span class="line">      8     4        (object header)             5a ef 00 f8 (01011010 11101111 00000000 11111000)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                VALUE</span><br><span class="line">      0     4        (object header)            05 e0 80 c7 (00000101 11100000 10000000 11000111) # Biased lock</span><br><span class="line">      4     4        (object header)            f7 7f 00 00 (11110111 01111111 00000000 00000000) # Biased lock</span><br><span class="line">      8     4        (object header)            5a ef 00 f8 (01011010 11101111 00000000 11111000)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                VALUE</span><br><span class="line">      0     4        (object header)            05 e0 80 c7 (00000101 11100000 10000000 11000111) # Biased lock</span><br><span class="line">      4     4        (object header)            f7 7f 00 00 (11110111 01111111 00000000 00000000) # Biased lock</span><br><span class="line">      8     4        (object header)            5a ef 00 f8 (01011010 11101111 00000000 11111000)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">hashCode: 4cc77c2e</span><br><span class="line"></span><br><span class="line">**** After the hashcode</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           01 2e 7c c7 (00000001 00101110 01111100 11000111) # Hashcode</span><br><span class="line">      4     4        (object header)           4c 00 00 00 (01001100 00000000 00000000 00000000) # Hashcode</span><br><span class="line">      8     4        (object header)           5a ef 00 f8 (01011010 11101111 00000000 11111000) </span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the second lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION        		VALUE</span><br><span class="line">      0     4        (object header)    		80 59 9e 02 (10000000 01011001 10011110 00000010) # Lightweight lock</span><br><span class="line">      4     4        (object header)    		00 70 00 00 (00000000 01110000 00000000 00000000) # Lightweight lock</span><br><span class="line">      8     4        (object header)    		5a ef 00 f8 (01011010 11101111 00000000 11111000) </span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the second lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION              VALUE</span><br><span class="line">      0     4        (object header)          01 2e 7c c7 (00000001 00101110 01111100 11000111) # Hashcode</span><br><span class="line">      4     4        (object header)          4c 00 00 00 (01001100 00000000 00000000 00000000) # Hashcode</span><br><span class="line">      8     4        (object header)          5a ef 00 f8 (01011010 11101111 00000000 11111000) </span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>刚开始对象通过偏向锁定的宽限期后为无锁状态，可偏向（锁标记为 …101）。第一次进入代码同步块时，<strong>偏向锁通过 CAS 操作将线程 ID 置换到 mark word 中。在释放锁后，偏向锁仍然会保留在对象头中，以便于减少单个线程未竞争情况下时锁定和解锁的 CAS 操作。</strong></p>
<p>一旦我们调用了对象的 hashcode 方法，将触发 <code>identity hashcode</code> 的计算（我们的对象没有重写 <code>Object.hashcode</code>），<em><strong>偏向锁被撤销为无锁</strong></em>，线程 ID 置换为 hashcode。</p>
<p>第二次执行到方法对象同步时，由于存放了 hashcode，这时检查到为不可偏向的无锁标志，虚拟机会将当前的 <code>mark word</code> 备份到当前线程方法的栈桢的 <code>Lock Record</code> 中，并通过 <code>CAS</code> 操作将 <code>Lock Record</code> 指针更新到对象的 <code>mark word</code> 中，如果 CAS 操作成功，那么该线程就获取了该对象上的锁，并且对象的 mark word 锁标记变为 00，表示该对象处于轻量级锁状态。<strong>在代码退出同步块时，轻量级锁释放，再通过 CAS 操作把对象当前的 mark word 和线程中复制的替换回来。</strong></p>
<p><img data-src="../../../images/java/jvm/light-weight-lock-before-cas.png" alt="轻量级锁 CAS 操作之前堆栈与对象的状态"></p>
<p><img data-src="../../../images/java/jvm/light-weight-after-cas.png" alt="轻量级锁 CAS 操作之后堆栈与对象的状态"></p>
<h2 id="6-Class-Word">6. Class Word</h2>
<p>从机器的角度来看，每个对象只是一堆字节。在某些情况下，我们想知道在运行时处理的对象的<strong>类型</strong>是什么。需要的非详尽清单：</p>
<ul>
<li>运行时类型检查</li>
<li>确定对象的大小</li>
<li>找出虚拟/接口调用的目标。</li>
</ul>
<p>Class word 也可以被压缩。即使类指针不是 Java 堆引用，它们仍然可以享受类似的优化。</p>
<h3 id="6-1-运行时类型检查">6.1 运行时类型检查</h3>
<p>Java 是一门类型安全的语言，所以在很多地方都需要运行时类型检查。Class word 携带有关我们拥有的对象的实际类型的数据，这使编译器可以发出<em>运行时类型检查</em>。这些运行时检查的效率取决于元数据类型的形状。</p>
<p>如果元数据以简单的形式编码，则编译器甚至可以直接在代码流中内联那些检查。在 Hotspot 中，Class word 持有指向 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/oop.hpp#l57">VM <code>Klass</code> 实例的本机指针</a>(Klass Pointer)，该实例包含大量元信息，包括它<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/klass.hpp#l120">继承的超类的类型，实现的接口等</a>，它还带有 <em>Java 镜像</em> - <code>java.lang.Class</code> 的<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/klass.hpp#l138">关联实例</a>。这种间接方式允许将 <code>java.lang.Class</code> 实例视为常规对象，并在 GC 期间不更新每个 class word 的情况下移动它们：<code>java.lang.Class</code> 可以移动，而 <code>Klass</code> 始终保持在同一位置。</p>
<h3 id="6-2-确定对象大小">6.2 确定对象大小</h3>
<p>确定对象大小采用相似的方法。与运行时类型检查无法静态地知道对象的类型相比，分配确实或多或少地精确地知道了分配对象的大小：它由使用的构造函数的类型，使用的数组初始化器等定义。因此，在这些情况下，不需要通过 class word 进行访问。</p>
<p>但是，本机代码中有一些情况（最著名的是垃圾收集器）想要使用以下代码遍历<a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/5-tlabs-and-heap-parsability/">可解析堆</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HeapWord* cur = heap_start;</span><br><span class="line"><span class="keyword">while</span> (cur &lt; heap_used) &#123;</span><br><span class="line">  object o = (object)cur;</span><br><span class="line">  <span class="built_in">do_object</span>(o);</span><br><span class="line">  cur = cur + o-&gt;<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此，本机代码需要提前知道当前（未确定类型）object 的大小。因此，对于本机代码，如何安排类元数据非常重要。在 Hotspot 中，我们可以遍历 class word 访问<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/klass.hpp#l89">布局助手</a>，这将为我们提供有关对象大小的信息。</p>
<h3 id="6-3-找出虚方法-接口调用的目标">6.3 找出虚方法/接口调用的目标</h3>
<p>当运行时需要在对象实例上调用虚拟/接口方法时，它需要确定目标方法在哪里。虽然大多数时间<a target="_blank" rel="noopener" href="https://shipilev.net/blog/2015/black-magic-method-dispatch/">可以优化</a>，但在某些情况下，<a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/16-megamorphic-virtual-calls/">我们需要</a>进行实际的调度。该调度的性能还取决于类元数据的距离，因此不能忽略这一点。</p>
<h3 id="6-4-观察：压缩引用影响对象头文件">6.4 观察：压缩引用影响对象头文件</h3>
<p>与根据 JVM 位数观察 mark word 大小类似，我们也可以期待压缩引用模式会影响对象大小，<em>即使不涉及引用字段</em>。为了证明这一点，让我们在两个堆大小上使用 java.lang.Integer，小 (1 GB) 和大 (64 GB)。默认情况下，这些堆大小将分别打开和关闭压缩引用。这意味着默认情况下压缩类指针也是打开或关闭的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -Xmx1g -jar jol-cli.jar internals java.lang.Integer</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">Instantiated the sample instance via public java.lang.Integer(int)</span><br><span class="line"></span><br><span class="line">java.lang.Integer object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      0     4        (object header)              01 00 00 00 # Mark word</span><br><span class="line">      4     4        (object header)              00 00 00 00 # Mark word</span><br><span class="line">      8     4        (object header)              de 21 00 20 # Class word</span><br><span class="line">     12     4    int Integer.value                0</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">jdk8-64/bin/java -Xmx64g -jar jol-cli.jar internals java.lang.Integer</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Running 64-bit HotSpot VM.</span></span><br><span class="line"></span><br><span class="line">Instantiated the sample instance via public java.lang.Integer(int)</span><br><span class="line"></span><br><span class="line">java.lang.Integer object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      0     4        (object header)              01 00 00 00 # Mark word</span><br><span class="line">      4     4        (object header)              00 00 00 00 # Mark word</span><br><span class="line">      8     4        (object header)              40 69 25 ad # Class word</span><br><span class="line">     12     4        (object header)              e5 7f 00 00 # (uncompressed)</span><br><span class="line">     16     4    int Integer.value                0</span><br><span class="line">     20     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes # AHHHHHHH....</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>这里，在具有 1 GB 堆的 VM 中，对象头占用 8（mark word）+ 4（class word）= 12 个字节，而 64G VM 头占用 8（mark word）和 + 8（class word）= 16 个字节。如果没有字段，由于对象对齐方式为 8，两者都会四舍五入到 16 个字节。 但是，由于有一个 int 字段，在 64 GB 的情况下，我们需要将其分配超过 16 个字节，因此需要另外 8 个字节，总共占用 24 个字节。</p>
<h2 id="7-对象头：数组长度">7. 对象头：数组长度</h2>
<p>数组带有另一小部分元数据：数组长度。由于数组元素类型仅编码对象类型，因此我们需要将数组长度存储在其他位置。</p>
<p>可以通过相关的 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_25_ArrayAlignment.java#l41">JOLSample_25_ArrayAlignment</a> 查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ jdk8-<span class="number">64</span>/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_25_ArrayAlignment</span><br><span class="line"># Running <span class="number">64</span>-bit HotSpot VM.</span><br><span class="line"># Using compressed oop with <span class="number">3</span>-bit shift.</span><br><span class="line"># Using compressed klass with <span class="number">3</span>-bit shift.</span><br><span class="line"></span><br><span class="line">[J object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              d8 0c <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>   <span class="type">long</span> [J.&lt;elements&gt;                N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">0</span> bytes total</span><br><span class="line">                      </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>   <span class="type">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">0</span> bytes total</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">1</span>   <span class="type">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">     <span class="number">17</span>     <span class="number">7</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">7</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">7</span> bytes total</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">2</span>   <span class="type">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">     <span class="number">18</span>     <span class="number">6</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">6</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">6</span> bytes total</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">3</span>   <span class="type">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">     <span class="number">19</span>     <span class="number">5</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">5</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">5</span> bytes total</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              08 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   <span class="type">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> <span class="type">bytes</span> <span class="variable">external</span> <span class="operator">=</span> <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure>
<p>偏移 +12 处有一个插槽，用于承载数组长度。当我们分配 0…8 个元素的 byte[] 数组时，该插槽不断变化。将 arraylength 与数组实例一起携带有助于计算对象遍历器的实际大小，并且还可以进行有效的范围检查，以使数组长度非常接近。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shipilev.net/jvm/objects-inside-out/#_introduction"><em>原文链接</em></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Mark Word</tag>
        <tag>Class Word</tag>
        <tag>Klass</tag>
        <tag>GC 分代</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 存储引擎【翻译】</title>
    <url>/persistence/db/InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<blockquote>
<p>本文为 MySQL 8.0 官方文档 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">The InnoDB Storage Engine</a> 的部分翻译。</p>
</blockquote>
<h1>InnoDB 简介</h1>
<p>InnoDB 是一个兼顾高可靠性和高性能的通用存储引擎。在 MySQL 8.0 中，InnoDB 是默认的 MySQL 存储引擎。除非您配置了不同的默认存储引擎，否则发出不带 ENGINE 子句的 <code>CREATE TABLE</code> 语句默认会创建一个 InnoDB 表。</p>
<h2 id="InnoDB-的主要优势">InnoDB 的主要优势</h2>
<ul>
<li>它的 <code>DML(data manipulation language)</code> 操作遵循 <code>ACID</code> 模型，事务具有提交、回滚和崩溃恢复功能，以保护用户数据。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysql-acid.html">第 15.2 节，“InnoDB 和 ACID 模型”</a>。</li>
<li>行级锁定和 Oracle 风格的一致性读取提高了多用户并发性和性能。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html#:~:text=Section%C2%A015.7%2C%20%E2%80%9CInnoDB%20Locking%20and%20Transaction%20Model%E2%80%9D">第 15.7 节，“InnoDB 锁定和事务模型”</a>。</li>
<li>InnoDB 表将您的数据排列在磁盘上以优化基于主键的查询。每个 InnoDB 表都有一个称为聚集索引的主键索引，用于组织数据以最小化主键查找的 I/O。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html#:~:text=Section%C2%A015.6.2.1%2C%20%E2%80%9CClustered%20and%20Secondary%20Indexes%E2%80%9D">第 15.6.2.1 节，“聚集索引和二级索引”</a>。</li>
<li>为了保持数据完整性，InnoDB 支持外键 <code>FOREIGN KEY</code> 约束。使用外键检查插入、更新和删除以确保它们不会导致相关表之间的不一致。</li>
</ul>
<span id="more"></span>
<p><strong>Table InnoDB 存储引擎功能</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">是否支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>B-tree 索引</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">备份/基于时间点恢复（在服务端实现，而不是在存储引擎中。）</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>数据库集群支持</strong></td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left"><strong>聚集索引</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>压缩数据</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>数据缓存</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>加密数据</strong></td>
<td style="text-align:left">Yes (在服务器中通过加密函数实现；在 MySQL 5.7 及更高版本中，支持静态数据加密。)</td>
</tr>
<tr>
<td style="text-align:left"><strong>外键支持</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>全文检索索引</strong></td>
<td style="text-align:left">Yes (MySQL 5.6 及更高版本支持全文索引。)</td>
</tr>
<tr>
<td style="text-align:left"><strong>地理空间数据类型支持</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>地理空间索引支持</strong></td>
<td style="text-align:left">Yes (MySQL 5.7 及更高版本支持地理空间索引。)</td>
</tr>
<tr>
<td style="text-align:left"><strong>哈希索引</strong></td>
<td style="text-align:left">No (InnoDB 在内部利用哈希索引来实现其自适应哈希索引功能。)</td>
</tr>
<tr>
<td style="text-align:left"><strong>索引缓存</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>锁定粒度</strong></td>
<td style="text-align:left">行</td>
</tr>
<tr>
<td style="text-align:left"><strong>MVCC - 多版本并发控制</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>复制支持</strong> (在服务端实现，而不是在存储引擎中。)</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>存储限制</strong></td>
<td style="text-align:left">64TB</td>
</tr>
<tr>
<td style="text-align:left"><strong>T树索引</strong></td>
<td style="text-align:left">No</td>
</tr>
<tr>
<td style="text-align:left"><strong>事物</strong></td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left"><strong>数据字典的更新统计信息</strong></td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<h2 id="使用-InnoDB-表的好处">使用 InnoDB 表的好处</h2>
<p>InnoDB 表具有以下优点：</p>
<ul>
<li>如果服务器由于硬件或软件问题而意外退出，无论当时数据库中发生了什么，您都无需在重新启动数据库后执行任何特殊操作。<code>InnoDB</code>崩溃恢复会自动完成崩溃之前提交的更改，并撤消正在进行但未提交的更改，允许您重新启动并从上次中断的地方继续。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-recovery.html">第 15.18.2 节，“InnoDB 恢复”</a>。</li>
<li>InnoDB 存储引擎维护自己的缓冲池 - <code>buffer pool</code>，在访问数据时将表和索引数据缓存在主内存中。经常使用的数据直接从内存中处理。此缓存适用于多种类型的信息并加快处理速度。在专用数据库服务器上，多达 80% 的物理内存通常分配给缓冲池。请参见<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">第 15.5.1 节，“缓冲池 - Buffer Pool”</a>。</li>
<li>如果将相关数据拆分到不同的表中，则可以设置强制参照完整性的外键。请参见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html">第 13.1.20.5 节，“外键约束”</a>。</li>
<li>如果磁盘或内存中的数据损坏，校验和机制会在您使用之前提醒您注意虚假数据。该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_checksum_algorithm"><code>innodb_checksum_algorithm</code></a> 变量定义了 <code>InnoDB</code> 使用的校验和算法。</li>
<li>当您为每个表设计具有适当主键列的数据库时，会自动优化涉及这些列的操作。在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>WHERE</code></a> 子句、<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>ORDER BY</code></a>子句、 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>GROUP BY</code></a> 子句和连接操作中引用主键列的速度非常快 。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">第 15.6.2.1 节，“聚集索引和二级索引”</a>。</li>
<li>插入、更新和删除通过称为更改缓冲去 - <code>change buffering</code> 的自动机制进行优化。<code>InnoDB</code> 不仅允许对同一个表进行并发读写访问，它还缓存更改的数据以简化磁盘 I/O。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html">第 15.5.2 节，“更改缓冲区 - Change Buffer”</a>。</li>
<li>性能优势不仅限于具有长时间运行查询的大型表。当从表中一遍又一遍地访问相同的行时，自适应哈希索引会接管以加快这些查找，就好像它们来自哈希表一样。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-adaptive-hash.html">第 15.5.3 节，“自适应哈希索引”</a>。</li>
<li>您可以压缩表和关联的索引。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-compression.html">第 15.9 节，“InnoDB 表和页面压缩”</a>。</li>
<li>您可以加密您的数据。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-data-encryption.html">第 15.13 节，“InnoDB 静态数据加密”</a>。</li>
<li>您可以创建和删除索引以及执行其他 DDL 操作，而对性能和可用性的影响要小得多。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html">第 15.12.1 节，“在线 DDL 操作”</a>。</li>
<li>截断（Truncating）每个表的文件表空间非常快，可以释放磁盘空间供操作系统重用，而不仅仅是<code>InnoDB</code>. 请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-file-per-table-tablespaces.html">第 15.6.3.2 节，“单表文件空间”</a>。</li>
<li>表数据的存储布局对于<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/blob.html"><code>BLOB</code></a>长文本字段和<code>DYNAMIC</code>行格式更有效 。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html">第 15.10 节，“InnoDB 行格式”</a>。</li>
<li>您可以通过查询<code>INFORMATION_SCHEMA</code>表来监控存储引擎的内部工作。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema.html">第 15.15 节，“InnoDB INFORMATION_SCHEMA 表”</a>。</li>
<li>您可以通过查询 Performance Schema 表来监控存储引擎的性能详细信息。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-schema.html">第 15.16 节，“InnoDB 与 MySQL Performance Schema 的集成”</a>。</li>
<li>您可以将<code>InnoDB</code>表与来自其他 MySQL 存储引擎的表混合使用，即使在同一语句中也是如此。例如，您可以使用连接操作在单个查询中组合来自表<code>InnoDB</code>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/memory-storage-engine.html"><code>MEMORY</code></a>表的数据 。</li>
<li><code>InnoDB</code> 专为处理大量数据时的 CPU 效率和最大性能而设计。</li>
<li><code>InnoDB</code> 表可以处理大量数据，即使在文件大小限制为 2GB 的操作系统上也是如此。</li>
</ul>
<p>对于<code>InnoDB</code>可以应用于 MySQL 服务器和应用程序代码的特定调整技术，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb.html">第 8.5 节“优化 InnoDB 表”</a>。</p>
<h2 id="InnoDB-表的最佳实践">InnoDB 表的最佳实践</h2>
<p>本节介绍使用<code>InnoDB</code>表时的最佳实践 。</p>
<ul>
<li>使用最常查询的一列或多列来为每个表指定一个主键，如果没有明显的主键，则指定一个自增值。</li>
<li>在根据多个表中的相同 ID 值从多个表中提取数据的地方使用连接 - <code>join</code>。为了快速连接性能，在连接列上定义外键，并在每个表中用相同的数据类型声明这些列。添加外键确保引用的列被索引，这可以提高性能。外键还会将删除和更新传播到所有受影响的表，并在父表中不存在相应 ID 时阻止在子表中插入数据。</li>
<li>关闭自动提交。每秒提交数百次会限制性能（受存储设备的写入速度限制）。</li>
<li>通过用<code>START TRANSACTION</code>和 <code>COMMIT</code>语句将相关的 DML 操作集分组到事务中。虽然您不想太频繁地提交，但您也不想发出大量运行数小时而不提交的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>、 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>、 或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/delete.html"><code>DELETE</code></a>语句。</li>
<li>不要使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html"><code>LOCK TABLES</code></a> 语句。<code>InnoDB</code>可以在不牺牲可靠性或高性能的情况下同时处理对同一个表的所有读取和写入的多个会话。要获得对一组行的独占写访问权限，请使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html"><code>SELECT ... FOR UPDATE</code></a>语法锁定您打算更新的行。</li>
<li>启用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a> 变量或使用通用表空间将表的数据和索引放入单独的文件而不是系统表空间。<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a> 默认情况下启用该变量。</li>
<li>评估您的数据和访问模式是否受益于<code>InnoDB</code>表或页面压缩功能。您可以在<code>InnoDB</code>不牺牲读/写能力的情况下压缩表。</li>
<li>使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_sql_mode"><code>--sql_mode=NO_ENGINE_SUBSTITUTION</code></a> 选项运行服务器以防止使用您不想使用的存储引擎创建表。</li>
</ul>
<h1>InnoDB 架构</h1>
<p>下图显示了构成<code>InnoDB</code>存储引擎架构的内存和磁盘结构。内存结构包括<code>缓冲池 - Buffer Pool</code>、<code>自适应哈希索引 - Adaptive Hash Index</code>、<code>更改缓冲区 - Buffer Pool</code> 和<code>日志缓冲区 - Log Buffer</code>。 磁盘结构包括<code>表空间 - Table Space</code>、<code>重做日志 - Redo Log</code> 和<code>双写缓冲区文件 - Doublewrite Buffer Files</code>。</p>
<p><img data-src="../../../images/db/innodb/innodb-architecture.png" alt="InnoDB 架构"></p>
<h1>InnoDb 内存结构</h1>
<h2 id="缓冲池-Buffer-Pool">缓冲池 - Buffer Pool</h2>
<p>缓冲池是主内存中的一个区域，用于在 <code>InnoDB</code>访问时缓存表和索引数据。缓冲池允许直接从内存访问经常使用的数据，从而加快处理速度。在专用服务器上，多达 80% 的物理内存通常分配给缓冲池。</p>
<p>为了提高大量读取操作的效率，缓冲池被划分为可能包含多行的<code>页 - Page</code>。为了缓存管理的效率，缓冲池被实现为页的链表；很少使用的数据使用最近最少使用 (LRU) 算法的变体从缓存中老化。</p>
<p>了解如何利用缓冲池将经常访问的数据保存在内存中是 MySQL 调优的一个重要方面。</p>
<h3 id="缓冲池-LRU-算法">缓冲池 LRU 算法</h3>
<p>缓冲池作为列表 - List 使用 LRU 算法的变体来进行管理。当需要空间向缓冲池添加新页时，最近最少使用的页会被逐出，并将新页添加到列表中间。此中点插入策略将列表视为两个子列表：</p>
<ul>
<li>在头部，最近访问的新（“年轻”）页的子列表</li>
<li>在尾部，最近访问过的旧页的子列表</li>
</ul>
<p><img data-src="../../../images/db/innodb/innodb-buffer-pool-list.png" alt="缓冲池列表"></p>
<p>该算法将经常使用的页保留在新的子列表中。旧的子列表包含不太常用的页；这些页是要被<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_eviction">驱逐的</a>候选页。</p>
<p>默认情况下，算法操作如下：</p>
<ul>
<li>缓冲池的 3/8 专用于旧子列表。</li>
<li>列表的中间是新子列表尾部与旧子列表头部相交的边界。</li>
<li>当<code>InnoDB</code>将页读入缓冲池时，它最初将它插入到中间（旧子列表的头部）。可以读取该页，因为它是用户初始化操作（例如 SQL 查询）所必需的，或者是由 <code>InnoDB</code> 自动执行的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_read_ahead">预读</a>操作的一部分。</li>
<li>访问旧子列表中的页使其 “变新”，将其移动到新子列表的头部。如果页面是因为用户启动的操作需要它而被读取，则第一次访问会立即发生，并且页会变新。如果页面是由于预读操作而读取的，则第一次访问不会立即发生，并且在页被逐出之前可能根本不会发生。</li>
<li>随着数据库的运行，缓冲池中未被访问的页面会通过向列表尾部移动来“老化”。新旧子列表中的页随着其他页的更新而老化。旧子列表中的页也会随着页插入中点而老化。最终，一个未使用的页到达旧子列表的尾部并被驱逐。</li>
</ul>
<p>默认情况下，查询读取的页会立即移动到新的子列表中，这意味着它们在缓冲池中停留的时间更长。例如，为 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html"><strong>mysqldump</strong></a> 操作或 <code>SELECT</code> 没有 <code>WHERE</code> 子句的语句执行的表扫描可以将大量数据带入缓冲池并驱逐等量的旧数据，即使这些新数据不需要再使用。类似地，由预读后台线程加载且仅访问一次的页也会被移动到新列表的头部。这些情况会将经常使用的页推送到旧的子列表，在那里它们会被逐出。有关优化此行为的信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-midpoint_insertion.html">第 15.8.3.3 节，“使缓冲池扫描具有抵抗性”</a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-read_ahead.html">第 15.8.3.4 节，“配置 InnoDB 缓冲池预取（预读）”</a>。</p>
<p><code>InnoDB</code> 标准监视器输出在 <code>BUFFER POOL AND MEMORY</code> 有关缓冲池 LRU 算法操作的部分中包含多个字段。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html#innodb-buffer-pool-monitoring">使用 InnoDB 标准监视器监视缓冲池</a>。</p>
<h2 id="更改缓冲区-Change-Buffer">更改缓冲区 - Change Buffer</h2>
<p>更改缓冲区是一种特殊的数据结构，当<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index">二级索引</a>页不在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_buffer_pool">缓冲池中</a>时，它会缓存对<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_secondary_index">二级索引</a>页的更改 。可能由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>、 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/delete.html"><code>DELETE</code></a>操作 (DML) 导致的缓冲更改稍后在其他读取操作将页加载到缓冲池时合并。</p>
<p><img data-src="../../../images/db/innodb/innodb-change-buffer.png" alt="更改缓冲区"></p>
<p>与<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">聚集索引</a>不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页。合并更改的缓存，以便稍后在其他操作将受影响的页读入缓冲池时可避免大量随机访问 I/O，而这些 I/O 需要将二级索引页面从磁盘读入缓冲池。</p>
<p>在系统大部分空闲时或在缓慢关闭期间运行的<code>清洗 - purge</code> 操作会定期将更新的索引页写入磁盘。与将每个值立即写入磁盘相比，purge 操作可以更有效地为一系列索引值写入磁盘块。</p>
<p>当有许多受影响的行和许多二级索引要更新时，更改缓冲区合并可能需要几个小时。在此期间，磁盘 I/O 增加，这可能会导致磁盘绑定查询的显着减慢。在提交事务后，甚至在服务器关闭并重新启动之后，更改缓冲区合并也可能继续发生（ 有关更多信息<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html">，</a>请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html">第 15.21.3 节，“强制 InnoDB 恢复”</a>）。</p>
<p>在内存中，更改缓冲区占据了缓冲池的一部分。在磁盘上，更改缓冲区是系统表空间的一部分，当数据库服务器关闭时，索引更改会在其中缓冲。</p>
<p>缓存在更改缓冲区中的数据类型由 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_change_buffering"><code>innodb_change_buffering</code></a>变量控制。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-configuration">配置更改缓冲</a>。您还可以配置最大更改缓冲区大小。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-change-buffer.html#innodb-change-buffer-maximum-size">配置更改缓冲区最大大小</a>。</p>
<p>如果索引包含降序索引列或主键包含降序索引列，则二级索引不支持更改缓冲。</p>
<p>有关更改缓冲区的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/faqs-innodb-change-buffer.html">常见问题解答</a>，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/faqs-innodb-change-buffer.html">第 A.16 节，“MySQL 8.0 常见问题解答：InnoDB 更改缓冲区”</a>。</p>
<h2 id="自适应哈希索引-Adaptive-Hash-Index">自适应哈希索引 - Adaptive Hash Index</h2>
<p>自适应哈希索引能够让 <code>InnoDB</code> 在具有适当组合的工作负载和足够的缓冲池内存的系统上的执行更像内存数据库，而不会牺牲事务功能或可靠性。自适应哈希索引由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index"><code>innodb_adaptive_hash_index</code></a> 变量启用 ，或在服务器启动时由参数 <code>--skip-innodb-adaptive-hash-index</code> 关闭。</p>
<p>根据观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只有 B 树中的某些值出现在哈希索引中。哈希索引是针对经常访问的索引页按需构建的。</p>
<p>如果一个表几乎完全放在主内存中，哈希索引会通过启用任何元素的直接查找来加速查询，将索引值转换为一种指针。 <code>InnoDB</code>具有监视索引搜索的机制。如果<code>InnoDB</code>注意到查询可以从构建哈希索引中受益，它会自动这样做。</p>
<p>对于某些工作负载，哈希索引查找的加速优势大大超过了监视索引查找和维护哈希索引结构的带来的额外工作。对自适应哈希索引的访问有时也会成为繁重工作负载下的争用源，例如多个并发连接。带有 <code>LIKE</code> 运算符和 <code>%</code> 通配符的查询也往往不会受益。对于无法从自适应哈希索引中受益的工作负载，将其关闭可减少不必要的性能开销。由于很难提前预测自适应哈希索引是否适合特定系统和工作负载，请考虑在启用和禁用它的情况下运行基准测试。</p>
<p>自适应哈希索引功能是分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的闩锁 - latch 保护。分区由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index_parts"><code>innodb_adaptive_hash_index_parts</code></a> 变量控制 。该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_adaptive_hash_index_parts"><code>innodb_adaptive_hash_index_parts</code></a> 变量默认设置为 8。最大设置为 512。</p>
<p>您可以在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a> 输出的 <code>SEMAPHORES </code>部分监控自适应哈希索引的使用和争用。如果有大量线程在等待 <code>btr0sea.c</code> 中创建的 <code>rw-latch</code>，请考虑增加自适应散列索引分区的数量或禁用自适应散列索引。</p>
<p>有关哈希索引的性能特征的信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html">第 8.3.9 节，“B 树和哈希索引的比较”</a>。</p>
<h2 id="日志缓冲区-Log-Buffer">日志缓冲区 - Log Buffer</h2>
<p>日志缓冲区是保存要写入到磁盘上日志文件的数据的内存区域。日志缓冲区大小由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_log_buffer_size"><code>innodb_log_buffer_size</code></a>变量定义 。默认大小为 16MB。日志缓冲区的内容会定期刷新到磁盘。大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将重做日志数据写入磁盘。因此，如果您有更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p>
<p>该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit"><code>innodb_flush_log_at_trx_commit</code></a> 变量控制日志缓冲区的内容如何写入和刷新到磁盘。该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_timeout"><code>innodb_flush_log_at_timeout</code></a> 变量控制日志刷新频率。</p>
<p>有关相关信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html#innodb-startup-memory-configuration">内存配置</a> 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-innodb-logging.html">第 8.5.4 节, “优化 InnoDB 重做日志”</a>。</p>
<h1>InnoDB 物理结构</h1>
<h2 id="表-Tables">表 - Tables</h2>
<h3 id="创建-InnoDB-表">创建 InnoDB 表</h3>
<p><code>InnoDB</code>表是使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a> 语句创建的 ；例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (a)) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>当把 <code>InnoDB</code> 定义为默认存储引擎时不需要 <code>ENGINE=InnoDB</code> 该子句 ，默认情况下就是 <code>InnoDB</code>。但是，如果 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a> 要在默认存储引擎不存在 <code>InnoDB</code> 或未知的其他 MySQL 服务器实例上重放语句，则该子句很有用 。您可以通过发出以下语句来确定 MySQL 服务器实例上的默认存储引擎：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@default</span>_storage_engine;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@default</span>_storage_engine <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br><span class="line"><span class="operator">|</span> InnoDB                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+</span></span><br></pre></td></tr></table></figure>
<p><code>InnoDB</code> 默认情况下，表是在 <code>File-Per-Table Tablespaces</code> 表空间中创建的。要让 <code>InnoDB</code> 在 <code>InnoDB</code> 系统表空间（System Tablespace）中创建表，请在创建表之前禁用该变量 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>。要让 <code>InnoDB</code> 在通用表空间（General Tablespaces）中创建表，请使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE ... TABLESPACE </code></a>语法。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tablespace.html">第 15.6.3 节，“表空间”</a>。</p>
<h4 id="行格式">行格式</h4>
<p><code>InnoDB</code>表 的行格式决定了其行在磁盘上的物理存储方式。 <code>InnoDB</code> 支持四种行格式，每种格式具有不同的存储特性。支持的行格式包括 <code>REDUNDANT</code>，<code>COMPACT</code>， <code>DYNAMIC</code>，和 <code>COMPRESSED</code>。默认的行格式为 <code>DYNAMIC</code>。有关行格式特征的信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html">第 15.10 节，“InnoDB 行格式”</a>。</p>
<p>该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_default_row_format"><code>innodb_default_row_format</code></a> 变量定义了默认的行格式。表的行格式也可以使用 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 语句中的 <code>ROW_FORMAT</code> 表选项显式定义。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-defining">定义表的行格式</a>。</p>
<p><strong>表 InnoDB 行格式概述</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">行格式</th>
<th style="text-align:left">紧凑的存储特性</th>
<th style="text-align:left">增强的可变长度列存储</th>
<th style="text-align:left">大索引键前缀支持</th>
<th style="text-align:left">压缩支持</th>
<th style="text-align:left">支持的表空间类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDUNDANT</code></td>
<td style="text-align:left">No</td>
<td style="text-align:left">No</td>
<td style="text-align:left">No</td>
<td style="text-align:left">No</td>
<td style="text-align:left">system, file-per-table, general</td>
</tr>
<tr>
<td style="text-align:left"><code>COMPACT</code></td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No</td>
<td style="text-align:left">No</td>
<td style="text-align:left">No</td>
<td style="text-align:left">system, file-per-table, general</td>
</tr>
<tr>
<td style="text-align:left"><code>DYNAMIC</code></td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">No</td>
<td style="text-align:left">system, file-per-table, general</td>
</tr>
<tr>
<td style="text-align:left"><code>COMPRESSED</code></td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">file-per-table, general</td>
</tr>
</tbody>
</table>
<h4 id="主键">主键</h4>
<p>建议您为您创建的每个表定义一个主键。选择主键列时，选择具有以下特征的列：</p>
<ul>
<li>最重要的查询引用的列。</li>
<li>永远不会留空的列。</li>
<li>从不具有重复值的列。</li>
<li>插入后很少更改值的列。</li>
</ul>
<p>例如，在包含有关人员信息的表中，您不会创建主键，<code>(firstname, lastname)</code> 因为可以有多个人具有相同的姓名，姓名列可能留空，有时人们会更改他们的姓名。由于有如此多的约束，通常没有一组明显的列用作主键，因此您创建一个带有数字 ID 的新列作为主键的全部或部分。您可以声明一个 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_auto_increment">自动递增</a> 列，以便在插入行时自动填充升序值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># ID 的值可以充当不同表中相关项之间的指针。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 (id <span class="type">INT</span> AUTO_INCREMENT, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (id));</span><br><span class="line"></span><br><span class="line"># 主键可以由多列组成。任何 autoinc 列都必须排在第一位。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 (id <span class="type">INT</span> AUTO_INCREMENT, a <span class="type">INT</span>, b <span class="type">CHAR</span> (<span class="number">20</span>), <span class="keyword">PRIMARY</span> KEY (id,a));</span><br></pre></td></tr></table></figure>
<p>有关自动增量列的更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">第 15.6.1.6 节，“InnoDB 中的 AUTO_INCREMENT 处理”</a>。</p>
<p>尽管表在没有定义主键的情况下也能正常工作，但主键涉及性能的许多方面，并且是任何大型或经常使用的表的关键设计方面。建议您始终在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a> 语句中指定主键。如果创建表，加载数据，然后运行 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a> 添加主键，该操作比创建表时定义主键要慢得多。有关主键的更多信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">第 15.6.2.1 节，“聚集索引和二级索引”</a>。</p>
<h4 id="查看-InnoDB-表属性">查看 InnoDB 表属性</h4>
<p>要查看 <code>InnoDB</code> 表的属性，可以发出一条 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html"><code>SHOW TABLE STATUS</code></a> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">FROM</span> test <span class="keyword">LIKE</span> <span class="string">&#x27;t%&#x27;</span> \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           Name: t1</span><br><span class="line">         Engine: InnoDB</span><br><span class="line">        Version: <span class="number">10</span></span><br><span class="line">     Row_format: <span class="keyword">Dynamic</span></span><br><span class="line">           <span class="keyword">Rows</span>: <span class="number">0</span></span><br><span class="line"> Avg_row_length: <span class="number">0</span></span><br><span class="line">    Data_length: <span class="number">16384</span></span><br><span class="line">Max_data_length: <span class="number">0</span></span><br><span class="line">   Index_length: <span class="number">0</span></span><br><span class="line">      Data_free: <span class="number">0</span></span><br><span class="line"> Auto_increment: <span class="keyword">NULL</span></span><br><span class="line">    Create_time: <span class="number">2021</span><span class="number">-02</span><span class="number">-18</span> <span class="number">12</span>:<span class="number">18</span>:<span class="number">28</span></span><br><span class="line">    Update_time: <span class="keyword">NULL</span></span><br><span class="line">     Check_time: <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">Collation</span>: utf8mb4_0900_ai_ci</span><br><span class="line">       Checksum: <span class="keyword">NULL</span></span><br><span class="line"> Create_options: </span><br><span class="line">        Comment:</span><br></pre></td></tr></table></figure>
<p>有关 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html"><code>SHOW TABLE STATUS</code></a> 输出的信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-table-status.html">第 13.7.7.38 节，“显示表状态语句”</a>。</p>
<p>您还可以通过查询 <code>InnoDB</code>  Information Schema 系统表来访问表属性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TABLES <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;test/t1&#x27;</span> \G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">     TABLE_ID: <span class="number">1144</span></span><br><span class="line">         NAME: test<span class="operator">/</span>t1</span><br><span class="line">         FLAG: <span class="number">33</span></span><br><span class="line">       N_COLS: <span class="number">5</span></span><br><span class="line">        SPACE: <span class="number">30</span></span><br><span class="line">   ROW_FORMAT: <span class="keyword">Dynamic</span></span><br><span class="line">ZIP_PAGE_SIZE: <span class="number">0</span></span><br><span class="line">   SPACE_TYPE: Single</span><br><span class="line"> INSTANT_COLS: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema-system-tables.html">第 15.15.3 节，“InnoDB INFORMATION_SCHEMA 模式对象表”</a>。</p>
<h3 id="InnoDB-中的-AUTO-INCREMENT-处理">InnoDB 中的 AUTO_INCREMENT 处理</h3>
<p>InnoDB 提供了一种可配置的锁定机制，可以显着提高向具有 AUTO_INCREMENT 列的表添加行的 SQL 语句的可伸缩性和性能。要对 <code>InnoDB</code> 表使用该 <code>AUTO_INCREMENT</code> 机制，必须将 <code>AUTO_INCREMENT</code> 列定义为索引的一部分，以便可以对表执行等效的索引查找 <code>SELECT MAX(ai_col)</code> 以获得最大列值。通常，这是通过将该列作为某个表索引的第一列来实现的。</p>
<p>本节描述 <code>AUTO_INCREMENT</code> 锁定模式、不同 <code>AUTO_INCREMENT</code> 锁定模式设置的使用含义，以及 <code>InnoDB</code> 如何初始化 <code>AUTO_INCREMENT</code> 计数器。</p>
<h4 id="InnoDB-AUTO-INCREMENT-锁定模式">InnoDB AUTO_INCREMENT 锁定模式</h4>
<p>本节介绍用于生成自动增量值的 <code>AUTO_INCREMENT</code> 锁模式，以及每种锁模式如何影响复制。在启动时使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#:~:text=startup%20using%20the-,innodb_autoinc_lock_mode,-variable."><code>innodb_autoinc_lock_mode</code></a> 变量来配置自动增量锁定模式。</p>
<p>以下术语用于描述 <code>innodb_autoinc_lock_mode</code> 设置：</p>
<ul>
<li>
<p>“类似 Insert”的语句</p>
<p>在表中生成新行的所有语句，包括 <code>INSERT</code>、<code>INSERT ... SELECT</code>、<code>REPLACE</code>、<code>REPLACE ... SELECT</code> 和 <code>LOAD DATA</code>。包括“简单插入”、“批量插入”和“混合模式”插入。</p>
</li>
<li>
<p>“简单插入”</p>
<p>可以预先确定要插入的行数的语句（在最初处理语句时）。这包括没有嵌套子查询的单行和多行 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/replace.html"><code>REPLACE</code></a>语句，但不包含 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a>.</p>
</li>
</ul>
<ul>
<li>
<p>“批量插入”</p>
<p>要插入的行数（以及所需的自动增量值的数量）事先未知的语句。这包括 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html"><code>INSERT ... SELECT</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/replace.html"><code>REPLACE ... SELECT</code></a>和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html"><code>LOAD DATA</code></a>语句，但不包括普通的 <code>INSERT</code>。在处理每一行时，一次为列<code>InnoDB</code>分配一个新值 <code>AUTO_INCREMENT</code>。</p>
</li>
<li>
<p>“混合模式插入”</p>
<p>其中一部分是“简单插入”语句，用于指定某些（但不是全部）新行的自动增量值。下面是一个示例，其中 c1 是表 t1 的 <code>AUTO_INCREMENT</code> 列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c1,c2) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="keyword">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>另一种类型的“混合模式插入”是<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html"><code>INSERT ... ON DUPLICATE KEY UPDATE</code></a>，在最坏的情况下实际上是一个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> 后跟一个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a>，其中<code>AUTO_INCREMENT</code>在更新阶段可能会或可能不会使用为列分配的值 。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a> 变量有三种可能的设置 。设置为 0、1 或 2，分别表示 “传统”、“连续”或 “交错”锁定模式。从 MySQL 8.0 开始，交错锁模式 ( <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode=2</code></a>) 是默认设置。在 MySQL 8.0 之前，连续锁定模式是默认的 ( <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode=1</code></a>)。</p>
<p>MySQL 8.0 中交错锁模式的默认设置反映了从基于语句的复制更改为基于行的复制作为默认复制类型。基于语句的复制需要连续的自增锁模式，以保证给定的 SQL 语句序列以可预测和可重复的顺序分配自增值，而基于行的复制对 SQL 语句的执行顺序不敏感.</p>
<ul>
<li>
<p><code>innodb_autoinc_lock_mode = 0</code> （“传统”锁定模式）</p>
<p>传统的锁定模式提供与引入该<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a> 变量存在之前的行为相同 。由于语义可能存在差异，提供传统锁定模式选项是为了向后兼容、性能测试和解决“混合模式插入”问题。</p>
<p>在这种锁定模式下，所有“类似 INSERT ”的语句都会获得一个特殊的表级<code>AUTO-INC</code> 锁定，用于插入到带有 <code>AUTO_INCREMENT</code>列的表中。此锁通常保持到语句的末尾（而不是事务的末尾），以确保为给定的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> 语句序列以可预测和可重复的顺序分配自动增量值，并确保自动增量值由任何给定语句赋值都是连续的。</p>
<p>在基于语句的复制的情况下，这意味着在副本服务器上复制 SQL 语句时，自动增量列使用的值与源服务器上的值相同。多个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>语句的执行结果是确定性的，副本复制与源上相同的数据。如果多个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>语句生成的自动增量值被交错，则两个并发<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>语句的结果将是不确定的，并且无法使用基于语句的复制可靠地传播到副本服务器。</p>
<p>为清楚起见，请考虑使用此表的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">  c1 <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  c2 <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (c1)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>假设有两个事务在运行，每个事务都将行插入到带有 <code>AUTO_INCREMENT</code>列的表中 。一个事务使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html"><code>INSERT ... SELECT</code></a>插入 1000 行的语句，另一个事务使用插入一行的简单<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Tx1: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c2) <span class="keyword">SELECT</span> <span class="number">1000</span> <span class="keyword">rows</span> <span class="keyword">from</span> another <span class="keyword">table</span> ...</span><br><span class="line">Tx2: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 (c2) <span class="keyword">VALUES</span> (<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><code>InnoDB</code>无法预先知道从 Tx1<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a>中的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>语句中检索了多少行 ，并且随着语句的进行，它一次分配一个自动增量值。使用表级锁，一直保持到语句的末尾，一次只能执行一条 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>引用 table 的语句<code>t1</code>，并且不同语句的自增数的生成不会交错。Tx1<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html"><code>INSERT ... SELECT</code></a>语句生成的自增值是连续的，并且使用的（单个）自增值 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> Tx2 中的语句小于或大于所有用于 Tx1 的语句，具体取决于哪个语句先执行。</p>
<p>只要 SQL 语句在从二进制日志重放时（使用基于语句的复制时，或在恢复场景中）以相同的顺序执行，结果与 Tx1 和 Tx2 首次运行时的结果相同。因此，在语句结束之前一直持有的表级锁使 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>使用自动增量的语句安全用于基于语句的复制。但是，当多个事务同时执行插入语句时，这些表级锁会限制并发性和可伸缩性。</p>
<p>在前面的示例中，如果没有表级锁，则用于<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>到 Tx2 的自增列的值取决于语句的执行时间。如果 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a> Tx2 的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>在 Tx1 的运行时执行（而不是在它开始之前或完成之后），则这两个<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>语句分配的特定自动增量值是不确定的，并且可能会因运行而异。</p>
<p>在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-mode-consecutive">连续</a> 锁模式下，<code>InnoDB</code>可以避免对预先知道行数的“简单插入”语句使用表级<code>AUTO-INC</code>锁 ，并且仍然保留基于语句的复制的确定性执行和安全性。</p>
<p>如果您不使用二进制日志来重放 SQL 语句作为恢复或复制的一部分， 则可以使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-mode-interleaved">交错</a>锁模式来消除所有表级<code>AUTO-INC</code>锁的使用， 以获得更高的并发性和性能，代价是允许自动中断 - 增加由语句分配的编号，并且可能将同时执行的语句分配的编号交错。</p>
</li>
</ul>
<ul>
<li>
<p><code>innodb_autoinc_lock_mode = 1</code> （“连续”锁定模式）</p>
<p>在这种模式下，“批量插入”使用特殊的 <code>AUTO-INC</code>表级锁并保持到语句结束。这适用于所有 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html"><code>INSERT ... SELECT</code></a>， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/replace.html"><code>REPLACE ... SELECT</code></a>和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/load-data.html"><code>LOAD DATA</code></a>语句。一次<code>AUTO-INC</code>只能执行一个持有锁的语句 。如果批量插入操作的源表与目标表不同，则<code>AUTO-INC</code>在对源表中选择的第一行上取共享锁后，再取目标表上的锁。如果批量插入操作的源和目标是同一个表，则<code>AUTO-INC</code> 在对所有选定行采取共享锁之后，才会采取锁定措施。</p>
<p>“简单插入”（预先知道要插入的行数）通过在互斥锁（轻量级锁）的控制下获取所需数量的自动增量值来避免表级 AUTO-INC 锁只在分配过程中保留，直到语句完成。除非另一个事务持有 AUTO-INC 锁，否则不使用表级 AUTO-INC 锁。如果另一个事务持有 AUTO-INC 锁，则“简单插入”等待 AUTO-INC 锁，就好像它是“批量插入”一样。</p>
<p>这种锁定模式确保在存在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>行数未知的语句时（并且随着语句的进行分配自动递增编号），任何“<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT-like</code></a>” 语句分配的所有自动增量值都是连续的，并且操作对于基于语句的复制是安全的。</p>
<p>简而言之，这种锁定模式显着提高了可伸缩性，同时可以安全地用于基于语句的复制。此外，与“传统” 锁定模式一样，任何给定语句分配的自动递增编号都是<em>连续的</em>。对于任何使用自动增量的语句，与“传统”模式相比，语义上<em>没有任何变化</em>，只有一个重要的例外。</p>
<p>例外情况是“混合模式插入”，其中用户为<code>AUTO_INCREMENT</code>多行“简单插入”中的某些（但不是全部）行提供列的显式值 。对于此类插入，对于此类插入，InnoDB 分配的自动增量值多于要插入的行数。但是，所有自动分配的值都是连续生成的（因此高于）由最近执行的前一条语句生成的自动增量值。“多余”的数字丢失。</p>
</li>
<li>
<p><code>innodb_autoinc_lock_mode = 2</code> （“交错”锁定模式）</p>
<p>在这种锁模式下，没有“INSERT-like”语句使用表级 <code>AUTO-INC</code> 锁，可以同时执行多条语句。 这是最快和最具扩展性的锁模式，但在使用基于语句的复制或从二进制日志重放 SQL 语句的恢复场景时，它是<em>不安全的</em>。</p>
<p>在这种锁定模式下，自动递增值保证在所有并发执行的“<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html"><code>INSERT</code></a>-like ” 语句中是唯一的并且单调递增 。但是，由于多个语句可以同时生成数字（即，数字的分配在语句之间<em>交错</em>），因此为任何给定语句插入的行生成的值可能不是连续的。</p>
<p>如果执行的唯一语句是提前知道要插入的行数的“简单插入”，则为单个语句生成的数字没有间隙，“混合模式插入”除外 。但是，当执行“批量插入”时，任何给定语句分配的自动增量值中可能存在间隙。</p>
</li>
</ul>
<h2 id="索引-Indexes">索引 - Indexes</h2>
<h3 id="聚集索引和二级索引">聚集索引和二级索引</h3>
<p>每个<code>InnoDB</code>表都有一个称为聚集索引（clustered index）的特殊索引，用于存储行数据。通常，聚集索引与主键同义。为了从查询、插入和其他数据库操作中获得最佳性能，了解<code>InnoDB</code>如何使用聚集索引来优化常见查询和 DML 操作非常重要。</p>
<ul>
<li>在表上定义<code>PRIMARY KEY</code>时，InnoDB 将其用作聚集索引。应该为每个表定义一个主键。如果没有逻辑唯一且非空的列或列集使用主键，请添加自动增量列。自动递增列值是唯一的，并在插入新行时自动添加。</li>
<li>如果您没有为表定义 PRIMARY KEY，则 InnoDB 使用第一个所有键列都定义为 NOT NULL 的 UNIQUE 索引作为聚集索引。</li>
<li>如果表没有<code>PRIMARY KEY</code>或没有合适的 <code>UNIQUE</code>索引，则 InnoDB 会在包含行 ID 值的合成列上生成一个名为 <code>GEN_CLUST_INDEX</code> 的隐藏聚集索引。行按<code>InnoDB</code>分配的行 ID 排序。行 ID 是一个 6 字节的字段，随着插入新行而单调增加。因此，按行 ID 排序的行在物理上是按插入顺序排列的。</li>
</ul>
<h5 id="聚集索引如何加快查询速度">聚集索引如何加快查询速度</h5>
<p>通过聚集索引访问一行很快，因为索引搜索直接指向包含行数据的页面。如果表很大，与使用与索引记录不同的页面存储行数据的存储组织相比，聚簇索引体系结构通常可以节省磁盘 I/O 操作。</p>
<h5 id="二级索引与聚集索引的关系">二级索引与聚集索引的关系</h5>
<p>聚集索引以外的索引称为二级索引。在<code>InnoDB</code>中，二级索引中的每条记录都包含该行的主键列，以及为二级索引指定的列。<code>InnoDB</code>使用此主键值搜索聚集索引中的行。</p>
<p>如果主键很长，二级索引会占用更多的空间，所以主键短是有利的。</p>
<p>有关利用<code>InnoDB</code> 聚集索引和二级索引的指南，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html">第 8.3 节 “优化和索引”</a>。</p>
<h3 id="InnoDB-索引的物理结构">InnoDB 索引的物理结构</h3>
<p>除空间索引外，<code>InnoDB</code>索引都是 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree">B 树</a>数据结构。空间索引使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_r_tree">R 树</a>，它是用于索引多维数据的专用数据结构。索引记录存储在其 B 树或 R 树数据结构的叶页中。索引页的默认大小为 16KB。页大小由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size"><code>innodb_page_size</code></a>MySQL 实例初始化时的设置决定 。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html">第 15.8.1 节，“InnoDB 启动配置”</a>。</p>
<p>当新记录插入到<code>InnoDB</code> <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">聚集索引中时</a>， <code>InnoDB</code>尝试保留 1/16 的页空闲空间以供将来插入和更新索引记录。如果按顺序（升序或降序）插入索引记录，则生成的索引页大约为 15/16。如果以随机顺序插入记录，则页从 1/2 到 15/16 。</p>
<p><code>InnoDB</code>创建或重建 B 树索引时执行批量加载。这种创建索引的方法称为<strong>排序索引构建</strong>(Sorted Index Builds)。该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_fill_factor"><code>innodb_fill_factor</code></a>变量定义了在排序索引构建期间填充的每个 B 树页面上的空间百分比，剩余空间保留用于将来的索引增长。空间索引不支持排序索引构建。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/sorted-index-builds.html">第 15.6.2.3 节，“排序索引构建”</a>。<code>innodb_fill_factor</code> 设置为 100 会留下聚集索引页中 1/16 的空间用于将来的索引增长。</p>
<p>如果<code>InnoDB</code>索引页面的填充因子（fill factor）低于<code>MERGE_THRESHOLD</code>，默认情况下为 50%，如果未指定，则<code>InnoDB</code>尝试收缩索引树以释放页面。该 <code>MERGE_THRESHOLD</code>设置适用于 B 树和 R 树索引。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/index-page-merge-threshold.html">第 15.8.11 节，“配置索引页面的合并阈值”</a>。</p>
<h3 id="排序索引构建">排序索引构建</h3>
<p><code>InnoDB</code>在创建或重建索引时执行批量加载而不是一次插入一个索引记录。这种索引创建方法也称为排序索引构建。空间索引不支持排序索引构建。</p>
<p>索引构建分为三个阶段。在第一阶段， 扫描<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">聚集索引</a>，生成索引条目并添加到排序缓冲区。当<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_sort_buffer">排序缓冲区</a>变满时，条目被排序并写出到临时中间文件。此过程也称为 “运行-run”。在第二阶段，将一次或多次运行写入临时中间文件，对文件中的所有条目执行归并排序。在第三个也是最后一个阶段，排序后的条目被插入到 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree">B 树中</a>。</p>
<p>在引入排序索引构建之前，使用插入 API 将索引条目一次一条地插入到 B 树中。此方法涉及打开 B 树 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_cursor">游标</a>以查找插入位置，然后使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_optimistic">乐观</a>插入将条目插入 B 树页面 。如果由于页面已满而导致插入失败， 则将执行<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_pessimistic">悲观</a>插入，这涉及打开 B 树游标并根据需要拆分和合并 B 树节点，以便为条目找到空间。这种构建索引的“自顶向下”方法的缺点是搜索插入位置的成本以及 B 树节点的不断分裂和合并。</p>
<p>排序索引构建使用“自下而上”建立索引的方法。使用这种方法，对最右侧叶页的引用保存在 B 树的所有级别。分配必要 B 树深度的最右侧叶页，并根据其排序顺序插入条目。一旦叶页已满，节点指针将附加到父页，并为下一次插入分配同级叶页。这个过程一直持续到所有条目都被插入，这可能会导致插入到根级别。分配同级页时，释放对先前固定的叶页的引用，新分配的叶页成为最右侧的叶页和新的默认插入位置。</p>
<h2 id="表空间-Tablespaces">表空间 - Tablespaces</h2>
<h3 id="系统表空间">系统表空间</h3>
<p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间中创建的，而不是在每个表文件或通用表空间中创建，则它还可能包含表和索引数据。在以前的 MySQL 版本中，系统表空间包含<code>InnoDB</code>数据字典。在 MySQL 8.0 中，<code>InnoDB</code>将元数据存储在 MySQL 数据字典中。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/data-dictionary.html">第 14 章，<em>MySQL 数据字典</em></a>。在以前的 MySQL 版本中，系统表空间还包含双写缓冲区存储区。从 MySQL 8.0.20 开始，此存储区域位于单独的双写文件中。请参见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-doublewrite-buffer.html">第 15.6.4 节，“双写缓冲区”</a>。</p>
<p>系统表空间可以有一个或多个数据文件。默认情况下，会在数据目录中创建一个名为 <code>ibdata1</code> 的系统表空间数据文件。系统表空间数据文件的大小和数量由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_file_path"><code>innodb_data_file_path</code></a>启动选项定义。有关配置信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration">系统表空间数据文件配置</a>。</p>
<h4 id="调整系统表空间的大小">调整系统表空间的大小</h4>
<p>本节介绍如何增加或减少系统表空间的大小。</p>
<h5 id="增加系统表空间的大小">增加系统表空间的大小</h5>
<p>增加系统表空间大小的最简单方法是将其配置为自动扩展。为此，在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_file_path"><code>innodb_data_file_path</code></a> 设置中指定最后一个数据文件的 <code>autoextend</code> 属性，然后重新启动服务器。例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">innodb_data_file_path</span>=ibdata1:<span class="number">10</span>M:autoextend</span><br></pre></td></tr></table></figure>
<p>当指定了 <code>autoextend</code> 属性时，数据文件的大小会随着空间的需要自动增加 <code>8MB</code>。 <code>innodb_autoextend_increment</code> 变量控制增量大小。</p>
<p>您还可以通过添加另一个数据文件来增加系统表空间的大小。可以这样做：</p>
<ol>
<li>停止 MySQL 服务器。</li>
<li>如果设置中的最后一个数据文件 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_file_path"><code>innodb_data_file_path</code></a> 是用该<code>autoextend</code> 属性定义的，请将其删除，然后修改 <code>size</code> 属性以反映当前数据文件的大小。要确定指定的数据文件大小，请检查文件系统的文件大小，并将该值向下舍入到最接近的 MB 值，其中 1MB 等于 1024 x 1024 字节。</li>
<li>将新数据文件附加到 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_file_path"><code>innodb_data_file_path</code></a> 设置，可选择指定<code>autoextend</code>属性。<code>autoextend</code>只能为 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_file_path"><code>innodb_data_file_path</code></a>设置中的最后一个数据文件指定该属性。</li>
<li>启动 MySQL 服务器。</li>
</ol>
<p>例如，这个表空间有一个自动扩展的数据文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">innodb_data_home_dir</span> =<span class="string"></span></span><br><span class="line"><span class="attr">innodb_data_file_path</span> = <span class="string">/ibdata/ibdata1:10M:autoextend</span></span><br></pre></td></tr></table></figure>
<p>假设数据文件随时间增长到 988MB。这是<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_file_path"><code>innodb_data_file_path</code></a> 修改 size 属性以反映当前数据文件大小后的设置，并在指定新的 50MB 自动扩展数据文件后：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">innodb_data_home_dir</span> =<span class="string"></span></span><br><span class="line"><span class="attr">innodb_data_file_path</span> = <span class="string">/ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend</span></span><br></pre></td></tr></table></figure>
<p>添加新数据文件时，请勿指定现有文件名。<code>InnoDB</code>在您启动服务器时创建并初始化新的数据文件。</p>
<h5 id="减少-InnoDB-系统表空间的大小">减少 InnoDB 系统表空间的大小</h5>
<p>不支持减小现有系统表空间的大小。实现更小的系统表空间的唯一选择是将数据从备份恢复到使用所需系统表空间大小配置创建的新 MySQL 实例。</p>
<p>有关创建备份的信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-backup.html">第 15.18.1 节，“InnoDB 备份”</a>。</p>
<p>有关为新系统表空间配置数据文件的信息。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration">系统表空间数据文件配置</a>。</p>
<p>为避免使用大型系统表空间，请考虑为您的数据使用 <code>file-per-table</code> 表空间或通用表空间。<code>File-per-table</code> 表空间是默认的表空间类型，在创建<code>InnoDB</code> 表时隐式使用。与系统表空间不同，每个表的文件表空间在被截断或删除时将磁盘空间返回给操作系统。通用表空间是多表表空间，也可以用作系统表空间的替代。见 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/general-tablespaces.html">第 15.6.3.3 节，“通用表空间”</a>。</p>
<h3 id="File-Per-Table-表空间">File-Per-Table 表空间</h3>
<p>每个表的文件表空间包含单个<code>InnoDB</code>表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p>
<h4 id="File-Per-Table-表空间配置">File-Per-Table 表空间配置</h4>
<p><code>InnoDB</code>默认情况下，在 <code>file-per-table</code> 表空间中创建表。此行为由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a>变量控制 。禁用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a> 导致<code>InnoDB</code>在系统表空间中创建表。</p>
<p>的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a> 设置可以在选项文件来指定，或者使用在运行时配置的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/set-variable.html"><code>SET GLOBAL</code></a>语句。在运行时更改设置需要足够的权限来设置全局系统变量。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/system-variable-privileges.html">第 5.1.9.1 节，“系统变量权限”</a>。</p>
<p>选项文件：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_file_per_table</span>=<span class="literal">ON</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/set-variable.html"><code>SET GLOBAL</code></a>运行时 使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_file_per_table<span class="operator">=</span><span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>
<h4 id="File-Per-Table-表空间数据文件">File-Per-Table 表空间数据文件</h4>
<p>在 MySQL 数据目录下的架构目录中的 <code>.idb</code> 数据文件中创建一个 <code>file-per-table</code> 表空间。该<code>.ibd</code>文件以表 ( <code>*</code>table_name<code>*.ibd</code>)命名。例如，例如在 MySQL 数据目录下的 <code>test</code> 目录下创建表 <code>test.t1</code> 的数据文件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> USE test;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">   id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">   name <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line"> ) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line">shell<span class="operator">&gt;</span> cd <span class="operator">/</span>path<span class="operator">/</span><span class="keyword">to</span><span class="operator">/</span>mysql<span class="operator">/</span>data<span class="operator">/</span>test</span><br><span class="line">shell<span class="operator">&gt;</span> ls</span><br><span class="line">t1.ibd</span><br></pre></td></tr></table></figure>
<p>您可以使用 <code>CREATE TABLE</code> 语句的 <code>DATA DIRECTORY</code> 子句在数据目录之外隐式地创建一个 <code>file-per-table</code> 表空间数据文件。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-create-table-external.html">第 15.6.1.2 节，“在外部创建表”</a>。</p>
<h4 id="File-Per-Table-表空间优势">File-Per-Table 表空间优势</h4>
<p><code>File-per-table</code> 表空间与共享表空间（例如系统表空间或通用表空间）相比具有以下优势。</p>
<ul>
<li>截断或删除在 file-per-table 表空间中创建的表后，磁盘空间将返回给操作系统。截断或删除存储在共享表空间中的表会在共享表空间数据文件中创建空闲空间，该空间只能用于 <code>InnoDB</code>数据。换句话说，共享表空间数据文件在表被截断或删除后不会缩小。</li>
<li>对位于共享表空间中的表进行表复制 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a> 操作会增加表空间占用的磁盘空间量。此类操作可能需要与表中的数据加上索引一样多的额外空间。该空间不会像用于 file-per-table 表空间那样释放回操作系统。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/truncate-table.html"><code>TRUNCATE TABLE</code></a> 在驻留在 file-per-table 表空间中的表上执行时，性能更好。</li>
<li>File-per-table 表空间数据文件可以在单独的存储设备上创建，用于 I/O 优化、空间管理或备份目的。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-create-table-external.html">第 15.6.1.2 节，“在外部创建表”</a>。</li>
<li>您可以从另一个 MySQL 实例导入驻留在 file-per-table 表空间中的表。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-table-import.html">第 15.6.1.3 节，“导入 InnoDB 表”</a>。</li>
<li>在 file-per-table 表空间中创建的表支持<code>DYNAMIC</code>与 <code>COMPRESSED</code>行格式相关的功能，而系统表空间不支持这些功能。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html">第 15.10 节，“InnoDB 行格式”</a>。</li>
<li>当发生数据损坏、备份或二进制日志不可用或 MySQL 服务器实例无法重新启动时，存储在单个表空间数据文件中的表可以节省时间并提高成功恢复的机会。</li>
<li>可以使用 MySQL Enterprise Backup 快速备份或恢复在 file-per-table 表空间中创建的表，而不会中断其他<code>InnoDB</code>表的使用 。这对于备份计划不同或需要较少备份的表很有用。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/partial.html">进行部分备份</a>。</li>
<li>File-per-table 表空间允许通过监视表空间数据文件的大小来监视文件系统上的表大小。</li>
<li>当 <code>innodb_flush_method</code> 设置为 <code>O_DIRECT</code> 时，常见的 Linux 文件系统不允许并发写入单个文件，例如共享表空间数据文件。因此，结合此设置使用每个表的文件表空间时，可能会提高性能。</li>
<li>共享表空间中的表的大小受 64TB 表空间大小限制。相比之下，每个表每个文件的表空间都有 64TB 的大小限制，这为单个表的大小增长提供了足够的空间。</li>
</ul>
<h4 id="File-Per-Table-表空间的缺点">File-Per-Table 表空间的缺点</h4>
<p>与共享表空间（例如系统表空间或通用表空间）相比，File-Per-Table 文件表空间具有以下缺点。</p>
<ul>
<li>使用 file-per-table 表空间，每个表可能有未使用的空间，只能由同一表的行使用，如果管理不当，可能会导致空间浪费。</li>
<li><code>fsync</code>操作是在多个 file-per-table 数据文件而不是单个共享表空间数据文件上执行的。由于 <code>fsync</code>操作是针对每个文件的，因此无法合并多个表的写操作，这会导致<code>fsync</code> 操作总数更高。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqld.html"><strong>mysqld</strong></a> 必须为每个 file-per-table 表空间保留一个打开的文件句柄，如果在 file-per-table 表空间中有多个表，这可能会影响性能。</li>
<li>当每个表都有自己的数据文件时，需要更多的文件描述符。</li>
<li>存在更多碎片的可能性，这会阻碍<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/drop-table.html"><code>DROP TABLE</code></a>和表扫描性能。但是，如果管理碎片，每个表的文件表空间可以提高这些操作的性能。</li>
<li>删除驻留在 file-per-table 表空间中的表时会扫描缓冲池，这对于大型缓冲池可能需要几秒钟。使用广泛的内部锁执行扫描，这可能会延迟其他操作。</li>
<li>该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoextend_increment"><code>innodb_autoextend_increment</code></a> 变量定义了在自动扩展共享表空间文件变满时扩展其大小的增量大小，不适用于 file-per-table 表空间文件，这些文件无论<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_autoextend_increment"><code>innodb_autoextend_increment</code></a> 如何设置都会自动扩展。每个表的初始文件表空间扩展是少量的，之后扩展以 4MB 的增量发生。</li>
</ul>
<h2 id="通用表空间-General-Tablespaces">通用表空间 - General Tablespaces</h2>
<p>通用表空间是<code>InnoDB</code> 使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-tablespace.html"><code>CREATE TABLESPACE</code></a>语法创建的共享表空间。本节的以下主题中描述了常规表空间功能和特性：</p>
<h3 id="通用表空间功能">通用表空间功能</h3>
<p>通用表空间提供以下功能：</p>
<ul>
<li>与系统表空间类似，通用表空间是能够为多个表存储数据的共享表空间。</li>
<li>通用表空间比 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-file-per-table-tablespaces.html">file-per-table 表</a>空间具有潜在的内存优势 。服务器在表空间的生命周期内将表空间元数据保存在内存中。与在每个单独的文件表空间中的相同数量的表相比，较少的通用表空间中的多个表为表空间元数据消耗的内存更少。</li>
<li>通用表空间数据文件可以放在一个相对于或独立于 MySQL 数据目录的目录中，它为您提供了许多和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-file-per-table-tablespaces.html">File-Per-Table 表空间</a>的数据文件和存储管理一样的能力 。与 file-per-table 表空间一样，比如将数据文件放置在 MySQL 数据目录之外的能力允许您单独管理关键表的性能，为特定表设置 RAID 或 DRBD，或将表绑定到特定磁盘。</li>
<li>通用表空间支持所有表行格式和相关功能。</li>
<li><code>TABLESPACE</code> 选项可以与 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a> 一起使用，以在通用表空间、每个表文件表空间或系统表空间中创建表。</li>
<li><code>TABLESPACE</code>选项可以与 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a> 一起使用，在通用表空间、每个表文件表空间和系统表空间之间移动表。</li>
</ul>
<h3 id="创建通用表空间">创建通用表空间</h3>
<p>通用表空间是使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-tablespace.html"><code>CREATE TABLESPACE</code></a>语法创建的 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE tablespace_name</span><br><span class="line">    [<span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span>]</span><br><span class="line">    [FILE_BLOCK_SIZE <span class="operator">=</span> <span class="keyword">value</span>]</span><br><span class="line">        [ENGINE [<span class="operator">=</span>] engine_name]</span><br></pre></td></tr></table></figure>
<p>可以在数据目录中或外部创建通用表空间。为避免与隐式创建的 file-per-table 表空间冲突，不支持在数据目录下的子目录中创建通用表空间。在数据目录之外创建通用表空间时，该目录必须存在并且必须<code>InnoDB</code>在创建表空间之前已知 。要使 <code>InnoDB</code> 知道未知目录，请将目录添加到 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories"><code>innodb_directories</code></a>参数值中。<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories"><code>innodb_directories</code></a>是只读启动选项。配置它需要重新启动服务器。</p>
<p>例子：</p>
<p>在数据目录中创建通用表空间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE `ts1` <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;ts1.ibd&#x27;</span> Engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE `ts1` Engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>该<code>ADD DATAFILE</code>子句从 MySQL 8.0.14 开始是可选的，在此之前是必需的。如果<code>ADD DATAFILE</code>在创建表空间时未指定该子句，则会隐式创建具有唯一文件名的表空间数据文件。唯一的文件名是一个 128 位的 UUID，它被格式化为五组由破折号 ( <em><code>aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee</code></em>)分隔的十六进制数字。通用表空间数据文件包括 <code>.ibd</code>文件扩展名。在复制环境中，在源上创建的数据文件名与在副本上创建的数据文件名不同。</p>
<p>在数据目录之外的目录中创建通用表空间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE `ts1` <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;/my/tablespace/directory/ts1.ibd&#x27;</span> Engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<p>只要表空间目录不在数据目录下，就可以指定相对于数据目录的路径。在此示例中， <code>my_tablespace</code>目录与数据目录处于同一级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE `ts1` <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;../my_tablespace/ts1.ibd&#x27;</span> Engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注<br>
该<code>ENGINE = InnoDB</code>子句必须定义为<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-tablespace.html"><code>CREATE TABLESPACE</code></a>语句的一部分，或者<code>InnoDB</code> 必须定义为默认存储引擎 ( <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_default_storage_engine"><code>default_storage_engine=InnoDB</code></a>)。</p>
</blockquote>
<h3 id="将表添加到通用表空间">将表添加到通用表空间</h3>
<p>创建通用表空间后，可以使用 <code>CREATE TABLE tbl_name ... TABLESPACE [=] tablespace_name</code> 或 <code>ALTER TABLE tbl_name TABLESPACE [=] tablespace_name</code> 语句向表空间添加表，如下例所示：</p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY) TABLESPACE ts1;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t2 TABLESPACE ts1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注</p>
<p>支持将表分区添加到共享表空间在 MySQL 5.7.24 中已弃用，并在 MySQL 8.0.13 中删除。共享表空间包括 InnoDB 系统表空间和通用表空间。</p>
</blockquote>
<p>有关详细的语法信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/create-table.html"><code>CREATE TABLE</code></a>和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a>。</p>
<h3 id="通用表空间限制">通用表空间限制</h3>
<ul>
<li>
<p>生成的或现有的表空间不能更改为通用表空间。</p>
</li>
<li>
<p>不支持创建临时通用表空间。</p>
</li>
<li>
<p>通用表空间不支持临时表。</p>
</li>
<li>
<p>与系统表空间类似，截断或删除存储在通用表空间中的表会在通用表空间<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_ibd_file">.ibd 数据文件</a>内部创建仅可用于新<code>InnoDB</code>数据的可用空间 。空间不会释放回操作系统。</p>
<p>此外，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a>对位于共享表空间（通用表空间或系统表空间）中的表进行表复制操作可能会增加表空间使用的空间量。此类操作需要与表中的数据加上索引一样多的额外空间。表复制<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE</code></a> 操作所需的额外空间不会像每个表文件表空间那样释放回操作系统。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE ... DISCARD TABLESPACE</code></a>并且 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table.html"><code>ALTER TABLE ...IMPORT TABLESPACE</code></a>不支持属于通用表空间的表。</p>
</li>
<li>
<p>在 MySQL 5.7.24 中不推荐使用对将表分区放置在通用表空间中的支持，并在 MySQL 8.0.13 中删除。</p>
</li>
<li>
<p>在源和副本驻留在同一主机上的复制环境中，不支持 <code>ADD DATAFILE</code> 子句，因为它会导致源和副本在同一位置创建同名表空间，但是，如果省略该 <code>ADD DATAFILE</code> 子句，则在数据目录中创建表空间，生成的文件名是唯一的，这是允许的。</p>
</li>
<li>
<p>从 MySQL 8.0.21 开始，除非 InnoDB 直接知道该目录，否则不能在撤消表空间目录 ( <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_undo_directory"><code>innodb_undo_directory</code></a>) 中创建通用表空间。InnoDB 已知的目录包括那些被定义的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_datadir"><code>datadir</code></a>， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir</code></a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories"><code>innodb_directories</code></a> 变量。</p>
</li>
</ul>
<h2 id="撤销表空间-Undo-Tablespaces">撤销表空间 - Undo Tablespaces</h2>
<p>撤消表空间包含撤消日志（undo log），这是包含有关如何撤消事务对聚集索引记录的最新更改的信息的记录集合。</p>
<h3 id="默认撤消表空间">默认撤消表空间</h3>
<p>初始化 MySQL 实例时会创建两个默认的 undo 表空间。默认撤消表空间在初始化时创建，为在接受 SQL 语句之前必须存在的回滚片段提供位置。至少需要两个撤消表空间来支持撤消表空间的自动截断。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html#truncate-undo-tablespace">截断撤消表空间</a>。</p>
<p>默认撤消表空间在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_undo_directory"><code>innodb_undo_directory</code></a> 变量定义的位置创建。如果 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_undo_directory"><code>innodb_undo_directory</code></a>变量未定义，则在数据目录中创建默认的撤消表空间。默认撤消表空间数据文件命名为 <code>undo_001</code>和<code>undo_002</code>。数据字典中定义的对应撤销表空间名称是<code>innodb_undo_001</code>和 <code>innodb_undo_002</code>。</p>
<p>从 MySQL 8.0.14 开始，可以在运行时使用 SQL 创建额外的撤消表空间。请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html#innodb-add-undo-tablespaces">添加撤消表空间</a>。</p>
<h3 id="撤消表空间大小">撤消表空间大小</h3>
<p>在 MySQL 8.0.23 之前，undo 表空间的初始大小取决于<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size"><code>innodb_page_size</code></a> 值。对于默认的 16KB 页面大小，初始撤消表空间文件大小为 10MiB。对于 4KB、8KB、32KB 和 64KB 页面大小，初始撤消表空间文件大小分别为 7MiB、8MiB、20MiB 和 40MiB。从 MySQL 8.0.23 开始，初始撤消表空间大小通常为 16MiB。当通过截断操作创建新的撤消表空间时，初始大小可能会有所不同。在这种情况下，如果文件扩展名大于 16MB，并且前一个文件扩展名发生在最后一秒内，则新的撤消表空间将创建为<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_max_undo_log_size"><code>innodb_max_undo_log_size</code></a> 变量定义的大小的四分之一 。</p>
<p>在 MySQL 8.0.23 之前，undo 表空间一次扩展四个区。从 MySQL 8.0.23 开始，undo 表空间至少扩展了 16MB。为了应对急剧增长，如果前一个文件扩展名发生的时间少于 0.1 秒，则文件扩展名大小会加倍。扩展大小的两倍可以发生多次，最大为 256MB。如果前一个文件扩展名早于 0.1 秒出现，则扩展名大小将减少一半，也可能多次出现，最小为 16MB。如果该 <code>AUTOEXTEND_SIZE</code>选项是为撤销表空间定义的，则它会被扩展 <code>AUTOEXTEND_SIZE</code>设置和扩展大小由上述逻辑确定。有关该<code>AUTOEXTEND_SIZE</code>选项的信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-tablespace-autoextend-size.html">第 15.6.3.9 节，“表空间 AUTOEXTEND_SIZE 配置”</a>。</p>
<h2 id="临时表空间-Temporary-Tablespaces">临时表空间 - Temporary Tablespaces</h2>
<p><code>InnoDB</code> 使用会话临时表空间和全局临时表空间。</p>
<h3 id="会话临时表空间">会话临时表空间</h3>
<p>当 <code>InnoDB</code> 被配置为磁盘内部临时表的存储引擎时，会话临时表空间存储用户创建的临时表和优化器创建的内部临时表。从 MySQL 8.0.16 开始，用于磁盘内部临时表的存储引擎是<code>InnoDB</code>. （以前，存储引擎由 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine"><code>internal_tmp_disk_storage_engine</code></a> 的值决定。）</p>
<p>会话临时表空间在第一次请求创建磁盘临时表时从临时表空间池中分配给会话。一个会话最多分配两个表空间，一个用于用户创建的临时表，另一个用于优化器创建的内部临时表。分配给会话的临时表空间用于会话创建的所有磁盘临时表。当会话断开连接时，其临时表空间被截断并释放回池中。服务器启动时会创建一个包含 10 个临时表空间的池。池的大小永远不会缩小，并且表空间会根据需要自动添加到池中。在正常关闭或中止初始化时删除临时表空间池。会话临时表空间文件在创建时大小为五页，并且具有<code>.ibt</code> 文件扩展名。</p>
<p>为会话临时表空间保留了 40 万个空间 ID。因为每次服务器启动时都会重新创建会话临时表空间池，所以当服务器关闭时会话临时表空间的空间 ID 不会保留，并且可能会被重用。</p>
<p>该<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_temp_tablespaces_dir"><code>innodb_temp_tablespaces_dir</code></a> 变量定义了创建会话临时表空间的位置。默认位置是 <code>#innodb_temp</code> 数据目录中的目录。如果无法创建临时表空间池，则拒绝启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell&gt; cd BASEDIR/data/#innodb_temp</span><br><span class="line">shell&gt; ls</span><br><span class="line">temp_10.ibt  temp_2.ibt  temp_4.ibt  temp_6.ibt  temp_8.ibt</span><br><span class="line">temp_1.ibt   temp_3.ibt  temp_5.ibt  temp_7.ibt  temp_9.ibt</span><br></pre></td></tr></table></figure>
<p>在基于语句的复制 (SBR) 模式下，在副本上创建的临时表驻留在单个会话临时表空间中，该表空间仅在 MySQL 服务器关闭时被截断。</p>
<p>该<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-session-temp-tablespaces-table.html"><code>INNODB_SESSION_TEMP_TABLESPACES</code></a> 表提供有关会话临时表空间的元数据。</p>
<p>该 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-temp-table-info-table.html"><code>INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO</code></a> 表提供有关在<code>InnoDB</code>实例中处于活动状态的用户创建的临时表的元数据。</p>
<h3 id="全局临时表空间">全局临时表空间</h3>
<p>全局临时表空间 ( <code>ibtmp1</code>) 存储对用户创建的临时表所做更改的回滚片段。</p>
<p>该<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_temp_data_file_path"><code>innodb_temp_data_file_path</code></a> 变量定义了全局临时表空间数据文件的相对路径、名称、大小和属性。如果没有为 <code>innodb_temp_data_file_path</code> 指定值，默认行为是在 <code>innodb_data_home_dir</code> 目录中创建一个名为 <code>ibtmp1</code> 的自动扩展数据文件。初始文件大小略大于 12MB。</p>
<p>全局临时表空间在正常关闭或中止初始化时被删除，并在每次服务器启动时重新创建。全局临时表空间在创建时会收到一个动态生成的空间 ID。如果无法创建全局临时表空间，则拒绝启动。如果服务器意外停止，则不会删除全局临时表空间。在这种情况下，数据库管理员可以手动删除全局临时表空间或重新启动 MySQL 服务器。重新启动 MySQL 服务器会自动删除并重新创建全局临时表空间。</p>
<p>全局临时表空间不能驻留在原始设备上。</p>
<h2 id="双写缓冲区-Doublewrite-Buffer">双写缓冲区 - Doublewrite Buffer</h2>
<p>双写缓冲区是一个存储区域，在 <code>InnoDB</code>将页写入<code>InnoDB</code>数据文件中的适当位置之前，从缓冲池中写入页面 。如果在页面写入过程中存在操作系统、存储子系统或意外的 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqld.html"><strong>mysqld</strong></a> 进程退出，则 <code>InnoDB</code>可以在崩溃恢复期间从双写缓冲区中找到该页面的良好副本。</p>
<p>虽然数据被写入两次，但双写缓冲区不需要两倍的 I/O 开销或两倍的 I/O 操作。数据以一个大的顺序块写入双写缓冲区，只需<code>fsync()</code>调用一次操作系统（<code>innodb_flush_method</code>设置为<code>O_DIRECT_NO_FSYNC</code>的情况除外）。</p>
<p>在 MySQL 8.0.20 之前，doublewrite 缓冲区存储区位于<code>InnoDB</code>系统表空间中。从 MySQL 8.0.20 开始，双写缓冲区存储区域位于双写文件中。</p>
<h2 id="重做日志-Redo-Log">重做日志 - Redo Log</h2>
<p>重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间纠正不完整事务写入的数据。在正常操作期间，重做日志对由 SQL 语句或低级 API 调用产生的更改表数据的请求进行编码。在初始化期间和接受连接之前，会自动重放在意外关闭之前未完成更新数据文件的修改。有关重做日志在崩溃恢复中的作用的信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-recovery.html">第 15.18.2 节，“InnoDB 恢复”</a>。</p>
<p>默认情况下，重做日志在磁盘上由两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>物理文件表示。MySQL 以循环方式写入重做日志文件。重做日志中的数据根据受影响的记录进行编码；这些数据统称为重做。通过重做日志的数据通道由不断增加的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_lsn">LSN</a>值表示。</p>
<h2 id="撤销日志-Undo-Log">撤销日志 - Undo Log</h2>
<p>撤消日志是与单个读写事务相关联的撤消日志记录的集合。撤消日志记录包含有关如何撤消事务对<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_clustered_index">聚集索引</a>记录的最新更改的信息。如果另一个事务需要查看原始数据作为一致性读取操作的一部分，则未修改的数据将从撤消日志记录中检索。撤消日志存在于 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log_segment">撤消日志段中</a>，而<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log_segment">撤消日志段</a>包含在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_rollback_segment">回滚段中</a>。回滚段驻留在<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_tablespace">撤销表空间</a>和<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_global_temporary_tablespace">全局临时表空间中</a>。</p>
<p>驻留在全局临时表空间中的撤消日志用于修改用户定义临时表中数据的事务。这些撤消日志不会被重做日志，因为它们不是崩溃恢复所必需的。它们仅用于在服务器运行时回滚。这种类型的撤消日志通过避免重做日志记录 I/O 来提高性能。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDb</tag>
        <tag>Redo Log</tag>
        <tag>Undo Log</tag>
        <tag>Buffer Pool</tag>
        <tag>Change Buffer</tag>
        <tag>Doublewrite Buffer Files</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Explain 执行计划解释</title>
    <url>/persistence/db/MySQL-Explain/</url>
    <content><![CDATA[<h1>理解查询执行计划</h1>
<p><img data-src="../../../images/db/mysql_arthitecture.png" alt="MySQL Architecture"></p>
<p><img data-src="../../../images/db/mysql-architecture.png" alt="MySQL architecture diagram showing connectors, interfaces, pluggable storage engines, the file system with files and logs."></p>
<p>根据你的表，列，索引的细节，你的 WHERE 子句中的条件，MySQL 优化器（Optimizer） 考虑多种技术来有效地执行 SQL 查询中涉及的查找。可以在不读取所有行的情况下执行对大表的查询；可以在不比较每个行组合的情况下执行涉及多个表的连接。优化器选择执行最有效查询的一组操作称为“查询执行计划”，也称为 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html"><code>EXPLAIN</code></a> 计划。您的目标是识别 <code>EXPLAIN</code> 计划中表明查询优化良好的方面，并学习 SQL 语法和索引技术以在您发现一些低效操作时改进计划。</p>
<span id="more"></span>
<h2 id="EXPLAIN-简介">EXPLAIN 简介</h2>
<p><code>EXPLAIN</code> 语句提供有关 MySQL 如何执行语句的信息，MySQL 解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。EXPLAIN 可以与 SELECT，DELETE，INSERT，REPLACE 和 UPDATE 语句一起使用。</p>
<p>在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 的帮助下，您可以看到应该在表中添加索引的位置，以便通过使用索引查找行来使语句更快地执行。您还可以使用 EXPLAIN 检查优化器是否以最佳顺序连接表。</p>
<blockquote>
<p>EXPLAIN 也可用于获取有关表中各列的信息。 EXPLAIN <em><strong>tbl_name</strong></em> 与 DESCRIBE <em><strong>tbl_name</strong></em> 和 SHOW COLUMNS FROM <em><strong>tbl_name</strong></em> 相同。</p>
</blockquote>
<p>以下示例中的表使用 MySQL <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">Sakila 示例数据库</a>。</p>
<p>EXPLAIN 的输出总是有相同的列。可变的是行数及内容。下表汇总这些列及它的简介，在接下来的小节中，我们将展示在 EXPLAIN 结果中每一列的意义。记住，输出中的行以 MySQL 实际执行的查询部分的顺序出现，而这个顺序不总是与其在原始 SQL 中的相一致。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Column</th>
<th style="text-align:left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id"><code>id</code></a></td>
<td style="text-align:left"><code>SELECT</code> 编号</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type"><code>select_type</code></a></td>
<td style="text-align:left"><code>SELECT</code> 类型</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table"><code>table</code></a></td>
<td style="text-align:left">该行的表名</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions"><code>partitions</code></a></td>
<td style="text-align:left">匹配的分区</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type"><code>type</code></a></td>
<td style="text-align:left">关联类型</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td>
<td style="text-align:left">可能用到的索引</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key"><code>key</code></a></td>
<td style="text-align:left">实际用到的索引</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len"><code>key_len</code></a></td>
<td style="text-align:left">实际用到索引的键长度</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref"><code>ref</code></a></td>
<td style="text-align:left">与索引进行比较的列名</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows"><code>rows</code></a></td>
<td style="text-align:left">估算要检查的行数</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered"><code>filtered</code></a></td>
<td style="text-align:left">按表条件过滤的行百分比</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra"><code>Extra</code></a></td>
<td style="text-align:left">附加信息</td>
</tr>
</tbody>
</table>
<h2 id="id-列">id 列</h2>
<p>这一列总是包含一个编号，标识 SELECT 所属的行。如果在语句当中没有子査询或联合，那么只会有唯一的 SELECT，于是每一行在这个列中都将显示一个 1。否则，内层的 SELECT 语句一般会顺序编号，对应于其在原始语句中的位置。<br>
MYSQL 将 SELECT 査询分为简单和复杂类型，复杂类型可分成三大类：简单子査询、所谓的派生表(在 FROM 子句中的子査询)，以及 UNION 查询。下面是一个简单的子査询：</p>
<blockquote>
<p>id 的值代表 SELECT 在原 SQL 中的顺序，id 的顺序代表执行计划的顺序。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT (SELECT 1 FROM sakila.actor LIMIT 1) FROM sakila.film;</span></span><br><span class="line">+----+-------------+....</span><br><span class="line">| id | select_type |....</span><br><span class="line">+----+-------------+....</span><br><span class="line">|  1 | PRIMARY     |....</span><br><span class="line">|  2 | SUBQUERY    |....</span><br><span class="line">+----+-------------+....</span><br></pre></td></tr></table></figure>
<p>FROM 子句中的子査询和联合增加了 id 列的复杂性。下面是一个 FROM 子句中的基本子査询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT film_id FROM (SELECT film_id from sakila.film LIMIT 10) as der;</span></span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">| id | select_type | table      |...</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; |...</span><br><span class="line">|  2 | DERIVED     | film       |...</span><br><span class="line">+----+-------------+------------+...</span><br></pre></td></tr></table></figure>
<p>如你所知，这个查询执行时有一个匿名临时表。 MySQL 内部通过别名（der）在外层查询中引用这个临时表，在更复杂的査询中可以看到 ref 列。</p>
<p>最后，下面是一个 UNION 查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT 1 UNION SELECT 1;</span></span><br><span class="line">+------+--------------+------------+...</span><br><span class="line">|  id  | select_type  | table      |...</span><br><span class="line">+------+--------------+------------+...</span><br><span class="line">|  1   | PRIMARY      | NULL       |...</span><br><span class="line">|  2   | UNION        | NULL       |...</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; |...</span><br><span class="line">+------+--------------+------------+...</span><br></pre></td></tr></table></figure>
<p>注意 UNION 结果输出中的额外行。 UNION 结果总是放在一个匿名临时表中，之后 MySQL 将结果读取到临时表外。临时表并不在原 SQL 中出现，因此它的 id 列是 NULL。与之前的例子相比（演示子査询的那个 FROM 子句中），从这个査询产生的临时表在结果中出现在最后一行，而不是第一行。</p>
<p>上面只是简单语句，但这三类语句的混合则会使输出变得非常复杂，后面我们会看到。</p>
<h2 id="select-type-列">select_type 列</h2>
<p>这一列显示了对应行是简单还是复杂 SELECT（如果是后者，那么是三种复杂类型中的哪一种)。 可能的值如下：</p>
<h3 id="SIMPLE"><code>SIMPLE</code></h3>
<p>SIMPLE 值意味着查询不包括子査询和  UNION。</p>
<h3 id="PRIMARY"><code>PRIMARY</code></h3>
<p>如果査询有任何复杂的子部分，则最外层部分标记为 PRIMARY，其他部分标记如下。</p>
<h3 id="SUBQUERY"><code>SUBQUERY</code></h3>
<p>包含在 SELECT 列表中的子査询中的 SELECT (换句话说，不在 FROM 子句中)标记为 SUBOUERY。</p>
<h3 id="DERIVED"><code>DERIVED</code></h3>
<p>DERIVED 值用来表示包含在 FROM 子句的子査询中的 SELECT，MySQL 会递归执行并将结果放到一个临时表中。服务器内部称其“派生表”，因为该临时表是从子査询中派生来的。</p>
<h3 id="UNION"><code>UNION</code></h3>
<p>在 UNION 中的第二个和随后的 SELECT 被标记为 UNION。</p>
<blockquote>
<p>UNION 和 UNION DISTINCT 同义，会删除重复行。UNION ALL 不会删除重复行。</p>
</blockquote>
<h3 id="UNION-RESULT"><code>UNION RESULT</code></h3>
<p>用来从 UNION 的匿名临时表检索结果的 SELECT 被标记为 UNION RESULT。</p>
<h3 id="其它-2">其它</h3>
<p>除了这些值，SUBQUERY 和 UNI0N 还可以被标记为 <code>DEPENDENT</code> 和 <code>UNCACHEABLE</code>。 DEPENDENT 意味着 SELECT 依赖于外层査询中发现的数据，UNCACHEABLE 意味着 SELECT 中的某些特性阻止结果被缓存于ー个 Item cache 中。（ Item cache 未被文档记载，它与査询缓存不是一回事，尽管它可以被一些相同类型的构件否定，例如 RAND() 函数。)</p>
<h2 id="table-列">table 列</h2>
<p>这一列显示了对应行正在访问哪个表。在通常情况下，它相当明了：它就是那个表，或是该表的别名(如果 SQL 中定义了别名)。</p>
<p>可以在这一列中从上往下观察 MySQL 的关联优化器为査询选择的关联顺序。例如，可以看到在下面的査询中 MySQL 选择的关联顺序不同于语句中所指定的顺序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT film.film_id</span></span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor USING (actor_id);</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">| id | select_type | table      |...</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">|  1 | SIMPLE      | actor      |...</span><br><span class="line">|  1 | SIMPLE      | film_actor |...</span><br><span class="line">|  1 | SIMPLE      | film       |...</span><br><span class="line">+----+-------------+------------+...</span><br></pre></td></tr></table></figure>
<p>MySQL 的査询执行计划总是左侧深度优先树。如果把这个计划放倒，就能按顺序读出叶子节点，它们直接对应于 EXPLAIN 中的行。之前的査询计划看起来如图所示。</p>
<p><img data-src="../../../images/db/explain-left-deep.jpg" alt="left-deep"></p>
<blockquote>
<p>在 SELECT 后加入指示 <code>STRAIGHT_JOIN</code> 会要求 Mysql 按指定顺序进行连接，但是这也会丧失自动优化的好处。</p>
</blockquote>
<h3 id="派生表和联合">派生表和联合</h3>
<p>当 FROM 子句中有子査询或有 UNION 时，table 列会变得复杂得多。在这些场景下，确实没有一个“表”可以参考到，因为  MySQL 创建的匿名临时表仅在査询执行过程中存在。<br>
当在 FROM 子句中有子査询时，table 列是&lt;derived<em>N</em>&gt;的形式，其中 N 是子査询的 id。这总是“向前引用”一换言之，N 指向 EXPLAIN 输出中后面的一行。<br>
当有 UNION 时，UNION RESULT 的 table 列包含一个参与 UNION 的 id 列表。这总是“向后引用”，因为 UNION RESULT 出现在 UION 中所有参与行之后。如果在列表中有超过 20 个 id， table 列可能被截断以防止太长，此时不可能看到所有的值。幸运的是，仍然可以推测包括哪些行，因为你可以看到第一行的 id。在这一行和 UNION RESULT 之间出现的一切都会以某种方式被包含。</p>
<p>下面是一个无意义的査询，我们这里把它用作某种复杂 SELECT 类型的紧凑示例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1   EXPLAIN</span><br><span class="line">2   SELECT actor_id,</span><br><span class="line">3          (SELECT 1 FROM sakila.film_actor WHERE film_actor.actor_id =</span><br><span class="line">4                                                 der_1.actor_id LIMIT 1)</span><br><span class="line">5   FROM (</span><br><span class="line">6       SELECT actor_id</span><br><span class="line">7       FROM sakila.actor LIMIT 5</span><br><span class="line">8   ) AS der_1</span><br><span class="line">9   UNION</span><br><span class="line">10  SELECT film_id,</span><br><span class="line">11         (SELECT @var1 FROM sakila.rental LIMIT 1)</span><br><span class="line">12  FROM (</span><br><span class="line">13      SELECT film_id,</span><br><span class="line">14             (SELECT 1 FROM sakila.store LIMIT 1)</span><br><span class="line">15      FROM sakila.film LIMIT 5</span><br><span class="line">16  ) AS der_2;</span><br></pre></td></tr></table></figure>
<p>下面是 EXPLAIN 的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+------+----------------------+------------+...</span><br><span class="line">| id   | select_type          | table      |...</span><br><span class="line">+------+----------------------+------------+...</span><br><span class="line">|  1   | PRIMARY              | &lt;derived3&gt; |...</span><br><span class="line">|  3   | DERIVED              | actor      |...</span><br><span class="line">|  2   | DEPENDENT SUBQUERY   | film_actor |...</span><br><span class="line">|  4   | UNION                | &lt;derived6&gt; |...</span><br><span class="line">|  6   | DERIVED              | film       |...</span><br><span class="line">|  7   | SUBQUERY             | store      |...</span><br><span class="line">|  5   | UNCACHEABLE SUBQUERY | rental     |...</span><br><span class="line">| NULL | UNION RESULT         | &lt;union1,4&gt; |...</span><br><span class="line">+------+----------------------+------------+...</span><br></pre></td></tr></table></figure>
<h2 id="type-列">type 列</h2>
<p>MySQL 用户手册上说这一列显示了“关联类型”，但我们认为更准确的说法是访问类型一一换言之就是 MySQL 决定如何查找表中的行。下面是最重要的访问方法，依次从最优到最差。</p>
<h3 id="NULL"><code>NULL</code></h3>
<p>这种访问方式意味着 MySQL 能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。例如，从一个索引列里选取最小值可以通过单独查找索引来完成，不需要在执行时访问表。</p>
<h3 id="const-system"><code>const, system</code></h3>
<p>当 MySQL 能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型。举例来说，如果你通过将某一行的主键放入 WHERE 子句里的方式来选取此行的主键，MySQL 就能把这个查询转换为一个常量。然后就可以高效地将表从联接执行中移除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT * FROM sakila.film WHERE film_id = 1;</span>     </span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br><span class="line">| id | select_type | table | partitions | type  |...</span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br><span class="line">|  1 | SIMPLE      | film  | NULL       | const |...</span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br></pre></td></tr></table></figure>
<p><code>system</code>是 const 的特例，<strong>对应于系统表的数据过滤</strong>。</p>
<h3 id="eq-ref"><code>eq_ref</code></h3>
<p>使用这种索引査找，MySQL 知道最多只返回一条符合条件的记录。这种访问方法可以在 MySQL 使用<strong>主键或者唯一性索引</strong>査找时看到，它会将它们与某个参考值做比较。MySQL 对于这类访问类型的优化做得非常好，因为它知道无须估计匹配行的范围或在找到匹配行后再继续査找。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN</span></span><br><span class="line">    -&gt; SELECT film.film_id</span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor USING (actor_id);</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br><span class="line">| id | select_type | table      | partitions | type   |...</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br><span class="line">|  1 | SIMPLE      | actor      | NULL       | index  |...</span><br><span class="line">|  1 | SIMPLE      | film_actor | NULL       | ref    |...</span><br><span class="line">|  1 | SIMPLE      | film       | NULL       | eq_ref |...</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br></pre></td></tr></table></figure>
<h3 id="ref"><code>ref</code></h3>
<p>这是一种索引访问(有时也叫做索引査找)，它返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，它是査找和扫描的混合体。此类索引访问只有当使用<strong>非唯一性索引或者唯一性索引的非唯一性前缀时</strong>オ会发生。把它叫做 ref 是因为索引要跟某个参考值相比较。这个参考值或者是一个常数，或者是来自多表査询前一个表里的结果值。</p>
<p>可以用于使用 = 或 &lt;=&gt; 运算符进行比较的索引列。</p>
<h3 id="ref-or-null"><code>ref_or_null</code></h3>
<p>这种连接类型类似于 ref，但是 MySQL 会额外搜索包含 NULL 值的行。此联接类型优化最常用于解析子查询。在以下示例中，MySQL 可以使用 ref_or_null 连接来处理 ref_table：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="operator">=</span> expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="range"><code>range</code></h3>
<p>范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这比全索引扫描好一些，因为它用不着遍历全部索引。显而易见的范围扫描是带有 <code>BETWEEN</code> 或在 WHERE 子句里带有比较运算法（&lt;&gt;, &lt;=&gt;, &gt;, &gt;=, &lt;, &lt;=）的查询。当 MySQL 使用索引去査找一系列值时，例如 <code>IN()</code> 和 <code>OR</code> 列表，也会显示为范围扫描。<br>
然而，这两者其实是相当不同的访问类型，在性能上有重要的差异。</p>
<p>输出行中的 key 列表示使用了哪个索引。key_len 包含使用的最长的键部分。此类型的 ref 列为 NULL。</p>
<h3 id="index"><code>index</code></h3>
<p>这个跟全表扫描一样，只是 MySQL 扫描表时按索引次序进行而不是行。它的主要优点是避免了排序；最大的缺点是要承担按索引次序读取整个表的开销。这通常意味着若是按随机次序访问行，开销将会非常大。<br>
如果在 Extra 列中看到 “Using index”，说明 MySQL 正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行。它比按索引次序全表扫描的开销要少很多。</p>
<h3 id="ALL"><code>ALL</code></h3>
<p>这就是人们所称的全表扫描，通常意味着 MySQL 必须扫描整张表，从头到尾，去找到需要的行。(这里也有个例外，例如在査询里使用了 LIMIT，或者在 Extra 列中显示 “Using distinct/not exists”。)</p>
<h2 id="possible-keys-列">possible_keys 列</h2>
<p>这一列显示了査询<strong>可以使用哪些索引</strong>，这是基于査询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早期创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。</p>
<h2 id="key-列">key 列</h2>
<p>这一列显示了 MySQL <strong>决定采用哪个索引</strong>来优化对该表的访问。如果该索引没有出现在 possible_keys 列中，那么 MySQL 选用它是出于另外的原因一例如，它可能选择了个覆盖索引，哪怕没有 WHERE 子句。<br>
换句话说，possible keys 揭示了哪一个索引能有助于高效地行査找，而 key 显示的是优化采用哪一个索引可以最小化査询成本。下面就是一个例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor \G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: idx_fk_film_id</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5462</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure>
<h2 id="key-len-列"><code>key_len</code> 列</h2>
<p>该列显示了 MySQL 在索引里使用的字节数。如果 MySQL 正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列。要记住，MySQL5.5 及之前版本只能使用索引的最左前缀。举例来说，sakila.film_actor 的主键是两个 SMALLINT 列，并且每个 SMALLINT 列是两字节，那么索引中的每项是 4 字节。以下就是一个査询的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor WHERE actor_id=4;</span></span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br><span class="line">| id | select_type | table      | possible_keys          | key     | key_len |...</span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br><span class="line">|  1 | SIMPLE      | film_actor | PRIMARY,idx_fk_film_id | PRIMARY | 2       |...</span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br></pre></td></tr></table></figure>
<p>基于结果中的 key_len 列，可以推断出査询使用唯一的首列一 actor_id 列，来执行索引査找。当我们计算列的使用情况时，务必把字符列中的字符集也考虑进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">CREATE TABLE t</span></span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt;     a char(3) NOT NULL,</span><br><span class="line">    -&gt;     b int(11) NOT NULL,</span><br><span class="line">    -&gt;     c char(1) NOT NULL,</span><br><span class="line">    -&gt;     PRIMARY KEY (a, b, c)</span><br><span class="line">    -&gt; ) ENGINE = MYISAM</span><br><span class="line">    -&gt;   DEFAULT CHARSET = utf8;</span><br><span class="line">    </span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">INSERT INTO t(a, b, c)</span></span><br><span class="line">    -&gt; SELECT DISTINCT LEFT(TABLE_SCHEMA, 3), ORD(TABLE_NAME), LEFT(COLUMN_NAME, 1)</span><br><span class="line">    -&gt; FROM INFORMATION_SCHEMA.COLUMNS;</span><br><span class="line">    </span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT a FROM t WHERE a = <span class="string">&#x27;sak&#x27;</span> AND b = 112;</span></span><br><span class="line">...+------+---------------+---------+---------+...</span><br><span class="line">...| type | possible_keys | key     | key_len |...</span><br><span class="line">...+------+---------------+---------+---------+...</span><br><span class="line">...| ref  | PRIMARY       | PRIMARY | 13      |...</span><br><span class="line">...+------+---------------+---------+---------+...</span><br></pre></td></tr></table></figure>
<p>这个査询中平均长度为 13 字节，即为 a 列和 b 列的总长度。a 列是 3 个字符，utf8 下每一个最多为 3 字节，而 b 列是一个 4 字节整型。则 key_len = 3*3 + 4；</p>
<p>key_len 列显示了在索引字段中可能的最大长度，而不是表中数据使用的实际字节数。<br>
在前面例子中 MySQL 总是显示 13 字节，即使 a 列恰巧只包含一个字符长度。换言之，key_len 通过査找表的定义而被计算出，而不是表中的数据。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td>char(n)：n 字节长度；varchar(n)：2 字节存储字符串长度</td>
<td>如果是 utf-8，则 n 字节变为 3n</td>
</tr>
<tr>
<td>数值类型</td>
<td>tinyint：1 字节；smallint：2 字节；int：4 字节；bigint：8 字节</td>
<td></td>
</tr>
<tr>
<td>时间类型</td>
<td>date：3 字节；timestamp：4 字节；datetime：8 字节</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ref-列">ref 列</h2>
<p>ref 列显示将哪些列或常量与 key 列中的列出的索引进行比较，以从表中选择行。下面是一个展示关联条件和别名组合的例子。注意，ref 列反映了在査询文本中 film 表是如何以 f 为别名的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN</span></span><br><span class="line">    -&gt; SELECT STRAIGHT_JOIN f.film_id</span><br><span class="line">    -&gt; FROM sakila.film AS f</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor AS fa</span><br><span class="line">    -&gt;              ON f.film_id = fa.film_id AND fa.actor_id = 1</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor AS a USING (actor_id);</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br><span class="line">...| table |...| key                | key_len | ref                    |...</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br><span class="line">...| f     |...| idx_fk_language_id | 1       | NULL                   |...</span><br><span class="line">...| fa    |...| PRIMARY            | 4       | const,sakila.f.film_id |...</span><br><span class="line">...| a     |...| PRIMARY            | 2       | const                  |...</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br></pre></td></tr></table></figure>
<h2 id="rows-列">rows 列</h2>
<p>rows 列表示 MySQL 认为执行查询必须检查的行数。这个数字是内嵌循环关联计划里的循环数目。也就是说它不是 MySQL 认为它最终要从表里读取出来的行数，而是 MySQL 为了找到符合査询的每一点上标谁的那些行而必须读取的行的平均数。（这个标准包括 SQL 里给定的条件，以及来自联接次序上前一个表的当前列。）</p>
<p>根据表的统计信息和索引的选用情况，这个估算可能很不精确。在有些版本里,它也反映不出 LIMIT 子句。举例来说，下面这个査询不会真的检査1000 行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">explain select * from sakila.film <span class="built_in">limit</span> 1\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film</span><br><span class="line">            ...</span><br><span class="line">         rows: 1000</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure>
<p>通过把所有 rows 列的值相乘，可以粗略地估算出整个査询会检査的行数。例如，以下这个査询大约会检査 5400 行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN</span></span><br><span class="line">    -&gt; SELECT f.film_id</span><br><span class="line">    -&gt; FROM sakila.film AS f</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor AS fa USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor AS a USING (actor_id);</span><br><span class="line">...+------+...</span><br><span class="line">...| rows |...</span><br><span class="line">...+------+...</span><br><span class="line">...|  200 |...</span><br><span class="line">...|   27 |...</span><br><span class="line">...|    1 |...</span><br><span class="line">...+------+...</span><br></pre></td></tr></table></figure>
<p>要记住这个数字是 MySQL 认为它要检査的行数，而不是结果集里的行数。同时也要认识到有很多优化手段，例如关联缓冲区和缓存，无法影响到行数的显示。MySQL 可能不必真的读所有它估计到的行，它也不知道任何关于操作系统或硬件缓存的信息。</p>
<h2 id="partitions、filtered-列">partitions、filtered 列</h2>
<p>partitions 表示所匹配的分区；</p>
<p>filtered 显示的是针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估算。最大值为100，这表示未对行进行过滤。值从 100 减小表示过滤量增加。rows 显示要检查的行的估计数，rows × filtered 显示与接下来的表连接的行数。例如，如果 rows 为1000，filtered 为 50.00（50％），则与下表连接的行数为1000×50％ = 500。</p>
<h2 id="Extra-列">Extra 列</h2>
<p>这一列包含的是不适合在其他列显示的额外信息。 MySQL 用户手册里记录了大多数可以在这里出现的值。</p>
<p>常见的最重要的值如下：</p>
<h3 id="”Using-index“">”<em>Using index</em>“</h3>
<p>此值表示 MySQL 将使用覆盖索引，以避免访问表。不要把覆盖索引和 index 访问类型弄混了。</p>
<p>表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表。</p>
<h3 id="“Using-where”">“<em>Using where</em>”</h3>
<p>这意味着 MySQL 服务器将在存储擎检索行后再进行过滤。许多 WHERE 条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带 WHERE 子句的査询都会显示 “Using where”。有时 “Using where” 的出现就是个暗示：査询可受益于不同的索引。</p>
<p>WHERE 子句用于限制要与下一个表匹配或发送给客户端的行。除非您特别打算从表中获取或检查<strong>所有行</strong>，否则，如果 Extra 值不是 Using where 并且表联接类型为 ALL 或 index，则查询中可能出现了问题。</p>
<h3 id="“Using-temporary”">“<em>Using temporary</em>”</h3>
<p>为了完成查询，MySQL 需要创建一个临时表来保存结果。如果查询包含以不同方式列出列的 <code>GROUP_BY</code> 和 <code>ORDER BY</code> 子句，通常会发生这种情况。</p>
<h3 id="“Using-filesort”">“<em>Using filesort</em>”</h3>
<p>这意味着 MySQL 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。 如果读取到的行数据于 sort_buffer_size 系统变量相比小，则在内存排序，相反内存不够或超过该变量，那么 MySQL 会先将数据分块，对每个独立的块使用 “快速排序” 进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。 EXPLAIN 不会告诉你 MySQL 将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。</p>
<h3 id="“Using-join-buffer”">“<em>Using join buffer</em>”</h3>
<p>Using join buffer 表示使用连接缓冲区的行提取匹配行。</p>
<p>内部细分可能包含：块级联循环算法（Block Nested-Loop），批量键访问算法（Batched Key Access），hash join。</p>
<h3 id="“Impossible-where”">“<em>Impossible where</em>”</h3>
<p>WHERE 子句始终为 false，无法选择任何行。</p>
<h3 id="“Select-tables-optimized-away”">“<em>Select tables optimized away</em>”</h3>
<p>表示 SELECT 语句没有遍历表或者索引就返回数据了。</p>
<p>比如在优化阶段可以确定要读取的行（通过读取索引行），则在查询阶段无需读取任何表。如下面的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">EXPLAIN SELECT MIN(film_id) FROM sakila.film;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL utf8 和 utf8mb4 的区别</title>
    <url>/persistence/db/MySQL-utf8-vs-utf8mb4/</url>
    <content><![CDATA[<h1>字符集、校对规则和 Unicode</h1>
<p><strong>字符集</strong> (<code>Character Sets</code>) 是指一种从二进制编码到某类字符符号的映射，可以参考如何使用一个字节来表示英文字母。</p>
<p><strong>“校对”</strong> (<code>Collations</code>) 是指一组用于某个字符集的排序规则。</p>
<p>MySQL 服务器有默认的字符集和校对规则，每个数据库也有自己的默认值，每个表也有自己的默认值。这是一个逐层继承的默认设置，最终最靠底层的默认设置将影响你创建的对象。这些默认值，至上而下地告诉 MySQL 应该使用什么字符集来存储某个列。</p>
<p>MySQL 8.0 默认服务端字符集和校对规则分别为 <code>utf8mb4</code> 和 <code>utf8mb4_0900_ai_ci</code>；</p>
<p>MySQL 5.6/5.7 默认服务端字符集和校对规则分别为 <code>latin1</code> 和 <code>latin1_swedish_ci</code>。</p>
<span id="more"></span>
<p>使用命令 <code>SHOW CHARACTERSET</code> 和 <code>SHOW COLLATION</code> 来查看 MySQL 支持的字符集和校对规则。</p>
<p>可通过查询环境变量查看当前版本信息：<code>SHOW VARIABLES Like '%character_set%';</code></p>
<p>更多介绍查看<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/charset.html">官方文档</a>。</p>
<h2 id="Unicode-支持">Unicode 支持</h2>
<p>Unicode 标准包括来自基本多文种平面 (BMP) 的字符和位于 BMP 之外的补充字符。本节介绍 MySQL 中对 Unicode 的支持。有关 Unicode 标准本身的信息，请访问 <a target="_blank" rel="noopener" href="http://www.unicode.org/">Unicode 联盟网站</a>。</p>
<p>BMP 字符具有以下特征：</p>
<ul>
<li>它们的码点值 (code point values) 在 0 到 65535 之间 (U+0000 和 U+FFFF)。</li>
<li>它们可以使用 8 位，16 位或 24 位（1 到 3 个字节）以可变长度编码进行编码。</li>
<li>它们可以使用 16 位（2 字节）以固定长度编码进行编码。</li>
<li>它们足以应付主要语言中的几乎所有字符。</li>
</ul>
<p>补充字符位于 BMP 之外：</p>
<ul>
<li>它们的码点值在 U+10000 和 U+10FFFF 之间，主要是一些 emoji 表情。</li>
<li>Unicode 对补充字符的支持要求字符集的范围超出了 BMP 字符，因此比 BMP 字符占用更多的空间（每个字符最多 4 个字节）。</li>
</ul>
<p>根据 RFC 3629 实现了用于对 Unicode 数据进行编码的 UTF-8（具有 8 位单位的 Unicode 转换格式）方法，该方法描述了从一到四个字节的编码序列。 UTF-8 的思想是使用不同长度的字节序列对各种 Unicode 字符进行编码：</p>
<ul>
<li>基本的拉丁字母，数字和标点符号使用一个字节。</li>
<li>大多数欧洲和中东脚本字母均以 2 字节的顺序排列：扩展的拉丁字母（带有波浪号，长音符号，重音和其他重音符号），西里尔字母，希腊语，亚美尼亚语，希伯来语，阿拉伯语，叙利亚语等。</li>
<li>韩文，中文和日文表意文字使用 3 字节或 4 字节序列。</li>
</ul>
<p>MySQL 支持以下 Unicode 字符集：</p>
<ul>
<li>utf8mb4: Unicode 字符集的 UTF-8 编码，每个字符使用一到四个字节。</li>
<li>utf8mb3: Unicode 字符集的 UTF-8 编码，每个字符使用一到三个字节。</li>
<li>utf8: utf8mb3 的别名。</li>
<li>…</li>
</ul>
<blockquote>
<p>在 8.0 之后 utf8mb3 字符集已被弃用，可能在将来的 MySQL 版本中将被删除。请改用 utf8mb4。尽管 utf8 当前是 utf8mb3 的别名，但在某些时候 utf8 有望成为对 utf8mb4 的引用。为避免对 utf8 的含义含糊不清，请考虑为字符集引用而不是 utf8 显式指定 utf8mb4。</p>
</blockquote>
<p><strong>Table Unicode 字符集的一般特征</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">字符集</th>
<th style="text-align:left">支持的字符</th>
<th style="text-align:left">单个字符需要的存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>utf8mb3</code>, <code>utf8</code></td>
<td style="text-align:left">BMP only</td>
<td style="text-align:left">1, 2, or 3 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>ucs2</code></td>
<td style="text-align:left">BMP only</td>
<td style="text-align:left">2 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf8mb4</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">1, 2, 3, or 4 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf16</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">2 or 4 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf16le</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">2 or 4 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf32</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">4 bytes</td>
</tr>
</tbody>
</table>
<h2 id="校对规则命名约定">校对规则命名约定</h2>
<p>MySQL 校对规则名称遵循以下约定：</p>
<ul>
<li>
<p>校对规则名称以与其关联的字符集的名称开头，通常后跟一个或多个后缀，以表示其他校对特征。例如，<code>utf8mb4_general_ci</code> 和 <code>latin1_swedish_ci</code> 分别是 <code>utf8mb4</code> 和 <code>latin1</code> 字符集的校对规则。二进制字符集具有单个排序规则，也称为 <code>binary</code>，没有后缀。</p>
</li>
<li>
<p>特定于语言的校对规则包括语言环境代码或语言名称。例如，<code>utf8mb4_tr_0900_ai_ci</code> 和 <code>utf8mb4_hu_0900_ai_ci</code> 使用土耳其语和匈牙利语规则对 <code>utf8mb4</code> 字符集的字符进行排序。 相对应的 <code>utf8mb4_turkish_ci</code> 和 <code>utf8mb4_hungarian_ci</code> ，只是基于 <code>Unicode</code> 排序算法的较新版本。</p>
</li>
<li>
<p>排序规则后缀指示排序规则是否区分大小写，区分重音还是假名敏感（或其某种组合）还是二进制。下表显示了用于表示这些特征的后缀。</p>
<p><strong>Table 排序规则后缀含义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">后缀</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>_ai</code></td>
<td style="text-align:left">Accent-insensitive (重音不敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_as</code></td>
<td style="text-align:left">Accent-sensitive (重音敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_ci</code></td>
<td style="text-align:left">Case-insensitive (大小写不敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_cs</code></td>
<td style="text-align:left">Case-sensitive (大小写敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_ks</code></td>
<td style="text-align:left">Kana-sensitive (假名敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_bin</code></td>
<td style="text-align:left">Binary</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Unicode 字符集的排序规则名称可以包括版本号，以指示排序规则所基于的 Unicode 排序规则算法 (UCA) 的版本。在名称中没有版本号的基于 UCA 的排序规则使用版本 4.0.0 UCA 作为其配重键。例如：</p>
<ul>
<li>utf8mb4_0900_ai_ci 基于 UCA 9.0.0 配重键 (<a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt">http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt</a>)。</li>
<li>utf8mb4_unicode_520_ci 基于 UCA 5.2.0 配重键 (<a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt">http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt</a>)。</li>
<li>utf8mb4_unicode_ci（未命名版本）基于 UCA 4.0.0 配重键 (<a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt">http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt</a>)。</li>
</ul>
</li>
<li>
<p>对于 Unicode 字符集，<code>xxx_general_mysql500_ci</code> 排序规则保留原始 <code>xxx_general_ci</code> 排序规则在 5.1.24 之前的顺序，并允许对在 MySQL 5.1.24 之前创建的表进行升级 (Bug #27877)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Character Sets</tag>
        <tag>Collations</tag>
        <tag>Unicode</tag>
        <tag>BMP</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 锁和事物模型</title>
    <url>/persistence/db/MySQL-%E9%94%81%E5%92%8C%E4%BA%8B%E7%89%A9%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文为 MySQL 8.0 官方文档 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-transaction-model.html">InnoDB Locking and Transaction Model</a> 的翻译，所述的锁和事物模型针对于 InnoDB 存储引擎。</p>
</blockquote>
<p>要实现大规模、繁忙或高可靠的数据库应用程序，或调优 MySQL 性能，了解 InnoDB 锁和 InnoDB 事务模型很重要。</p>
<h1>InnoDB 和 ACID 模型</h1>
<p>ACID 模型是一组数据库设计原则，强调对业务数据和任务关键型应用程序很重要的可靠性方面。MySQL 包括 InnoDB 存储引擎等组件，它们与 ACID 模型密切相关，因此数据不会损坏，结果不会因软件崩溃和硬件故障等异常情况而失真。当您依赖符合 ACID 的特性时，您不需要重新发明一致性检查和崩溃恢复机制的轮子。如果您有额外的软件保护措施、超可靠的硬件、或者可以容忍少量数据丢失或不一致的应用程序，您可以调整 MySQL 设置以换取一些 ACID 可靠性以获得更高的性能或吞吐量。</p>
<p>以下部分讨论 MySQL 特性，特别是 InnoDB 存储引擎，如何与 ACID 模型的类别交互：</p>
<ul>
<li>
<p><strong>A</strong>：atomicity - 原子性</p>
<p>事务通常由多个语句组成。原子性保证每个事务都被视为一个“单元”，要么完全成功，要么完全失败：如果构成事务的任何语句未能完成，则整个事务失败，数据库数据保持不变。原子系统必须保证在每一种情况下的原子性，包括电源故障、错误和崩溃。保证原子性可以防止对数据库的更新仅部分发生，这可能会导致比完全拒绝整个系列更大的问题。</p>
</li>
<li>
<p><strong>C</strong>：consistency - 一致性/正确性</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Consistency_(database_systems)">一致性</a>确保事务只能将数据库从一种有效状态带到另一种有效状态，维护数据库<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Invariant_(computer_science)">不变性</a>：根据所有定义的规则，写入数据库的任何数据都必须有效，包括<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Integrity_constraints">约束</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cascading_rollback">级联</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Database_trigger">触发器</a>及其任意组合。这可以防止非法事务导致数据库损坏，但不能保证事务是<em>正确的</em>。</p>
</li>
<li>
<p><strong>I</strong>：isolation - 隔离型</p>
<p>事务通常是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrent_computing">并发</a>执行的（例如，多个事务同时读取和写入一个表）。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">隔离</a>确保事务的并发执行使数据库处于与顺序执行事务时获得的状态相同。隔离是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrency_control">并发控制</a>的主要目标；根据所使用的方法，不完整事物的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition">影响</a>甚至可能对其他事物不可见。</p>
</li>
<li>
<p><strong>D</strong>：durability - 持久性</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Durability_(computer_science)">持久性</a>保证一旦事务被提交，即使在系统故障（例如，断电或<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Crash_(computing)">崩溃</a>）的情况下它也将保持提交。这通常意味着已完成的事物（或它们的影响）被记录在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Non-volatile_memory">非易失性存储器中</a>。</p>
</li>
</ul>
<h2 id="Atomicity">Atomicity</h2>
<p>ACID 模型的原子性方面主要涉及 InnoDB 事务。相关的 MySQL 功能包括：</p>
<ul>
<li>自动提交（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit"><code>autocommit</code></a>）设置。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/commit.html"><code>COMMIT</code></a> 语句。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/commit.html"><code>ROLLBACK</code></a> 语句。</li>
</ul>
<span id="more"></span>
<h2 id="Consistency">Consistency</h2>
<p>ACID 模型的一致性方面主要涉及内部 InnoDB 处理，以保护数据免于崩溃。相关的 MySQL 功能包括：</p>
<ul>
<li>InnoDB 双写缓冲区。请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-doublewrite-buffer.html">参阅第 15.6.4 节，“双写缓冲区”</a>。</li>
<li>InnoDB 崩溃恢复。请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-recovery.html#innodb-crash-recovery">参阅 InnoDB 崩溃恢复</a>。</li>
</ul>
<h2 id="Isolation">Isolation</h2>
<p>ACID 模型的隔离方面主要涉及 InnoDB 事务，特别是适用于每个事务的隔离级别。相关的 MySQL 功能包括：</p>
<ul>
<li>自动提交设置。</li>
<li>事务隔离级别和 <code>SET TRANSACTION</code> 语句。</li>
<li>InnoDB 锁定的底层细节。可以在 <code>INFORMATION_SCHEMA</code> 表（请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-information-schema-transactions.html">参阅第 15.15.2 节，“InnoDB INFORMATION_SCHEMA 事务和锁定信息”</a>）和 Performance Schema <code>data_locks</code> 和 <code>data_lock_waits</code> 表中查看详细信息。</li>
</ul>
<h2 id="Durability">Durability</h2>
<p>ACID 模型的持久性方面涉及与您的特定硬件配置交互的 MySQL 软件功能。由于根据您的 CPU、网络和存储设备的能力存在多种可能性，这方面是最复杂的，提供具体的指导方针。 （这些指南可能采取“购买新硬件”的形式。）相关的 MySQL 功能包括：</p>
<ul>
<li>InnoDB 双写缓冲区。请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-doublewrite-buffer.html">参阅第 15.6.4 节，“双写缓冲区”</a>。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit"><code>innodb_flush_log_at_trx_commit</code></a> 变量。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_sync_binlog"><code>sync_binlog</code></a> 变量。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_file_per_table"><code>innodb_file_per_table</code></a> 变量。</li>
<li>存储设备中的写入缓冲区，例如磁盘驱动器、SSD 或 RAID 阵列。</li>
<li>存储设备中的电池后备缓存。</li>
<li>用于运行 MySQL 的操作系统，特别是它对 <code>fsync()</code> 系统调用的支持。</li>
<li>不间断电源 (UPS) 保护运行 MySQL 服务器和存储 MySQL 数据的所有计算机服务器和存储设备的电源。</li>
<li>您的备份策略，例如备份的频率和类型以及备份保留期。</li>
<li>对于分布式或托管数据应用程序，MySQL 服务器硬件所在的数据中心的特定特征，以及数据中心之间的网络连接。</li>
</ul>
<h1>InnoDB 多版本控制</h1>
<p><strong>InnoDB 是一个多版本的存储引擎。 它保留有关已更改行的旧版本的信息以支持事务功能，例如并发和回滚</strong>。 该信息以称为回滚片段的数据结构存储在撤消表空间中。 请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html">参阅第 15.6.3.4 节，“撤消表空间”</a>。 InnoDB 使用回滚片段中的信息来执行事务回滚所需的撤消（undo）操作。 它还使用这些信息来构建行的早期版本以实现一致性读取。</p>
<p>在内部，InnoDB 为存储在数据库中的每一行添加三个字段：</p>
<ul>
<li>一个 6 字节的 <code>DB_TRX_ID</code> 字段指示插入或更新行的最后一个事务的事务标识符。此外，删除在内部被视为更新，其中设置了行中的特殊位（bit）以将其标记为已删除。</li>
<li>一个 7 字节的 <code>DB_ROLL_PTR</code> 字段称为回滚指针（roll pointer）。回滚指针指向写入回滚片段的撤消日志（undo log）记录。如果该行被更新，撤消日志记录包含在更新前重建该行内容所需的信息。</li>
<li>一个 6 字节的 <code>DB_ROW_ID</code> 字段包含一个行 ID，随着插入新行而单调增加。如果 InnoDB 自动生成聚集索引，则索引包含行 ID 值。否则，<code>DB_ROW_ID</code> 列不会出现在任何索引中。</li>
</ul>
<p>回滚片段中的撤消日志分为插入和更新撤消日志。插入撤消日志仅在事务回滚时需要，并且可以在事务提交后立即丢弃。更新撤消日志也用于一致性读取，但只有当不存在 InnoDB 为其分配了快照的事务后，它们才能被丢弃，在一致读取中可能需要更新撤消日志中的信息来构建数据库行的早期版本，有关撤消日志（und log）的其他信息，请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html">参阅第 15.6.6 节，“撤消日志”</a>。</p>
<p>建议您定期提交事务，包括仅发出一致性读取的事务。否则，InnoDB 无法丢弃更新撤销日志中的数据，并且回滚段可能会变得太大，填满它所在的撤消表空间。有关管理撤消表空间的信息，请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-tablespaces.html">参阅第 15.6.3.4 节，“撤消表空间”</a>。</p>
<p>回滚片段中撤消日志记录的物理大小通常小于相应的插入或更新行。您可以使用此信息来计算回滚片段所需的空间。</p>
<p>在 InnoDB 多版本控制方案中，当您使用 SQL 语句删除某行时，不会立即从数据库中物理删除该行。InnoDB 仅在丢弃为了删除而写入的更新撤消日志记录时才物理删除相应的行及其索引记录。这种删除操作称为清除（purge），它非常快，通常与执行删除操作的 SQL 语句花费的时间顺序相同。</p>
<p>如果您在表中以大致相同的速度以小批量进行插入和删除行，清除线程可能会开始滞后，并且由于所有“死”行，表会变得越来越大，从而使所有内容都受磁盘限制并且非常缓慢。在这种情况下，通过调整 <code>innodb_max_purge_lag</code> 系统变量来限制新行操作，并为清除线程分配更多资源。有关更多信息，请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-purge-configuration.html">参阅第 15.8.9 节，“清除配置”</a>。</p>
<h2 id="多版本和二级索引">多版本和二级索引</h2>
<p>InnoDB 多版本并发控制 (MVCC) 处理二级索引与聚簇索引不同。聚集索引中的记录立即更新，并且它们隐藏的系统列指向可以重建早期版本记录的撤消日志条目。与聚集索引记录不同，二级索引记录不包含隐藏的系统列，也不会立即更新。</p>
<p>当二级索引列被更新时，旧的二级索引记录被标记为删除，新记录被插入时，旧的被删除标记的记录最终被清除。当二级索引记录被删除标记或二级索引页由较新的事务更新时，InnoDB 会在聚集索引中查找该数据库记录。在聚簇索引中，会检查记录的 <code>DB_TRX_ID</code>，如果在启动读取事务后该记录发生了修改，则从撤消日志中检索记录的正确版本。</p>
<p>如果二级索引记录被标记为删除或二级索引页被较新的事务更新， 则不使用<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index">覆盖索引</a>（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index">covering index</a>）技术。这时不是从二级索引结构返回值，而是<code>InnoDB</code>在聚集索引中查找记录。</p>
<p>但是，如果启用了 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html">索引条件下推 (ICP)</a>优化，并且<code>WHERE</code>可以仅使用索引中的字段评估部分条件，则 MySQL 服务器会将这部分<code>WHERE</code>条件下推到存储引擎。如果没有找到匹配的记录，则避免聚集索引查找。如果找到匹配的记录，即使是在删除标记的记录中，也会在 <code>InnoDB</code>聚集索引中查找该记录。</p>
<h1>InnoDB 锁定</h1>
<p>本节介绍 InnoDB 使用的锁类型。</p>
<h2 id="Shared-and-Exclusive-Locks">Shared and Exclusive Locks</h2>
<p>InnoDB 实现了标准的行级锁定，其中有两种类型的锁，共享 - Share (S) 锁和排它 - Exclusive (X) 锁。</p>
<ul>
<li>共享 (S) 锁允许持有锁的事务读取一行。</li>
<li>排他 (X) 锁允许持有锁的事务更新或删除行。</li>
</ul>
<p>如果事务 <code>T1</code> 在行 <code>r</code> 上持有共享 (<code>S</code>) 锁，那么来自某个不同事务 <code>T2</code> 的对行 <code>r</code> 的锁的请求将按如下方式处理：</p>
<ul>
<li>可以立即授予 <code>T2</code> 对 <code>S</code> 锁的请求。结果，<code>T1</code> 和 <code>T2</code> 都持有 <code>r</code> 的 <code>S</code> 锁。</li>
<li>T2 对 <code>X</code> 锁的请求不能立即被授予。</li>
</ul>
<p>如果事务 <code>T1</code> 在行 <code>r</code> 上持有排他 (<code>X</code>) 锁，则不能立即授予来自某个不同事务 <code>T2</code> 的对 <code>r</code> 上任一类型锁的请求。相反，事务 <code>T2</code> 必须等待事务 <code>T1</code> 释放其对行 <code>r</code> 的锁。</p>
<!-- more -->
<h2 id="Intention-Locks">Intention Locks</h2>
<p>InnoDB 支持<em><strong>多粒度锁定</strong></em>，允许行锁和表锁共存。例如，诸如 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html"><code>LOCK TABLES ... WRITE</code></a> 之类的语句在指定的<strong>表</strong>上使用排他锁（X 锁）。为了使多粒度级别的锁定起作用，InnoDB 使用意向锁（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_lock">intention locks</a>）。<strong>意向锁是表级锁，指示事务稍后需要对表中的行使用哪种类型的锁（共享锁或独占锁）</strong>。意向锁有两种类型：</p>
<ul>
<li>意向共享锁 - <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_shared_lock">intention shared lock</a> (IS) 表示事务打算在表中的各个行上设置共享锁。</li>
<li>意图排他锁 - <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_intention_exclusive_lock">intention exclusive lock</a> (IX) 表示事务打算对表中的各个行设置排他锁。</li>
</ul>
<p>例如，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT ... FOR SHARE</code></a> 设置一个 <code>IS</code> 锁，而 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT ... FOR UPDATE</code></a> 设置一个 <code>IX</code> 锁。</p>
<p>意图锁定协议如下：</p>
<ul>
<li>在事务获得表中某行的共享锁之前，它必须首先获得表上的 <code>IS</code> 锁或更强的锁。</li>
<li>在事务获得表中行的排他锁之前，它必须首先获得表的 <code>IX</code> 锁。</li>
</ul>
<p>表级锁类型和行级锁类型兼容性总结在以下矩阵中，由表可以看出意向锁之间不会冲突，但是意向锁在和行锁之间有不同程度的冲突：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"><code>X</code></th>
<th style="text-align:left"><code>IX</code></th>
<th style="text-align:left"><code>S</code></th>
<th style="text-align:left"><code>IS</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>X</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
</tr>
<tr>
<td style="text-align:left"><code>IX</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left"><strong>Compatible</strong></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left"><strong>Compatible</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>S</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">Compatible</td>
<td style="text-align:left">Compatible</td>
</tr>
<tr>
<td style="text-align:left"><code>IS</code></td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left"><strong>Compatible</strong></td>
<td style="text-align:left">Compatible</td>
<td style="text-align:left">Compatible</td>
</tr>
</tbody>
</table>
<p>如果请求事务与现有锁兼容，则向请求事务授予锁，但如果与现有锁冲突，则不会授予。事务一直等到冲突的现有锁被释放。如果锁定请求与现有锁定发生冲突并且由于死锁而无法授予，则会发生错误。</p>
<p><strong>除了全表请求（例如，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html"><code>LOCK TABLES ... WRITE</code></a>）之外，意向锁不会阻塞任何东西。意向锁的主要目的是表明有人正在锁定一行，或者打算锁定表中的一行。</strong></p>
<p>意向锁的事务数据在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a> 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB monitor</a> 输出中显示类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TABLE LOCK table `test`.`t` trx id 10080 lock mode IX</span><br></pre></td></tr></table></figure>
<h2 id="Record-Locks">Record Locks</h2>
<p>记录锁是对<strong>索引记录</strong>的锁。例如，<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 阻止任何其他事务插入、更新或删除 t.c1 值为 10 的行。</p>
<p>记录锁总是锁定索引记录，即使一个表没有定义索引。对于这种情况，InnoDB 会创建一个隐藏的聚集索引并使用该索引进行记录锁定。<a href="">请参阅第 15.6.2.1 节，“聚集索引和二级索引”</a>。</p>
<p>记录锁的事务数据在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a> 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB monitor</a> 输出中显示类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`</span><br><span class="line">trx id 10078 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>
<h2 id="Gap-Locks">Gap Locks</h2>
<p>间隙锁是对<strong>索引记录之间的间隙</strong>的锁，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁。例如，<code>SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> 防止其他事务将 15 的值插入到列 t.c1 中，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙已被锁定。</p>
<p>间隙可能跨越单个索引值、多个索引值，甚至是空的。</p>
<p><strong>间隙锁是性能和并发性之间权衡的一部分，用于某些事务隔离级别。比如可序列化（Serializable）、可重复读（Repeatable Read）隔离级别。</strong></p>
<p>使用唯一索引锁定行以搜索唯一行的语句不需要间隙锁定。 （这不包括搜索条件只包含<strong>多列唯一索引的部分列</strong>的情况；在这种情况下，确实会发生间隙锁定。）例如，如果 id 列具有唯一索引，则以下语句仅对 id 值为 100 的行使用索引记录锁，其他会话是否在前面的间隙中插入行无关紧要：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>如果 id 未编入索引或具有非唯一索引，则该语句会锁定前面的间隙。</p>
<p>这里还值得注意的是，<strong>不同的事务可以在间隙上持有冲突的锁</strong>。 例如，事务 A 可以在间隙上持有共享间隙锁（gap S-lock），而事务 B 在同一间隙上持有排他间隙锁（gap X-lock）。 <strong>允许冲突间隙锁的原因是：如果要从索引中清除记录，则必须合并不同事务在记录上持有的间隙锁。</strong></p>
<p>间隙锁定在 <code>InnoDB</code> 中是“纯粹的抑制”，<strong>这意味着它们的唯一目的是防止其他事务插入间隙</strong>。间隙锁可以共存。一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。共享和排他间隙锁之间没有区别。它们彼此不冲突，并且执行相同的功能。</p>
<p>可以明确禁用间隙锁定。比如将事务隔离级别更改为<code>读已提交</code> -  <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a> 。在这种情况下，间隙锁定对搜索和索引扫描禁用，仅用于外键约束检查和重复键检查。</p>
<p>使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a> 隔离级别还有其他影响 。在 MySQL 评估 <code>WHERE</code> 条件后释放不匹配行的记录锁。对于 <code>UPDATE</code> 语句，<code>InnoDB</code> 做一个“半一致 - semi-consistent”读，这样它返回最新提交版本到 MySQL 使 MySQL 能够确定该行是否匹配 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> 的 <code>WHERE</code>  的条件。</p>
<h2 id="Next-Key-Locks">Next-Key Locks</h2>
<p>next-key 锁是<strong>索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合</strong>。</p>
<p>InnoDB 执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，<strong>行级锁实际上是索引记录锁</strong>。索引记录上的 next-key 锁也会影响该索引记录之前的“间隙”。也就是说，**next-key 锁是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。**如果一个会话对索引中的记录 R 具有共享或排他锁，则另一个会话不能在索引顺序中紧靠 R 之前的间隙中插入新的索引记录。</p>
<p>假设一个索引包含值 10、11、13 和 20。该索引可能的 next-key 锁涵盖以下间隔，其中圆括号表示排除区间边界值，方括号表示包含边界值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(negative infinity, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, positive infinity)</span><br></pre></td></tr></table></figure>
<p>对于最后一个时间间隔，next-key lock 锁定索引中最大值之上的间隙，并且最后的“supremum”伪记录的值高于索引中的任何实际值。supremum 不是真正的索引记录，因此，实际上，这个 next-key 锁只锁定最大索引值之后的间隙。</p>
<p>默认情况下，InnoDB 的事务隔离级别为<code>可重复读</code> - <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read"><code>REPEATABLE READ</code></a>。在这种情况下，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻像行（phantom rows），也就是防止幻读（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#:~:text=Section%C2%A015.7.4%2C%20%E2%80%9CPhantom%20Rows%E2%80%9D">请参阅第 15.7.4 节，“幻像行”</a>）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books(name,price) <span class="keyword">VALUES</span> (<span class="string">&#x27;深入理解Java虚拟机&#x27;</span>,<span class="number">90</span>)	<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure>
<p><strong>InnoDB 在只读事务中可以完全避免幻读问题</strong>，譬如上面例子中事务 T1 只有查询语句，是一个只读事务，所以例子中幻读问题在 MySQL 中并不会出现。但在读写事务中，MySQL 仍然会出现幻读问题，譬如例子中事务 T1 如果在其他事务插入新书后，不是重新查询一次数量，而是要将所有小于 100 元的书改名，那就依然会受到新插入书籍的影响。</p>
<p>next-key 锁的事务数据在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a> 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB monitor</a> 输出中显示类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`</span><br><span class="line">trx id 10080 lock_mode X</span><br><span class="line">Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0</span><br><span class="line"> 0: len 8; hex 73757072656d756d; asc supremum;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000274f; asc     &#x27;O;;</span><br><span class="line"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></pre></td></tr></table></figure>
<h2 id="Insert-Intention-Locks">Insert Intention Locks</h2>
<p>插入意向锁是一种在行插入之前由 <code>INSERT</code> 操作设置的<strong>间隙锁</strong>。此锁表示插入意图，如果插入同一索引间隙的多个事务未插入间隙内的相同位置，则它们无需相互等待。假设存在值为 4 和 7 的索引记录。分别尝试插入值 5 和 6 的单独事务，在获得插入行的排他锁之前，每个事务都使用插入意图锁锁定 4 和 7 之间的间隙，但不会相互阻塞，因为行是不冲突的。</p>
<p>以下示例演示了在获取插入记录的排他锁之前采用插入意向锁的事务。该示例涉及两个客户端 A 和 B。</p>
<p>客户端 A 创建一个包含两条索引记录（90 和 102）的表，然后启动一个事务：对 ID 大于 100 的索引记录放置排他锁。</p>
<p>排他锁包括记录 102 之前的间隙锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> child (id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY(id)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">values</span> (<span class="number">90</span>),(<span class="number">102</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> id  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+</span></span><br></pre></td></tr></table></figure>
<p>客户端 B 开始一个事务以在间隙中插入一条记录。事务在等待获得排他锁时使用插入意向锁。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> child (id) <span class="keyword">VALUES</span> (<span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<p>插入意图锁的事务数据在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/show-engine.html"><code>SHOW ENGINE INNODB STATUS</code></a> 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-standard-monitor.html">InnoDB monitor</a> 输出中显示类似于以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`</span><br><span class="line">trx id 8731 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000066; asc    f;;</span><br><span class="line"> 1: len 6; hex 000000002215; asc     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure>
<h2 id="AUTO-INC-Locks">AUTO-INC Locks</h2>
<p>AUTO-INC 锁是一种特殊的<strong>表级锁</strong>，由插入到具有 <code>AUTO_INCREMENT</code> 列的表中的事务获取。在最简单的情况下，如果一个事务正在向表中插入值，任何其他事务对该表的插入操作必须等待，以便从第一个事务插入的行接收连续的主键值。</p>
<p><code>innodb_autoinc_lock_mode</code> 变量控制用于自动增量锁定的算法。它允许您选择如何在可预测的自动增量值序列和插入操作的最大并发之间进行权衡。</p>
<p>有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">第 15.6.1.6 节，“InnoDB 中的 AUTO_INCREMENT 处理”</a>。</p>
<h2 id="Predicate-Locks-for-Spatial-Indexes">Predicate Locks for Spatial Indexes</h2>
<blockquote>
<p>该锁为空间索引 - R Tree 索引类型的锁，由于我们很少使用 MySQL 存储空间数据以及空间运算，不做过多研究。</p>
</blockquote>
<p>InnoDB 支持包含空间数据的列的空间索引（请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimizing-spatial-analysis.html">第 11.4.9 节，“优化空间分析”</a>）。</p>
<p>为了处理涉及 SPATIAL 空间索引的操作的锁定，<code>next-key</code> 锁定不能很好地支持 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read"><code>REPEATABLE READ</code></a> 或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable"><code>SERIALIZABLE</code></a> 事务隔离级别。</p>
<p>多维数据中没有绝对排序的概念，所以不清楚哪个是“下一个”键。</p>
<p>为了支持具有 SPATIAL 索引的表的隔离级别，InnoDB 使用谓词锁（predicate lock）。空间索引包含最小边界矩形 (MBR) 值，因此 InnoDB 通过在用于查询的 MBR 值上设置谓词锁来强制对索引进行一致读取。其他事务无法插入或修改与查询条件匹配的行。</p>
<h1>InnoDB 事物模型</h1>
<p>InnoDB 事务模型旨在将多版本（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_mvcc">multi-versioning</a>）数据库的最佳属性与传统的两阶段锁定相结合。 InnoDB 在行级别执行锁定，默认情况下以 Oracle 的风格使用一致性非锁定读取执行查询。InnoDB 中的锁信息以节省空间的方式存储，因此不需要锁升级。通常，允许多个用户锁定 InnoDB 表中的每一行或行的任何随机子集，而不会导致 InnoDB 内存耗尽。</p>
<h2 id="事物隔离级别">事物隔离级别</h2>
<p>事务隔离是数据库处理的基础之一。隔离（Isolation）是缩写 ACID 中的 I；隔离级别是在多个事务同时进行更改和执行查询时微调结果的性能和可靠性、一致性和可再现性之间的平衡的设置。</p>
<p>InnoDB 提供 SQL:1992 标准描述的所有四种事务隔离级别：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted"><code>READ UNCOMMITTED</code></a>、<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a>、<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read"><code>REPEATABLE READ</code></a> 和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_serializable"><code>SERIALIZABLE</code></a>。 InnoDB 的默认隔离级别是 <strong>REPEATABLE READ</strong>。</p>
<p>用户可以使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html"><code>SET TRANSACTION</code></a> 语句更改单个会话或所有后续连接的隔离级别。要为所有连接设置服务器的默认隔离级别，在命令行或选项文件中使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-options.html#option_mysqld_transaction-isolation"><code>--transaction-isolation</code></a> 选项。有关隔离级别和级别设置语法的详细信息，请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/set-transaction.html">参阅第 13.3.7 节，“SET TRANSACTION 语句”</a>。</p>
<p>InnoDB 使用不同的锁定策略支持这里描述的每个事务隔离级别。对于对 ACID 合规性很重要的关键数据的操作，您可以使用默认的 <code>REPEATABLE READ</code> 级别强制执行高度的一致性。或者你可以通过 <code>READ COMMITTED</code> 甚至 <code>READ UNCOMMITTED</code> 来放松一致性规则，比如在诸如批量报告之类的情况下，精确的一致性和可重复的结果不如最小化锁定开销重要。<code>SERIALIZABLE</code> 执行比 <code>REPEATABLE READ</code> 遵守更严格的规则，主要用于特殊情况，例如 <code>XA</code> 事务以及解决并发和死锁问题。</p>
<p>下面的列表描述了 MySQL 如何支持不同的事务级别。该列表从最常用的级别到最不常用的级别。</p>
<ul>
<li>
<p><code>REPEATABLE READ</code>（可重复读）</p>
<p>这是 InnoDB 的默认隔离级别。同一事务内的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_consistent_read"><strong>一致性读取</strong></a>使用由第一次读取建立的快照。这意味着如果您在同一个事务中发出多个普通（非锁定）SELECT 语句，这些 SELECT 语句彼此之间也是一致的。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">第 15.7.2.3 节，“一致的非锁定读取”</a>。</p>
<p><strong>对于锁定读取</strong>（<code>SELECT FOR UPDATE</code> 或 <code>FOR SHARE</code>）、<code>UPDATE</code> 和 <code>DELETE</code> 语句，锁定取决于语句是使用具有唯一搜索条件的唯一索引还是范围类型搜索条件。</p>
<ul>
<li>对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定它之前的间隙。</li>
<li>对于其他搜索条件，InnoDB 锁定扫描的索引范围，<strong>使用间隙锁或 next-key 锁来阻止其他会话插入范围所覆盖的间隙</strong>。</li>
</ul>
</li>
<li>
<p><code>READ COMMITTED</code>（读已提交）</p>
<p>每个<strong>一致性的读取</strong>，即使在同一个事务中，也会设置和读取自己的新快照。</p>
<p><strong>对于锁定读取</strong>（<code>SELECT with FOR UPDATE</code> 或 <code>FOR SHARE</code>）、<code>UPDATE</code> 语句和 <code>DELETE</code> 语句，InnoDB 只锁定索引记录，而不是它们之前的间隙，因此允许在锁定记录旁边自由插入新记录。</p>
<p>由于间隙锁定被禁用，可能会出现幻像行问题，<strong>也就是存在幻读问题</strong>，因为其他会话可以将新行插入间隙中。有关幻像行的信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html">第 15.7.4 节，“幻像行”</a>。</p>
<p><code>READ COMMITTED</code> 隔离级别仅支持基于行的二进制日志记录。如果您将 <code>READ COMMITTED</code> 与 <code>binlog_format=MIXED</code> 一起使用，则服务器会自动使用基于行的日志记录。</p>
<p>使用 <code>READ COMMITTED</code> 有额外的效果：</p>
<ul>
<li>对于 <code>UPDATE</code> 或 <code>DELETE</code> 语句，<strong>只为满足条件的更新或删除数据行设置锁</strong>，不满足条件的行记录锁会在 MySQL 评估完 WHERE 条件后释放。</li>
<li>对于 <code>UPDATE</code> 语句，如果一行已经被锁定，InnoDB 执行“半一致性”读取，将最新提交的版本返回给 MySQL，以便 MySQL 可以确定该行是否匹配 UPDATE 的 WHERE 条件。如果该行匹配（必须更新），MySQL 再次读取该行，这次 InnoDB 要么锁定它，要么等待锁定它。</li>
</ul>
<p>考虑以下示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (a <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, b <span class="type">INT</span>) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">4</span>,<span class="number">3</span>),(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，表没有索引字段，因此搜索和索引扫描使用隐藏的聚集索引进行记录锁定（请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">第 15.6.2.1 节，“聚集索引和二级索引”</a>）而不是索引列。</p>
<p>假设一个会话使用以下语句执行 UPDATE：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Session A</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">5</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>还假设第二个会话通过在第一个会话之后执行这些语句来执行 UPDATE：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Session B</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">4</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>InnoDB 在执行每个 UPDATE 时，首先为每一行获取一个排他锁，然后再决定是否修改它。如果 InnoDB 不修改该行，它会释放锁。否则，InnoDB 会保留锁直到事务结束。这会影响事务处理如下。</p>
<p>当使用默认的 <code>REPEATABLE READ</code> 隔离级别时，第一个 UPDATE 在它读取的每一行上获取一个 x 锁，并且不会释放任何行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x<span class="operator">-</span>lock(<span class="number">1</span>,<span class="number">2</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">2</span>,<span class="number">3</span>); <span class="keyword">update</span>(<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">to</span> (<span class="number">2</span>,<span class="number">5</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">3</span>,<span class="number">2</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">4</span>,<span class="number">3</span>); <span class="keyword">update</span>(<span class="number">4</span>,<span class="number">3</span>) <span class="keyword">to</span> (<span class="number">4</span>,<span class="number">5</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">5</span>,<span class="number">2</span>); retain x<span class="operator">-</span>lock</span><br></pre></td></tr></table></figure>
<p>第二个 UPDATE 在尝试获取任何锁时立即阻塞（因为第一个更新已保留所有行上的锁），并且在第一个 UPDATE 提交或回滚之前不会继续：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x<span class="operator">-</span>lock(<span class="number">1</span>,<span class="number">2</span>); block <span class="keyword">and</span> wait <span class="keyword">for</span> <span class="keyword">first</span> <span class="keyword">UPDATE</span> <span class="keyword">to</span> <span class="keyword">commit</span> <span class="keyword">or</span> roll back</span><br></pre></td></tr></table></figure>
<p>如果改为使用 <code>READ COMMITTED</code>，则第一个 UPDATE 在它读取的每一行上获取一个 x 锁，并为它不修改的行释放那些锁：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x<span class="operator">-</span>lock(<span class="number">1</span>,<span class="number">2</span>); unlock(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">2</span>,<span class="number">3</span>); <span class="keyword">update</span>(<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">to</span> (<span class="number">2</span>,<span class="number">5</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">3</span>,<span class="number">2</span>); unlock(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">4</span>,<span class="number">3</span>); <span class="keyword">update</span>(<span class="number">4</span>,<span class="number">3</span>) <span class="keyword">to</span> (<span class="number">4</span>,<span class="number">5</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">5</span>,<span class="number">2</span>); unlock(<span class="number">5</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>对于第二次 UPDATE，InnoDB 执行“半一致性”读取，将读取的每一行的最新提交版本返回给 MySQL，以便 MySQL 可以确定该行是否与 UPDATE 的 WHERE 条件匹配：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">x<span class="operator">-</span>lock(<span class="number">1</span>,<span class="number">2</span>); <span class="keyword">update</span>(<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">to</span> (<span class="number">1</span>,<span class="number">4</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">2</span>,<span class="number">3</span>); unlock(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">3</span>,<span class="number">2</span>); <span class="keyword">update</span>(<span class="number">3</span>,<span class="number">2</span>) <span class="keyword">to</span> (<span class="number">3</span>,<span class="number">4</span>); retain x<span class="operator">-</span>lock</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">4</span>,<span class="number">3</span>); unlock(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">x<span class="operator">-</span>lock(<span class="number">5</span>,<span class="number">2</span>); <span class="keyword">update</span>(<span class="number">5</span>,<span class="number">2</span>) <span class="keyword">to</span> (<span class="number">5</span>,<span class="number">4</span>); retain x<span class="operator">-</span>lock</span><br></pre></td></tr></table></figure>
<p>但是，如果 WHERE 条件包含索引列，并且 InnoDB 使用该索引，则在获取和保留记录锁时<strong>仅考虑索引列</strong>。</p>
<p>在以下示例中，第一个 UPDATE 在 b = 2 的每一行上获取并保留一个 x 锁。第二个 UPDATE 在尝试获取相同记录上的 x 锁时阻塞，因为它也使用在 b 列上定义的索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (a <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, b <span class="type">INT</span>, c <span class="type">INT</span>, INDEX (b)) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"># Session A</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">3</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"># Session B</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> b <span class="operator">=</span> <span class="number">4</span> <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> c <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p><code>READ COMMITTED</code> 隔离级别可以在启动时设置或在运行时更改。在运行时，它可以为所有会话全局设置，也可以为每个会话单独设置。</p>
</li>
<li>
<p><code>READ UNCOMMITTED</code>（读未提交）</p>
<p>**SELECT 语句以非锁定方式执行，但可能会使用行的早期版本。**因此，使用此隔离级别，<strong>将产生读取不一致。这也称为脏读</strong>。除了读取，此隔离级别的工作方式类似于 <code>READ COMMITTED</code>。</p>
</li>
<li>
<p><code>SERIALIZABLE</code>（序列化读）</p>
<p>此级别类似于 <code>REPEATABLE READ</code>，但 InnoDB 在禁用自动提交情况下将所有普通 SELECT 语句隐式转换为 <code>SELECT ... FOR SHARE</code>。如果启用了自动提交，则 SELECT 语句为它自己的事务。 因此，它是只读的，如果作为一致（非锁定）读取执行并且不需要阻塞其他事务，则可以序列化。（如果其他事务修改了所选行，要强制普通 SELECT 阻塞，请禁用自动提交。）</p>
</li>
</ul>
<h2 id="自动提交-手动提交-和回滚">自动提交, 手动提交, 和回滚</h2>
<p>在 InnoDB 中，所有用户活动都发生在一个事务中。<strong>如果启用了自动提交（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_autocommit"><code>autocommit</code></a>）模式，则每个 SQL 语句都会单独形成一个事务</strong>。默认情况下，MySQL 为每个启用自动提交的新连接启动会话，因此，如果该语句没有返回错误，则 MySQL 在每个 SQL 语句之后执行一次提交。如果语句返回错误，则提交或回滚行为取决于错误。请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-error-handling.html">第 15.21.5 节，“InnoDB 错误处理”</a>。</p>
<p>**启用了自动提交的会话可以通过显式的 <code>START TRANSACTION</code> 或 <code>BEGIN</code> 语句启动它并以 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句结束它来执行多语句事务。**请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/commit.html">参阅第 13.3.1 节，“START TRANSACTION、COMMIT 和 ROLLBACK 语句”</a>。</p>
<p>如果使用 <code>SET autocommit = 0</code> 在会话中禁用自动提交模式，则会话始终打开<em><strong>一个</strong></em>事务。 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句结束当前事务并开始一个新事务。</p>
<p>如果禁用自动提交的会话在没有明确提交最终事务的情况下结束，MySQL 将回滚该事务。</p>
<p>有些语句隐式地结束了一个事务，就好像您在执行该语句之前已经完成了 <code>COMMIT</code> 一样。有关详细信息，请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html">参阅第 13.3.3 节，“导致隐式提交的语句”</a>。</p>
<p><code>COMMIT</code> 意味着在当前事务中所做的更改是永久的，并且对其他会话可见。另一方面，<code>ROLLBACK</code> 语句取消当前事务所做的所有修改。 <code>COMMIT</code> 和 <code>ROLLBACK</code> 都释放在当前事务期间设置的所有 InnoDB 锁。</p>
<h3 id="将-DML-操作与事务分组">将 DML 操作与事务分组</h3>
<p>默认情况下，与 MySQL 服务器的连接以启用自动提交模式开始，它会在您执行每个 SQL 语句时自动提交它。如果您有其他数据库系统的经验，这种操作模式可能会比较陌生，标准做法是发出一系列 DML 语句并将它们提交或全部回滚。</p>
<p>要使用多语句事务，请使用 SQL 语句 <code>SET autocommit = 0</code> 关闭自动提交，并根据需要使用 <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束每个事务。或者在保持自动提交的情况下，显式的以 <code>START TRANSACTION</code> 开始每个事务，并以 <code>COMMIT</code> 或 <code>ROLLBACK</code> 结束。</p>
<p>以下示例显示了两个事务。第一个是提交成功的；第二个回滚。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">shell&gt; </span><span class="language-bash">mysql <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">-- Do a transaction with autocommit turned on.</span></span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">START TRANSACTION;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">INSERT INTO customer VALUES (10, <span class="string">&#x27;Heikki&#x27;</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">COMMIT;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">-- Do another transaction with autocommit turned off.</span></span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">SET autocommit=0;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">INSERT INTO customer VALUES (15, <span class="string">&#x27;John&#x27;</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">INSERT INTO customer VALUES (20, <span class="string">&#x27;Paul&#x27;</span>);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">DELETE FROM customer WHERE b = <span class="string">&#x27;Heikki&#x27;</span>;</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">-- Now we undo those last 2 inserts and the delete.</span></span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">ROLLBACK;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">SELECT * FROM customer;</span></span><br><span class="line">+------+--------+</span><br><span class="line">| a    | b      |</span><br><span class="line">+------+--------+</span><br><span class="line">|   10 | Heikki |</span><br><span class="line">+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="客户端语言的事务">客户端语言的事务</h3>
<p>在 PHP、Perl DBI、JDBC、ODBC 或 MySQL 的标准 C 调用接口等 API 中，您可以像 SELECT 或 INSERT 等任何其他 SQL 语句一样将 COMMIT 等事务控制语句作为字符串发送到 MySQL 服务器。一些 API 还提供单独的特殊事务提交和回滚功能或方法。</p>
<h2 id="一致性非阻塞读取">一致性非阻塞读取</h2>
<p><strong>一致性读取意味着 InnoDB 使用多版本控制在某个时间点向查询呈现数据库的快照</strong>。查询会看到在该时间点之前提交的事务所做的更改，而不会看到稍后或未提交的事务所做的更改。此规则的一个例外是查询会看到同一事务中较早的语句所做的更改。此异常会导致以下异常情况：如果更新表中的某些行，SELECT 会看到更新行的最新版本，但它也可能会看到任何行的旧版本。如果其他会话同时更新同一个表，则异常意味着您可能会看到该表处于数据库中从未存在过的状态。</p>
<p>如果事务隔离级别是 <code>REPEATABLE READ</code>（默认级别），则同一事务中的所有一致性读取都会使用第一次读取建立的快照。你可以通过提交当前事务然后发出新查询来为您的查询获取更新的快照。</p>
<p>使用 <code>READ COMMITTED</code> 隔离级别，事务中的每个一致性读取设置并读取自己的新快照。</p>
<p>一致读取是 InnoDB 在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 隔离级别处理 SELECT 语句的默认模式。<strong>一致读不会在它访问的表上设置任何锁</strong>，因此，其他会话可以在对表执行一致读取的同时自由修改这些表。</p>
<p>假设您在默认的 <code>REPEATABLE READ</code> 隔离级别下运行。当您发出一致性读取（即普通的 SELECT 语句）时，InnoDB 为您的事务提供一个时间点，您的查询根据该时间点查看数据库。如果另一个事务在分配您的时间点后删除一行并提交，您不会看到该行已被删除。插入和更新的处理方式类似。</p>
<blockquote>
<p>数据库状态的快照适用于事务中的 SELECT 语句，不一定适用于 DML 语句。如果您插入或修改一些行然后提交该事务，从另一个并发 REPEATABLE READ 事务发出的 DELETE 或 UPDATE 语句可能会影响那些刚刚提交的行，即使会话无法查询它们。如果一个事务确实更新或删除了由不同事务提交的行，则这些更改对当前事务是可见的。例如，您可能会遇到如下情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c1) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- Returns 0: no rows match.</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> <span class="string">&#x27;xyz&#x27;</span>;</span><br><span class="line"><span class="comment">-- Deletes several rows recently committed by other transaction.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- Returns 0: no rows match.</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span> <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">-- Affects 10 rows: another txn just committed 10 rows with &#x27;abc&#x27; values.</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 <span class="operator">=</span> <span class="string">&#x27;cba&#x27;</span>;</span><br><span class="line"><span class="comment">-- Returns 10: this txn can now see the rows it just updated.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>您可以通过提交您的事物，然后使用另一个 <code>SELECT</code> 或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/commit.html"><code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code></a> 来提前您的时间点。</p>
<p>这称为多版本并发控制。</p>
<p>在以下示例中，会话 A 仅在 B 已提交插入且 A 也已提交时才能看到 B 插入的行，因此时间点会提前到 B 的提交之后。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">             Session A              Session B</span><br><span class="line"></span><br><span class="line">           <span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;      <span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="type">time</span></span><br><span class="line"><span class="operator">|</span>          <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line"><span class="operator">|</span>          <span class="keyword">empty</span> <span class="keyword">set</span></span><br><span class="line"><span class="operator">|</span>                                 <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="operator">|</span></span><br><span class="line">v          <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line">           <span class="keyword">empty</span> <span class="keyword">set</span></span><br><span class="line">                                  <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line">           <span class="keyword">empty</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br><span class="line">           <span class="comment">---------------------</span></span><br><span class="line">           <span class="operator">|</span>    <span class="number">1</span>    <span class="operator">|</span>    <span class="number">2</span>    <span class="operator">|</span></span><br><span class="line">           <span class="comment">---------------------</span></span><br></pre></td></tr></table></figure>
<p>如果要查看数据库的“最新”状态，请使用 <code>READ COMMITTED</code> 隔离级别或锁定读取：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>
<p>使用 <code>READ COMMITTED</code> 隔离级别，事务中的每个一致性读取设置并读取自己的新快照。使用 <code>FOR SHARE</code> 时，会发生锁定读取：SELECT 会阻塞，直到包含最新行的事务结束。</p>
<p>一致性读取不适用于某些 DDL 语句：</p>
<ul>
<li>一致性读取不适用于 <code>DROP TABLE</code>，因为 MySQL 无法使用已删除的表，并且 InnoDB 会破坏该表。</li>
<li>一致性读取不适用于 <code>ALTER TABLE</code> 操作，这些操作创建原始表的临时副本并在构建临时副本时删除原始表。当您在事务中重新发出一致性读取时，新表中的行不可见，因为在获取事务快照时这些行不存在。在这种情况下，事务返回错误：<code>ER_TABLE_DEF_CHANGED</code>，“表定义已更改，请重试事务”。</li>
</ul>
<p>读取类型因 <code>INSERT INTO ... SELECT</code>、<code>UPDATE ... (SELECT)</code> 和 <code>CREATE TABLE ... SELECT</code> 等子句中的选择而异，这些子句未指定 <code>FOR UPDATE</code> 或 <code>FOR SHARE</code>：</p>
<ul>
<li>默认情况下，InnoDB 对这些语句使用更强的锁，SELECT 部分的作用类似于 <code>READ COMMITTED</code>，其中每个一致性的读取，即使在同一个事务中，也会设置和读取自己的新快照。</li>
<li>要在这种情况下执行非锁定读取，请将事务的隔离级别设置为 <code>READ UNCOMMITTED</code> 或 <code>READ COMMITTED</code> 以避免对从所选表读取的行设置锁定。</li>
</ul>
<h2 id="锁定读取">锁定读取</h2>
<p>如果您查询数据然后在同一事务中插入或更新相关数据，则常规 SELECT 语句不会提供足够的保护。其他事务可以更新或删除您刚刚查询的相同行。InnoDB 支持两种类型的锁定读取，提供额外的安全性：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT ... FOR SHARE</code></a></p>
<p>在读取的任何行上设置共享模式锁。其他会话可以读取这些行，但在您的事务提交之前无法修改它们。如果这些行中的任何一行被另一个尚未提交的事务更改，您的查询将等待该事务结束，然后使用最新值。</p>
<p>在 MySQL 8.0.22 之前，<code>SELECT ... FOR SHARE</code> 需要 <code>SELECT</code> 权限和至少 <code>DELETE</code>、<code>LOCK TABLES</code> 或 <code>UPDATE</code> 权限之一。从 MySQL 8.0.22 开始，只需要 <code>SELECT</code> 权限。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT ... FOR UPDATE</code></a></p>
<p>对于搜索遇到的索引记录，将会锁定该行和任何关联的索引条目，就像您为这些行发出 UPDATE 语句一样。其他事务被阻止更新这些行、执行 <code>SELECT ... FOR SHARE</code> 或读取某些事务隔离级别的数据。</p>
<p>一致读取忽略对读取视图中存在的记录设置的任何锁定。 （旧版本的记录不能被锁定；它们是通过在记录的内存副本上应用撤消日志（<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_undo_log">undo logs</a>）来重建的。）</p>
<p><code>SELECT ... FOR UPDATE</code> 需要 <code>SELECT</code> 权限和需要执行的 <code>DELETE</code>、<code>LOCK TABLES</code> 或 <code>UPDATE</code> 权限之一。</p>
</li>
</ul>
<p>这些语句主要在处理树结构或图结构数据时有用，无论是在单个表中还是拆分到多个表中。你遍历边界或将树从一个地方到分支另一个地方，同时保留返回并更改任何这些“指针”值。</p>
<p>当事务提交或回滚时，所有由 <code>FOR SHARE</code> 和 <code>FOR UPDATE</code> 查询设置的锁都会被释放。</p>
<blockquote>
<p>只有在禁用自动提交时才可能锁定读取（通过使用 START TRANSACTION 开始事务或将自动提交设置为 0。)</p>
</blockquote>
<p>除非在子查询中还指定了锁定读取子句，否则外部语句中的锁定读取子句不会锁定嵌套子查询中表的行。例如，以下语句不会锁定表 t2 中的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> (<span class="keyword">SELECT</span> c1 <span class="keyword">FROM</span> t2) <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>要锁定表 t2 中的行，请向子查询添加锁定读取子句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 <span class="operator">=</span> (<span class="keyword">SELECT</span> c1 <span class="keyword">FROM</span> t2 <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>) <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h3 id="锁定读取示例">锁定读取示例</h3>
<p>假设您要在表 <em>child</em> 中插入新行，并确保子行在表 <em>parent</em> 中也存在。您的应用程序代码需要确保整个序列操作中的数据正确引用。</p>
<p>首先，使用一致性读取来查询表 <em>PARENT</em> 并验证父行是否存在。您可以安全地将子行插入到表 <em>CHILD</em> 中吗？不，因为其他一些会话可能会在您的 SELECT 和您的 INSERT 之间删除父行，而您没有意识到这一点。</p>
<p>为避免此潜在问题，请使用 <code>FOR SHARE</code> 执行 <code>SELECT</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> parent <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;Jones&#x27;</span> <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>
<p>在 <code>FOR SHARE</code> 查询返回父“Jones”后，您可以安全地将子记录添加到 <em>CHILD</em> 表并提交事务。</p>
<p>任何试图在 <em>PARENT</em> 表中的这些行上获取排他锁的事务都将等待您完成，即直到所有表中的数据都处于一致状态。</p>
<p>再举一个例子，考虑表 <em>CHILD_CODES</em> 中的整数计数器字段，用于为添加到表 <em>CHILD</em> 的每个子项分配唯一标识符。不要使用一致读取或共享模式读取来读取计数器的当前值，因为数据库的两个用户可能会看到计数器的相同值，如果两个事务尝试将具有相同标识符的行添加到 <em>CHILD</em> 表，则会发生重复键错误。</p>
<p>要实现计数器的读取和递增，首先使用 <code>FOR UPDATE</code> 对计数器进行锁定读取，然后递增计数器。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> counter_field <span class="keyword">FROM</span> child_codes <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> child_codes <span class="keyword">SET</span> counter_field <span class="operator">=</span> counter_field <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>SELECT ... FOR UPDATE</code> 读取最新的可用数据，在它读取的每一行上设置排他锁。因此，它设置了与搜索 SQL UPDATE 将在行上设置的相同的锁。</p>
<p>前面的描述仅仅是 <code>SELECT ... FOR UPDATE</code> 如何工作的一个例子。在 MySQL 中，生成唯一标识符的具体任务实际上可以通过对表的单次访问来完成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> child_codes <span class="keyword">SET</span> counter_field <span class="operator">=</span> LAST_INSERT_ID(counter_field <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();</span><br></pre></td></tr></table></figure>
<p>SELECT 语句仅检索标识符信息（特定于当前连接）。它不访问任何表。</p>
<h3 id="使用-NOWAIT-和-SKIP-LOCKED-锁定读取并发">使用 NOWAIT 和 SKIP LOCKED 锁定读取并发</h3>
<p>如果行被事务锁定，则请求同一锁定行的 <code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... FOR SHARE</code> 事务必须等到阻塞事务释放行锁。此行为可防止事务更新或删除其他事务查询更新的行。但是，如果您希望在请求的行被锁定时立即返回查询，或者如果从结果集中排除锁定的行是可以接受的，则不必等待行锁被释放。</p>
<p>为了避免等待其他事务释放行锁，可以将 <code>NOWAIT</code> 和 <code>SKIP LOCKED</code> 选项与 <code>SELECT ... FOR UPDATE</code> 或 <code>SELECT ... FOR SHARE</code> 锁定读取语句一起使用。</p>
<ul>
<li>
<p><code>NOWAIT</code></p>
<p>使用 <code>NOWAIT</code> 的锁定读取从不等待获取行锁。查询立即执行，如果请求的行被锁定，则会失败并显示错误。</p>
</li>
<li>
<p><code>SKIP LOCKED</code></p>
<p>使用 <code>SKIP LOCKED</code> 的锁定读取从不等待获取行锁。查询立即执行，从结果集中删除锁定的行。</p>
<blockquote>
<p>跳过锁定行的查询会返回不一致的数据视图。因此，SKIP LOCKED 不适用于一般事务性工作。但是，当多个会话访问同一个类似队列的表时，它可以用来避免锁争用。</p>
</blockquote>
</li>
</ul>
<p><code>NOWAIT</code> 和 <code>SKIP LOCKED</code> 仅适用于行级锁。</p>
<p>使用 <code>NOWAIT</code> 或 <code>SKIP LOCKED</code> 的语句对于基于语句的复制是不安全的。</p>
<p>下面的示例演示了 <code>NOWAIT</code> 和 <code>SKIP LOCKED</code>。会话 1 启动一个对单个记录进行行锁定的事务。会话 2 尝试使用 <code>NOWAIT</code> 选项对同一记录进行锁定读取。由于请求的行被会话 1 锁定，锁定读取会立即返回并显示错误。在会话 3 中，使用 <code>SKIP LOCKED</code> 的锁定读取返回请求的行，但会话 1 锁定的行除外。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Session <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (i) <span class="keyword">VALUES</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"></span><br><span class="line"># Session <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> NOWAIT;</span><br><span class="line">ERROR <span class="number">3572</span> (HY000): Do <span class="keyword">not</span> wait <span class="keyword">for</span> lock.</span><br><span class="line"></span><br><span class="line"># Session <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> LOCKED;</span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> i <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---+</span></span><br></pre></td></tr></table></figure>
<h1>InnoDB 中不同 SQL 语句设置的锁</h1>
<p>锁定读取、更新或删除通常会在处理 SQL 语句时在扫描的每个索引记录上设置记录锁定。**语句中是否存在排除该行的 WHERE 条件并不重要。**InnoDB 不记得确切的 WHERE 条件，但只知道扫描了哪些索引范围。锁通常是 <code>next-key</code> 锁，它也阻止插入记录之前的“间隙”。但是，可以显式禁用间隙锁定，这会导致不使用 <code>next-key</code> 锁定。事务隔离级别也会影响设置了哪些锁；</p>
<p>如果在搜索中使用二级索引并且要设置的索引记录锁是排他的，则 InnoDB 还会检索相应的聚集索引记录并对其设置锁。</p>
<p>如果您没有适合您的语句的索引，并且 MySQL 必须扫描整个表来处理该语句，则该表的每一行都会被锁定，从而阻止其他用户对该表的所有插入。创建好的索引很重要，这样您的查询就不会扫描过多的行。</p>
<p>InnoDB 设置特定类型的锁如下。</p>
<ul>
<li>
<p><code>SELECT ... FROM</code> 是一致性读取，读取数据库的快照并且不设置锁，除非事务隔离级别设置为 <code>SERIALIZABLE</code>。对于 <code>SERIALIZABLE</code> 级别，搜索在它遇到的索引记录上设置共享的 <code>next-key</code> 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p>
</li>
<li>
<p><code>SELECT ... FOR UPDATE</code> 和 <code>SELECT ... FOR SHARE</code> 语句使用唯一索引获取扫描行的锁，并释放不符合包含在结果集中的行的锁（例如，如果它们不符合 WHERE 子句中给出的条件）。但是，在某些情况下，行可能不会立即解锁，因为在查询执行期间结果行与其原始数据之间的关系丢失。例如，在 <code>UNION</code> 中，表中的扫描（和锁定）行可能会在评估它们是否符合结果集的条件之前插入到临时表中。在这种情况下，临时表中的行与原始表中的行的关系丢失，并且后面的行直到查询执行结束才解锁。</p>
</li>
<li>
<p>对于锁定读取（<code>SELECT with FOR UPDATE</code> 或 <code>FOR SHARE</code>）、<code>UPDATE</code> 和 <code>DELETE</code> 语句，采用的锁定取决于该语句是使用具有唯一搜索条件的唯一索引还是范围类型搜索条件。</p>
<ul>
<li>对于具有唯一搜索条件的唯一索引，InnoDB 只锁定找到的索引记录，而不锁定它之前的间隙。</li>
<li>对于其他搜索条件，对于非唯一索引，InnoDB 会锁定扫描的索引范围，使用间隙锁或 <code>next-key</code> 锁来阻止其他会话插入范围所覆盖的间隙。</li>
</ul>
</li>
<li>
<p>对于搜索遇到的索引记录，<code>SELECT ... FOR UPDATE</code> 阻止其他会话执行 <code>SELECT ... FOR SHARE</code> 或读取某些事务隔离级别。</p>
</li>
<li>
<p><code>UPDATE ... WHERE ...</code> 在搜索遇到的每条记录上设置一个独占的 <code>next-key</code> 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p>
</li>
<li>
<p>当 <code>UPDATE</code> 修改聚集索引记录时，会对受影响的二级索引记录进行隐式锁定。在插入新的二级索引记录之前执行重复检查扫描时，以及在插入新的二级索引记录时，<code>UPDATE</code> 操作还会对受影响的二级索引记录使用共享锁。</p>
</li>
<li>
<p><code>DELETE FROM ... WHERE ...</code> 在搜索遇到的每条记录上设置一个独占的 <code>next-key</code> 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。</p>
</li>
<li>
<p><code>INSERT</code> 在插入的行上设置排他锁。这个锁是索引记录锁，不是 <code>next-key</code> 锁（即没有间隙锁），并且不会阻止其他会话在插入行之前插入间隙。</p>
<p>在插入行之前，设置了一种称为插入意向间隙锁（Insert intention gap lock）的间隙锁。此锁表示插入意图，如果插入同一索引间隙的多个事务未插入间隙内的相同位置，则它们无需相互等待。假设存在值为 4 和 7 的索引记录。 尝试插入值 5 和 6 的单独事务在获得插入行的排他锁之前，每个事务都使用插入意向锁锁定了 4 和 7 之间的间隙，但不会相互阻塞，因为行不冲突。</p>
<p>如果发生重复键错误，则在重复索引记录上设置共享锁。如果另一个会话已经拥有排它锁，那么如果有多个会话尝试插入同一行，则使用共享锁可能会导致死锁。如果另一个会话删除该行，就会发生这种情况。假设 InnoDB 表 t1 具有以下结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="type">INT</span>, <span class="keyword">PRIMARY</span> KEY (i)) ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>
<p>现在假设三个会话依次执行以下操作：</p>
<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Session 2:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Session 3:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>
<p>会话 1 的第一个操作获取该行的排它锁。会话 2 和 3 的操作都会导致重复键错误，并且它们都为该行请求共享锁。当会话 1 回滚时，它会释放它对该行的排它锁，并且会话 2 和 3 的排队共享锁请求被授予。此时，会话 2 和会话 3 陷入僵局：此时，会话 2 和 3 死锁：由于对方都持有共享锁，因此都无法获取该行的排他锁。</p>
<p>如果表中已经包含键值为 1 的行，并且三个会话依次执行以下操作，则会出现类似情况：</p>
<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>Session 2:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Session 3:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>Session 1:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>会话 1 的第一个操作获取该行的排它锁。会话 2 和 3 的操作都会导致重复键错误，并且它们都为该行请求共享锁。当会话 1 提交时，它会释放其在该行上的排它锁，并授予会话 2 和 3 的排队共享锁请求。此时，会话 2 和会话 3 陷入僵局：由于对方都持有共享锁，双方都无法获得该行的排他锁。</p>
</li>
<li>
<p><code>INSERT ... ON DUPLICATE KEY UPDATE</code> 与简单的 INSERT 的不同之处在于，当发生重复键错误时，将在要更新的行上放置排他锁而不是共享锁。对重复的主键值采用独占索引记录锁。对重复的唯一键值采用独占的 <code>next-key</code> 锁。</p>
</li>
<li>
<p><code>REPLACE</code> 就像 <code>INSERT</code> 一样，如果唯一键没有冲突。否则，将在要替换的行上放置一个独占的 <code>next-key</code> 锁。</p>
</li>
<li>
<p><code>INSERT INTO T SELECT ... FROM S WHERE ...</code> 在插入到 <code>T</code> 的每一行上设置排他索引记录锁（没有间隙锁）。如果事务隔离级别为<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed"><code>READ COMMITTED</code></a>，<code>InnoDB</code>则将搜索<code>S</code>作为一致读（无锁）进行。否则，<code>InnoDB</code>对来自 <code>S</code> 的行设置共享 <code>next-key</code> 锁。 <code>InnoDB</code>在后一种情况下必须设置锁：在使用基于语句的二进制日志的前滚恢复期间，每个 SQL 语句都必须以与最初执行的方式完全相同的方式执行。</p>
<p><code>CREATE TABLE ... SELECT ...</code> 使用共享的 <code>next-key</code> 锁或作为一致读取执行 <code>SELECT</code>，如 <code>INSERT ... SELECT</code>。</p>
<p>当在结构 <code>REPLACE INTO t SELECT ... FROM s WHERE ...</code> 或 <code>UPDATE t ... WHERE col IN (SELECT ... FROM s ...)</code> 中使用 <code>SELECT</code> 时，InnoDB 将共享 <code>next-key</code> 锁设置为表 s 中的行。</p>
</li>
<li>
<p>InnoDB 在初始化表上先前指定的 <code>AUTO_INCREMENT</code> 列时，在与 <code>AUTO_INCREMENT</code> 列关联的索引的末尾设置排他锁。</p>
<p>当 <code>innodb_autoinc_lock_mode=0</code> 时，InnoDB 使用特殊的 <code>AUTO-INC</code> 表锁模式，在访问自动递增计数器时，获取锁并将其保持到当前 SQL 语句的末尾（而不是整个事务的末尾）。持有 <code>AUTO-INC</code> 表锁时，其他客户端无法插入表中。对于 <code>innodb_autoinc_lock_mode=1</code> 的“批量插入”也会发生相同的行为。表级 <code>AUTO-INC</code> 锁不与 <code>innodb_autoinc_lock_mode=2</code> 一起使用。有关更多信息，请<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html">参阅第 15.6.1.6 节，“InnoDB 中的 AUTO_INCREMENT 处理”</a>。</p>
<p>InnoDB 在不设置任何锁的情况下获取先前初始化的 <code>AUTO_INCREMENT</code> 列的值。</p>
</li>
<li>
<p>如果在表上定义了 <code>FOREIGN KEY</code> 约束，则任何需要检查约束条件的插入、更新或删除都会在它查看以检查约束的记录上设置共享记录级锁。InnoDB 也会在约束失败的情况下设置这些锁。</p>
</li>
<li>
<p><code>LOCK TABLES</code> 设置表锁，但设置这些锁的是 InnoDB 层之上的更高 MySQL 层。如果 <code>innodb_table_locks = 1</code>（默认值）和 <code>autocommit = 0</code>，InnoDB 知道表锁，并且 InnoDB 之上的 MySQL 层知道行级锁。</p>
<p>否则，InnoDB 的自动死锁检测无法检测到涉及此类表锁的死锁。因为在这种情况下，更高的 MySQL 层不知道行级锁，可以在另一个会话当前具有行级锁的表上获得表锁。但是，这不会危及事务完整性，如<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html">第 15.7.5.2 节“死锁检测”中所述</a>。</p>
</li>
<li>
<p>如果 <code>innodb_table_locks=1</code>（默认值），<code>LOCK TABLES</code> 会在每个表上获取两个锁。除了 MySQL 层的表锁外，它还获取了一个InnoDB 表锁。为了避免获取 InnoDB 表锁，设置 <code>innodb_table_locks=0</code>。如果没有获取 InnoDB 表锁，即使表的某些记录被其他事务锁定，<code>LOCK TABLES</code> 也会完成。</p>
<p>在 MySQL 8.0 中，<code>innodb_table_locks=0</code> 对使用 <code>LOCK TABLES ... WRITE</code> 显式锁定的表没有影响。但是对通过 <code>LOCK TABLES ... WRITE</code> 隐式（例如，通过触发器）锁定以进行读取或写入的表有影响。</p>
</li>
<li>
<p>当事务提交或中止时，事务持有的所有 InnoDB 锁都会被释放。因此，在 <code>autocommit=1</code> 模式下在 InnoDB 表上调用 <code>LOCK TABLES</code> 没有多大意义，因为获取的 InnoDB 表锁会立即释放。</p>
</li>
<li>
<p>你不能在事务中间锁定其他表，因为 <code>LOCK TABLES</code> 执行隐式 <code>COMMIT</code> 和 <code>UNLOCK TABLES</code>。</p>
</li>
</ul>
<h1>幻读</h1>
<p>当一个事物中同一个查询在不同时间产生不同的行集时，就认为发生了幻读问题。例如，如果 SELECT 执行两次，但第二次返回第一次未返回的行，则该行被称为“幻影”行。</p>
<p>假设 <em>child</em> 表的 <em>id</em> 列上有一个索引，并且您想要读取并锁定表中 <em>id</em> 值大于 100 的所有行，以便稍后更新所选行中的某些列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> child <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>查询从 <em>id</em> 大于 100 的第一条记录开始扫描索引。该表包含 <em>id</em> 值为 90 和 102 的行。如果在扫描范围内的索引记录上设置的锁没有锁定在间隙（在本例中为 90 和 102 之间的间隙）中进行的插入，另一个会话就可以在表的该间隙中插入一个新行，<em>id</em> 为 101。如果你在同一个事务中执行相同的 SELECT，就会在查询返回的结果集中看到一个 <em>id</em> 为 101（“幻影”）的新行。如果我们把一组行看作一个数据项整体，新的幻影行就会违反事务的隔离原则：隔离确保事务的并发执行使数据库处于与顺序执行事务时获得的状态相同。不完整的事物的影响甚至可能对其他事物不可见。</p>
<p>为了防止幻读，InnoDB 使用了一种称为 <code>next-key</code> 锁定的算法，该算法将索引行锁定与间隙锁定相结合。InnoDB 执行行级锁定的方式是，当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或排他锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的 <code>next-key</code> 锁也会影响索引记录之前的“间隙”。也就是说，<code>next-key</code> 锁是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。如果一个会话在索引中的记录 <em>R</em> 上有共享锁或排他锁，另一个会话就不能在索引顺序中紧靠 R 之前的间隙中插入新的索引记录。</p>
<p>InnoDB 扫描索引时，也可以锁定索引中最后一条记录后的间隙。在前面的例子中就是这样：为了防止在 <em>id</em> 大于 100 的表中进行任何插入，InnoDB 设置的锁包括对 <em>id</em> 值 102 之后的间隙的锁。</p>
<p>你可以使用 <code>next-key</code> 锁定在你的应用程序中实现唯一性检查：如果您在共享模式下读取数据并且没有看到您要插入的行的重复项，那么您可以安全地插入您的行并知道在读取期间在您的行的后继者上设置的 <code>next-key</code> 锁可防止任何人同时为您的行插入重复项。因此，<code>next-key</code> 锁定使您能够“锁定”表中不存在的内容。</p>
<p>可以禁用间隙锁定，如 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">第 15.7.1 节，“InnoDB 锁定”中所述</a>。这可能会导致幻读问题，因为当禁用间隙锁定时，其他会话可以将新行插入间隙中。</p>
<h1>总结</h1>
<p>在默认的事物隔离级别可重复读 <code>REPEATABLE READ</code> 在同一事物中会使用基于 <code>MVCC</code> 的多版本控制系统来实现<strong>无锁的一致性读</strong>，多次读取会使用第一次建立的快照。</p>
<p>对于 <code>UPDATE</code>、<code>DELETE</code> 等操作使用锁定读取，锁定读取会为扫描到的每条记录设置锁定，不管有没有匹配 <code>WHERE</code> 条件，如果查询是搜索唯一行的唯一索引，则只锁定记录锁，否则对于非唯一索引、其他搜索条件，会使用 <code>next-key</code> 独占锁锁定记录和之间的间隙锁。</p>
<p>对于 <code>INSERT</code> 语句，会先使用插入意向锁这种间隙锁来表明自己要在此间隙插入的意图，在获取到要插入位置的意向锁后会使用排他记录锁锁定该行。</p>
<p>由于可重复读隔离级别使用一次建立快照的一致性读和 <code>next-key</code> 锁，有效避免了同一事物在间隙中插入数据而导致两次查询返回不同的数据的<strong>幻读</strong>问题。</p>
<p>对于读已提交 <code>READ COMMITTED</code>隔离级别，也是使用一致性读，但是统一事物中每次一致性读都会建立新的快照，而且对于 <code>UPDATE</code>、<code>DELETE</code> 等操作的锁定读取变为只锁定记录，不锁定间隙，且只锁定满足条件的记录。<code>INSERT</code> 和可重复读保持一致。</p>
<p>由于少了间隙锁和使用每次建立新快照的一致性读，导致同一事物中可能在两次范围查询中间存在该范围的插入数据，导致后面一次查询出现幻影行，导致幻读。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>InnoDB</tag>
        <tag>Locking</tag>
        <tag>Transaction</tag>
        <tag>Intention Lock</tag>
        <tag>Record Lock</tag>
        <tag>Gap Lock</tag>
        <tag>Next-Key Lock</tag>
        <tag>Insert Intention Lock</tag>
        <tag>AUTO-INC Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引初探</title>
    <url>/persistence/db/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。<br>
索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。</p>
<span id="more"></span>
<h1>索引的类型</h1>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。在 <code>MySQL</code> 中，案引是存储引擎层而不是服务器层实现的，所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<p>下面列举 <code>MySQL</code> 常见的索引类型，以及他们的优缺点。</p>
<h2 id="B-Tree-索引">B-Tree 索引</h2>
<p>当人们讨论索引的时候，如果没有特别指明类型，那多半说的是 B-Tree 索引，术语 <code>B-Tree</code> 并不特别指它的存储结构就是 <code>B-Tree</code>，<code>InnoDB</code> 使用的就是它的变种 <code>B+Tree</code>。</p>
<blockquote>
<p>B 树是二叉树的升级版，又叫平衡多路查找树，它的结点可以有很多子节点，二叉树最多只有 2 个子节点。</p>
<p>B+ 树是应文件系统所需而产生的一种 B 树的变形树，只有最底层的叶子节点保存数据，非叶子节点只保存索引，不保存实际的数据。</p>
<p>B+ 数中每个叶子节点都包含指向下一个叶子结点的顺序访问指针，方便叶子结点的范围遍历，节点的链接也方便了磁盘的顺序 IO。</p>
</blockquote>
<p><code>B-Tree</code> 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。下图展示了 <code>B-Tree</code> 索引的抽象表示，大致表示了 <code>InnoDB</code> 索引是如何工作的。</p>
<p><img data-src="../../../images/db/b+tree_index.png" alt="B+Tree 索引"></p>
<p>B-Tree 索引能够加快访问数据的速度，因为存储引起不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根结点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。</p>
<p>叶子结点比较特别，他们的指针指向的是被索引的数据，而不是其它的节点页。下图绘制了一个节点和其对应的叶子节点，其实在根节点和叶子节点之间可能有很多层节点页，树的深度和表的大小直接相关。</p>
<p>**B-Tree 对索引列是顺序组织存储的，所以很适合范围查找数据。**例如，在一个基于文本域的索引树上，像“找出所有以 I 到 K 开头的名字”这样的查找效率会非常高。</p>
<p>假如有如下一张表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">    last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    dob <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender enum(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>表中的每一行数据，索引中包含了 last_name、first_name 和 dob 列中的值，下图展示了该索引是如何组织数据存储的。</p>
<p><img data-src="../../../images/db/tree_item.png" alt="索引树中的部分条目"></p>
<p>请注意，**索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。**看一下最后两个条目，两个人的姓和名都一样，则根据他们的出生日期来排列顺序。</p>
<p>可以使用 B-Tree 索引的查询类型。 B-Tree 索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找，前面所述的索引对如下类型的查询有效。</p>
<p><em><strong>全值匹配</strong></em></p>
<p>全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen，出生于 1960-01-01 的人。</p>
<p><em><strong>匹配最左前缀</strong></em></p>
<p>前面提到的索引可用于查找所有姓为 Allen 的人，即只使用索引的第一列。</p>
<p><em><strong>匹配列前缀</strong></em></p>
<p>也可以只匹配某一列值的开头部分。例如前面提到的索引可用于查找所有以 J 开头的姓的人。这里也只使用索引的第一列。</p>
<p><em><strong>匹配范围值</strong></em></p>
<p>例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。</p>
<p><em><strong>精确匹配某一列并范围匹配另外一列</strong></em></p>
<p>前面提到的索引也可用于査找所有姓为 Allen，并且名字是字母 K 开头(比如 Kim、Karl 等)的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</p>
<p><em><strong>只访问索引的查询</strong></em></p>
<p>B-Tree 通常可以支持“只访问索引的査询”，即査询只需要访问索引，而无须访问数据行。后面我们将单独讨论这种“覆盖索引”的优化。</p>
<p>因为索引树中的节点是有序的，所以除了按值査找之外，索引还可以用于査询中的 <code>ORDER BY</code> 操作(按顺序査找)。一般来说，如果 <code>B-Tree</code> 可以按照某种方式査找到值，那么也可以按照这种方式用于排序。所以，如果 <code>ORDER BY</code> 子句满足前面列出的几种査询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于 B-Tree 索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始査找，则无法使用索引。例如上面例子中的索引无法用于査找名字为 Bill 的人，也无法査找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法査找姓氏以某个字母结尾的人。</li>
<li>不能跳过索引中的列。也就是说，前面所述的索无法用于査找姓为 Smith 并且在某个特定日期出生的人。如果不指定名 (first name)，则 MYSQL 只能使用索引的第一列。</li>
<li>如果査询中有某个列的范围査询，则其右边所有列都无法使用索引优化査找。例如有査询 <code>WHERE last name=' Smith' AND first name LIKE'1%' AND dob='1976 12-23'</code>，这个査询只能使用索引的前两列，因为这里 <code>LIKE</code> 是一个范围条件(但是服务器可以把其余列用于其他目的)。如果范围査询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。</li>
</ul>
<h3 id="为什么使用-B-Tree-B-Tree">为什么使用 B-Tree (B+Tree)</h3>
<p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析 B-/+Tree 作为索引的效率。</p>
<h4 id="局部性原理与磁盘预读">局部性原理与磁盘预读</h4>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p><strong>当一个数据被用到时，其附近的数据也通常会马上被使用。</strong></p>
<p><strong>程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h4 id="B-Tree-索引的性能分析">B-/+Tree 索引的性能分析</h4>
<p>从使用磁盘 I/O 次数评价索引结构的优劣性：根据 B-Tree 的定义，可知检索一次最多需要访问 h 个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，<strong>将一个结点的大小设为等于一个页面（默认 16 kb）</strong>，这样每个结点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。</p>
<p>**B-Tree 中一次检索最多需要 h-1 次 I/O（根结点常驻内存），渐进复杂度为 O(h)=O(log<sub>d</sub>N)。**一般实际应用中，出读 d 是非常大的数字，通常超过 100，因此 h 非常小。</p>
<p>综上所述，用 B-Tree 作为索引结构效率是非常高的。</p>
<p>而红黑树结构，h 明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的 I/O 渐进复杂度也为 O(h)，但是查找效率明显比 B-Tree 差得多。</p>
<h2 id="哈希索引">哈希索引</h2>
<p>哈希索引 (hash index) 基于哈希表实现，只有精确匹配索引所有列的査询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码 (hash code)，哈希码是个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>因为索自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引査找的速度非常快。然而，哈希索引也有它的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配査找，因为哈希索始终是使用索引列的全部内容来计算哈希值的。例如，在数据列 (A,B) 上建立哈希索引，如果査询只有数据列 A，则无法使用该索引。</li>
<li>哈希索引只支持等值比较査询，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>(注意 <code>&lt;&gt;</code> 和 <code>&lt;=&gt;</code> 是不同的操作，该操作是 NULL-safe equals)。也不支持任何范围査询，例如 <code>WHERE price&gt;100</code>。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。当出现哈希冲突的时候，存储引檠必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<p>InnoDB 引擎有一个特殊的功能叫做“<strong>自适应哈希索引 (adaptive hash index)</strong>”。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希査找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。</p>
<p>**创建自定义哈希索引。**如果我们即想使用 B-Tree 的优势，又想使用哈希索引增加速度，可以创建一个单独的列来存放数据的伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用 B-Tree 进行查找，但是它使用哈希值而不是键本身进行索引査找。你需要做的就是在査询的 WHERE 子句中手动指定使用哈希函数。</p>
<p>如果采用这种方式，不要使用 <code>SHA1()</code> 或 <code>MD5()</code> 这种哈希函数，因为他们计算出的哈希值会非常长，浪费空间。它们设计目标是最大程度消除冲突，如果我们的数据量不是特别大，可以使用 <code>CRC32()</code> 这样的函数或者自己编写哈希函数，最简单的就是取前面这种强哈希函数的一部分。CRC32() 返回的是 32 位的整数,当索引有 93000 条记录时出现冲突的概率是 1%。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONV(RIGH(MD5(<span class="string">&#x27;HTTP://www.mysql.com/&#x27;</span>),<span class="number">16</span>),<span class="number">16</span>,<span class="number">10</span>)<span class="keyword">AS</span> HASH64</span><br></pre></td></tr></table></figure>
<h2 id="空间数据索引（R-Tree）">空间数据索引（R-Tree）</h2>
<p><code>MYISAM</code> 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无须前缀査询。空间索引会从所有维度来索引数据。査询时，可以有效地使用任意维度来组合查询。必须使用 MYSQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。 MYSQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对 GIS 的解决方案做得比较好的是 Postgresql 的 POSTGIS。</p>
<h2 id="全文索引">全文索引</h2>
<p>全文索引是一种特殊类型的索引，它査找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的 WHERE 条件匹配。<br>
在相同的列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突，全文索引适用于 MATCH AGAINST 操作,而不是普通的 WHERE 条件操作。</p>
<h1>索引的优点</h1>
<p>索引可以让服务器快速地定位到表的指定位置。但是这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。<br>
最常见的 <code>B-Tree</code> 索引，按照顺序存储数据，所以 MYSQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些査询只使用索引就能够完成全部査询。据此特性，总结下来索引有如下三个优点:</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
</ol>
<h1>高性能索引策略</h1>
<h2 id="独立的列">独立的列</h2>
<p>我们通常会看到一些查询不当地使用索引，或者使得 MYSQL 无法使用已有的索引。如果查询中的列不是独立的，则 MYSQL 就不会使用索引。<strong>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</strong></p>
<h2 id="前缀索引和索引选择性">前缀索引和索引选择性</h2>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的<strong>模拟哈希索引</strong>。但有时候这样做还不够，还可以做些什么呢？</p>
<p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**索引的选择性是指，不重复的索引值（也称为基数, cardinality）和数据表的记录总数（#T）的比值,范围从 1/#T 到 1 之间。**索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MYSQL 在查找时过滤掉更多的行唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。<br>
一般情况下某个列前缀的选择性也是足够高的，足以满足査询性能。对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MYSQL 不允许索引这些列的完整长度。<br>
<strong>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长(以便节约空间)。</strong></p>
<blockquote>
<p>有时侯后缀索引(suffix index)也有用途(例如，找到某个域名的所有电子邮件地址)。 <strong>MYSQL 原生并不支持反向索引</strong>，但是可以把字符串反转后存储，并基于此建立前缀索引。</p>
</blockquote>
<h2 id="多列索引">多列索引</h2>
<p><strong>在多个列上建立独立的单列索引大部分情况下并不能提高 MYSQL 的査询性能。</strong> <strong>MYSQL 5.0 和更新版本引入了一种叫“索引合并”(index merge)的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。更早版本的 MYSQL 只能使用其中某一个单列索引。</strong></p>
<h2 id="选择合适的索引列顺序">选择合适的索引列顺序</h2>
<p>**对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。**这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机 IO 和排序那么重要，考虑问题需要更全面(场景不同则选择不同，没有一个放之四海皆准的法则。这里只是说明,，这个经验法则可能没有你想象的重要)。</p>
<p>如果是从诸如 <code>pt-gery-digest</code> 这样的工具的报告中提取“最差”査询，那么再按上述办法选定的索引顺序往往是非常高效的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest --processlist h=192.168.10.11,u=root,p=root --interval=0.01 --output slowlog &gt; slowsql.log</span><br></pre></td></tr></table></figure>
<p><strong>尽可能将需要做范围査询的列放到索引的后面，以便优化器能使用尽可能多的索引列来进行最左匹配。</strong></p>
<h2 id="聚簇索引">聚簇索引</h2>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，**但 <code>InnoDB</code> 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。**索引和数据存入同一个 .idb 文件中。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中，索引列包含的是整数值。</p>
<p><img data-src="../../../images/db/clustered_index.png" alt="Clustered index"></p>
<p><strong>InnoDB 将通过主键聚集数椐</strong>，这也就是上图中的“被索引的列”就是主键列。</p>
<blockquote>
<p>默认情况下 Innodb 会使用定义的主键来作为聚簇索引，没有主键的话会使用所有列都不为空的第一个唯一索引，再没有的话会生成一个隐藏的基于行 ID 的聚簇索引，行 ID 就是插入顺序。</p>
</blockquote>
<p>聚集的数据有一些重要的优点：</p>
<ul>
<li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中査找要快。</li>
<li>使用覆盖索引扫描的査询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了 I/O 密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插人速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 <code>OPTIMIZE TABLE</code> 命令重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时侯。</li>
<li>**<u>二级索引(非聚簇索引)</u>**可能比想象的要更大，因为在二级索引中既包含了为其指定的列，索引的叶子节点还包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引査找，而不是一次。</li>
</ul>
<p>最后一点可能让人有些疑惑，为什么二级索引需要两次索引査找？答案在于二级索引中保存的“行指针”的实质。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</p>
<p><strong>这意味着通过二级索引査找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中査找到对应的行。这里做了重复的工作：两次 B-Tree 査找而不是一次。对于 InnoDB，自适应哈希索能够减少这样的重复工作。这就是所谓的“回表查询”。也就是说聚簇索引叶子结点存放主键和数据，非聚簇索引（其它索引）叶子结点存放的是引用行的主键列而非数据的指针。</strong></p>
<h3 id="InnoDB-数据分布">InnoDB 数据分布</h3>
<p>假设有如下表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout test (</span><br><span class="line">	col1 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col2 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(CO11),</span><br><span class="line">  KEY(CO12)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>假设该表的主键取值为 1~10000，按照随机顺序插入并使用 OPTIMIZE TABLE 命令做了优化。换句话说，数据在磁盘上的存储方式已经最优，但行的顺序是随机的。列 coL2 的值是从 1~100 之间随机赋值，所以有很多重复的值。</p>
<p>InnoDB 的数据分布。因为 InnoDB 支持聚簇索引，所以使用非常不同的方式存储同样的数据。 InnoDB 以如图所示的方式存储数据。</p>
<p><img data-src="../../../images/db/innodb_layout.png" alt="InnoDB layout"></p>
<p>聚簇索引的每一个叶子节点都包含了主键值、事务 ID、用于事务和 MVCC 的回滚指针以及所有的剩余列 (在这个例子中是 coL2)。如果主键是一个列前缀索引, InnoDB 也会包含完整的主键列和剩下的其他列。</p>
<p>InnoDB 二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><strong>上图展示了 B-Tree 的聚簇索引的叶子节点结构</strong>，<strong>下图是非叶子节点</strong>，它包含了索引列和一个指向下级节点的指针（下一级节点可以是非叶子节点，也可以是叶子节点）。这对聚簇索引和二级索引都适用。</p>
<p><img data-src="../../../images/db/secondary_Indexes.png" alt="Secondary Indexes"></p>
<h3 id="在-InnoDB-表中按主键顺序插入行">在 InnoDB 表中按主键顺序插入行</h3>
<p><strong>在 Mysql 中最简单的就是使用自增的主键列，这样可以保证行按顺序写入，对于根据主键做关联操作的性能也会更好。</strong></p>
<p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于 I/O 密集型的应用。例如，<strong><u>从性能的角度考虑，使用 UUID 来作为聚簇索引则会很糟糕：它使得聚簇索引的插人变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</u></strong></p>
<p>缺点如下：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机 I/O。</li>
<li>因为写入是乱序的，InnoDB 不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。</li>
</ul>
<h2 id="覆盖索引">覆盖索引</h2>
<p>索引确实是一种査找数据的高效方式，但是 MYSQL 也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含要査询的数据，那么还有什么必要再回表査询呢？<strong>如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称之为“覆盖索引”。</strong></p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果査询只需要扫描索引而无须回表，会带来多少好处：</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那 MYSQL 就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于 IO 密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中。</li>
<li>因为索引是按照列值顺序存储的(至少在单个页内是如此)，所以对于 I/O 密集型的范围査询会比随机从磁盘读取每一行数据的 I/O 要少得多。对于某些存储引擎，例如 <code>MyISAM</code> 和 <code>Percona Xtradb</code>，甚至可以通过 <code>OPTIMIZE</code> 命令使得索引完全顺序排列，这让简单的范围查询能使用完全顺序的索引访问。</li>
<li>一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。</li>
<li>由于 InnoDB 的聚簇索引，覆盖索引对 InnoDB 表特别有用。 InnoDB 的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖査询，则可以避免对主键索引的二次查询。</li>
</ul>
<p>不是所有类型的索引都可以成为覆盖索引。<strong>覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引副等都不存储索引列的值,所以 MySQL 只能使用 B-Tree 索引做覆盖索引。</strong></p>
<p>当发起一个**被索引覆盖的査询(也叫做索引覆盖査询)**时，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>“Using index”</code> 的信息。</p>
<p>对于部分需要查询不包含所有索引的字段时，我们可以通过**<u>延迟关联（deferred join</u>）**来利用覆盖索引的优势。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> products</span><br><span class="line">	  <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">JOIN</span> ( </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>	     <span class="keyword">SELECT</span> prod_id </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>       <span class="keyword">FROM</span> product </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>	     <span class="keyword">WHERE</span> actor <span class="operator">=</span> <span class="string">&#x27;SEAN_CARREY&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%APOLLO%&#x27;</span> </span><br><span class="line">	  <span class="operator">-</span><span class="operator">&gt;</span>     ) <span class="keyword">AS</span> t1 <span class="keyword">ON</span> ( t1.prod_id <span class="operator">=</span> products.prod_id );</span><br></pre></td></tr></table></figure>
<p>在 prod_id 和 actor 上我们设置了索引，在查询的一阶段 Mysql 可以使用覆盖索引，从子查询中先找到符合条件的 prod_id，然后根据 prod_id 值在外层查询匹配所有需要的列值。这样优化的效果取决于 WHERE 条件匹配的行数，匹配的行数越多且使用到索引越多越优化。</p>
<p>在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的査询。不过，可以更进一步优化 InnoDB。<strong>回想一下，InnoDB 的二级索引的叶子节点都包含了主键的值，这意味着 InnoDB 的二级索引可以有效地利用这些“额外”的主键列来覆盖査询。</strong><br>
例如， sakila.actor 使用 InnoDB 存储引擎，并在 last_name 字段有二级索引，虽然该索引的列不包括主键 actor_id，但也能够用于对 actor_id 做覆盖査询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id, last_name <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> last_name <span class="operator">=</span><span class="string">&#x27;HOPPER&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">           id: <span class="number">1</span> </span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">type</span>: SIMPLE </span><br><span class="line">        <span class="keyword">table</span>: actor </span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span> </span><br><span class="line">possible_keys: idx_actor_last_name</span><br><span class="line">          key: idx_actor_last_name</span><br><span class="line">          key_len: <span class="number">137</span> </span><br><span class="line">          <span class="keyword">ref</span>: const </span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">2</span> </span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">index</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面提到的很多限制都是由于存储引擎 API 设计所导致的。 <strong>MySQL 5.6 版本引入了 “索引条件推送(index condition pushdown)” 将过滤条件传到存储引擎层，可以减少传递到服务器层的数据量，这个优化默认开启。</strong></p>
</blockquote>
<h2 id="使用索引扫描来做排序">使用索引扫描来做排序</h2>
<p>MySQL 有两种方式可以生成有序的结果；通过排序操作，或者按索引顺序扫描，<strong>如果 <code>EXPLAIN</code> 出来的 <code>type</code> 列的值为 <code>“index”</code>，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）</strong>。</p>
<p><strong>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL 才能够使用索引来对结果做排序。如果査询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。</strong><br>
ORDER BY 子句和查找型査询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL 都需要执行排序操作，而无法利用索引排序。</p>
<p>有一种情况下 ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果 WHERE 子句或者 J0IN 子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>
<p>例如， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">Sakila 示例数据库的表</a> rental 在列 (rental_date, Inventory_id, customer_id) 上有名为 rental_date 的索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>				 <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>			   <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
<p>MYSQL 可以使用 rental_date 索引为下面的査询做排序，从 EXPLAIN 中可以看到没有出现文件排序 (Using filesort) 操作；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">				 type<span class="punctuation">:</span> ref </span><br><span class="line">possible keys<span class="punctuation">:</span> rental_date </span><br><span class="line">					key<span class="punctuation">:</span> rental_date </span><br><span class="line">				 rows<span class="punctuation">:</span> <span class="number">1</span> </span><br><span class="line">				Extra<span class="punctuation">:</span> Using where</span><br></pre></td></tr></table></figure>
<p>下面是一些不能使用索引做排序的查询：</p>
<ul>
<li>
<p>下面这个查询使用了两种不同的排序方向，但是索引列都是正序排序的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>, customer_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询的 ORDER BY 子句中引用了一个不在索引中的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, staff_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询的 WHERE 和 ORDER BY 中的列无法组合成索引的最左前缀：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询在索引列的第一列上是范围条件，所以 MYSQL 无法使用索引的其余列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个査询在 inventory_id 列上有多个等于条件。对于排序来说，这也是一种范围查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">AND</span> inventory_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面这个例子理论上是可以使用索引进行关联排序的，但由于优化器在优化时将 file_actor 表当作关联的第二张表，所以实际上无法使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id, title <span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.film <span class="keyword">USING</span>(film_id ) <span class="keyword">ORDER</span> <span class="keyword">BY</span> actor_id;</span><br></pre></td></tr></table></figure>
<h2 id="冗余和重复索引">冗余和重复索引</h2>
<p>MySQL 允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL 需要单独维护重复的索引，并且优化器在优化査询的时侯也需要逐个地进行考虑，这会影响性能。</p>
<p>冗余索引和重复索引有一些不同。如果创建了索引(A)，再创建索引(A,B)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当作索引(A)来使用(这种冗余只是对 B-Tree 索引来说的)。但是如果再创建索引(B,A)，则不是冗余索引，索引(B) 也不是，因为B不是索引(A,B)的最左前缀列。另外，其他不同类型的索引(例如哈希索引或者全文索引)也不会是 B-Tree 索引的冗余索引，无论覆盖的索引列是什么。</p>
<p>解决冗余索引和重复索引的方法很简单，删除这些索引就可以，但首先要做的是找出这样的索引。Percona Tookit 中的 <code>pt-duplicate-key-checker</code> 可以帮我们分析表结构找出冗余和重复的索引。</p>
<h2 id="未使用的索引">未使用的索引</h2>
<p>这样的索引完全是累赘，建议考虑删除。</p>
<p>定位未使用的索引最简单有效的办法是在 Percona Server 或者 MariaDB 中先打开 User statistics 服务器变量，</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> userstat<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后让服务正常运行一段时间，再通过 INFOMATION_SCHEMA.INDEX_STATISTICS 就能查到每个索引的使用频率。</p>
<p>另外，还可以使用 Percona Toolkit 中的 <code>pt-index-usage</code>，该工具可以读取査询日志，并对日志中的每条査询进行 EXPLAIN 操作，然后打印出关于索引和查询的报告。这个工具不仅可以找出哪些索引是未使用的，还可以了解査询的执行计划一一例如在某些情况有些类似的査询的执行方式不一样，这可以帮助你定位到那些偶尔服务质量差的査询，优化它们以得到一致的性能表现。该工具也可以将结果写入到  MYSQL 的表中，方便查询结果。</p>
<h2 id="索引和锁">索引和锁</h2>
<p>索引可以让査询锁定更少的行。如果你的査询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然 InnoDB 的行锁效率很高，内存使用也很少，但是锁定行的时侯仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。但这只有当 InnoDB 在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在 InnoDB 检索到数据并返回给服务器层以后，MySQL 服务器才能应用 WHERE 子句。这时已经无法避免锁定行了：InnoDB 已经锁住了这些行，到适当的时候オ释放。在 MySQL5.1 和更新的版本中，InnoDB 可以在服务器端过滤掉行后就释放锁，但是在早期的 MYSQL 版本中, InnoDB 只有在事务提交后オ能释放锁。</p>
<p>通过下面的例子再次使用数据库 Sakila 很好地解释了这些情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id<span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| actor_id |</span><br><span class="line">+----------+</span><br><span class="line">|        2 |</span><br><span class="line">|        3 |</span><br><span class="line">|        4 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<p>这条査询仅仅会返回 2-4 之间的行，但是实际上获取了 1~4 之间的行的排他锁。InnoDB 会锁住第 1 行，这是因为 MySQL 为该查询选择的执行计划是索引范围扫描：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br><span class="line">| id | select_type | table | type  | key     | Extra                    | </span><br><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br><span class="line">|  1 | SIMPLE      | actor | range | PRIMARY | Using where; Using index | </span><br><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br></pre></td></tr></table></figure>
<p>换句话说，底层存储引擎的操作是“从索引的开头开始获取满足条件 actor_id&lt;5 的记录”，服务器并没有告诉 InnoDB 可以过滤第 1 行的  WHERE 条件。注意到 EXPLAIN 的 Extra 列出现了“Using where”，这表示 MySQL 服务器将存储引擎返回行以后再应用 WHERE 过滤条件。</p>
<p>下面的第二个査询就能证明第 1 行确实已经被锁定，尽管第一个査询的结果中并没有这个第 1 行。保持第一个连接打开，然后开启第二个连接并执行如下査询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<p>这个查询将会挂起，直到第一个事务释放第 1 行的锁。</p>
<p>关于 InnoDB、索引和锁有一些很少有人知道的细节：InnoDB 在二级索引上使用共享(读)锁，但访问主键索引需要排他(写)锁。这消除了使用覆盖索引的可能性，并且使得 SELECT FOR UPDATE 比 L0CK IN SHARE MODE 或非锁定査询要慢很多。</p>
<h2 id="避免多个范围条件">避免多个范围条件</h2>
<p>EXPLAIN 输出中 type 为 range 的代表范围查询，比如下面这种查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">&gt;</span> <span class="number">45</span>;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span><span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">				 id: <span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> type: SIMPLE </span><br><span class="line">			<span class="keyword">table</span>: actor </span><br><span class="line">			 type: <span class="keyword">range</span></span><br></pre></td></tr></table></figure>
<p>但是下面这条查询呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">99</span>);</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span><span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">				 id: <span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> type: SIMPLE </span><br><span class="line">			<span class="keyword">table</span>: actor </span><br><span class="line">			 type: <span class="keyword">range</span></span><br></pre></td></tr></table></figure>
<p>从 EXPLAIN 的结果是无法区分这两者的，但可以从值的范围和多个等于条件来得出不同。在我们看来，第二个查询就是多个等値条件查询。<br>
我们不是挑剔：这两种访问效率是不同的。对于范围条件查询，MySQL 无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询”则没有这个限制。</p>
<h2 id="更新索引统计信息">更新索引统计信息</h2>
<p>可以使用 <code>SHOW INDEX FROM</code> 命令来査看索引的基数(Cardinality)。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt; </span><span class="language-bash">SHOW INDEX FROM sakila.actor;</span></span><br><span class="line">******************* 1.row *******************</span><br><span class="line">	  	 Table: actor </span><br><span class="line">  Non_unique: 0 </span><br><span class="line">    Key_name: PRIMARY </span><br><span class="line">Seq_in_index: 1 </span><br><span class="line"> Column_name: actor_id </span><br><span class="line">   Collation: A </span><br><span class="line"> Cardinality: 200 </span><br><span class="line">    Sub_part: NULL </span><br><span class="line">      Packed: NULL </span><br><span class="line">        Null:</span><br><span class="line">  Index_type: BTREE</span><br><span class="line">     Comment:</span><br></pre></td></tr></table></figure>
<p>这里需要特别提及的是索引列的<strong>基数(Cardinality)</strong>，<strong>其显示了存储引擎估算索引列有多少个不同的取值</strong>。引擎估算索引列有多少个不同的取值。在 MySQL5.0 和更新的版本中，还可以通过 <code>INFORMATION_SCHEMA.STATISTICS</code> 表很方便地査询到这些信息。</p>
<p>InnoDB 会在表首次打开，或者执行 <code>ANALYZE TABLE</code>，抑或表的大小发生非常大的变化(大小变化超过十六分之一或者新插入了 20 亿行都会触发)的时候计算索引的统计信息。</p>
<p>InnoDB 在打开某些 INFORMATION_SCHEMA 表，或者使用 SHOW TABLE STATUS 和 SHOW INDEX，抑或在 MYSQL 客户端开启自动补全功能的时侯都会触发索引统计信息的更新。</p>
<h1>总结</h1>
<p>在 MySQL 中，大多数情况下都会使用 B-Tree 索引。其他类型的索引大多只适用于特殊的目的。如果在合适的场景中使用索引，将大大提高査询的响应时间。本章将不再介绍更多这方面的内容了，最后值得总的回顾一下这些特性以及如何使用 B-Tree 索引。<br>
在选择索引和编写利用这些索引的査询时，有如下三个原则始终需要记住：</p>
<ol>
<li>单行访问是很慢的。特别是在机械硬盘存储中(SSD 的随机 I/O 要快很多，不过这点仍然成立)。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 IO 不需要多次磁盘寻道，所以比随机 I/O 要快很多(特别是对机械硬盘)。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且 GROUP BY 查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖査询是很快的。如果一个索引包含了査询需要的所有列，那么存储引擎就不需要再回表査找行。这避免了大量的单行访向，而上面的第 1 点已经写明单行访问是很慢的。</li>
</ol>
<p>**那如何判断一个系统创建的索引是合理的呢？**一般来说，我们建议按响应时间来对査询进行分析。找出那些消耗最长时间的査询或者那些给服务器带来最大压力的査询，然后检査这些査询的 schema、SQL 和索引结构，判断是否有査询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用随机 I/O 访问数据，或者是有太多回表査询那些不在索引中的列的操作。</p>
<p>如果仍然想找到那些索引不是很合适的査询并在它们成为问题前进行优化，则可以使用 <code>pt-query-digest</code> 的查询审査“review’”功能，分析其 EXPLAIN 出来的执行计划。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>索引</tag>
        <tag>B+Tree</tag>
        <tag>B-Tree</tag>
        <tag>覆盖索引</tag>
        <tag>聚簇索引</tag>
      </tags>
  </entry>
</search>
