<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 运算符</title>
    <url>/JavaScript-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>在 JavaScript 中会出现很多运算符，对于有些运算符不明白看别人代码就有些懵，学习并整理一下它们的功能及用法。</p>
<p>主要包括：双叹号<code>!!</code>，短路或<code>||</code>，短路与<code>&amp;&amp;</code>，按位非<code>~</code>，按位与<code>&amp;</code>，双波浪号<code>~~</code>，可选链式操作符(Optional Chaining Operator) <code>?.</code></p>
<p>这些运算符也不并不是 JavaScript 特有的，在其他语言中也具有普遍性，但是也有差异。</p>
<p>可能还会有一些运算符比如：可选参数<code>?:</code>，非空断言<code>!.</code>, 这些包含在 TypeScript 中的运算符在此不再解释。</p>
<hr />
<a id="more"></a>
<h2 id="双叹号"><a class="markdownIt-Anchor" href="#双叹号"></a> 双叹号 <code>!!</code></h2>
<ul>
<li>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>将值转换为 boolean，并确保它是 boolean 类型，相当于三元运算符返回 boolean 类型</p>
<p>当值是非空字符串和非零数字返回true，当值是空字符串、0或者null返回false。</p>
</li>
<li>
<h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h3>
<p>在需要传入 boolean 类型的地方，比如字符串判空的条件表达式等</p>
</li>
</ul>
<p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">&#x27;id&#x27;</span>)) &#123; <span class="keyword">else</span>... &#125;</span><br></pre></td></tr></table></figure><br />
 在值不为空字符串或者null的情况，条件为真</p>
<h2 id="短路或"><a class="markdownIt-Anchor" href="#短路或"></a> 短路或 <code>||</code></h2>
<ul>
<li>
<h3 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用</h3>
</li>
</ul>
<p>左边的表达式为 true 则不执行右边的表达式，为 false 则执行右边的表达式</p>
<ul>
<li>
<h3 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2"></a> 用法</h3>
</li>
</ul>
<p>1. 默认值处理<br />
    <code>const param = object || ''</code><br />
  2. 逻辑运算</p>
<h2 id="短路与"><a class="markdownIt-Anchor" href="#短路与"></a> 短路与 <code>&amp;&amp;</code></h2>
<ul>
<li>
<h3 id="作用-3"><a class="markdownIt-Anchor" href="#作用-3"></a> 作用</h3>
</li>
</ul>
<p>左边的表达式为 false 则不执行右边的表达式，为 true 则执行右边的表达式</p>
<ul>
<li>
<h3 id="用法-3"><a class="markdownIt-Anchor" href="#用法-3"></a> 用法</h3>
</li>
</ul>
<p>1. 访问对象属性时，检测对象是否存在<br />
    <code>object &amp;&amp; object.getName()</code><br />
  2. 逻辑运算<br />
  3. 虽然<code>||</code>和<code>&amp;&amp;</code>配合可以做<code>if/else</code>判断，<code>object &amp;&amp; object.getName() || ''</code>，但是建议使用三目运算符</p>
<h2 id="按位非-~"><a class="markdownIt-Anchor" href="#按位非-~"></a> 按位非 <code>~</code></h2>
<ul>
<li>
<h3 id="作用-4"><a class="markdownIt-Anchor" href="#作用-4"></a> 作用</h3>
</li>
</ul>
<p>可以简单的理解为该值取负值后减1<code>~N = -(N+1)</code></p>
<p>&gt; 按位运算符会将其操作数隐式转换为带符号的32位整数。</p>
<ul>
<li>
<h3 id="用法-4"><a class="markdownIt-Anchor" href="#用法-4"></a> 用法</h3>
</li>
</ul>
<p>+ 判断数组或者字符串中是否存在某个元素<br />
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.indexOf(subStr) != <span class="number">-1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(str.indexOf(subStr) &gt;= <span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><br />
  可以简写为:<br />
<code>if(~str.indexOf(subStr)) &#123;&#125;</code><br />
原理：<br />
    不存在返回-1，~-1 = 0，大于-1的值，0，1，2，3 … 按位非的值1，2，3，4…都大于0<br />
    &gt; ES6中引入了新的方法<code>includes()</code>，可以用来检测一个字符串是否包含另外一个字符串。</p>
<h2 id="按位与"><a class="markdownIt-Anchor" href="#按位与"></a> 按位与 <code>&amp;</code></h2>
<ul>
<li>
<h3 id="作用-5"><a class="markdownIt-Anchor" href="#作用-5"></a> 作用</h3>
</li>
</ul>
<p>按位操作，同时为1则为1，否则为0</p>
<ul>
<li>
<h3 id="用法-5"><a class="markdownIt-Anchor" href="#用法-5"></a> 用法</h3>
</li>
</ul>
<p>+ 权限管理的权限判断  <br />
  一个用户对文件或目录所拥有的权限分为三种：”可读”、”可写”和”可执行”，分别用 1(001) 、2(010) 和 4(100) 来表示，它们之间可以任意组合：有“可读”、“可写”权限就用 3 来表示（1 + 2 = 3）；有”可读“、”可执行“权限就用5来表示（1 + 4 = 5），三种权限全部拥有就用 7 表示（1 + 2 + 4 = 7）。  <br />
  判断用户是否有可读可写权限 <code>if (role &amp; 2 === 2)</code>  <br />
  假设用户权限为 5(101) &amp; 2(010) = 1(001) !== 2(010)，可读可执行权限中部包含可写权限  <br />
  用户权限为 3(011) &amp; 2(010) = 2(010) === 2(010)，可读可写权限中包含可写权限</p>
<h2 id="双波浪号-~~"><a class="markdownIt-Anchor" href="#双波浪号-~~"></a> 双波浪号 <code>~~</code></h2>
<ul>
<li>
<h3 id="作用-6"><a class="markdownIt-Anchor" href="#作用-6"></a> 作用</h3>
</li>
</ul>
<p>可以将浮点数或者字符串数值删除小数点后的所有内容并转换为整形,<br />
对于小于0的数字向上转型，大于0的数字向下转型，相当于：</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(x);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&gt; x 只能位于 -(2^31) 和 2^31 - 1 之间，否则会溢出</p>
<h2 id="可选链式操作符optional-chaining-operator"><a class="markdownIt-Anchor" href="#可选链式操作符optional-chaining-operator"></a> 可选链式操作符(Optional Chaining Operator) <code>?.</code></h2>
<ul>
<li>
<h3 id="作用-7"><a class="markdownIt-Anchor" href="#作用-7"></a> 作用</h3>
</li>
</ul>
<p>确保在取对象属性时不用做不必要的前置对象存在的判断，以及避免抛出undefined异常<br />
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Zeral&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会抛出异常</span></span><br><span class="line">    <span class="keyword">const</span> city = user?.address?.city</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(city) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><br />
 之前我们可能会这样写：<br />
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Zeral&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">var</span> city = user</span><br><span class="line">   &amp;&amp; user.address</span><br><span class="line">   &amp;&amp; user.address.city</span><br></pre></td></tr></table></figure><br />
 该语法也支持 function 和 constructor 的调用<br />
 <code>const address = getAddressById?.(123)</code><br />
 如果 <code>getAddressById</code> 是个函数则会被调用，否则返回undefined</p>
<p>&gt; 该语法暂未被浏览器广泛支持，使用时请配置<code>babel-plugin-transform-optional-chaining</code></p>
<pre class="highlight"><code class=""></code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>运算符</tag>
        <tag>位权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux bindActionCreators 使用</title>
    <url>/Redux-bindActionCreators-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>总结下 <code>bindActionCreators(actionCreators, dispatch)</code> 的用法：</p>
<hr />
<h2 id="actioncreator"><a class="markdownIt-Anchor" href="#actioncreator"></a> ActionCreator</h2>
<ul>
<li>
<h3 id="为什么需要-actioncreator"><a class="markdownIt-Anchor" href="#为什么需要-actioncreator"></a> 为什么需要 <code>actionCreator</code>:</h3>
</li>
</ul>
<p>如果我们的 action 直接可以拿到的，当然就不需要 actionCreator，我们可以直接 <code>store.dispatch(&#123;'INCREMENT'&#125;)</code></p>
<p>但是如果我们的 action 信息是异步获取的，或者其它方法获取的话，就需要 actionCreator，感觉是废话。</p>
<ul>
<li>
<h3 id="actioncreator-是什么"><a class="markdownIt-Anchor" href="#actioncreator-是什么"></a> <code>actionCreator</code> 是什么</h3>
</li>
</ul>
<p>我们直接复制文档中的概念：</p>
<blockquote>
<p>一个 <strong>action creator</strong> 就是一个创建 action 的函数。action 是信息的载体，action creator 是用来创建 action 的工厂。</p>
</blockquote>
<p>&gt; 调用 action creator 只会产生一个 action，但是不会分发（dispatch）它。需要调用 store 的  <code>dispatch</code> 方法去完成分发。平时我们所说的 <strong>bound action creator</strong>(绑定行为创建器) 其实是说 <strong>调用 action   creator 并立即将结果分发给特定的 store 实例</strong> 的方法。</p>
<a id="more"></a>
<p>下面就是一个最简单的例子：</p>
<p>action:</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;	</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>action creator:</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> addTodo = <span class="function">(<span class="params">text=<span class="string">&#x27;default text&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">type</span>: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>+ ### 分发(dispatch) action</p>
<p>正常的，我们分发action是这样的，<br />
 <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">store</span>.dispatch(addTodo(<span class="class"><span class="keyword">data</span>));</span></span><br></pre></td></tr></table></figure><br />
或者，可以创建一个自动调度的<strong>bound action creator</strong>：</p>
  <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">const boundAddTodo = text =&gt; dispatch(<span class="name">addTodo</span>(<span class="name">text</span>))</span><br><span class="line">const boundCompleteTodo = index =&gt; dispatch(<span class="name">completeTodo</span>(<span class="name">index</span>))</span><br></pre></td></tr></table></figure>
<p>现在，我们就可以直接调用了：<br />
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">boundAddTodo</span><span class="params">(text)</span></span></span><br><span class="line"><span class="function"><span class="title">boundCompleteTodo</span><span class="params">(index)</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>
<h3 id="使用-bindactioncreators-创建可直接调用的-actioncreator"><a class="markdownIt-Anchor" href="#使用-bindactioncreators-创建可直接调用的-actioncreator"></a> 使用 bindActionCreators 创建可直接调用的 ActionCreator</h3>
</li>
</ul>
<p>通常，你应该直接在 Store 实例上调用 dispatch。如果你将 Redux 与 React 一起使用，react-redux 将为你提供调度功能，你也可以直接调用它。</p>
<p>bindActionCreators 的唯一用例是当你想将一些动作创建者传递给一个不知道 Redux 的组件时，你不想将 dispatch 或 Redux store 传递给它。</p>
<pre><code>比如上面的两个 actionCreator，我们想在组件外直接调用它，我们可以先定义：
</code></pre>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions = bindActionCreators(&#123;</span><br><span class="line">                           addTodo: boundAddTodo,</span><br><span class="line">                           completeTodo: boundCompleteTodo</span><br><span class="line">                       &#125;, store.dispatch)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以直接在其它地方调用：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions.addTodo(<span class="string">&#x27;N个BUG待处理&#x27;</span>)</span><br><span class="line">actions.completeTodo(<span class="string">&#x27;已处理1个，剩余N-1个&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>PM2 使用指南</title>
    <url>/PM2-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>P（rocess）M（anager）2 Runtime 是具有内置 Load Balancer 的 Node.js 应用程序的项目进程管理器。它允许永久保持应用程序的在线，无需停机即可重新加载它们，并可以完成常见的 Devops 任务。</p>
<h2 id="安装使用"><a class="markdownIt-Anchor" href="#安装使用"></a> 安装使用</h2>
<p>使用 npm 安装全局指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i pm2 -g</span><br></pre></td></tr></table></figure>
<p>系统启动或重启时自动启动/禁用自启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pm2 startup/unstartup</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>启动应用，指定名称，设置集群 Node 数量，检测文件变化时自动重启，忽略检测文件，指定脚本参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pm2 start npm -i max --name=<span class="string">&quot;doc-manager&quot;</span> --watch --ignore-watch=<span class="string">&quot;node_modules&quot;</span> -- run start</span><br></pre></td></tr></table></figure>
<h2 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h2>
<ul>
<li>
<p>查看进程列表：<code>pm2 list</code></p>
</li>
<li>
<p>启动进程：<code>pm2 start</code></p>
</li>
<li>
<p>停止进程：<code>pm2 stop</code></p>
</li>
<li>
<p>删除进程：<code>pm2 delete</code></p>
</li>
<li>
<p>重启进程：<code>pm2 restart</code></p>
<ul>
<li>修改环境变量，重启更新配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ NODE_ENV=production pm2 restart app --update-env</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重新加载进程：<code>pm2 reload</code></p>
</li>
<li>
<p>查看日志：<code>pm2 logs</code>  — error 只输出错误 —lines n 输出最后的多少行</p>
<ul>
<li>清空日志：<code>pm2 flush</code></li>
</ul>
</li>
<li>
<p>查看当前进程环境变量：<code>pm2 env &lt;pm_id&gt;</code></p>
</li>
<li>
<p>查看监控：<code>pm2 monitor</code></p>
</li>
<li>
<p>保存当前列表到硬盘：<code>pm2 save</code></p>
</li>
<li>
<p>恢复上一次保存的列表：<code>pm2 resurrect</code></p>
</li>
</ul>
<h3 id="集群模式"><a class="markdownIt-Anchor" href="#集群模式"></a> 集群模式</h3>
<p><img src="../images/devops/cluster-mode.png" alt="scale across all cpu's available" /></p>
<p>内置的负载均衡器提供联网的 Node.js 应用程序（http(s)/ tcp / udp服务器），可以在所有可用的 CPU 上进行扩展，无需任何代码修改。</p>
<p>要启用集群模式，只需传递 -i <number-instances> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>
<p>max 代表 cpu 最大可用数，也可以使用负数来移除 Node 服务数量。</p>
<h2 id="静态文件服务"><a class="markdownIt-Anchor" href="#静态文件服务"></a> 静态文件服务</h2>
<p>pm2 也可以作为静态文件的服务来使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pm2 serve &lt;path&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>默认使用当前文件夹和 8080 端口。</p>
<blockquote>
<p>pm2 也可以使用配置文件的形式；通过 SSH使用自动化代理部署，具体请查看官方文档；</p>
</blockquote>
<p>命令行的所有指令可以在这查看：<a target="_blank" rel="noopener" href="https://pm2.io/doc/en/runtime/reference/pm2-cli/">CLI</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Nuxt</tag>
        <tag>Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>NGINX root 和 alias</title>
    <url>/nginx-root-%E5%92%8C-alias/</url>
    <content><![CDATA[<p>在配置 NGINX 文件映射时发现 root 并没有按照期待映射，找解决方法，建议换作 alias 映射目录，不解，查下文档，理解区别。</p>
<h2 id="root"><a class="markdownIt-Anchor" href="#root"></a> root</h2>
<p>root 指令用于指定搜索文件的根目录。NGINX 将请求 URI 附加到 <code>root</code> 指定的路径。该指令可以放置在 <code>http</code>，<code>server</code> 或 <code>location</code> 上下文中的任何级别上。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    root &#x2F;www&#x2F;data;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;images&#x2F; &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.(mp3|mp4) &#123;</span><br><span class="line">        root &#x2F;www&#x2F;media;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们请求以 <code>/images/</code> 匹配的 URI 时，NGINX 会在 <code>/www/data/images/</code> 目录下查找相应的文件，但是如果 URI 以 .mp3 或 .mp4 扩展名结尾，那么 NGINX 会在 <code>/www/media/</code> 目录中搜索文件，因为它是在匹配的 location 块中定义的。</p>
<p>如果请求以斜线结尾，NGINX 将其视为对目录的请求，并尝试在目录中查找索引文件。<code>index</code> 指令用于定义索引文件的名称（默认值为 index.html）。继续这个例子，如果请求的 URI 是<code>/images/some/path/</code>，NGINX 查找文件 <code>/www/data/images/some/path/index.html</code>（如果它存在）。如果不存在，NGINX 默认返回 HTTP 代码 404（未找到）。</p>
<h2 id="alias"><a class="markdownIt-Anchor" href="#alias"></a> alias</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  location &#x2F;i&#x2F; &#123;</span><br><span class="line">      # linux	</span><br><span class="line">      # alias &#x2F;data&#x2F;images&#x2F;;</span><br><span class="line">      alias D:&#x2F;data&#x2F;images&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们请求<code>/i/top.gif</code>时，将会查找<code>D:/data/images/top.gif</code>该文件。<br />
地址中可以包含变量，具体查看文档。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2>
<ul>
<li><code>root</code> UIR 映射 URI + location Path</li>
<li><code>alias</code> URI 映射 location</li>
</ul>
<p>如果请求后缀和文件夹名称相同，建议使用<code>root</code></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>面试整理</title>
    <url>/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h2 id="java-面试问题整理"><a class="markdownIt-Anchor" href="#java-面试问题整理"></a> Java 面试问题整理</h2>
<p>[TOC]</p>
<h4 id="java-程序如何做到一次编写到处运行"><a class="markdownIt-Anchor" href="#java-程序如何做到一次编写到处运行"></a> Java 程序如何做到一次编写，到处运行</h4>
<p>java 代码源文件经过 javac 编译期编译为 .class 文件，.class 文件不包含处理器本机代码，而是包含字节码 - JVM 的机器语言。启动器使用虚拟机运行程序。</p>
<p><img src="../images/java/getStarted-compiler.gif" alt="Figure showing MyProgram.java, compiler, MyProgram.class, Java VM, and My Program running on a computer." /></p>
<p>由于 JVM 可在许多不同的操作系统上使用，因此相同的 .class 文件可以在不同系统上运行。</p>
<h4 id="jdk-和-jre-的区别"><a class="markdownIt-Anchor" href="#jdk-和-jre-的区别"></a> JDK 和 JRE 的区别</h4>
<p>JRE(Java Runtime Environment)是 JVM 执行代码的基础。JDK 是 Java 程序开发所有特性的工具，包含JRE，编译，开发和调试工具。</p>
<h4 id="什么是按值传递什么是引用传递java-中是值传递还是引用传递"><a class="markdownIt-Anchor" href="#什么是按值传递什么是引用传递java-中是值传递还是引用传递"></a> 什么是按值传递，什么是引用传递，Java 中是值传递还是引用传递</h4>
<p>值传递：传递到方法中的形参值只是实参值的一个副本，对形参的修改不会影响之前的值；</p>
<p>引用传递：形参只是实参的别名。它指向真正的实参，对形参所做的任意修改都反映在实参中。</p>
<p>Java中都是值传递，基本类型值传递，对象类型是引用值传递，也就是说值的内容是对象的引用。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31203609">https://www.zhihu.com/question/31203609</a></p>
<h4 id="通过-new-创建-string-对象和字面量形式创建有什么区别"><a class="markdownIt-Anchor" href="#通过-new-创建-string-对象和字面量形式创建有什么区别"></a> 通过 new 创建 String 对象和字面量形式创建有什么区别</h4>
<p>当使用 new 创建 String 对象时它总是会在堆内存中创建一个新对象，使用字面量创建时则会优先返回字符串常量池已存在的对象引用，否则，会创建一个新对象，并放入字符串池以备后用。</p>
<p>java7 之前字符串池存在在永久代，很难被回收，导致 OOM；之后移到了堆内存；</p>
<p>除了字符串池，包装类使用包装类缓存来实现同样的效果，比如 Integer、Byte、Short、Long、Character 使用内部类维护对应的缓存。</p>
<h4 id="如何跳出多重循环"><a class="markdownIt-Anchor" href="#如何跳出多重循环"></a> 如何跳出多重循环</h4>
<p>通过对代码块加标签的形式为代码块命名，标签为任意有效的标识符后面加冒号，通过 <code>break 标签名;</code> 跳转到代码块所在结束范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">continueLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">continue</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot; &quot;</span> + (i * j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名代码块同样适用于 <code>continue</code> 的跳转，同 goto 不同，标签块只能在自身代码块闭合范围内跳转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BreakLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Pass &quot;</span> + i + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;This will not print&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Loops complete.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jdk-和-jre-的区别-2"><a class="markdownIt-Anchor" href="#jdk-和-jre-的区别-2"></a> JDK 和 JRE 的区别</h4>
<p>JRE(Java Runtime Environment)是 JVM 执行代码的基础。JDK 是 Java 程序开发所有特性的工具，包含 JRE，编译，执行 Java 应用。</p>
<h4 id="静态方法能否重写静态方法能否访问非静态内容"><a class="markdownIt-Anchor" href="#静态方法能否重写静态方法能否访问非静态内容"></a> 静态方法能否重写，静态方法能否访问非静态内容</h4>
<p>不能，虽然子类可以包含同名静态方法，但并不属于重写。重写相对于类实例而言，子类重写父类的方法实现不同的行为，方法重写是运行时多态的重要表现。1.8之前静态方法、变量存储在堆的永久代中，它们是class相关的数据，而不是实例，具体如何存储取决于JVM，不同JVM略有差异</p>
<h4 id="hashcode-和-equals-方法主要是做什么"><a class="markdownIt-Anchor" href="#hashcode-和-equals-方法主要是做什么"></a> hashCode 和 equals 方法主要是做什么</h4>
<p>equasl 去比较两个对象是否相等，重写后用来比较业务相等，重写 equals 必须重写 hashCode。</p>
<p>hashCode 方法不是用于提供对象的唯一标识符，而是将对象的状态(即成员字段的值)摘要为一个整数。此值主要由某些基于哈希的数据结构(例如 Map 和集合)使用，以有效地存储和检索对象。</p>
<p>hashCode 和 equals 的一些基本约定，比如：equals 相等，hashCode 一定要相等；重写了 hashCode 也要重写 equals；hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。equals 的对称、反射、传递等特性。</p>
<span id="more"></span>
<h4 id="arraylist-和-linkedlist-区别"><a class="markdownIt-Anchor" href="#arraylist-和-linkedlist-区别"></a> ArrayList 和 LinkedList 区别</h4>
<p>ArrayList 和 LinkedList 都实现了 List 接口，顺序为添加时的顺序，可以包含重复元素。</p>
<p><code>LinkedList</code> :</p>
<ol>
<li>除了实现 List 接口外，<code>LinkedList</code> 类还为在列表的开头及结尾 <code>get</code>、<code>remove</code> 和 <code>insert</code> 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</li>
<li>通过代价较低的在 List 中间进行的插入和删除操作，提供了优化的顺序访问，LinkedList 在随机访问相对比较慢，但是它的特性集较 ArrayList 更大。</li>
<li>由双向链表实现，其中的每个对象包含数据的同时包含指向链表的前后引用。</li>
</ol>
<p><code>ArrayList</code>:</p>
<ol>
<li>它长于随机访问元素，</li>
<li>在List的中间插入和移除元素时较慢。</li>
<li>ArrayList底层由数组支持。</li>
</ol>
<h4 id="jdbcjdbc-driver作用"><a class="markdownIt-Anchor" href="#jdbcjdbc-driver作用"></a> JDBC，JDBC Driver作用</h4>
<p>Java数据库连接（JDBC）是用于编程语言Java的应用程序编程接口（API），它定义了客户端如何访问数据库。它是一种基于Java的数据访问技术，用于Java数据库连接。</p>
<p>JDBC驱动程序提供JDBC API提供的抽象类的特定于供应商的实现。 每个驱动程序必须提供以下java.sql包类的实现：Connection，Statement，PreparedStatement，CallableStatement，ResultSet和Driver。</p>
<h4 id="drivermanager-statement-resultset-preparedstatement"><a class="markdownIt-Anchor" href="#drivermanager-statement-resultset-preparedstatement"></a> DriverManager、Statement、ResultSet、PreparedStatement</h4>
<p>DriverManager类是JDBC的管理层，作用于用户和驱动程序之间，跟踪可用的驱动程序，建立数据库和驱动程序之间的连接，记录驱动程序运行的一些信息。</p>
<p>Statement 对象用于将 SQL 语句发送到数据库中。</p>
<p>ResultSet 包含符合 SQL 语句中条件的所有行，通过一套 get 方法来获取当前行中不同列的数据。  使用 next 方法移动当前行。</p>
<h3 id="数据库连接池作用"><a class="markdownIt-Anchor" href="#数据库连接池作用"></a> 数据库连接池作用</h3>
<p>关于数据库连接的打开和关闭，与数据库的交互可能是昂贵的。 特别是，当数据库客户端数量增加时，此成本非常高并且消耗了大量资源。应用程序服务器在启动时获得数据库连接池并将其维护在池中。 连接请求由驻留在池中的连接提供。 在连接结束时，请求将返回到池中，并可用于满足将来的请求。</p>
<h3 id="对象的构建顺序"><a class="markdownIt-Anchor" href="#对象的构建顺序"></a> 对象的构建顺序</h3>
<p>初始化子类时，先初始化父类<br />
初始化父类的静态变量和静态代码块<br />
初始化子类的静态变量和静态代码块<br />
初始化父类的非静态变量，初始化父类的构造函数<br />
如果父类的构造函数中调用的方法被子类重写，那么调用的会是子类的方法<br />
初始化子类的非静态变量，初始化子类的构造函数</p>
<p>基类静态（按定义顺序）-&gt; 子类静态 -&gt; 基类非静态 -&gt; 基类构造 -&gt; 子类非静态 -&gt; 子类构造</p>
<h4 id="servlet-的生命周期"><a class="markdownIt-Anchor" href="#servlet-的生命周期"></a> Servlet 的生命周期：</h4>
<p>实例化 --&gt; 初始化 --&gt; 服务 --&gt; 销毁</p>
<ol>
<li>当 servlet 第一次被调用的时候，会触发 init 函数，该函数通过web.xml配置文件由web服务器自动实例化 servlet 装载到内存， init 函数只会被调用一次</li>
<li>然后去调用  servlet 的 service 函数，由 service 方法判断请求的方式，get、post或者其它，调用相应的方法</li>
<li>当 web 应用 reload 或者关闭 tomcat 或者 关机 都会去调用 destroy 函数，该函数就去销毁 servlet</li>
</ol>
<ul>
<li>
<h4 id="表单提交数据-get-请求和-post-请求的区别"><a class="markdownIt-Anchor" href="#表单提交数据-get-请求和-post-请求的区别"></a> 表单提交数据 get 请求和 post 请求的区别：</h4>
• 从安全性看 get &lt; post, get 提交的数据会在浏览器的地址栏显示<br />
• 从提交的内容的大小来看  get &lt; post get提交的数据不能大于 2K ，而 Post 从理论上不受限制， 但是实际的变成中建议不要大于 64K<br />
• 从请求响应速度看： get &gt; post , get 要求服务器立即处理请求，而 post 请求可能形成一个队列请求</li>
</ul>
<h2 id="java8-问题整理"><a class="markdownIt-Anchor" href="#java8-问题整理"></a> Java8 问题整理</h2>
<h4 id="java8-添加了哪些新特性"><a class="markdownIt-Anchor" href="#java8-添加了哪些新特性"></a> Java8 添加了哪些新特性</h4>
<p>Java8 添加了很多新特性。但最主要的是下面的内容：</p>
<ul>
<li><strong>Lambda 表达式</strong> - 一种新的语言特性，允许将操作视为对象</li>
<li><strong>方法引用</strong> - 允许直接使用方法的名称引用去定义 Lambda</li>
<li><strong>Optional</strong> - 用于表达可能存在的特殊包装类</li>
<li><strong>函数接口</strong> - 具有最多一个抽象方法的接口，可以使用 Lambda 表达式提供实现</li>
<li><strong>默认方法</strong> - 除了使用抽象方法，让我们能够在接口中添加完整的实现</li>
<li><strong>Nashorn，JavaScript 引擎</strong> - 一种基于 Java 的引擎，用于执行和评估 JavaScript 代码</li>
<li><strong>流（Stream）接口</strong> - 一个特殊的迭代器类，允许以函数方式处理对象集合</li>
<li><strong>CompletableFuture</strong> - 为复杂的异步编码提供了可行性</li>
<li><strong>Date 接口</strong> - 一个改进的，不可改变的 JodaTime 灵感的 Date API<br />
除了这些新功能外，还有很多在编译器和 JVM 级别下的功能增强。</li>
</ul>
<h4 id="什么是方法引用"><a class="markdownIt-Anchor" href="#什么是方法引用"></a> 什么是方法引用</h4>
<p>方法引用是一种 Java8 结构，它允许在不调用方法时引用方法。用于将方法视为 Lambda 表达式。它只能作为语法糖来减少一些 lambda 的冗长。比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">0</span>) -&gt; o.toString();</span><br></pre></td></tr></table></figure>
<p>可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object::toString();</span><br></pre></td></tr></table></figure>
<p>方法引用可以使用双冒号来分割类、对象名称、方法名。它有不同的变体，如构造函数引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>静态方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String::valueOf;</span><br></pre></td></tr></table></figure>
<p>绑定实例方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str::toString;</span><br></pre></td></tr></table></figure>
<p>未绑定实例方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String::toString;</span><br></pre></td></tr></table></figure>
<h4 id="什么是-optional我们怎么使用它"><a class="markdownIt-Anchor" href="#什么是-optional我们怎么使用它"></a> 什么是 Optional？我们怎么使用它？</h4>
<p>可选是 Java 8 中的一个新类，它封装了一个可选值，即是否存在的值。它是对象的包装器，您可以将其视为零或一个元素的容器。<br />
Optional 具有特殊的 Optional.empty() 值而不是被包裹的 null。因此，在许多情况下，可以使用它来代替可空值来消除 NullPointerException（NPE）。<br />
Optional 是一种返回类型的方法，以前会返回 null。这样的方法需要你编写样板代码来检查返回值，有时可能会忘记进行防御性检查。在 Java 8 中，Optional 返回类型明确要求您以不同方式处理 null 或非 null 包装值。<br />
例如，Stream.min() 方法计算值流中的最小值。但是如果流是空的呢？如果它不是 Optional，则该方法将返回 null 或抛出异常。<br />
但它返回一个 Optional 值，可能是 Optional.empty()（第二种情况）。这使我们可以轻松处理这种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> min1 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">  .min()</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">assertEquals(<span class="number">1</span>, min1);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> min2 = Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;)</span><br><span class="line">  .min()</span><br><span class="line">  .orElse(<span class="number">0</span>);</span><br><span class="line">assertEquals(<span class="number">0</span>, min2);</span><br></pre></td></tr></table></figure>
<p>Optional 不能用在实体的字段上，因为它没有实现 Serializable 接口。</p>
<h4 id="描述标准库中的一些函数接口"><a class="markdownIt-Anchor" href="#描述标准库中的一些函数接口"></a> 描述标准库中的一些函数接口</h4>
<p>java.util.function 包中有很多功能接口，更常见的包括但不限于：</p>
<ul>
<li><strong>Function</strong> - 它接受一个参数并返回结果 T -&gt; R</li>
<li><strong>Consumer</strong> - 它需要一个参数并且不返回接口（表示副作用）T -&gt; void</li>
<li><strong>Supplier</strong> - 它不需要参数并返回结果 () -&gt; R</li>
<li><strong>Predicate</strong> - 它需要一个参数并返回一个布尔值 T -&gt; boolean</li>
<li><strong>BiFunction</strong> - 它需要两个参数并返回一个结果 (T, U) -&gt; R</li>
<li><strong>BinaryOperator</strong> - 它类似于 BiFunction，接受两个参数并返回结果。两个参数和结果都是相同的类型 (T, T) -&gt; T</li>
<li><strong>UnaryOperator</strong> - 它类似于 Function，只接受一个参数并返回相同类型的结果 T -&gt; T</li>
</ul>
<h4 id="函数接口的作用"><a class="markdownIt-Anchor" href="#函数接口的作用"></a> 函数接口的作用</h4>
<p>函数接口为可以为 <strong>lambda 表达式</strong>和<strong>方法引用</strong>提供目标类型。</p>
<h4 id="什么是-default-方法我们可以用来做什么"><a class="markdownIt-Anchor" href="#什么是-default-方法我们可以用来做什么"></a> 什么是 default 方法，我们可以用来做什么</h4>
<p>default 方法是接口中具有实现的方法。<br />
我们可以使用默认方法向接口添加新功能，同时保持与已实现接口的类的向后兼容性：<br />
通常，当一个新的抽象方法被添加到接口时，所有实现类都将中断，直到它们实现新的抽象方法。在 Java 8 中，通过使用默认方法解决了这个问题。<br />
例如，Collection 接口没有 forEach 方法声明。因此，添加此类方法只会破坏整个集合 API。<br />
Java 8 引入了默认方法，以便 Collection 接口可以具有 forEach 方法的默认实现，而不需要实现此接口的类来实现相同的方法。</p>
<h4 id="什么是-lambda-表达式以及它用于什么"><a class="markdownIt-Anchor" href="#什么是-lambda-表达式以及它用于什么"></a> 什么是 Lambda 表达式以及它用于什么</h4>
<p>简单来说，lambda 表达式是一个可以<strong>作为对象引用和传递</strong>的函数。<br />
Lambda 表达式引入了 Java 中的函数式处理，并有助于编写紧凑且易于阅读的代码。<br />
因此，lambda 表达式是匿名类作为方法参数的自然替代品。它们的主要用途之一是定义函数接口的内联实现。</p>
<h2 id="spring-问题整理"><a class="markdownIt-Anchor" href="#spring-问题整理"></a> Spring 问题整理</h2>
<h4 id="使用-spring-有什么好处"><a class="markdownIt-Anchor" href="#使用-spring-有什么好处"></a> 使用 Spring 有什么好处</h4>
<h4 id="spring-ioc-容器"><a class="markdownIt-Anchor" href="#spring-ioc-容器"></a> Spring IOC 容器</h4>
<p>ApplicationContext 是 Spring IOC 的核心容器，它是 BeanFactory 的超集。BeanFactory 是 Spring 的核心接口，其实现类必须支持 Bean 的生命周期接口，初始化的顺序如下：</p>
<ul>
<li>
<p>BeanNameAware’s {@code setBeanName}</p>
</li>
<li>
<p>BeanClassLoaderAware’s {@code setBeanClassLoader}</p>
</li>
<li>
<p>BeanFactoryAware’s {@code setBeanFactory}</p>
</li>
<li>
<p>EnvironmentAware’s {@code setEnvironment}</p>
</li>
<li>
<p>EmbeddedValueResolverAware’s {@code setEmbeddedValueResolver}</p>
</li>
<li>
<p>ResourceLoaderAware’s {@code setResourceLoader}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ApplicationEventPublisherAware’s {@code setApplicationEventPublisher}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>MessageSourceAware’s {@code setMessageSource}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ApplicationContextAware’s {@code setApplicationContext}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>ServletContextAware’s {@code setServletContext}</p>
</li>
<li>
<p>(ApplicationConetxt特有方法：)</p>
<p>{@code postProcessBeforeInitialization} methods of BeanPostProcessors</p>
</li>
<li>
<p>InitializingBean’s {@code afterPropertiesSet}</p>
</li>
<li>
<p>a custom init-method definition 自定义的 init 方法</p>
</li>
<li>
<p>{@code postProcessAfterInitialization} methods of BeanPostProcessors</p>
</li>
</ul>
<p>关闭bean工厂时，以下生命周期方法适用：<br />
 * {@ code postProcessBeforeDestruction} DestructionAwareBeanPostProcessors 的方法<br />
 * DisposableBean 的{@code destroy}<br />
 * 自定义销毁方法</p>
<h4 id="beanfactory-和-applicationcontext-区别"><a class="markdownIt-Anchor" href="#beanfactory-和-applicationcontext-区别"></a> <code>BeanFactory</code> 和 <code>ApplicationContext</code> 区别 ？</h4>
<p>主要体现在容器级别之间的区别以及对引导的影响。</p>
<p>除非有充分的理由，否则应使用 ApplicationContext，将 GenericApplicationContext 及其子类 AnnotationConfigApplicationContext 作为自定义引导的常见实现。这些是用于所有常见目的的 Spring 核心容器的主要入口点：加载配置文件，触发类路径扫描，以编程方式注册 Bean 定义和带注解的类，以及（从5.0版本开始）注册功能性 Bean 定义。</p>
<p>因为 ApplicationContext 包含 BeanFactory 的所有功能，所以通常建议在 ApplicationContext 上使用，除非需要对 Bean 处理的完全控制。在 ApplicationContext（例如 GenericApplicationContext 实现）中，按照惯例（即， 按Bean 名称或 Bean 类型（尤其是后处理器））检测多种 Bean，而普通的 DefaultListableBeanFactory 不知道任何特殊的 Bean。</p>
<p>对于许多扩展的容器功能，例如注解处理和 AOP 代理，BeanPostProcessor 扩展点至关重要。 如果仅使用普通的 DefaultListableBeanFactory，则默认情况下不会检测到此类后处理器并将其激活。 这种情况可能会造成混乱。</p>
<p>下表列出了 BeanFactory 和 ApplicationContext 接口和实现所提供的功能。</p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left"><code>BeanFactory</code></th>
<th style="text-align:left"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Bean 实例化/编织</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">集成生命周期管理</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">自动 BeanPostProcessor 注册</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">自动 BeanFactoryPostProcessor 注册</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">方便的 MessageSource 访问（用于内部化）</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">内置的 ApplicationEvent 发布机制</td>
<td style="text-align:left">No</td>
<td style="text-align:left">Yes</td>
</tr>
</tbody>
</table>
<h4 id="spring-bean-的作用范围"><a class="markdownIt-Anchor" href="#spring-bean-的作用范围"></a> Spring Bean 的作用范围</h4>
<ul>
<li>单例（<strong>默认</strong> 将单个bean定义范围限定为每个Spring IoC容器的单个对象实例。）</li>
<li>原型（将单个bean定义范围限定为任意数量的对象实例。）</li>
<li>request（将单个bean定义范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，它是在单个bean定义的后面创建的。）</li>
<li>session（将单个bean定义范围限定为HTTP会话的生命周期。）</li>
<li>application（将单个bean定义范围限定为ServletContext的生命周期。）</li>
<li>websocket（将单个bean定义范围限定为WebSocket的生命周期。）</li>
<li>线程 （3.0提供，但未配置）<br />
中间 request、session、application、websocket 只有在使用 Web 感知的 Spring ApplicationContext 实现（例如 <code>XmlWebApplicationContext</code> ）时，</li>
</ul>
<h4 id="spring-bean-的生命周期回调"><a class="markdownIt-Anchor" href="#spring-bean-的生命周期回调"></a> Spring Bean 的生命周期回调</h4>
<p>生命周期回调可以用在多个方面，比如 <code>JDBC</code> 的关闭，服务的启动和销毁。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(initMethod = &quot;start&quot;, destroyMethod = &quot;stop&quot;)</span></span><br><span class="line"><span class="meta">@Profile(JHipsterConstants.SPRING_PROFILE_DEVELOPMENT)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">h2TCPServer</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> H2ConfigurationHelper.createServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要与容器的bean生命周期管理进行交互，可以实现 Spring <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。容器为前者调用 <code>afterPropertiesSet()</code>，为后者调用<code>destroy()</code>，让bean在初始化和销毁bean时执行某些操作。</p>
<p>JSR-250 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注释通常被认为是在现代Spring应用程序中接收生命周期回调的最佳实践。使用这些注释意味着您的bean不会耦合到特定于Spring的接口。</p>
<p>如果您不想使用JSR-250注释但仍想删除耦合，请考虑使用<code>init-method</code> 和 <code>destroy-method</code> 对象定义元数据。<br />
要让注入Bean调用指定的构造方法，可以在注解 <code>@Bean</code> 中指定 <code>initMethod</code> 和 <code>destroyMethod</code> 的方法名。<br />
当这三种配置同时存在时，他们的执行顺序如下，销毁相同：</p>
<ol>
<li>使用 <code>@PostConstruct</code> 注释的方法</li>
<li>由 <code>InitializingBean</code> 回调接口定义的 <code>afterPropertiesSet()</code></li>
<li>自定义的 <code>initMethod</code> 方法</li>
</ol>
<h4 id="启动和停止应用回调"><a class="markdownIt-Anchor" href="#启动和停止应用回调"></a> 启动和停止应用回调</h4>
<p><code>Lifecycle</code> 接口为具有自己的生命周期要求的任何对象定义了基本方法（例如启动和停止某些后台进程）。<br />
当 <code>ApplicationContext</code> 接到开始或停止信号时（比如，运行时的停止/重启场景），他将级联调用上下文中的所有  <code>Lifecycle</code> 实现。具体调用会委托给 <code>LifecycleProcessor</code> 完成。<br />
默认的 Lifecycle 并没有细粒化控制自动启动，如果要对特定的 bean 自动启动，需要实现 <code>SmartLifecycle</code>。<br />
<code>DefaultLifecycleProcessor</code> 默认处理会在应用启动时检测自动启动的 Bean，并调用 start 方法。<br />
<code>depends-on</code>定义了显式的依赖，但是有时候我们只知道前后，并不确定具体依赖顺序。 <code>SmartLifecycle</code> 接口定义了另外一种方法 <code>getPhase()</code> 。<br />
启动时，phase 越小的对象最先启动；停止时，越大的越先停止。<br />
默认的 Lifecycle 的 phase 是 0，因此，负值表示这个对象比标准组件启动快。<br />
在非 web 项目中，可以通过在 JVM 中注册关闭钩子实现关闭回调，<code>registerShutdownHook()</code> 方法定义在 <code>ConfigurableApplicationContext</code> 接口中。</p>
<h4 id="元数据是什么spring-的配置元数据来自于哪"><a class="markdownIt-Anchor" href="#元数据是什么spring-的配置元数据来自于哪"></a> 元数据是什么，Spring 的配置元数据来自于哪</h4>
<p>元数据是描述其他数据的数据。 Meta 是一种前缀，在大多数信息技术中，用法意味着“基础定义或描述”。元数据总结了有关数据的基本信息，可以更轻松地查找和处理特定的数据实例。<br />
配置元数据来自于多个方面，包含但不局限于：</p>
<ul>
<li>注解配置</li>
<li>java 配置类</li>
<li>xml 配置文件</li>
</ul>
<h4 id="spring-是否支持运行时注册新-bean"><a class="markdownIt-Anchor" href="#spring-是否支持运行时注册新-bean"></a> Spring 是否支持运行时注册新 Bean</h4>
<p>在运行时注册新bean（并发实时访问工厂）不受官方支持，并且可能导致并发访问异常，bean容器中的不一致状态，或两者兼而有之。</p>
<h4 id="spring-是否支持添加用户自己注册的实例对象"><a class="markdownIt-Anchor" href="#spring-是否支持添加用户自己注册的实例对象"></a> Spring 是否支持添加用户自己注册的实例对象</h4>
<p>除了包含有关如何创建特定 bean 信息的 bean 定义之外， <code>ApplicationContext</code> 实现还允许注册在容器外部（由用户）创建的现有对象。这是通过 <code>getBeanFactory()</code> 方法访问 <code>ApplicationContext</code> 的 <code>BeanFactory</code> 来完成的，该方法返回 <code>BeanFactory</code> 的 <code>DefaultListableBeanFactory</code> 实现。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和 <code>registerBeanDefinition(..)</code> 方法支持此注册。</p>
<h4 id="spring-bean-命名约定"><a class="markdownIt-Anchor" href="#spring-bean-命名约定"></a> Spring Bean 命名约定</h4>
<p>bean 名称以小写字母开头，并从那里开始驼峰。此类名称的示例包括 accountManager，accountService，userDao，loginController 等。<br />
但是，在（不常见的）特殊情况下，当有多个字符并且第一个和第二个字符都是大写字母时，原始大小写将会保留。这些规则与 <code>java.beans.Introspector.decapitalize</code>（Spring 在此处使用）中定义的规则相同。</p>
<h4 id="实例化-bean-方式"><a class="markdownIt-Anchor" href="#实例化-bean-方式"></a> 实例化 Bean 方式</h4>
<ul>
<li>构造方法实例化（空的构造方法），或者注入依赖（代参构造）</li>
<li>静态工厂方法实例化</li>
<li>实例工厂方法实例化<br />
如果要为静态嵌套类配置 bean 定义，则必须使用嵌套类的二进制名称。</li>
</ul>
<p>例如，如果在 com.example 包中有一个名为 SomeThing 的类，并且此 SomeThing 类具有一个名为 OtherThing 的静态嵌套类，则 bean 定义上的 class 属性值将为com.example.SomeThing$OtherThing。</p>
<p>请注意，在名称中使用 <code>$</code> 字符可以将嵌套类名与外部类名分开。</p>
<h4 id="使用-xml-和注解配置-bean-区别"><a class="markdownIt-Anchor" href="#使用-xml-和注解配置-bean-区别"></a> 使用 xml 和注解配置 Bean 区别</h4>
<p>xml 通常将这些 bean 配置为顶级 <beans /> 元素内的 <bean /> 元素；<br />
使用 xml 配置 bean 时，我们需要指明 bean 的实现类类名，以便反射实例化注册到容器，就是上述描述的方法；</p>
<p><code>@Bean</code> 注解大多用在 <code>@Configuration</code> 配置类中；<br />
使用注解时，我们可以显式的去返回对象的实例来进行配置，实例时也可以传入其他实例方法来依赖Bean，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Foo(bar());</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在 bean 直接调用同一个类中的其他 @Bean 方法时，不得将@Configuration 类及其工厂方法标记为 final 或 private，因为它需要在运行时对每个这样的配置类进行 CGLIB 子类化。<br />
在 @Component 组件或者普通对象中直接调用其它 @Bean 方法也不可行，因为这是标准的Java方法调用，Spring不会通过 CGLIB 代理拦截调用。</strong></p>
<p>也可以加入其它注解来共同配置 Bean，比如：</p>
<ul>
<li><strong>@Profile</strong> – 允许选择性地根据配置包含某些bean</li>
<li><strong>@Scope</strong> – 更改 bean 的范围</li>
<li><strong>@Lazy</strong> – 仅在默认单例范围的情况下起作用</li>
<li><strong>@DependsOn</strong> – 在创建此 bean 之前强制创建特定的其他bean。</li>
<li><strong>@Primary</strong> – 是一种解决注入点级别歧义的机制，如果需要按类型匹配来注入Bean，但是符合类型的有多个。</li>
<li><strong>@Order</strong> – 设置优先级</li>
</ul>
<h4 id="已经有了-ref-引用依赖为什么需要-depend-on"><a class="markdownIt-Anchor" href="#已经有了-ref-引用依赖为什么需要-depend-on"></a> 已经有了 ref 引用依赖，为什么需要 Depend-on</h4>
<ul>
<li>可能 Bean 之间不是显式的依赖，但的确需要有初始化顺序</li>
<li>当多个 Bean 存在循环依赖关系时</li>
<li>或者仅仅想在一个 Bean 之前初始化另一个 Bean</li>
</ul>
<h4 id="依赖注入的两种方式"><a class="markdownIt-Anchor" href="#依赖注入的两种方式"></a> 依赖注入的两种方式</h4>
<ul>
<li>基于构造方法依赖注入（调用具有多个参数的构造方法)</li>
<li>基于 Setter 的依赖注入</li>
<li>混合使用<br />
由于您可以混合基于构造函数和基于 setter 的 DI ，因此将构造函数用于强制依赖项和 setter 方法或可选依赖项的配置方法是一个很好的经验法则。请注意，在 setter 方法上使用 <code>@Required</code> 注释可用于使属性成为必需的依赖项。<br />
Spring 团队通常提倡<strong>构造函数注入</strong>，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为null.此外，构造函数注入的组件总是以完全初始化的状态返回到客户端（调用）代码。作为旁注，大量的构造函数参数是一个糟糕的代码气味，暗示该类可能有太多的责任，应该重构以更好地解决关注点的正确分离。<br />
Setter 注入应主要仅用于可在类中指定合理默认值的可选依赖项。否则，必须在代码使用依赖项的任何位置执行非空检查。 setter 注入的一个好处是 setter 方法使该类的对象可以在以后重新配置或重新注入。因此，通过 JMX MBean 进行管理是二次注入的一个引人注目的用例。</li>
</ul>
<h4 id="spring-aop-的编织是在什么时候"><a class="markdownIt-Anchor" href="#spring-aop-的编织是在什么时候"></a> Spring AOP 的编织是在什么时候</h4>
<p>运行时，也就是说都是动态代理。 AspectJ 是在编译时。</p>
<h3 id="如何扩展-spring-容器"><a class="markdownIt-Anchor" href="#如何扩展-spring-容器"></a> 如何扩展 Spring 容器</h3>
<p>通常，我们不需要子类化 <code>ApplicationContext</code> 实现类。相反，可以通过插入特殊集成接口的实现来扩展 Spring IOC 容器。</p>
<ul>
<li>
<p>使用 <code>BeanPostProcessor</code> 来自定义 Beans</p>
<p>BeanPostProcessor 接口定义了回调方法，你可以去实现它以提供自己的（或覆盖容器的默认）实例化逻辑，依赖解析逻辑，等等。如果要在 Spring 容器完成实例化，配置和初始化 bean 之后实现某些自定义逻辑，则可以插入一个或多个 BeanPostProcessor 实现。</p>
<p>该工厂钩子允许自定义修改新 bean 实例，例如检查标记接口或用代理包装它们。 ApplicationContexts 可以在其 bean 定义中自动检测 BeanPostProcessor bean，并将它们应用于随后创建的任何 bean。</p>
<p>该接口默认包含两个默认方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法在任何 bean 初始化回调之前将此 BeanPostProcessor 应用于给定的新bean实例（如 InitializingBean 的 afterPropertiesSet 或自定义 init 方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br></pre></td></tr></table></figure>
<p>在任何 bean 初始化回调（如 InitializingBean 的 afterPropertiesSet 或自定义 init 方法）之后，将此 BeanPostProcessor 应用于给定的新 bean 实例。</p>
</li>
<li>
<p>使用 <code>BeanFactoryPostProcessor</code> 来自定义配置元数据</p>
<p>BeanFactoryPostProcessor 对 bean 的配置元数据进行操作。也就是说，Spring IOC 容器允许 BeanFactoryPostProcessor 读取配置元数据，并允许在容器实例化除 BeanFactoryPostProcessor 实例之外的任何 bean 之前更改元数据。</p>
<p>比如：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html"><code>PropertyPlaceholderConfigurer</code></a> 该配置器可以读取配置文件中的占位符，并从外部文件或环境变量等拿到相应的值替换占位符：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/something/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们可以在指定的外部文件中定义相应的属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">org.hsqldb.jdbcDriver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://production:9002</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>在配置文件找不到相应的属性时，默认也会从环境变量去寻找。你也可以自定寻找策略通过配置 <code>systemPropertiesMode</code> 。</p>
</li>
<li>
<p>使用 <code>FactoryBean</code> 自定义实例化逻辑</p>
<p>FactoryBean 接口是 Spring IOC 容器实例化逻辑的可插拔点。如果你有一个复杂的初始化代码，用 Java 表示比较好，而不是（可能）冗长的 XML，你可以创建自己的 FactoryBean，在该类中编写复杂的初始化，然后将自定义 FactoryBean 插入容器。</p>
</li>
</ul>
<h3 id="注解是否比-xml-配置-spring-更好"><a class="markdownIt-Anchor" href="#注解是否比-xml-配置-spring-更好"></a> 注解是否比 XML 配置 Spring 更好？</h3>
<p>每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，注解在其声明中提供了大量上下文，从而导致更短更简洁的配置。但是，XML 擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将配置靠近源，而另一些开发人员则认为注释类不再是 POJO，而且配置变得分散且难以控制。</p>
<p>无论选择如何，Spring 都可以兼顾两种风格，甚至可以将它们混合在一起。值得指出的是，通过其 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java">JavaConfig</a> 选项，Spring 允许以非侵入方式使用注释，而无需触及目标组件源代码。</p>
<p>在注入 XML 之前执行注解注入。因此，XML 配置会覆盖通过这两种方法连接的相同属性的注解。</p>
<h3 id="sprng-aop-代理机制"><a class="markdownIt-Anchor" href="#sprng-aop-代理机制"></a> Sprng AOP 代理机制？</h3>
<p>Spring AOP 使用 JDK 动态代理或 CGLIB 为给定目标对象创建代理。（只要有选择，JDK 动态代理就是首选）。</p>
<p>如果要代理的目标对象实现至少一个接口，则使用 JDK 动态代理。目标类型实现的所有接口都是代理的。如果目标对象未实现任何接口，则会创建 CGLIB 代理。</p>
<p>这是因为 CGLIB 默认会继承目标对象，然后重写被代理方法，所以必须要求被代理类不为 final 类，代理方法也不能为 final 类型。代理类如果有接口，也会通过实现接口的方法代理。CGLIB 是第三方框架，基于 ASM 提供的字节码操作。</p>
<p>JDK 动态代理是通过实现目标对象接口来代理方法的，所以只能代理接口暴露出去的方法。它是纯 java 实现。</p>
<p>CGLIB 和 JDK 动态代理都是在代理运行时动态生成 class 文件达到动态代理的目的。</p>
<p>静态代理唯一的缺点就是我们需要对每一个方法编写我们的代理逻辑，造成了工作的繁琐和复杂。AspectJ 就是为了解决这个问题，在编译成 class 字节码的时候在方法周围加上业务逻辑。复杂的工作由特定的编译器帮我们做。所以会有 AOP 有切面(Aspect)、连接点(joinpoint)、通知(advice)、切入点(Pointcut)、目标对象(target)等概念来定义代理的逻辑。</p>
<h2 id="jpa-问题整理"><a class="markdownIt-Anchor" href="#jpa-问题整理"></a> JPA 问题整理</h2>
<h3 id="hql-和-jpql-区别"><a class="markdownIt-Anchor" href="#hql-和-jpql-区别"></a> HQL 和 JPQL 区别</h3>
<p>Hibernate Query Language（HQL）和 Java Persistence Query Language（JPQL）都是以对象模型为中心的查询语言，与 SQL 本质上类似。JPQL 是一个受 HQL 影响很大的子集。但是，JPQL 查询始终是有效的 HQL 查询，反之则不然。</p>
<p>HQL 和 JPQL 都是非类型安全的方法来执行查询操作。 Criteria 查询提供了一种类型安全的查询方法。</p>
<h2 id="spring-security-问题整理"><a class="markdownIt-Anchor" href="#spring-security-问题整理"></a> Spring-Security 问题整理</h2>
<h4 id="spring-security-如何实现认证和授权"><a class="markdownIt-Anchor" href="#spring-security-如何实现认证和授权"></a> Spring-Security 如何实现认证和授权</h4>
<h4 id="说一下-spring-security-几个重要的对象"><a class="markdownIt-Anchor" href="#说一下-spring-security-几个重要的对象"></a> 说一下 Spring-Security 几个重要的对象？</h4>
<ul>
<li><code>SecurityContextHolder</code>， 提供对 <code>SecurityContext</code> 的访问。</li>
<li><code>SecurityContext</code>，保存 <code>Authentication</code> 和可能的特定于请求的安全信息。</li>
<li><code>Authentication</code>，以 Spring Security 特定的方式表示认证主体（一般为用户信息） principal。</li>
<li><code>GrantedAuthority</code>，反映授予主体的应用程序范围的权限。</li>
<li><code>UserDetails</code>，提供从应用程序的 DAO 或其他安全数据源构建 Authentication 对象所需的信息。</li>
<li><code>UserDetailsService</code>，在基于字符串的用户名（或证书 ID 等）中传递时创建 UserDetails。</li>
</ul>
<h2 id="elasticsearch-问题整理"><a class="markdownIt-Anchor" href="#elasticsearch-问题整理"></a> Elasticsearch 问题整理</h2>
<h4 id="为什么选择使用-elasticsearch"><a class="markdownIt-Anchor" href="#为什么选择使用-elasticsearch"></a> 为什么选择使用 Elasticsearch</h4>
<h4 id="elatiscsearch-如何选择查询"><a class="markdownIt-Anchor" href="#elatiscsearch-如何选择查询"></a> Elatiscsearch 如何选择查询</h4>
<h4 id="elasticsearch-的索引和-mysql-索引优势在哪里"><a class="markdownIt-Anchor" href="#elasticsearch-的索引和-mysql-索引优势在哪里"></a> Elasticsearch 的索引和 Mysql 索引优势在哪里</h4>
<h4 id="如何实现类似-sql-的-like-查询"><a class="markdownIt-Anchor" href="#如何实现类似-sql-的-like-查询"></a> 如何实现类似 SQL 的 Like 查询</h4>
<h2 id="redis-问题整理"><a class="markdownIt-Anchor" href="#redis-问题整理"></a> Redis 问题整理</h2>
<h4 id="redis-的基本类型有哪些"><a class="markdownIt-Anchor" href="#redis-的基本类型有哪些"></a> Redis 的基本类型有哪些</h4>
<p>Redis 是一个开源的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。</p>
<h2 id="数据库-问题整理"><a class="markdownIt-Anchor" href="#数据库-问题整理"></a> 数据库 问题整理</h2>
<h4 id="mysql-底层如何存放数据"><a class="markdownIt-Anchor" href="#mysql-底层如何存放数据"></a> Mysql 底层如何存放数据</h4>
<h4 id="如何优化-sql"><a class="markdownIt-Anchor" href="#如何优化-sql"></a> 如何优化 SQL</h4>
<h2 id="kafka-问题整理"><a class="markdownIt-Anchor" href="#kafka-问题整理"></a> Kafka 问题整理</h2>
<h4 id="如何提高消息吞吐量"><a class="markdownIt-Anchor" href="#如何提高消息吞吐量"></a> 如何提高消息吞吐量</h4>
<h5 id="生产者"><a class="markdownIt-Anchor" href="#生产者"></a> 生产者</h5>
<ul>
<li>
<p>开启消息压缩</p>
<p><code>compression.type</code>：默认情况，消息不会被压缩。这个属性可以设置压缩算法：<code>gzip</code>, <code>snappy</code>, <code>lz4</code>, <code>zstd</code>。<code>zstd</code> 和 <code>gzip</code> 比较平衡。</p>
</li>
<li>
<p>等待更多的消息进入批次</p>
<p><code>linger.ms</code>：生产者在发送批次之前等待更多的消息加入批次的时间。增大这个值会增加延迟但可以提高吞吐量。</p>
</li>
<li>
<p>增大批次处理量</p>
<p><code>max.in.flight.requests.per.connection</code>：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
</li>
<li>
<p>分配合理的分区数和消费者个数</p>
</li>
</ul>
<h4 id="如何保证消息顺序"><a class="markdownIt-Anchor" href="#如何保证消息顺序"></a> 如何保证消息顺序</h4>
<p>Kafka 可以保证同一个分区里的消息是有序的。也就是说，如果生产者按照一定的顺序发送消息，broker 就会按照这个顺序把它们写入分区，消费者也会按照同样的顺序读取它们。</p>
<p><strong>使用单个分区能最大程度保证消息的顺序，或者消息使用相同的 key。还需注意下面的配置。</strong></p>
<h5 id="生产者-2"><a class="markdownIt-Anchor" href="#生产者-2"></a> 生产者</h5>
<p><code>retries</code>：生产者从服务器收到错误时的重试次数</p>
<p><code>max.in.flight.requests.per.connection</code>：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
<p>消息是否写入成功也是非常关键的，如果把 <code>retries</code> 设为非零整数，同时把 <code>max.in.flight.requests.per.connection</code> 设为比 1 大的数，那么第一批消息写入失败，而第二批写入成功，broker 重试第一个批次。此时第一个批次写入成功，那么两个批次的顺序就反了。</p>
<p>为了保证写入的顺序，不建议把 <code>retries</code> 设为 0。可以把 <code>max.in.flight.requests.per.connection</code> 设为 <strong>1</strong>，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker。不过这样的会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下。</p>
<h4 id="如何保证消息被消费-exactly-once"><a class="markdownIt-Anchor" href="#如何保证消息被消费-exactly-once"></a> 如何保证消息被消费 Exactly-Once</h4>
<p>由于各种故障，消息传递系统无法保证生产者和使用者应用程序之间的消息传递。根据客户端应用程序与此类系统交互的方式，可能会出现以下消息语义：</p>
<ul>
<li>如果消息传递系统永远不会复制消息，但可能会漏掉偶尔的消息，则我们称 <em><strong>最多一次 (at-most-once)</strong></em></li>
<li>如果它永远不会丢失一条消息，但可能会重复一条消息，则我们至少将其 <em><strong>至少一次 (at-least-once)</strong></em></li>
<li>如果它发送所有消息时总是不重复，那将是 <em><strong>恰好一次 (exactly-once)</strong></em></li>
</ul>
<p>要保证消息只发送一次，得保证生产者发送给服务器的消息只成功一次，消费者也只消费一次。Kafka 代理和客户端应用引入事物可确保进行一次准确的交付。</p>
<h5 id="生产者-3"><a class="markdownIt-Anchor" href="#生产者-3"></a> 生产者</h5>
<p><code>acks</code>：该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有影响。</p>
<ul>
<li><code>acks=0</code> 不需要确认</li>
<li><code>acks=1</code> 需要集群首领确认。首领确认纪录后失败，如果跟随者还没复制，则记录可能丢失。</li>
<li><code>acks=all</code> 集群首领及其追随者都确认后，才会收到成功响应。安全性更高，吞吐率下降。</li>
</ul>
<p><code>enable.idempotence</code>：当设置为 “true” 时，生产者将确保每个消息的仅有一个副本被写入流中。如果为 “false”，则生产者由于代理失败等原因而重试，可能会将重试消息的副本写入流中。 请注意，启用幂等性要求 <code>max.in.flight.requests.per.connection</code> 小于或等于 5，重试大于 0，<code>ack</code> 必须为 “<strong>all</strong>”。 如果用户未明确设置这些值，则将选择合适的值。 如果设置了不兼容的值，则将引发 ConfigException。</p>
<h6 id="幂等操作"><a class="markdownIt-Anchor" href="#幂等操作"></a> 幂等操作</h6>
<p>由于生产者出错重试会导致消息重复，所以为了生产者成功提交的消息恰好一次，可以使用幂等操作来保证。如果发生导致生产者重试的错误，则相同的消息（仍由生产者多次发送）将仅写入到代理上的 Kafka 日志一次。对于单个分区，幂等生产者发送消除了由于生产者或代理错误而产生重复消息的可能性。要启用此功能并为每个分区获取一次精确的语义（即没有重复，没有数据丢失和有序的语义），请将生产者配置为 <code>enable.idempotence = true</code>。</p>
<h6 id="事物"><a class="markdownIt-Anchor" href="#事物"></a> 事物</h6>
<p>生产者通过设定事物 Id (<code>transactional.id</code>)，然后开启事物。</p>
<h5 id="消费者"><a class="markdownIt-Anchor" href="#消费者"></a> 消费者</h5>
<h6 id="事物-2"><a class="markdownIt-Anchor" href="#事物-2"></a> 事物</h6>
<p><code>isolation.level</code>：控制如何读取事务写入的消息。如果设置为 <code>read_committed</code>，consumer.poll() 将仅返回已提交的事务性消息。如果设置为 <code>read_uncommitted</code>（<strong>默认</strong>），consumer.poll() 将返回所有消息，甚至是已中止的事务性消息。非事务性消息在两种方式下都返回。</p>
<h6 id="手动提交"><a class="markdownIt-Anchor" href="#手动提交"></a> 手动提交</h6>
<p><code>enable.auto.commit</code>：该属性决定是否自动提交偏移量，默认为 true。为了避免数据出现重复和丢失，可以通过手动提交的方式自行提交偏移量。</p>
<h4 id="是什么使-kafka-如此之快"><a class="markdownIt-Anchor" href="#是什么使-kafka-如此之快"></a> 是什么使 Kafka 如此之快</h4>
<h5 id="低延迟消息传递"><a class="markdownIt-Anchor" href="#低延迟消息传递"></a> 低延迟消息传递</h5>
<p>Kafka 通过顺序 IO 操作日志避免了长时间的磁盘寻道；</p>
<p>零复制原则，避免了内核上下文和应用上下文的文件读取和发送，直接在系统内核上下文中进行文件读取和发送，避免了上下文切换的时间消耗和内存占用。</p>
<p>传统数据复制方法</p>
<p><img src="../images/message/kafka/data-copying.gif" alt="Traditional data copying approach" /></p>
<p>零复制使用 <code>java.nio.channels.FileChannel.transferTo()</code></p>
<p><img src="../images/message/kafka/zero-copying.gif" alt="Data copy with transferTo()" /></p>
<h5 id="批处理数据和压缩"><a class="markdownIt-Anchor" href="#批处理数据和压缩"></a> 批处理数据和压缩</h5>
<p>高效压缩将同一批次的消息压缩在一起，并保持压缩在日志中，并且仅由使用者解压缩。支持的压缩算法：Zstd、Snappy、GZip 或 LZ4。</p>
<h5 id="水平扩展"><a class="markdownIt-Anchor" href="#水平扩展"></a> 水平扩展</h5>
<p>首先让我们了解什么是垂直扩展。可以说，对于传统的数据库服务器，当负载增加时，一种解决方法是添加更多资源，例如：CPU，RAM，SSD 等。这称为垂直扩展。它具有以下几个缺点：</p>
<ul>
<li>每个硬件都有局限性，不能无限地向上扩展。</li>
<li>如果机器出现故障怎么办？通常需要停机。</li>
</ul>
<p><strong>水平扩展</strong>通过添加更多机器来解决相同的问题。 Kafka 能够为单个主题提供数千个分区，并将其分布在数千台计算机中，这意味着 Kafka 可以处理巨大的负载。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Java8</tag>
        <tag>Spring Security</tag>
        <tag>Spring Boot</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate 继承映射</title>
    <url>/persistence/Hibernate-%E7%BB%A7%E6%89%BF%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>在关系型数据库中我们没有直接的方法去映射类的继承到数据库表中。为了解决这个问题，JPA 标准提供了几种策略：</p>
<ul>
<li>MappedSuperclass - 父类，不能是实体</li>
<li>Single Table - 来自具有共同祖先的不同类的实体被放置在单个表中</li>
<li>Joined Table - 每个类都有自己的表，查询子类实体需要连接表</li>
<li>Table-Per-Class - 类的所有的属性都在一张表中，所以不需要连接<br />
每种策略都会产生不同的数据库结构。</li>
</ul>
<a id="more"></a>
<p><strong>实体查询意味着我们可以在查询父类时使用动态查询获取所有的子类。</strong><br />
由于 Hibernate 是 JPA 的一个实现，它包含上述所有内容以及一些与继承相关的特定于 Hibernate 的功能。</p>
<h2 id="映射父类策略"><a class="markdownIt-Anchor" href="#映射父类策略"></a> 映射父类策略</h2>
<p>使用 MappedSuperclass 策略，继承只在类中体现，而不是实体模型。让我们从创建一个代表父类的Person类开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> personId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**请注意这里的类没有 <code>@Entity</code> 注解 ** ，所以它不会被持久化到数据库中。<br />
接着，我们添加一个 Employee 子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEmployee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="comment">// constructor, getters, setters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数据库中，这将只生成一个 “MyEmployee” 表，总共三列包含子类定义的字段以及继承而来的字段。</p>
<p>**如果我们使用此策略，祖先不能包含与其他实体的关联。<br />
该策略可以用于为相同类定义相同字段，比如创建时间，创建者等审计功能或者通用字段。 **</p>
<h2 id="单表策略"><a class="markdownIt-Anchor" href="#单表策略"></a> 单表策略</h2>
<p><strong>单表策略为每个类层次结构创建一个表。</strong> 如果我们没有明确指定，这也是 JPA 选择的默认策略。<br />
我们可以通过将 <code>@Inheritance</code> 注释添加到父类来定义我们想要使用的策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> productId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们添加一些子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">MyProduct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pen</span> <span class="keyword">extends</span> <span class="title">MyProduct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将生成下面的表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> MyProduct (</span><br><span class="line">  DTYPE <span class="built_in">varchar</span>(<span class="number">31</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  productId <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  author <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  color <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  primary <span class="keyword">key</span> (productId)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当我们向其中插入数据时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Book book = <span class="keyword">new</span> Book();</span><br><span class="line">book.setProductId(<span class="number">1L</span>);</span><br><span class="line">book.setAuthor(<span class="string">&quot;Zeral&quot;</span>);</span><br><span class="line"></span><br><span class="line">Pen pen = <span class="keyword">new</span> Pen();</span><br><span class="line">pen.setProductId(<span class="number">2L</span>);</span><br><span class="line">pen.setColor(<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Hibernate 将会使用子类名称填充 <code>DTYPE</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyProduct (author, DTYPE, productId) <span class="keyword">VALUES</span> (<span class="string">&#x27;Zeral&#x27;</span>, <span class="string">&#x27;Book&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyProduct (color, DTYPE, productId) <span class="keyword">VALUES</span> (<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;Pen&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="discriminator-values-鉴别器值"><a class="markdownIt-Anchor" href="#discriminator-values-鉴别器值"></a> Discriminator Values 鉴别器值</h3>
<p>由于所有的实体记录都在同一个表中，因此 Hibernate 需要一种区分它们的方法。<br />
**默认情况下，这是通过名为 <code>DTYPE</code> 的鉴别器列完成的 ** ，该列使用实体的名称作为值。<br />
要自定义鉴别器列，我们可以使用 <code>@DiscriminatorColumn</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name=&quot;products&quot;)</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;product_type&quot;, </span></span><br><span class="line"><span class="meta">  discriminatorType = DiscriminatorType.INTEGER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProduct</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们选择通过名为 product_type 的整数列来区分 MyProduct 子类实体。<br />
接下来，我们需要告诉 Hibernate 每个子类对应于 product_type 列的什么值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">extends</span> <span class="title">MyProduct</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pen</span> <span class="keyword">extends</span> <span class="title">MyProduct</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hibernate 添加了注解可以采用的另外两个预定义值：“null” 和 “not null”：</p>
<ul>
<li><code>@DiscriminatorValue(“null”)</code> - 当任意行没有鉴别器值时将被映射到使用此注解的实体类;这可以应用于层次结构的根类</li>
<li><code>@DiscriminatorValue(“not null”)</code> - 当任意行有鉴别器值时但是未找到该鉴别器对应的类时将被映射到使用此注解的实体类</li>
</ul>
<p><strong>这两个注解可以解决在集成遗留数据库时，鉴别器列包含 NULL 或某些与任何实体子类无关的值，如果不做该映射处理，这些异常数据在处理时会抛出异常。</strong></p>
<p>除了列，我们还可以使用特定于 Hibernate 的<code>@DiscriminatorFormula</code> 注释来确定区分值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorFormula(&quot;case when author is not null then 1 else 2 end&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProduct</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>**此策略具有多态查询性能的优点，因为在查询父实体时只需要访问一个表。另一方面，这也意味着我们不能再对子类实体属性使用 NOT NULL 约束。 **</p>
<h2 id="连表策略"><a class="markdownIt-Anchor" href="#连表策略"></a> 连表策略</h2>
<p>使用此策略，层次结构中的每个类都映射到其表。在所有表中重复出现的唯一列是标识符，将在需要时用于连接它们。<br />
让我们创建一个使用此策略的父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.JOINED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> animalId;</span><br><span class="line">    <span class="keyword">private</span> String species;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们定义一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个表都有一个 animalId 标识符列。 Pet 实体的主键还具有对其父实体的主键的外键约束。要自定义此列，我们可以添加 <code>@PrimaryKeyJoinColumn</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn(name = &quot;petId&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建的表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Animal (</span><br><span class="line">  animalId <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  species <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  primary <span class="keyword">key</span> (animalId);</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Pet (</span><br><span class="line">  petId <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">  primary <span class="keyword">key</span> (petId),</span><br><span class="line">  <span class="keyword">foreign</span> <span class="keyword">key</span>(petId) <span class="keyword">references</span> Animal(animalId) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>此继承映射方法的缺点是检索实体需要表之间的连接，这可能导致大量记录的性能降低。</strong><br />
查询父类时，连接数会更高，因为它将与每个相关的子项连接 - 因此，我们想要检索记录的层次结构越高，性能就越可能受到影响。</p>
<h2 id="单类单表策略"><a class="markdownIt-Anchor" href="#单类单表策略"></a> 单类单表策略</h2>
<p><strong>Table Per Class 策略将每个实体映射到一张表，该表包含实体的所有属性，包括继承的属性。</strong><br />
生成的模式类似于使用 @MappedSuperclass 的模式，但与此不同，它会为父类定义实体，从而允许关联和多态查询。<br />
要使用此策略，我们只需要将 <code>@Inheritance</code> 注解添加到基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> vehicleId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String manufacturer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// standard constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为其添加一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String engine;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// standard constructor, getters, setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的 sql 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Car (</span><br><span class="line">  vehicleId <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  manufacturer <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">engine</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (vehicleId)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这与在没有继承的情况下映射每个实体没有太大区别。在查询基类时，这种区别是显而易见的，它将在后台使用 UNION 语句返回所有子类记录。<br />
<strong>在选择此策略时，使用 UNION 也会导致性能下降。另一个问题是我们不能再使用标式键密钥生成。</strong></p>
<h2 id="多态查询"><a class="markdownIt-Anchor" href="#多态查询"></a> 多态查询</h2>
<p>我们创建两个 Book 和 Pen 对象，然后查询它们的超类 MyProduct 以验证我们将返回两个对象。<br />
<strong>Hibernate 还可以查询由实体类扩展或实现的接口或基类这些非实体类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.createQuery(</span><br><span class="line">  <span class="string">&quot;from com.baeldung.hibernate.pojo.inheritance.Person&quot;</span>)</span><br><span class="line">  .getResultList())</span><br><span class="line">  .hasSize(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>请注意，这也适用于任何父类或接口，无论它是否是 @MappedSuperclass。与通常的 HQL 查询的区别在于我们必须使用完全限定名称，因为它们不是由 Hibernate 管理的实体。<br />
如果我们不希望这种类型的查询返回特定子类，那么我们只需要在其定义中添加 Hibernate <code>@Polymorphism</code> 注释，类型为 <code>EXPLICIT</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Polymorphism(type = PolymorphismType.EXPLICIT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123; ...&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，查询父类时，不会返回 Bag 记录。</p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>MappedSuperclass</tag>
      </tags>
  </entry>
  <entry>
    <title>Java HashMap 实现</title>
    <url>/data-structure/Java-HashMap-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h1>
<p>我们先大概瞥一眼 JDK 1.7 之前的 HashMap 结构：</p>
<p><img src="../../images/java/hashmap/hashmap.jpg" alt="HashMap" /></p>
<p>简而言之，<code>HashMap</code> 是由数组组成的一定数量的桶（<code>bucket</code>）。在进行存储时，使用 <code>key</code> 的 hashcode 通过 <strong><code>hash</code> 函数</strong>计算得到  <code>hash</code> 值，然后通过 **<code>hash 值 % 数组长度</code>**来确定将 <code>Entry(key + value)</code> 放入数组的哪个桶里。</p>
<a id="more"></a>
<blockquote>
<p>为什么要用 <code>hashcode</code> 来确定位置？</p>
<p>为了高效的定位元素在数组中的位置，以及使放入的元素尽可能均匀的分布在数组中。</p>
<p>正确实现 hashcode 方法返回的 hash 值可以达到散列分布的目的，同样的键也会返回相同的 hash 值，因此我们使用 hash 信息来确定元素在数组中的下标信息以达到快速访问。</p>
</blockquote>
<p>如果 hash 函数足够完美，将能实现数据的均匀分配，此时时间复杂度未 O(1)。但是开发者通常会编写较差的哈希函数，这将导致分布不均。</p>
<blockquote>
<p>散列函数也被用于不可逆加密中，比如：MD 加密、SHA 加密</p>
</blockquote>
<p><img src="../../images/java/hashmap/buckets.png" alt="Bad hashmap" /></p>
<h2 id="hash-碰撞及解决collision"><a class="markdownIt-Anchor" href="#hash-碰撞及解决collision"></a> Hash 碰撞及解决（Collision）</h2>
<p>此时数组将会有很大一部分被浪费，而且含多不同的键将会产生相同的 hash 值**（hash 碰撞）**。</p>
<p><img src="../../images/java/hashmap/hash%20collision.png" alt="Hash function" /></p>
<h3 id="负载因子与容量"><a class="markdownIt-Anchor" href="#负载因子与容量"></a> 负载因子与容量</h3>
<p>为了解决这个问题，一方面，我们可以增大哈希值的取值空间来减少冲突的可能性，比如使 hash 表大于所需的总数据量。期望只要有哈希表的 70 % 被占用就足够。存储元素的个数和哈希表的长度的比值就叫做<strong>负载因子（Load factor）</strong>。</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: No such environment: align* at position 7: \begin{̲a̲l̲i̲g̲n̲*̲}̲
Load \quad Fac…'>\begin{align*}
Load \quad Factor = \frac{Total \quad number \quad of \quad items \quad stored} {Size \quad of \quad the \quad Buckets \quad array}
\end{align*}
</p>
<p>负载系数限制通常是可配置的，并在时间和空间成本之间进行权衡。</p>
<p><img src="../../images/java/hashmap/tradeoff-time-space.png" alt="Tradeoff Time And Space" /></p>
<p>Java 中 <code>HashMap</code> 的默认负载因子是 <code>0.75</code>。</p>
<p>容量（<code>Capacity</code>） 在 <code>Java HashMap</code> 中指桶的数量。</p>
<p><code>Java HashMap</code> 的默认初始容量为 <code>16</code>，即存储区数组在首次插入时被延迟初始化。</p>
<p>当插入的元素到达一定的阈值，HashMap 将会扩容来重新计算哈希，该阈值的计算公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>C</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Threshold = (Current Capacity) * (Load Factor)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p>
<p>以 HashMap 的默认值计算，则为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mo>=</mo><mn>16</mn><mo>∗</mo><mn>0.75</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">Threshold = 16 * 0.75 = 12
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></span></p>
<p>也就是说当插入第 13 个元素后会进行扩容为之前的两倍 <code>oldThreshold &lt;&lt; 1</code>，此时将发生重新哈希（<code>Rehashing</code>），由于重新哈希处理增加了存储桶的数量，因此降低了负载系数。</p>
<p><img src="../../images/java/hashmap/rehashing.gif" alt="Rehashing" /></p>
<blockquote>
<p>为什么 HashMap 加载因子默认是 0.75？</p>
<p>这个跟一个统计学里很重要的原理——泊松分布有关。</p>
<p>泊松分布是统计学和概率学常见的离散概率分布，适用于描述单位时间内随机事件发生的次数的概率分布。</p>
<p><img src="../../images/java/hashmap/poisson-distribution.png" alt="Poisson distribution" /><br />
等号的左边，P 表示概率，N 表示某种函数关系，t 表示时间，n 表示数量。等号的右边，λ 表示事件的频率。</p>
<p>在理想情况下，使用随机哈希码，在扩容阈值（加载因子）为 0.75 的情况下，节点出现在频率在 Hash 桶（表）中遵循参数平均为 0.5 的泊松分布。忽略方差，即 X = λt，P(λt = k)，其中 λt = 0.5的情况。</p>
<p>所以我们可以知道，其实常数 0.5 是作为参数代入泊松分布来计算的，而加载因子 0.75 是作为一个条件，当 HashMap 长度为length/size ≥ 0.75 时就扩容，在这个条件下，冲突后的拉链长度和概率结果为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>:    <span class="number">0.60653066</span></span><br><span class="line"><span class="number">1</span>:    <span class="number">0.30326533</span></span><br><span class="line"><span class="number">2</span>:    <span class="number">0.07581633</span></span><br><span class="line"><span class="number">3</span>:    <span class="number">0.01263606</span></span><br><span class="line"><span class="number">4</span>:    <span class="number">0.00157952</span></span><br><span class="line"><span class="number">5</span>:    <span class="number">0.00015795</span></span><br><span class="line"><span class="number">6</span>:    <span class="number">0.00001316</span></span><br><span class="line"><span class="number">7</span>:    <span class="number">0.00000094</span></span><br><span class="line"><span class="number">8</span>:    <span class="number">0.00000006</span></span><br></pre></td></tr></table></figure>
<p>计算结果如上述的列表所示，当一个桶中的链表长度达到 8 个元素的时候，概率为 0.00000006，几乎是一个不可能事件。</p>
<p>选择0.75作为默认的加载因子，完全是时间和空间成本上寻求的一种折衷选择。</p>
</blockquote>
<h3 id="寻址"><a class="markdownIt-Anchor" href="#寻址"></a> 寻址</h3>
<p>另一方面，为了给冲突元素一个合适的位置存储，我们将解决方案从寻址方向上分为两个大类：</p>
<table>
<thead>
<tr>
<th style="text-align:center">开放式寻址（Open Addressing）</th>
<th style="text-align:center">闭合式寻址（Closed Addressing）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通过在哈希表数组本身中搜索另一个空存储桶来处理冲突。</td>
<td style="text-align:center">键始终存储在散列到的桶中。在每个桶的基础上使用单独的数据结构来处理冲突。</td>
</tr>
<tr>
<td style="text-align:center">每个桶中最多存放一个键。</td>
<td style="text-align:center">每个桶存储任意键数。</td>
</tr>
<tr>
<td style="text-align:center">理论最大负载系数为1。</td>
<td style="text-align:center">没有理论上的最大负载系数。</td>
</tr>
<tr>
<td style="text-align:center">哈希表数组的大小必须始终至少与哈希表中键的数量一样大。</td>
<td style="text-align:center">性能随着负载系数的增长而降低。</td>
</tr>
</tbody>
</table>
<h4 id="开放式寻址相关技术"><a class="markdownIt-Anchor" href="#开放式寻址相关技术"></a> 开放式寻址相关技术</h4>
<ul>
<li>线性探测（<code>Linear Probing</code>）</li>
<li>二次方探测（<code>Quadratic Probing</code>）</li>
<li>再哈希（<code>Double hashing</code>）</li>
<li>罗宾汉哈希（<code>Robin Hood hashing</code>）</li>
<li>等</li>
</ul>
<p>插入和查找扫描阵列的顺序在实现之间有所不同。下面介绍一些常用技术。 （所有索引均以数组长度为模。）</p>
<h5 id="线性探测"><a class="markdownIt-Anchor" href="#线性探测"></a> 线性探测</h5>
<p>如果在存储区 i 中发生冲突，搜索序列将使用下列索引继续：</p>
<ul>
<li><em>i</em> + 1</li>
<li><em>i</em> + 2</li>
<li><em>i</em> + 3</li>
<li>…</li>
</ul>
<p>由于探测序列在内存中是线性的，因此该方法可实现良好的缓存性能。</p>
<h5 id="二次方探测"><a class="markdownIt-Anchor" href="#二次方探测"></a> 二次方探测</h5>
<p>通过二次方探测，从存储桶 i 开始的搜索序列如下：</p>
<ul>
<li><em>i</em> + 1<sup>2</sup></li>
<li><em>i</em> + 2<sup>2</sup></li>
<li><em>i</em> + 3<sup>2</sup></li>
<li>…</li>
</ul>
<h5 id="再哈希"><a class="markdownIt-Anchor" href="#再哈希"></a> 再哈希</h5>
<p>使用二次哈希（另一个哈希函数）双重哈希，h 用于确定搜索序列中步骤的大小。如果 h<sub>2</sub>(key) = j，则从存储区 i 开始的搜索序列如下：</p>
<ul>
<li><em>i</em> + 1 × <em>j</em></li>
<li><em>i</em> + 2 × <em>j</em></li>
<li><em>i</em> + 3 × <em>j</em></li>
</ul>
<p>（如果 j 恰好等于数组长度的倍数，则使用 1 代替。）</p>
<p><img src="../../images/java/hashmap/open-addressing.png" alt="Comparison of Probing Techniques" /></p>
<h4 id="闭合式寻址相关技术"><a class="markdownIt-Anchor" href="#闭合式寻址相关技术"></a> 闭合式寻址相关技术</h4>
<ul>
<li>使用链表单独存储 hash 相同的键值（拉链法）</li>
<li>使用动态数组单独存储 hash 相同的键值</li>
<li>使用自平衡二叉树</li>
</ul>
<p><strong>Java HashMap 是结合第一种和第三种的实现。</strong></p>
<p><img src="../../images/java/hashmap/hashmap-tree.png" alt="HashMap" /></p>
<h1 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h1>
<p>先总体了解下 HashMap 作为集合类的特性：</p>
<ul>
<li>
<p>HashMap 的键值都不能存储基本类型</p>
<p>要存储基本类型提高性能，可以使用 <a target="_blank" rel="noopener" href="https://github.com/eclipse/eclipse-collections/blob/master/docs/guide.md#primitive-maps"><code>Eclipse Collection</code> 的原始类型集合类</a></p>
</li>
<li>
<p>支持一个 null 键和多个 null value</p>
</li>
<li>
<p>键必须唯一，重复的键值将被后面的值替代</p>
</li>
<li>
<p>使用哈希技术存储索引，所以不保证插入顺序</p>
</li>
<li>
<p>非线程安全，需自己保证同步</p>
<p>可以使用 <code>Collections.synchronizedMap(new HashMap(...));</code> 包裹，或使用 <code>HashTable</code>，<code>ConcurrentHashMap</code>，后者性能更高</p>
</li>
<li>
<p>快速失败机制</p>
<p>在 Java 非线程安全的集合类中，遍历集合中，对集合做额外的操作比如调用新增、删除会立即停止当前操作并抛出 <code>ConcurrentModificationException</code>，在 HashMap 中使用 <code>modCount</code> 记录修改次数，如果遍历中该记录和开始时不相同，则报错。</p>
<p>可以使用 <code>Iterator</code> 接口安全的移除元素，一般集合会实现安全的移除操作。但是多线程环境下得保证 <code>Iterator</code> 实现类的线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">20</span>, <span class="number">0.75f</span>);</span><br><span class="line"><span class="keyword">final</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = hashMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().getKey().equals(<span class="string">&quot;test&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove(); <span class="comment">// ok!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// java 8 removeIf</span></span><br><span class="line">hashMap.entrySet().removeIf(stringStringEntry -&gt; stringStringEntry.getKey().equals(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>标记了 <strong>Serializeable</strong> 和 <strong>Cloneable</strong> 接口</p>
</li>
</ul>
<p><img src="../../images/java/hashmap/hashmap-1.8.png" alt="HashMap JDK 1.8" /></p>
<h2 id="桶数组-or-桶表"><a class="markdownIt-Anchor" href="#桶数组-or-桶表"></a> 桶数组 or 桶表</h2>
<p>在代码中，桶数组用如下变量表示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>这里需要注意几点：</p>
<ul>
<li>
<p>桶数组并没有在构造方法中初始化，而是在第一次使用时才会分配内存，比如 <code>put</code>、<code>compute</code>、<code>merge</code> 等。</p>
</li>
<li>
<p>当分配内存时，长度总是 2 的幂次方。</p>
<blockquote>
<p>为什么选择 2 的幂次方？</p>
<p>由于为了达到高效处理性能，很多操作都是通过位运算完成。比如其中的 <code>hash</code> 方法，计算桶索引等，后面会详细说明。</p>
</blockquote>
</li>
<li>
<p>如果初始化时传入的 capacity 不是 2 的幂次方，将会使用<a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">该位运算算法</a>增加到最近的 2 次幂。</p>
</li>
</ul>
<h2 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h2>
<p>每个桶内部由链表组成，在代码中为类 <code>Node&lt;K, V&gt;</code> 的实例，此类是 HashMap 类的静态内部类，并且实现 <code>Map.Entry&lt;K, V&gt;</code> 接口，此节点的表示形式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;			<span class="comment">// 使用 hash 定位桶</span></span><br><span class="line">        <span class="keyword">final</span> K key;				<span class="comment">// 节点存放的 key</span></span><br><span class="line">        V value;						<span class="comment">// 节点存放的 值</span></span><br><span class="line">        Node&lt;K,V&gt; next;     <span class="comment">// 指向链表的下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashmap-如何计算桶索引"><a class="markdownIt-Anchor" href="#hashmap-如何计算桶索引"></a> HashMap 如何计算桶索引？</h2>
<p>之前我们提到计算索引是使用 hash 值和桶数组长度求余，但是求余的效率并没有直接按位运算的高。同样我们需要借助一些<a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html#ModulusDivisionEasy">位运算的技巧</a>，这里 n 为桶数组的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index = hash(key) &amp; (n-<span class="number">1</span>)  <span class="comment">// 相当于求 hash(key) % n，当 n 位 2 的次幂且不为 0 时成立</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，为什么这里需要将高位数据移位到低位进行异或运算呢？这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</p>
<p>计算桶索引并不只是发生在 <code>put</code> 方法时，在调用 <code>get</code>、<code>contains</code>、<code>remove</code> 时都会调用 <code>hash</code> 方法重新计算 <code>hash</code> 值并在计算桶索引。</p>
<h2 id="为什么桶内不使用-arraylist-或-linkedlist"><a class="markdownIt-Anchor" href="#为什么桶内不使用-arraylist-或-linkedlist"></a> 为什么桶内不使用 ArrayList 或 LinkedList？</h2>
<p>HashMap 内部使用单向链表来维护哈希冲突的元素，但为什么不用数组或双向链表，这其实是一个平衡后的考虑：</p>
<ul>
<li><code>ArrayList</code> 使用较少的空间，检索速度快，但是最坏的情况下插入和删除元素的时间复杂度可能为 <strong><code>O(n)</code></strong></li>
<li><code>LinkedList</code> 使用更多空间维护前后节点信息，但是插入或删除元素的时间复杂度为 <strong><code>O(1)</code></strong></li>
</ul>
<p>使用单向链表的好处在于，其既可以使空间相对较少，也能保证删除和插入的时间复杂度为 <code>O(1)</code>。但是如果链表过长，最坏的可能是所有元素都放入一个桶里，此时时间复杂度将变为 <code>O(n)</code>。为了优化这一点，<code>JDK 1.8</code> 使用了红黑树来优化链表过长的情况。</p>
<p>当桶数组的长度超过 <code>MIN_TREEIFY_CAPACITY</code> 且桶中的元素超过 <code>TREEIFY_THRESHOLD</code> 值时，链表转为红黑树。</p>
<p>当桶中元素减少至 <code>UNTREEIFY_THRESHOLD</code> 时，红黑树退回到链表。</p>
<h2 id="为什么用红黑树"><a class="markdownIt-Anchor" href="#为什么用红黑树"></a> 为什么用红黑树？</h2>
<p><img src="../../images/java/hashmap/red-black-tree.jpg" alt="Red Black Tree" /></p>
<p>因为当大量哈希冲突的时候会导致节点链表越来越长从而降低 <code>HashMap</code> 性能。而红黑树为二叉查找树，所以时间复杂度为 <strong>O(logn)</strong>，因此在数据量大的散列表中红黑树更有优势。</p>
<p>**本质上这是个安全问题。**因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端 CPU 大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p>
<p><strong>为什么选择红黑树而不是二叉树或绝对平衡二叉树呢？</strong><br />
首先，二叉树在极端情况下依然会形成链表。例如 1,2,3,4 的 <code>hashCode</code> 相同时，二叉树退化成链表<br />
再是，绝对平衡就好像有强迫症一样把精力消耗在如何达到平衡上，因此造成不必要的性能开销<br />
而红黑树它是一棵平衡树但不是绝对平衡树，优点有以下：</p>
<ol>
<li>树属于折半查找，于较长的链表相比查询效率要高</li>
<li>平衡树解决了二叉树的计算情况问题（二叉树退化成链表）</li>
<li>非绝对平衡树比绝对平衡树在增删节点时要高效一些</li>
</ol>
<p>因此红黑树是综合性能较强的数型数据结构。</p>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://programming.guide/hash-tables-open-vs-closed-addressing.html#:~:text=Also%20known%20as%20open%20hashing,the%20bucket%20it's%20hashed%20to.">hash-tables-open-vs-closed-addressing</a> 开放寻址和闭合寻址比较</li>
<li><a target="_blank" rel="noopener" href="https://programming.guide/hash-tables-open-addressing.html">hash-tables-open-addressing</a> 介绍开放式寻址</li>
<li><a target="_blank" rel="noopener" href="https://programming.guide/hash-tables.html">hash-tables</a> hash table 实现</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发编程入门</title>
    <url>/concurrency/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h1>
<p>要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变（Mutable）的状态的访问。</p>
<p>对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包含其他依赖对象的域。</p>
<p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：</p>
<ul>
<li>不在线程之间共享该状态变量</li>
<li>该状态变量修改为不可变的变量</li>
<li>在访问状态变量时使用同步</li>
</ul>
<a id="more"></a>
<h2 id="什么是线程安全性"><a class="markdownIt-Anchor" href="#什么是线程安全性"></a> <strong>什么是线程安全性？</strong></h2>
<p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么称这个类是线程安全的。</p>
<p><strong>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</strong></p>
<p><strong>无状态对象一定是线程安全的。</strong></p>
<h2 id="活跃性与性能问题"><a class="markdownIt-Anchor" href="#活跃性与性能问题"></a> 活跃性与性能问题</h2>
<p>安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注于另一个目标，即“某件正确的事情最终会发生”。当某个操作无法继续执行下去时，就会发生活跃性问题。串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。</p>
<p>多线程中将遇到各种形式的活跃性问题，包括死锁、饥饿、以及活锁等。</p>
<p>与活跃性问题密切相关的是性能问题，活跃性意味着某件正确的事情最终会发生，但却不够好。因为我们通常希望正确的真情尽快发生。性能问题包括多个方面，例如服务时间过长、响应不灵敏、吞吐率过低、资源消耗过高、或者可伸缩性较低等。</p>
<h2 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> <strong>原子性</strong></h2>
<p>假定有两个操作 A 和 B，如果从执行 A 的线程来看，当另一个线程执行 B 时，要么将 B 全部执行完，要么完全不执行 B，那么 A 和 B 对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。</p>
<p>我们将“先检查后执行”以及“读取 — 修改 — 写入”等操作统称为符合操作。</p>
<h3 id="竞态条件"><a class="markdownIt-Anchor" href="#竞态条件"></a> 竞态条件</h3>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气。</p>
<h2 id="加锁机制"><a class="markdownIt-Anchor" href="#加锁机制"></a> 加锁机制</h2>
<p>要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。</p>
<h3 id="内置锁"><a class="markdownIt-Anchor" href="#内置锁"></a> 内置锁</h3>
<p>Java 提供内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态方法的 synchronized 方法以 Class 对象作为锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">  <span class="comment">// 访问或修改由锁保护的共享状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 Java 对象都可以用作一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或者监视器锁（Monitor Lock）。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。</p>
<p>Java 的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。</p>
<h3 id="重入"><a class="markdownIt-Anchor" href="#重入"></a> 重入</h3>
<p>由于**内置锁是可重入的，**因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。</p>
<p>重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并且将获取计数值置为 1 。如果同一个线程再次获取这个锁时，计数值将递增，而当线程退出同步代码块时，计数器会相应递减。当计数值为 0 时，这个锁将被释放。</p>
<h3 id="用锁来保护状态"><a class="markdownIt-Anchor" href="#用锁来保护状态"></a> 用锁来保护状态</h3>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们成状态变量是由这个锁保护的。</p>
<p>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。</p>
<p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。</p>
<h3 id="活跃性与性能"><a class="markdownIt-Anchor" href="#活跃性与性能"></a> 活跃性与性能</h3>
<p>当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络 I/O 或控制台 I/O），一定不要持有锁。</p>
<h1 id="对象的共享"><a class="markdownIt-Anchor" href="#对象的共享"></a> 对象的共享</h1>
<h2 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h2>
<p>同步代码块和同步方法不仅可以确保以原子的方式执行操作，同步还有另一个重要的方面：内存可见性（Memory Visibility）。我们不仅希望防治某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一个意想不到的调整，这种现象被称为“重排序（Reordering）”，在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p>
<h3 id="失效数据"><a class="markdownIt-Anchor" href="#失效数据"></a> 失效数据</h3>
<p>在缺乏同步的程序中可能产生错误结果的一种情况：失效数据。</p>
<h3 id="非原子的-64-位操作"><a class="markdownIt-Anchor" href="#非原子的-64-位操作"></a> 非原子的 64 位操作</h3>
<p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前的某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性（out-of-thin-air-safety）。</p>
<p>最低安全性适用于绝大多数变量，但是存在一个例外：非 volatile 类型的 64 位数值变量（double 和 long）。</p>
<p>Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非 volatile 类型的 long 和 double 变量， JVM 允许将 64 位的读操作或写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。</p>
<h3 id="加锁及可见性"><a class="markdownIt-Anchor" href="#加锁及可见性"></a> 加锁及可见性</h3>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
<h3 id="volatile-变量"><a class="markdownIt-Anchor" href="#volatile-变量"></a> Volatile 变量</h3>
<p>Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</p>
<p><strong>加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。</strong></p>
<p>当且仅当满足以下所有条件时，才应该使用 volatile 变量：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量不会与其它状态变量一起纳入不变性条件中。</li>
<li>在访问变量时不需要加锁。</li>
</ul>
<h2 id="发布与逸出"><a class="markdownIt-Anchor" href="#发布与逸出"></a> 发布与逸出</h2>
<p>“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。当某个不应该发布的对象被发布时，这种情况被称为逸出（Escape）。</p>
<ul>
<li>发布对象最简单的方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看到该对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knowSecrets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    knowSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发布对象还会发布其非私有字段引用的任何对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span> ...&#125;;</span><br><span class="line">    <span class="keyword">public</span> String[] getStates() &#123; <span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 getStates 方法发布对象，会导致任何对象都可以修改这个数组的内容。</p>
<ul>
<li>最后一种发布对象或其内部状态的机制就是发布一个内部的类实例。如 <code>ThisEscape</code> 所示，当 <code>ThisEscape</code> 发布 <code>EventListener</code> 时，也隐含地发布了 <code>ThisEscape</code> 实例本身，因为在这个内部类的实例中包含了对 <code>ThisEscape</code> 实例的隐含调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        source.registerListener( <span class="keyword">new</span> ThisEscape.EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123; doSomething(e); &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>安全的对象构造过程</strong></p>
<p>在 ThisEscape 中给出了逸出的一种特殊示例，即 this 引用在构造函数中逸出。当且仅当对象的构造函数返回时，对象才处于可预测和一致的状态。如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确构造。</p>
<p>不要在构造函数中使 this 引用逸出。</p>
<p>如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>&#123; doSomething(e); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span> </span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程封闭"><a class="markdownIt-Anchor" href="#线程封闭"></a> 线程封闭</h2>
<p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（<code>Thread confinement</code>）。它是实现线程安全性的最简单方式之一。</p>
<p>线程封闭技术最常见的应用是 JDBC 的 <code>Connection</code> 对象。由于大多数请求都是由单个线程采用同步的方式来处理，并且在 Connection 对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将 Connection 对象封闭在线程中。</p>
<p>Java 语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和 ThreadLocal 类，但程序员仍然需要确保封闭在线程中的对象不会从线程中逸出。</p>
<h3 id="栈封闭"><a class="markdownIt-Anchor" href="#栈封闭"></a> 栈封闭</h3>
<p>栈封闭是线程封闭的一种特例。在栈封闭中，只能通过变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中；它们位于执行线程的栈中，其他线程无法访问这个栈。</p>
<h3 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h3>
<p>维持线程封闭性的一种更规范方法是使用 <code>ThreadLocal</code>，这个类能使线程中的某个值与线程关联起来。 <code>ThreadLocal</code> 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。</p>
<h3 id="不变性"><a class="markdownIt-Anchor" href="#不变性"></a> 不变性</h3>
<p>满足同步需求的另一种方法是使用不可变对象（Immutable Object）。如果某个对象在被创建后其状态就不能被修改，那么这个对象就被称为不可变对象。</p>
<p>不可变对象一定是线程安全的。</p>
<p>当满足以下条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态就不能修改</li>
<li>对象的所有域都是 final 类型（或最终 final）</li>
<li>对象是正确创建的（在对象的创建期间，this 引用没有逸出）</li>
</ul>
<p>保存在不可变对象中的程序状态仍然可以更新，即通过将一个保存新状态的实例来“替换”原有的不可变对象。</p>
<h3 id="final-域"><a class="markdownIt-Anchor" href="#final-域"></a> Final 域</h3>
<p>final 用于构造不可变性对象。final 类型的域是不能修改的。</p>
<blockquote>
<p>如果 final 引用的是对象，则指引用不可变，对象的堆数据可以被修改；在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，具体指类加载后准备阶段，如果没有 final，会先为<strong>类成员变量设置初始值-零值</strong>，编译器发现有 final 时类变量将被直接赋值。</p>
</blockquote>
<p>正如“除非需要更高的可见性，否则应该将所有的域都声明为私有域”是一个良好的编程习惯。“除非需要某个域是可变的，否则应将其声明为 final 域”也是一个良好的编程习惯。</p>
<h3 id="安全发布"><a class="markdownIt-Anchor" href="#安全发布"></a> 安全发布</h3>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
<p>这种保证还将延伸到被正确创建对象中所有 final 类型的域。在没有额外同步的情况下，也可以安全地访问 final 类型的域。然而，如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。</p>
<p>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中</li>
<li>将对象的引用保存到某个正确构造对象的 final 类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ul>
<p>在线程安全容器内部的同步意味着，将对象放入到某个容器，例如 Vector 或 synchronizedList 时，将满足上述最后一条需求。</p>
<p>通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>静态初始化器由 JVM 在类的初始化阶段执行。由于在 JVM 内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。</p>
<h4 id="事实不可变对象"><a class="markdownIt-Anchor" href="#事实不可变对象"></a> 事实不可变对象</h4>
<p>如果对象从技术来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为“事实不可变对象（Effectively Immutable Object）”。</p>
<p>在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。</p>
<p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p>
<ul>
<li><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li><strong>只读共享</strong>。在没有额外的同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需用进一步的同步。</li>
<li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Lock</tag>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork/Join 框架入门</title>
    <url>/concurrency/ForkJoin-%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>fork/join 框架在 Java 7 中呈现。它提供了一些工具，通过尝试使用所有可用的处理器内核来帮助加速并行处理 - 这是通过分而治之的方法实现的——分治算法。</p>
<p><strong>Java 8 的并行流背后使用的基础架构就是该框架。</strong></p>
<p>在实践中，这意味着框架首先“fork(分叉)”，递归地将任务分解为较小的独立子任务，直到它们足够简单以便异步执行。</p>
<p>之后，“join(并入)”部分开始，其中所有子任务的结果递归地连接成单个结果，或者在返回 void 的任务的情况下，程序只是等待直到执行每个子任务。</p>
<p>为了提供有效的并行执行，fork/join 框架使用一个名为 <code>ForkJoinPool</code> 的线程池，它管理 <code>ForkJoinWorkerThread</code> 类型的工作线程。</p>
<a id="more"></a>
<h2 id="forkjoinpool"><a class="markdownIt-Anchor" href="#forkjoinpool"></a> ForkJoinPool</h2>
<p>ForkJoinPool 是框架的核心。它是 <code>ExecutorService</code> 的一个实现，它管理工作线程并为我们提供工具来获取有关线程池状态和性能的信息。</p>
<p>工作线程当时只能执行一个任务，但 ForkJoinPool 不会为每个子任务创建单独的线程。相反，池中的每个线程都有自己的双端队列（或deque），用于存储任务。</p>
<p>这种架构对于在<strong>工作窃取算法</strong>的帮助下平衡线程的工作负载至关重要。</p>
<h3 id="工作窃取算法"><a class="markdownIt-Anchor" href="#工作窃取算法"></a> 工作窃取算法</h3>
<p><strong>简单地说 - 空闲线程试图从繁忙线程的双端队列中“窃取”工作。</strong></p>
<p>默认情况下，工作线程从其自己的双端队列头部获取任务。当它为空时，线程从另一个忙线程的双端队列尾部或全局入口队列中获取任务。</p>
<p>这种方法最大限度地减少了线程竞争任务的可能性。它还减少了线程必须寻找工作的次数，因为它首先在最大可用工作块上工作。</p>
<h3 id="forkjoinpool-实例化"><a class="markdownIt-Anchor" href="#forkjoinpool-实例化"></a> ForkJoinPool 实例化</h3>
<p>在 Java 8 中，访问 ForkJoinPool 实例的最方便方法是使用其静态方法commonPool()。顾名思义，这将提供对公共池的引用，公共池是每个 ForkJoinTask 的默认线程池。</p>
<p>根据 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html">Oracle 文档</a>，使用预定义的公共池可以减少资源消耗，因为这会阻止为每个任务创建单独的线程池。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool commonPool = ForkJoinPool.commonPool();</span><br></pre></td></tr></table></figure>
<p>通过创建 ForkJoinPool 并将其分配给工具类的公共静态字段，可以在 Java 7 中实现相同的行为：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br></pre></td></tr></table></figure>
<p>然后，可以很容易的访问：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinPool forkJoinPool = PoolUtil.forkJoinPool;</span><br></pre></td></tr></table></figure>
<p>使用 ForkJoinPool 的构造函数，可以创建具有特定级别的并行性，线程工厂和异常处理程序的自定义线程池。默认使用当前可用的处理器核心。</p>
<h2 id="forkjointaskv"><a class="markdownIt-Anchor" href="#forkjointaskv"></a> ForkJoinTask<V></h2>
<p>ForkJoinTask 是 ForkJoinPool 中执行的任务的基本类型。在实践中，应扩展其两个子类中的一个：</p>
<ul>
<li>void 任务的 RecursiveAction</li>
<li>返回值的任务的 RecursiveTask <V>。</li>
</ul>
<p>它们都有一个抽象方法 compute()，该方法定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便拆分时，生成单个子任务结果的逻辑。该方法的实现类似于下面的伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (任务足够小或不可分) &#123;</span><br><span class="line">    顺序计算该任务</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有确切的标准决定一个任务是否应该再拆分。递归的任务拆分过程如图所示：</p>
<p><img src="../../images/stream/fork-join.jpg" alt="fork join" /></p>
<h3 id="recursiveaction-例子"><a class="markdownIt-Anchor" href="#recursiveaction-例子"></a> RecursiveAction – 例子</h3>
<p>为了演示框架的分支行为，如果使用 createSubtask() 方法，<strong>workload.length() 大于指定的阈值，则该示例将分割任务。</strong></p>
<p>String 被递归地划分为子串，创建基于这些子串的 CustomRecursiveTask 实例。</p>
<p>因此，该方法返回 List <CustomRecursiveAction>。 该列表使用 invokeAll() 方法提交给 ForkJoinPool：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRecursiveAction</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String workload = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = </span><br><span class="line">      Logger.getAnonymousLogger();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomRecursiveAction</span><span class="params">(String workload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workload = workload;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (workload.length() &gt; THRESHOLD) &#123;</span><br><span class="line">            ForkJoinTask.invokeAll(createSubtasks());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           processing(workload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;CustomRecursiveAction&gt; <span class="title">createSubtasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CustomRecursiveAction&gt; subtasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        String partOne = workload.substring(<span class="number">0</span>, workload.length() / <span class="number">2</span>);</span><br><span class="line">        String partTwo = workload.substring(workload.length() / <span class="number">2</span>, workload.length());</span><br><span class="line"> </span><br><span class="line">        subtasks.add(<span class="keyword">new</span> CustomRecursiveAction(partOne));</span><br><span class="line">        subtasks.add(<span class="keyword">new</span> CustomRecursiveAction(partTwo));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> subtasks;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processing</span><span class="params">(String work)</span> </span>&#123;</span><br><span class="line">        String result = work.toUpperCase();</span><br><span class="line">        logger.info(<span class="string">&quot;This result - (&quot;</span> + result + <span class="string">&quot;) - was processed by &quot;</span></span><br><span class="line">          + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此模式可用于开发自己的 RecursiveAction 类。要执行此操作，请创建一个表示工作总量的对象，选择合适的阈值，定义分割工作的方法，并定义执行工作的方法。</p>
<h3 id="recursivetaskv"><a class="markdownIt-Anchor" href="#recursivetaskv"></a> RecursiveTask<V></h3>
<p>对于返回值的任务，此处的逻辑类似，除了每个子任务的结果在一个结果中合并：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomRecursiveTask</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">return</span> ForkJoinTask.invokeAll(createSubtasks())</span><br><span class="line">              .stream()</span><br><span class="line">              .mapToInt(ForkJoinTask::join)</span><br><span class="line">              .sum();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> processing(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Collection&lt;CustomRecursiveTask&gt; <span class="title">createSubtasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CustomRecursiveTask&gt; dividedTasks = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> CustomRecursiveTask(</span><br><span class="line">          Arrays.copyOfRange(arr, <span class="number">0</span>, arr.length / <span class="number">2</span>)));</span><br><span class="line">        dividedTasks.add(<span class="keyword">new</span> CustomRecursiveTask(</span><br><span class="line">          Arrays.copyOfRange(arr, arr.length / <span class="number">2</span>, arr.length)));</span><br><span class="line">        <span class="keyword">return</span> dividedTasks;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">processing</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(arr)</span><br><span class="line">          .filter(a -&gt; a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">27</span>)</span><br><span class="line">          .map(a -&gt; a * <span class="number">10</span>)</span><br><span class="line">          .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，工作由存储在 CustomRecursiveTask 类的 arr 字段中的数组表示。createSubtask() 方法递归地将任务划分为较小的工作，直到每个部分小于阈值。然后，invokeAll() 方法将子任务提交给公共拉取并返回 Future 列表。</p>
<p>要触发执行，为每个子任务调用 join() 方法。</p>
<p>在这个例子中，这是使用 Java 8 的 Stream API 完成的; sum() 方法用于将子结果组合到最终结果中。</p>
<h2 id="将任务提交到-forkjoinpool"><a class="markdownIt-Anchor" href="#将任务提交到-forkjoinpool"></a> 将任务提交到 ForkJoinPool</h2>
<p>要将任务提交到线程池，只有很少的方法可以使用。 submit() 或 execute() 方法（它们的用例是相同的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">forkJoinPool.execute(customRecursiveTask);</span><br><span class="line"><span class="keyword">int</span> result = customRecursiveTask.join();</span><br></pre></td></tr></table></figure>
<p>invoke() 方法分叉任务并等待结果，不需要任何手动加入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> result = forkJoinPool.invoke(customRecursiveTask);</span><br></pre></td></tr></table></figure>
<p>invokeAll() 方法是将 ForkJoinTasks 序列提交给 ForkJoinPool 的最方便的方法。 它将任务作为参数（两个任务，var args 或集合），forks 它们按照生成它们的顺序返回 Future 对象的集合。</p>
<p>或者，您可以使用单独的 <code>fork()</code> 和 <code>join()</code> 方法。 fork() 方法将任务提交给池，但它不会触发它的执行。 join() 方法用于此目的。在 RecursiveAction 的情况下，join() 只返回 null；对于 RecursiveTask <V>，它返回任务执行的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customRecursiveTaskFirst.fork();</span><br><span class="line">result = customRecursiveTaskLast.join();</span><br></pre></td></tr></table></figure>
<p>在我们的 RecursiveTask <V> 示例中，我们使用 invokeAll() 方法向池提交一系列子任务。使用 fork() 和 join() 可以完成相同的工作，但这会对结果的排序产生影响。</p>
<p>为避免混淆，使用 invokeAll() 方法向 ForkJoinPool 提交多个任务通常是个好主意。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>使用 fork/join 框架可以加速处理大型任务，但要实现这一结果，应遵循一些指导原则：</p>
<ul>
<li><strong>使用尽可能少的线程池</strong> - 在大多数情况下，最好的决定是为每个应用程序或系统使用一个线程池</li>
<li><strong>请使用默认的公共线程池</strong> - 如果不需要特定调整</li>
<li><strong>使用合理的阈值</strong>将 ForkJoingTask 拆分为子任务</li>
<li><strong>避免在 ForkJoingTasks 中出现任何阻塞</strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Parallel</tag>
        <tag>Fork/Join</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 与 Hibernate 命名策略</title>
    <url>/persistence/JPA-%E4%B8%8E-Hibernate-%E5%91%BD%E5%90%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>hibernate 默认的命名策略是不会将驼峰式命名 (<code>cameCase</code>) 映射到蛇形命名 (<code>snake_case</code>) 上去的，<br />
虽然可以直接在 <code>@Column</code> 上指定需要映射的 <code>name</code>，但是使用策略一致地应用命名更方便些。</p>
<p>从 Hibernate 5 开始，数据库对象命名策略由 <code>PhysicalNamingStrategy</code> 接口表示，我们可以自定义该接口以自动将数据库标识符从 cameCase 转换为 snake_case。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CamelCaseToSnakeCaseNamingStrategy</span> </span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">PhysicalNamingStrategyStandardImpl</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CamelCaseToSnakeCaseNamingStrategy INSTANCE = </span><br><span class="line">        <span class="keyword">new</span> CamelCaseToSnakeCaseNamingStrategy();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CAMEL_CASE_REGEX = <span class="string">&quot;([a-z]+)([A-Z]+)&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SNAKE_CASE_PATTERN = <span class="string">&quot;$1\\_$2&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Identifier <span class="title">toPhysicalCatalogName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Identifier name, </span></span></span><br><span class="line"><span class="function"><span class="params">            JdbcEnvironment context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="keyword">super</span>.toPhysicalCatalogName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Identifier <span class="title">toPhysicalSchemaName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Identifier name, </span></span></span><br><span class="line"><span class="function"><span class="params">            JdbcEnvironment context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="keyword">super</span>.toPhysicalSchemaName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Identifier <span class="title">toPhysicalTableName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Identifier name, </span></span></span><br><span class="line"><span class="function"><span class="params">            JdbcEnvironment context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="keyword">super</span>.toPhysicalTableName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Identifier <span class="title">toPhysicalSequenceName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Identifier name, </span></span></span><br><span class="line"><span class="function"><span class="params">            JdbcEnvironment context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="keyword">super</span>.toPhysicalSequenceName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Identifier <span class="title">toPhysicalColumnName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Identifier name, </span></span></span><br><span class="line"><span class="function"><span class="params">            JdbcEnvironment context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> formatIdentifier(</span><br><span class="line">            <span class="keyword">super</span>.toPhysicalColumnName(name, context)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Identifier <span class="title">formatIdentifier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Identifier identifier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (identifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String name = identifier.getText();</span><br><span class="line"> </span><br><span class="line">        String formattedName = name</span><br><span class="line">        .replaceAll(</span><br><span class="line">            CAMEL_CASE_REGEX, </span><br><span class="line">            SNAKE_CASE_PATTERN)</span><br><span class="line">        .toLowerCase();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> !formattedName.equals(name) ?</span><br><span class="line">                    Identifier.toIdentifier(</span><br><span class="line">                        formattedName, </span><br><span class="line">                        identifier.isQuoted()</span><br><span class="line">                    ) :</span><br><span class="line">                    identifier;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你引用了 <code>hibernate-types</code>，则不需要该自定义策略：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.vladmihalcea<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-types-52<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-types.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要使用自定义的策略类，只需要将该类配置给 <code>hibernate.physical_naming_strategy</code> 属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.physical_naming_strategy&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">value</span>=<span class="string">&quot;com.vladmihalcea.hibernate.type.util.CamelCaseToSnakeCaseNamingStrategy&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 Spring Data JPA 中该策略的默认配置为：<br />
<code>org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</code></p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否驼峰，根据 aBa 类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUnderscoreRequired</span><span class="params">(<span class="keyword">char</span> before, <span class="keyword">char</span> current, <span class="keyword">char</span> after)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Character.isLowerCase(before) &amp;&amp; Character.isUpperCase(current)</span><br><span class="line">            &amp;&amp; Character.isLowerCase(after);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Identifier <span class="title">apply</span><span class="params">(Identifier name, JdbcEnvironment jdbcEnvironment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(name.getText().replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;_&#x27;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; builder.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUnderscoreRequired(builder.charAt(i - <span class="number">1</span>), builder.charAt(i),</span><br><span class="line">                builder.charAt(i + <span class="number">1</span>))) &#123;</span><br><span class="line">            builder.insert(i++, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getIdentifier(builder.toString(), name.isQuoted(), jdbcEnvironment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐式命名策略 (<code>ImplicitNamingStrategy</code>) 在缺省时提供相应的命名处理：</p>
<ul>
<li>实体主表： <code>@Table</code></li>
<li>连表： <code>@JoinTable</code></li>
<li>集合表： <code>@CollectionTable</code></li>
<li>列命名： <code>@Column</code></li>
</ul>
<p>Spring Data JPA 模式隐式命名策略为：<br />
<code>org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy</code></p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 JPA 和 Hibernate 映射 @OneToMany 关系的最好方式</title>
    <url>/persistence/%E4%BD%BF%E7%94%A8-JPA-%E5%92%8C-Hibernate-%E5%A4%84%E7%90%86-OneToMany-%E6%98%A0%E5%B0%84%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/</url>
    <content><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<p>在关系数据库系统中，通过外键列来链接两个表之间的一对多关联，以便子表记录引用父表的主键。</p>
<p><img src="../../images/jpa/many-to-one.png" alt="Many To One" /></p>
<p>尽管在关系型数据库管理系统（RDBMS）中可能很简单，但在涉及 JPA 时，一对多数据库关联可以通过 <code>@ManyToOne</code> 或 <code>@OneToMany</code> 关联来表示，因为面向对象编程（OOP）的关联可以是单向的，也可以是双向的。</p>
<a id="more"></a>
<p><code>@ManyToOne</code> 注解允许您在子实体映射中映射外键列，以便子实体具有对其父实体的实体对象引用。这是映射数据库一对多数据库关联的最自然方式，通常也是最有效的替代方法。</p>
<p>为方便起见，为了利用实体状态转换和脏检查机制，许多开发人员选择将子实体映射为父对象中的集合，为此，JPA 提供 <code>@OneToMany</code> 注解。</p>
<p>很多时候，最好用查询替换集合，这在查询性能方面要灵活得多。但是，有时候映射集合是正确的事情，然后你有两个选择：</p>
<ul>
<li>单向 <code>@OneToMany</code> 关联</li>
<li>双向 <code>@OneToMany</code> 关联</li>
</ul>
<p>双向关联要求子实体映射提供 <code>@ManyToOne</code> 注解，该注解<a target="_blank" rel="noopener" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-and-hibernate-cascade-types/">负责控制关联</a>。</p>
<p>另一方面，单向 <code>@OneToMany</code> 关联更简单，因为它只是在父端定义关系。在本文中，我将解释 <code>@OneToMany</code> 关联的问题，以及如何克服它们。</p>
<p>映射 <code>@OneToMany</code> 关联的方法有很多种。我们可以使用List或Set。 我们也可以定义@JoinColumn注释。 那么，让我们看看所有这些是如何工作的。</p>
<h2 id="单向-onetomany"><a class="markdownIt-Anchor" href="#单向-onetomany"></a> 单向 <code>@OneToMany</code></h2>
<p>考虑我们有以下映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Post&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">        cascade = CascadeType.ALL, </span></span><br><span class="line"><span class="meta">        orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;PostComment&gt; comments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Entity(name = &quot;PostComment&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post_comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostComment</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String review;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果我们持久化1个 Post 和3个 PostComment：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Post post = <span class="keyword">new</span> Post(<span class="string">&quot;First post&quot;</span>);</span><br><span class="line"> </span><br><span class="line">post.getComments().add(</span><br><span class="line">    <span class="keyword">new</span> PostComment(<span class="string">&quot;My first review&quot;</span>)</span><br><span class="line">);</span><br><span class="line">post.getComments().add(</span><br><span class="line">    <span class="keyword">new</span> PostComment(<span class="string">&quot;My second review&quot;</span>)</span><br><span class="line">);</span><br><span class="line">post.getComments().add(</span><br><span class="line">    <span class="keyword">new</span> PostComment(<span class="string">&quot;My third review&quot;</span>)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">entityManager.persist(post);</span><br></pre></td></tr></table></figure>
<p>Hibernate 将执行以下 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post (title, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;First post&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My first review&#x27;</span>, <span class="number">2</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My second review&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My third review&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_post_comment (Post_id, comments_id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_post_comment (Post_id, comments_id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_post_comment (Post_id, comments_id) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>那是什么！为什么执行这么多查询？无论如何，post_post_comment 表的处理是什么？</p>
<p>默认情况下，这就是单向 <code>@OneToMany</code>  关联的工作方式，这是从数据库角度看它的样子：</p>
<p><img src="../../images/jpa/one-to-many.png" alt="One To Many" /></p>
<p>对于数据库管理员（DBA）来说，这看起来更像是多对多数据库关联而不是一对多关系，并且它也不是很有效。 我们现在有三个表，而不是两个表，所以我们使用的存储空间超过了必要的数量。本来应该只有一个外键，我们现在有两个。我们最有可能将这些外键编入索引，因此我们需要两倍的内存来缓存此关联的索引。不太好！</p>
<h2 id="使用-joincolumn-的单向-onetomany"><a class="markdownIt-Anchor" href="#使用-joincolumn-的单向-onetomany"></a> 使用 <code>@JoinColumn</code> 的单向 <code>@OneToMany</code></h2>
<p>要解决上述额外的连接表问题，我们只需要添加 <code>@JoinColumn</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)</span></span><br><span class="line"><span class="meta">@JoinColumn(name = &quot;post_id&quot;)</span></span><br><span class="line"><span class="keyword">private</span> List&lt;PostComment&gt; comments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>@JoinColumn</code> 注解帮助 Hibernate（最着名的 JPA 提供者）找出 post_comment 表中一个 post_id 外键列来定义这种关联。</p>
<p>有了这个注释，当持久化三个 PostComment 实体时，我们得到以下 SQL 输出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post (title, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;First post&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My first review&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My second review&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;My third review&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id = <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id = <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id = <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> =  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>好一点，但这三个更新语句的目的是什么？</p>
<p>如果你看一下 <a target="_blank" rel="noopener" href="https://vladmihalcea.com/hibernate-facts-knowing-flush-operations-order-matters/">Hibernate flush order</a>，你会发现在处理集合元素之前执行了持久化操作。 这样，Hibernate 首先插入子记录而不使用外键，因为子实体不存储此信息。 在集合处理阶段，外键列会相应更新。</p>
<p>相同的逻辑适用于集合状态修改，因此从子集合中删除第一项时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">post.getComments().remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>Hibernate 执行两个语句而不是一个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> post_comment <span class="keyword">set</span> post_id = <span class="literal">null</span> <span class="keyword">where</span> post_id = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">id</span> = <span class="number">2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> post_comment <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样，首先执行父实体状态更改，这将触发子实体更新。之后，当处理集​​合时，orphan removal 操作将执行子行删除语句。</p>
<h2 id="双向-onetomany"><a class="markdownIt-Anchor" href="#双向-onetomany"></a> 双向 <code>@OneToMany</code></h2>
<p>映射 <code>@OneToMany</code> 关联的最佳方法是依赖 <code>@ManyToOne</code> 端传播所有实体状态更改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Post&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Post</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">        mappedBy = &quot;post&quot;, </span></span><br><span class="line"><span class="meta">        cascade = CascadeType.ALL, </span></span><br><span class="line"><span class="meta">        orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;PostComment&gt; comments = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addComment</span><span class="params">(PostComment comment)</span> </span>&#123;</span><br><span class="line">        comments.add(comment);</span><br><span class="line">        comment.setPost(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeComment</span><span class="params">(PostComment comment)</span> </span>&#123;</span><br><span class="line">        comments.remove(comment);</span><br><span class="line">        comment.setPost(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Entity(name = &quot;PostComment&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post_comment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostComment</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String review;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;post_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Post post;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Constructors, getters and setters removed for brevity</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> PostComment )) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> &amp;&amp; id.equals(((PostComment) o).id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于上述映射有几点需要注意：</p>
<ul>
<li><code>@ManyToOne</code> 关联使用 <code>FetchType.LAZY</code>，否则，我们将使用 <code>EAGER</code> 提取，<a target="_blank" rel="noopener" href="https://vladmihalcea.com/eager-fetching-is-a-code-smell/">这对性能有害</a>。</li>
<li>父实体 Post 有两个实用方法（例如 addComment 和 removeComment），用于同步双向关联的两端。 无论何时使用双向关联，都应始终提供这些方法，否则，您将面临<a target="_blank" rel="noopener" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-and-hibernate-cascade-types/">非常微妙的状态传播问题</a>。</li>
<li>子实体 PostComment 实现了 equals 和 hashCode 方法。 由于我们不能依赖自然标识符进行相等性检查，因此我们需要使用实体标识符。但是，您需要正确执行此操作，以使所有实体状态转换中的相等性保持一致。因为我们依赖于 removeComment 的相等性，所以在双向关联中覆盖子实体的 equals 和 hashCode 是一种好习惯。</li>
</ul>
<p>如果我们持久化3个 PostComment:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Post post = new Post(&quot;First post&quot;);</span><br><span class="line"> </span><br><span class="line">post.addComment(</span><br><span class="line">    new PostComment(&quot;My first review&quot;)</span><br><span class="line">);</span><br><span class="line">post.addComment(</span><br><span class="line">    new PostComment(&quot;My second review&quot;)</span><br><span class="line">);</span><br><span class="line">post.addComment(</span><br><span class="line">    new PostComment(&quot;My third review&quot;)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">entityManager.persist(post);</span><br></pre></td></tr></table></figure>
<p>Hibernate 为每个持久化的 PostComment 实体生成一个 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post (title, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;First post&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (post_id, review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;My first review&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (post_id, review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;My second review&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> post_comment (post_id, review, <span class="keyword">id</span>) </span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;My third review&#x27;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们移除一个 PostComment:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Post post = entityManager.find( Post.class, <span class="number">1L</span> );</span><br><span class="line">PostComment comment1 = post.getComments().get( <span class="number">0</span> );</span><br><span class="line"> </span><br><span class="line">post.removeComment(comment1);</span><br></pre></td></tr></table></figure>
<p>只有一个删除 SQL 语句被执行:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> post_comment <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>因此，双向 <code>@OneToMany</code> 关联是在我们真正需要在父端映射一对多关系集合时的最佳方式。</p>
<h2 id="只有-manytoone"><a class="markdownIt-Anchor" href="#只有-manytoone"></a> 只有 <code>@ManyToOne</code></h2>
<p>虽然你可以有选择的使用 <code>@OneToMany</code> 注解，但这并不意味着它应该是每个一对多数据库关系的默认选项。 集合的问题在于，当子记录的数量相当有限时，我们才使用它们。</p>
<blockquote>
<p>因此，实际上，<code>@OneToMany</code> 只有当 Many(多) 意味着 Few(一些) 时才是实用的。也许 <code>@OneToFew</code><br />
会成为这个注解的更具启发性的名称。</p>
</blockquote>
<p>正如我在此 <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/26328187/is-it-possible-to-limit-the-size-of-a-onetomany-collection-with-hibernate-or-jp/26329733#26329733">StackOverflow回答</a> 中所解释的那样，您无法限制 `@OneToMany 集合的大小，就像您使用查询级别分页一样。</p>
<p>因此，大多数情况下，子项上的 <code>@ManyToOne</code> 注解就是您需要的一切。 但是，如何获得与 Post 实体关联的子实体？</p>
<p>好吧，你只需要一个JPQL查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List&lt;PostComment&gt; comments = entityManager.createQuery(</span><br><span class="line">    &quot;<span class="keyword">select</span> pc <span class="string">&quot; +</span></span><br><span class="line"><span class="string">    &quot;</span><span class="keyword">from</span> PostComment pc <span class="string">&quot; +</span></span><br><span class="line"><span class="string">    &quot;</span><span class="keyword">where</span> pc.post.id = :postId<span class="string">&quot;, PostComment.class)</span></span><br><span class="line"><span class="string">.setParameter( &quot;</span>postId<span class="string">&quot;, 1L )</span></span><br><span class="line"><span class="string">.getResultList();</span></span><br></pre></td></tr></table></figure>
<p>这会转换为简单的 SQL 查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pc.id <span class="keyword">AS</span> id1_1_,</span><br><span class="line">       pc.post_id <span class="keyword">AS</span> post_id3_1_,</span><br><span class="line">       pc.review <span class="keyword">AS</span> review2_1_</span><br><span class="line"><span class="keyword">from</span>   post_comment pc</span><br><span class="line"><span class="keyword">where</span>  pc.post_id = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>即使不再管理集合，在必要时添加/删除子实体也相当简单。 至于更新子对象，即使您不使用托管集合，脏检查机制也可以正常工作。 使用查询的好处在于，您可以按照自己喜欢的方式对其进行分页，这样，如果子实体的数量随时间增长，则应用程序性能不会受到影响。</p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>正如您将在以后的文章中看到的那样，双向集合比单向集合更好，因为它们依赖于 <code>@ManyToOne</code> 关联，它在生成的 SQL 语句方面始终是高效的。</p>
<p>但是，即使它们非常方便，您也不必总是使用集合。 <code>@ManyToOne</code> 关联是映射一对多数据库关系的最自然且最有效的方式。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://vladmihalcea.com/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/"><em>原文链接</em></a></p>
</blockquote>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么需要使用 ResultTransformer 自定义结果集映射</title>
    <url>/persistence/%E4%BD%BF%E7%94%A8-ResultTransformer-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%9C%E9%9B%86%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>JPA 查询允许您获取实体或 <a target="_blank" rel="noopener" href="https://zeral.top/%E4%BD%BF%E7%94%A8-JPA-%E5%92%8C-Hibernate-%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-DTO-%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/">DTO 投影</a>。但是，有时需要一个组合的结果集。</p>
<h2 id="实体模型"><a class="markdownIt-Anchor" href="#实体模型"></a> 实体模型</h2>
<p>假设我们有下面两个实体：</p>
<p><img src="../../images/jpa/personcountry.png" alt="Person Country" /><br />
这两个实体没有通过 <code>@ManyToOne</code> 进行关联。但是，两个实体共享一个 locale 属性，我们可以使用它来在两者之间形成连接。</p>
<a id="more"></a>
<h2 id="在-dto-投影中返回实体"><a class="markdownIt-Anchor" href="#在-dto-投影中返回实体"></a> 在 DTO 投影中返回实体</h2>
<p>考虑我们将做下面的 DTO 的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonAndCountryDTO</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Person person;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String country;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonAndCountryDTO</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Person person, </span></span></span><br><span class="line"><span class="function"><span class="params">        String country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 JPQL 查询大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PersonAndCountryDTO&gt; personAndAddressDTOs = entityManager.createQuery(</span><br><span class="line">    <span class="string">&quot;select new &quot;</span> +</span><br><span class="line">    <span class="string">&quot;   com.vladmihalcea.book.hpjp.hibernate.query.dto.PersonAndCountryDTO(&quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       c.name&quot;</span> +</span><br><span class="line">    <span class="string">&quot;   ) &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Person p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;join Country c on p.locale = c.locale &quot;</span> +</span><br><span class="line">    <span class="string">&quot;order by p.id&quot;</span>, PersonAndCountryDTO.class)</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<p>hibernate 生成的 sql 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> col_0_0_,</span><br><span class="line">       c.name <span class="keyword">AS</span> col_1_0_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">       Country c </span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">       ( p.locale = c.locale )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">       p.id</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> id1_1_0_,</span><br><span class="line">       p.locale <span class="keyword">AS</span> locale2_1_0_,</span><br><span class="line">       p.name <span class="keyword">AS</span> name3_1_0_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">WHERE</span>  p.id = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> id1_1_0_,</span><br><span class="line">       p.locale <span class="keyword">AS</span> locale2_1_0_,</span><br><span class="line">       p.name <span class="keyword">AS</span> name3_1_0_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">WHERE</span>  p.id = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>Hibernate 5.2 实现的 DTO 投影无法在不执行辅助查询的情况下实现 <code>ResultSet</code> 中的 DTO 投影。但是，这对性能非常不利，因为它可能导致 N + 1 查询问题。</p>
<pre><code>Hibernate 6.0 新的 SQM 解析器可能会解决这个问题，
</code></pre>
<h2 id="resulttransformer"><a class="markdownIt-Anchor" href="#resulttransformer"></a> ResultTransformer</h2>
<p>但是，您不仅限于使用 JPA。 Hibernate 提供了许多在标准中没有直接定义的增强功能。其中一个增强功能是 <code>ResultTransformer</code> 机制，它允许您以任何方式自定义<code>ResultSet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PersonAndCountryDTO&gt; personAndAddressDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select p, c.name &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Person p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;join Country c on p.locale = c.locale &quot;</span> +</span><br><span class="line">    <span class="string">&quot;order by p.id&quot;</span>)</span><br><span class="line">.unwrap( org.hibernate.query.Query.class )</span><br><span class="line">.setResultTransformer( </span><br><span class="line">    <span class="keyword">new</span> ResultTransformer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">transformTuple</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Object[] tuple, </span></span></span><br><span class="line"><span class="function"><span class="params">            String[] aliases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PersonAndCountryDTO(</span><br><span class="line">                (Person) tuple[<span class="number">0</span>],</span><br><span class="line">                (String) tuple[<span class="number">1</span>]</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List <span class="title">transformList</span><span class="params">(List collection)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> collection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">)</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<p>此查询需要思考两件事：</p>
<ol>
<li><code>unwrap</code> 方法用于将 JPA <code>javax.persistence.Query</code> 转换为特定于 Hibernate 的 <code>org.hibernate.query.Query</code>，以便我们可以访问 <code>setResultTransformer</code> 方法。</li>
<li><code>ResultTransformer</code> 附带一个未遵循函数接口语法的旧定义。因此，在这个例子中我们不能使用 lambda。Hibernate 6.0 旨在克服这个问题，因此不推荐使用Hibernate ORM 5.2 <code>ResultTransformer</code>。尽管如此，还是会提供一种替代方案。</li>
</ol>
<p>运行上述 Hibernate ResultTransformer 查询时，Hibernate 会生成以下输出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.id <span class="keyword">AS</span> col_0_0_,</span><br><span class="line">       c.name <span class="keyword">AS</span> col_1_0_,</span><br><span class="line">       p.id <span class="keyword">AS</span> id1_1_,</span><br><span class="line">       p.locale <span class="keyword">AS</span> locale2_1_,</span><br><span class="line">       p.name <span class="keyword">AS</span> name3_1_</span><br><span class="line"><span class="keyword">FROM</span>   Person p</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">       Country c </span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line">       ( p.locale = c.locale )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">       p.id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ResultTransformer</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 JPA 和 Hibernate 将结果映射 DTO 的最好方式（翻译）</title>
    <url>/persistence/%E4%BD%BF%E7%94%A8-JPA-%E5%92%8C-Hibernate-%E5%B0%86%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84-DTO-%E7%9A%84%E6%9C%80%E5%A5%BD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="实体模型"><a class="markdownIt-Anchor" href="#实体模型"></a> 实体模型</h2>
<p>假设我们有以下 <code>Post</code> 实体：</p>
<p><img src="../../images/jpa/postentityfordtoprojection.png" alt="Post Domain" /><br />
如果你需要修改实体，则需要抓取整个实体；但是如果你只是对其中的几列感兴趣，则使用 DTO 会更有效。</p>
<p>如果我们只是想选择 <code>Post</code> 的 <code>id</code> 和 <code>title</code>，如果抓取整个实体会比较浪费资源，接下来我们看下 JPA 和 Hibernate 怎么实现我们的目标。</p>
<a id="more"></a>
<h2 id="使用-jpa-映射-dto"><a class="markdownIt-Anchor" href="#使用-jpa-映射-dto"></a> 使用 JPA 映射 DTO</h2>
<p>在使用 JPA 或 Hibernate 查询实体的时候，你可以通过执行 JPQL 或着 Criteria API 以及原生的 SQL 查询。</p>
<ul>
<li>
<h3 id="使用-tuple-和-jpql-映射-dto"><a class="markdownIt-Anchor" href="#使用-tuple-和-jpql-映射-dto"></a> 使用 Tuple 和 JPQL 映射 DTO</h3>
</li>
</ul>
<p>如果你不想将映射应用到 DTO，你可以使用 JPA 的 <code>Tuple</code>, 如果使用 <code>Tuple</code> 映射，你的 JPQL 查询看起来是这样的：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Tuple&gt; postDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id as id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title as title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.createdOn &gt; :fromTimestamp&quot;</span>, Tuple.class)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br><span class="line"> </span><br><span class="line">assertFalse( postDTOs.isEmpty() );</span><br><span class="line"> </span><br><span class="line">Tuple postDTO = postDTOs.get( <span class="number">0</span> );</span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="number">1L</span>, </span><br><span class="line">    postDTO.get( <span class="string">&quot;id&quot;</span> ) </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="string">&quot;High-Performance Java Persistence&quot;</span>, </span><br><span class="line">    postDTO.get( <span class="string">&quot;title&quot;</span> ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如您所见，<code>tuple</code> 是一种获取 DTO 投影的便捷方式，因为您不需要为需要支持的每种类型的投影指定 DTO 类。</p>
</blockquote>
<ul>
<li>
<h3 id="使用构造函数和-jpql-映射-dto"><a class="markdownIt-Anchor" href="#使用构造函数和-jpql-映射-dto"></a> 使用构造函数和 JPQL 映射 DTO</h3>
</li>
</ul>
<p>如果你想使用特定的类来映射 DTO，你可以使用构造函数来 New 一个你想要的参数列表的对象。</p>
<blockquote>
<p>DTO 类必须提供一个全参的构造函数来映射结果</p>
</blockquote>
<p>DTO 映射如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PostDTO</span><span class="params">(Number id, String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id.longValue();</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，使用构造函数的 JPQL 查询如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;PostDTO&gt; postDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select new &quot;</span> +</span><br><span class="line">    <span class="string">&quot;   com.vladmihalcea.book.hpjp.hibernate.query.dto.projection.jpa.PostDTO(&quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;   ) &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.createdOn &gt; :fromTimestamp&quot;</span>, PostDTO.class)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="使用-tuple-和原生-sql-查询-映射-dto"><a class="markdownIt-Anchor" href="#使用-tuple-和原生-sql-查询-映射-dto"></a> 使用 Tuple 和原生 SQL 查询 映射 DTO</h3>
</li>
</ul>
<p>从 Hibernate ORM 5.2.11开始，由于 HHH-11897 Jira 问题得到修复，您可以使用 Tuple 进行原生 SQL 查询。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;Tuple&gt; postDTOs = entityManager</span><br><span class="line">.createNativeQuery(</span><br><span class="line">    <span class="string">&quot;SELECT &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id AS id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title AS title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;FROM Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;WHERE p.created_on &gt; :fromTimestamp&quot;</span>, Tuple.class)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br><span class="line"> </span><br><span class="line">assertFalse( postDTOs.isEmpty() );</span><br><span class="line"> </span><br><span class="line">Tuple postDTO = postDTOs.get( <span class="number">0</span> );</span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="number">1L</span>, </span><br><span class="line">    ((Number) postDTO.get( <span class="string">&quot;id&quot;</span> )).longValue() </span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">assertEquals( </span><br><span class="line">    <span class="string">&quot;High-Performance Java Persistence&quot;</span>, </span><br><span class="line">    postDTO.get( <span class="string">&quot;title&quot;</span> ) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="使用-constructorresult-映射-dto"><a class="markdownIt-Anchor" href="#使用-constructorresult-映射-dto"></a> 使用 ConstructorResult 映射 DTO</h3>
</li>
</ul>
<p>对于原生的 SQl 查询，你不能使用构造函数，所以你需要使用一个命名原生查询（NamedNativeQuery）和配置一个 <code>SqlResultSetMapping</code>，这样你就可以通过构造函数或字段来填充 DTO 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedNativeQuery(</span></span><br><span class="line"><span class="meta">    name = &quot;PostDTO&quot;,</span></span><br><span class="line"><span class="meta">    query =</span></span><br><span class="line"><span class="meta">        &quot;SELECT &quot; +</span></span><br><span class="line"><span class="meta">        &quot;       p.id AS id, &quot; +</span></span><br><span class="line"><span class="meta">        &quot;       p.title AS title &quot; +</span></span><br><span class="line"><span class="meta">        &quot;FROM Post p &quot; +</span></span><br><span class="line"><span class="meta">        &quot;WHERE p.created_on &gt; :fromTimestamp&quot;,</span></span><br><span class="line"><span class="meta">    resultSetMapping = &quot;PostDTO&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@SqlResultSetMapping(</span></span><br><span class="line"><span class="meta">    name = &quot;PostDTO&quot;,</span></span><br><span class="line"><span class="meta">    classes = @ConstructorResult(</span></span><br><span class="line"><span class="meta">        targetClass = PostDTO.class,</span></span><br><span class="line"><span class="meta">        columns = &#123;</span></span><br><span class="line"><span class="meta">            @ColumnResult(name = &quot;id&quot;),</span></span><br><span class="line"><span class="meta">            @ColumnResult(name = &quot;title&quot;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<p>使用下面的代码执行 SQL 映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PostDTO&gt; postDTOs = entityManager</span><br><span class="line">.createNamedQuery(<span class="string">&quot;PostDTO&quot;</span>)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )</span><br><span class="line">        .toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<h2 id="使用-hibernate-映射-dto"><a class="markdownIt-Anchor" href="#使用-hibernate-映射-dto"></a> 使用 Hibernate 映射 DTO</h2>
<p>当然您可以将所有 JPA 特性在 Hibernate 上使用，因为 Hibernate 提供的特性比标准 Java Persistence 规范要多得多。</p>
<ul>
<li>
<h3 id="使用-resulttransformer-和-jpql-来映射-dto"><a class="markdownIt-Anchor" href="#使用-resulttransformer-和-jpql-来映射-dto"></a> 使用 ResultTransformer 和 JPQL 来映射 DTO</h3>
</li>
</ul>
<p>如前所述，<code>ResultTransformer</code> 允许您以任何方式自定义结果集，以便您可以使用它将典型的 Object [] 数组投影转换为 DTO 结果集。</p>
<p>这次，您不需要提供构造函数来匹配查询选择的实体属性。</p>
<blockquote>
<p>虽然你甚至不需要在你的DTO类中提供 setter，但是我们需要 setter，因为 id 列在数据库映射时会返回 BigInteger，而我们需要将它强制转换为 Long。</p>
<p>Hibernate 可以使用 Reflection 设置适当的字段，因此它比以前的 JPA 构造函数替代方案更灵活。</p>
</blockquote>
<p>考虑下面的 DTO 类：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostDTO</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Number id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 Hibernate 特定 <code>org.hibernate.query.Query</code> 接口的 <code>setResultTransformer</code> 方法转换结果集，该接口可以从 JPA <code>Query</code> 解析。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PostDTO&gt; postDTOs = entityManager</span><br><span class="line">.createQuery(</span><br><span class="line">    <span class="string">&quot;select &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id as id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title as title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.createdOn &gt; :fromTimestamp&quot;</span>)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ).toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.unwrap( org.hibernate.query.Query.class )</span><br><span class="line">.setResultTransformer( Transformers.aliasToBean( PostDTO.class ) )</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="使用-resulttransformer-和-原生-sql-查询映射-dto"><a class="markdownIt-Anchor" href="#使用-resulttransformer-和-原生-sql-查询映射-dto"></a> 使用 ResultTransformer 和 原生 SQL 查询映射 DTO</h3>
</li>
</ul>
<p>如果你想用原生 SQL 查询，你不需要经历声明<code>SqlResultSetMapping</code> 的所有麻烦，因为你可以使用 <code>AliasToBeanResultTransformer</code>，就像前面提到的 JPQL 示例的情况一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List postDTOs = entityManager</span><br><span class="line">.createNativeQuery(</span><br><span class="line">    <span class="string">&quot;select &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.id as id, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;       p.title as title &quot;</span> +</span><br><span class="line">    <span class="string">&quot;from Post p &quot;</span> +</span><br><span class="line">    <span class="string">&quot;where p.created_on &gt; :fromTimestamp&quot;</span>)</span><br><span class="line">.setParameter( <span class="string">&quot;fromTimestamp&quot;</span>, Timestamp.from(</span><br><span class="line">    LocalDateTime.of( <span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ).toInstant( ZoneOffset.UTC ) ))</span><br><span class="line">.unwrap( org.hibernate.query.NativeQuery.class )</span><br><span class="line">.setResultTransformer( Transformers.aliasToBean( PostDTO.class ) )</span><br><span class="line">.getResultList();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Hibernate N+1 问题</title>
    <url>/persistence/%E8%A7%A3%E5%86%B3-Hibernate-N+1-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1>
<p>作为一个例子，我将使用在线图书订购应用程序的简化版本。在这样的应用程序中，我可能会创建一个如下所示的实体来代表采购订单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String customerId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(cascade = ALL, fetch = EAGER)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;purchase_order_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;PurchaseOrderItem&gt; purchaseOrderItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>采购订单包括订单 ID，客户 ID 以及正在购买的一个或多个商品。 PurchaseOrderItem 实体可能具有以下结构 -</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseOrderItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bookId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在假设我们需要查找客户的订单以在其采购订单历史记录中显示它们。以下查询将用于此目的 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    P</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    PurchaseOrder P</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    P.customerId = :customerId</span><br></pre></td></tr></table></figure>
<p>转换为 SQL 时看起来如下所示 -</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    purchaseor0_.id <span class="keyword">as</span> id1_1_,</span><br><span class="line">    purchaseor0_.customer_id <span class="keyword">as</span> customer2_1_ </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    purchase_order purchaseor0_ </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    purchaseor0_.customer_id = ?</span><br></pre></td></tr></table></figure>
<p>这一个查询将返回客户拥有的所有采购订单。但是，为了获取订单商品，在我们遍历订单商品时，JPA 将为每个订单发出单独的查询。例如，如果客户有 5 个订单，那么 JPA 将发出 5 个额外的查询来获取这些订单中包含的订单商品。这就是 <code>N + 1</code> 问题 - 每个订单的查询导致 N 个订单商品的查询。</p>
<h1 id="抓取"><a class="markdownIt-Anchor" href="#抓取"></a> 抓取</h1>
<p>在理解问题和探索解决方法之前，我们先理解下 JPA 的抓取操作。</p>
<p>抓取本质上讲是从数据库中获取数据并将其提供给应用程序的过程。调整应用程序的抓取方式将决定应用程序如何执行，就宽度（值/列）和/或深度（结果/行）而言，获取太多数据会增加 JDBC 通信和 ResultSet 处理方面的不必要开销。抓取的数据太少可能会导致需要进行额外的抓取。调整应用程序获取数据的方式可以影响整体应用程序性能。</p>
<p>抓取的概念主要分为两个问题：</p>
<ul>
<li>什么时候数据需要被抓取？立即还是延迟？</li>
<li>数据以何种方式被抓取？</li>
</ul>
<p>hibernate 在不同的范围定义了抓取，通过 hibernate 的 <code>Fetch</code> 注解我们可以定义如何抓取数据，通过 <code>javax.persistence</code> 中 <code>@Baisc</code>、<code>@ManyToOne</code>、<code>@OneToMany</code> 等注解上的 <code>fetch</code> 属性 <code>javax.persistence.FetchType</code> 定义何时抓取数据。</p>
<p><strong><em>静态</em>（编译时）</strong></p>
<p>我们可以在定义映射时静态定义抓取策略。</p>
<ul>
<li><code>SELECT</code></li>
</ul>
<p>执行单独的 SQL 查询以加载数据。可以是 EAGER（立即发出第二个查询）或 LAZY（延迟第二个查询直到需要数据）。这就是通常所说的 N + 1 策略。</p>
<ul>
<li><code>JOIN</code></li>
</ul>
<p>通过使用 SQL 外部联接 (OUTER JOIN) 抓取要获取的数据。使用该类型时数据以 EAGER 形式加载，即使指明了 LAZY。</p>
<blockquote>
<p>当使用主键查询单个实体时，该注解正常工作。例如 Spring Data JPA 中的 findOne、findById，当使用 findAll 时，会继续使用 N+1 查询。</p>
<p>Join 查询会产生重复的结果，需要使用 Set 存储结果集等其它方式去重。</p>
</blockquote>
<ul>
<li><code>BATCH</code></li>
</ul>
<p>根据批次大小，使用 IN 限制作为 SQL WHERE 子句的一部分，执行单独的 SQL 查询以加载相关数据项。同样可以和 EAGER 或 LAZY 一起使用。</p>
<ul>
<li><code>SUBSELECT</code></li>
</ul>
<p>根据集合所有者构建单独的 SQL 查询加载关联的数据。同样可以和 EAGER 或 LAZY 一起使用。</p>
<blockquote>
<p>子查询会将所有关联的数据全部加载到内存中，例如用在 @OneToMany 上时，如果关联数据不多时可以使用。</p>
</blockquote>
<p><em><strong>动态（运行时）</strong></em></p>
<p>动态提供了更加灵活的运行时抓取策略定义方式。</p>
<ul>
<li><em>fetch profiles</em></li>
</ul>
<p>在映射中定义，但可以在会话上启用/禁用。</p>
<ul>
<li>HQL/JPQL</li>
</ul>
<p>Hibernate 和 JPA Criteria 查询都可以指定特定于该查询的抓取定义。</p>
<ul>
<li>entity graphs</li>
</ul>
<p>从 Hibernate 4.2（JPA 2.1）开始，实体图为我们提供了更加详细的抓取方案定义。</p>
<p>了解了抓取之后，我们就可以找到解决问题的方法。</p>
<h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1>
<h2 id="避免使用立即抓取eager-fetching"><a class="markdownIt-Anchor" href="#避免使用立即抓取eager-fetching"></a> 避免使用立即抓取（Eager Fetching）</h2>
<p>这是问题背后的主要原因。我们应该从我们的映射中摆脱所有立即抓取。它们几乎没有任何好处可以证明它们在生产级应用中的使用。我们应该将所有关系标记为懒惰。</p>
<h2 id="只抓取你真实需要的数据"><a class="markdownIt-Anchor" href="#只抓取你真实需要的数据"></a> 只抓取你真实需要的数据</h2>
<p>有时候我们并不想在查询订单时关联出所有的订单记录，我们可以将订单记录设为懒加载，在自己真实需要时再去查询对应的数据。</p>
<h2 id="在-jpql-中使用-fetch-join"><a class="markdownIt-Anchor" href="#在-jpql-中使用-fetch-join"></a> 在 JPQL 中使用 Fetch Join</h2>
<p>初始化延迟关联的更好选择是使用带有抓取连接的 JPQL 查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Query q = <span class="keyword">this</span>.em.createQuery(<span class="string">&quot;SELECT o FROM Order o JOIN FETCH o.items i WHERE o.id = :id&quot;</span>);</span><br><span class="line">q.setParameter(<span class="string">&quot;id&quot;</span>, orderId);</span><br><span class="line">newOrder = (Order) q.getSingleResult();</span><br></pre></td></tr></table></figure>
<p>这告诉实体管理器在同一查询中加载所选实体和关系。</p>
<h2 id="使用-batchsize-批量抓取"><a class="markdownIt-Anchor" href="#使用-batchsize-批量抓取"></a> 使用 BatchSize 批量抓取</h2>
<p>批量抓取是惰性选择抓取策略的优化。假设该订单的商品条目有 25 个，当配置了 BatchSize 后，在请求订单时，查询将变为 3 条，每条语句使用 In 查询 5 个商品条目。</p>
<p>使用 <code>@BatchSize</code> 注解可以配置到懒加载的集合或对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@BatchSize(size=100)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurchaseOrderItem</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@BatchSize(size = 5)</span> /</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;PurchaseOrderItem&gt; <span class="title">purchaseOrderItems</span><span class="params">()</span> </span>= &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实体图entity-graph"><a class="markdownIt-Anchor" href="#实体图entity-graph"></a> 实体图（Entity Graph）</h2>
<p>实体图是特定化查询或操作的模板。它们在创建**抓取方案（fetch plans）**时使用。应用程序开发人员使用抓取方案将相关的持久字段组合在一起以提高运行时性能。</p>
<p>默认情况下，实体字段或属性是**懒抓取（lazy fetch）**的。开发人员将字段或属性指定为抓取方案的一部分，持久性 provider 将立即抓取（eager fetch）它们。</p>
<p>我们可以使用<strong>注解</strong>或<strong>部署描述符(比如 web.xml)<strong>静态创建实体图，也可以使用</strong>标准接口动态创建</strong>实体图。</p>
<p>实体图定义了在查找或查询操作期间需要立即抓取的字段。</p>
<p>默认，实体的所有字段都是懒抓取，除非指定了实体元数据的 <code>fetch</code> 属性为 <code>javax.persistence.FetchType.EAGER</code>。但是主键和版本字段始终是立即抓取的，不需要将其显式添加到实体图中。</p>
<p>创建的实体图可以是 <code>fetch graph(抓取图)</code> 或 <code>load graph(加载图)</code>。</p>
<h3 id="fetch-graphs抓取图"><a class="markdownIt-Anchor" href="#fetch-graphs抓取图"></a> Fetch Graphs（抓取图）</h3>
<p>当 <code>javax.persistence.fetchgraph</code> 属性用于指定实体图时，实体图的属性节点指定的属性将被视为 <code>FetchType.EAGER</code>，未指定的属性将被视为 <code>FetchType.LAZY</code>。 以下规则适用，具体取决于属性类型。</p>
<h3 id="load-graphs加载图"><a class="markdownIt-Anchor" href="#load-graphs加载图"></a> Load Graphs（加载图）</h3>
<p>当 <code>javax.persistence.loadgraph</code> 属性用于指定实体图时，实体图的属性节点指定的属性将被视为 <code>FetchType.EAGER</code>，未指定的属性将根据其指定的或默认的<code>FetchType</code> 进行处理。</p>
<h3 id="命名实体图named-entity-graph"><a class="markdownIt-Anchor" href="#命名实体图named-entity-graph"></a> 命名实体图（Named Entity Graph）</h3>
<p>命名实体图是由应用于实体类的 <code>@NamedEntityGraph</code> 注解定义的实体图，或应用程序部署描述符中的 <code>named-entity-graph</code> 元素。部署描述符中定义的命名实体图覆盖任何具有相同名称的基于注解的实体图。</p>
<p>通过使用 <code>javax.persistence.NamedAttributeNode</code> 注解在 <code>@NamedEntityGraph</code> 的 <code>attributeNodes</code> 元素中指定字段，将字段添加到实体图中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedEntityGraph(name=&quot;emailEntityGraph&quot;, attributeNodes=&#123;</span></span><br><span class="line"><span class="meta">    @NamedAttributeNode(&quot;subject&quot;),</span></span><br><span class="line"><span class="meta">    @NamedAttributeNode(&quot;sender&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailMessage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    String messageId;</span><br><span class="line">    String subject;</span><br><span class="line">    String body;</span><br><span class="line">    String sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在 <code>@NamedEntityGraphs</code> 注解中对多个 <code>@NamedEntityGraph</code> 定义进行分组，可以将多个 <code>@NamedEntityGraph</code> 定义应用于类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NamedEntityGraphs(&#123;</span></span><br><span class="line"><span class="meta">    @NamedEntityGraph(name=&quot;previewEmailEntityGraph&quot;, attributeNodes=&#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;subject&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;sender&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;body&quot;)</span></span><br><span class="line"><span class="meta">    &#125;),</span></span><br><span class="line"><span class="meta">    @NamedEntityGraph(name=&quot;fullEmailEntityGraph&quot;, attributeNodes=&#123;</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;sender&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;subject&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;body&quot;),</span></span><br><span class="line"><span class="meta">        @NamedAttributeNode(&quot;attachments&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailMessage</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>通过为命名实体图调用 <code>EntityManager.getEntityGraph</code> 来获取定义的命名实体图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph&lt;EmailMessage&gt; eg = em.getEntityGraph(<span class="string">&quot;emailEntityGraph&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="在查询操作中使用-entity-graphs"><a class="markdownIt-Anchor" href="#在查询操作中使用-entity-graphs"></a> 在查询操作中使用 Entity Graphs</h3>
<p>要为有类型和无类型查询指定实体图，请在查询对象上调用 <code>setHint</code> 方法，并指定 <code>javax.persistence.loadgraph</code> 或 <code>javax.persistence.fetchgraph</code> 作为属性名称，并将 <code>EntityGraph</code> 实例指定为值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph&lt;EmailMessage&gt; eg = em.getEntityGraph(<span class="string">&quot;previewEmailEntityGraph&quot;</span>);</span><br><span class="line">List&lt;EmailMessage&gt; messages = em.createNamedQuery(<span class="string">&quot;findAllEmailMessages&quot;</span>)</span><br><span class="line">        .setParameter(<span class="string">&quot;mailbox&quot;</span>, <span class="string">&quot;inbox&quot;</span>)</span><br><span class="line">        .setHint(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>, eg)</span><br><span class="line">        .getResultList();</span><br></pre></td></tr></table></figure>
<p>有类型的查询使用相同的技术：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph&lt;EmailMessage&gt; eg = em.getEntityGraph(<span class="string">&quot;previewEmailEntityGraph&quot;</span>);</span><br><span class="line"></span><br><span class="line">CriteriaQuery&lt;EmailMessage&gt; cq = cb.createQuery(EmailMessage.class);</span><br><span class="line">Root&lt;EmailMessage&gt; message = cq.from(EmailMessage.class);</span><br><span class="line">TypedQuery&lt;EmailMessage&gt; q = em.createQuery(cq);</span><br><span class="line">q.setHint(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>, eg);</span><br><span class="line">List&lt;EmailMessage&gt; messages = q.getResultList();</span><br></pre></td></tr></table></figure>
<h3 id="动态实体图dynamic-entity-graph"><a class="markdownIt-Anchor" href="#动态实体图dynamic-entity-graph"></a> 动态实体图（Dynamic Entity Graph）</h3>
<p>创建动态实体图可以使用：<code>EntityManager.createEntityGraph</code></p>
<p>动态实体图 类似于命名的 entity graph。唯一的区别是，entity graph 是通过 Java API 定义的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EntityGraph graph = <span class="keyword">this</span>.em.createEntityGraph(Order.class);</span><br><span class="line">Subgraph itemGraph = graph.addSubgraph(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    </span><br><span class="line">Map hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">hints.put(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>, graph);</span><br><span class="line">  </span><br><span class="line">Order order = <span class="keyword">this</span>.em.find(Order.class, orderId, hints);</span><br></pre></td></tr></table></figure>
<p>使用代码动态创建 entity graph 允许我们可以不使用实体上的注解。因此，如果您需要创建一个不会重复使用的特定于用例的图表，我建议使用动态实体图。如果要重用实体图，则更容易注释命名实体图。</p>
<h3 id="spring-data-jpa-中使用-entity-graph"><a class="markdownIt-Anchor" href="#spring-data-jpa-中使用-entity-graph"></a> Spring Data JPA 中使用 Entity Graph</h3>
<p>在 Spring Data JPA 中，我们可以通过在查询接口方法上使用注解 <code>org.springframework.data.jpa.repository.EntityGraph</code> 来定义命名实体图或动态实体图：</p>
<ul>
<li>
<p>通过指定 <code>value</code> 属性指定命名实体图</p>
</li>
<li>
<p>通过指定 <code>attributePaths</code> 属性动态定义实体图</p>
<p>该属性为数组类型，我们可以定义多个 <code>attribute</code>，也可以通过 <code>property.nestedProperty</code> 形式来定义实体对象字段嵌套的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EntityGraph(attributePaths = &#123;&quot;questions&quot;, &quot;questions.questionOptions&quot;, &quot;questions.answers&quot;&#125;)</span></span><br><span class="line">    <span class="function">Optional&lt;Questionnaire&gt; <span class="title">findOneByProject_Id</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="存在问题"><a class="markdownIt-Anchor" href="#存在问题"></a> 存在问题</h3>
<ol>
<li>
<p>从理论上讲，抓取类型为 fetch 时，只有指定的属性会被立即加载，但是在 Hibernate <code>5.4.11</code> 之前，它还会读取实体映射属性上定义的抓取时机为 Eager 的属性，<a target="_blank" rel="noopener" href="https://hibernate.atlassian.net/browse/HHH-8776">该问题（HHH-8776）</a>已被修复。对应于 <code>spring-boot-starter-data-jpa</code> 版本 <code>2.2.5.RELEASE+</code> 都可以正常使用。</p>
</li>
<li>
<p><strong>JPA 图抓取规范不适用于 Hibernate 中的 basic（<code>@Basic</code>）属性。</strong> 换句话说，默认情况下，<code>@Basic</code> 这些属性依赖于默认的提取策略。默认的提取策略为 <code>FetchType.EAGER</code>。即使未明确指定这些属性，在使用实体图抓取的情况下也会加载这些属性。<strong>除非我们开启了字节码增强功能，基本属性使用 <code>@Basic(fetch = FetchType.LAZY)</code> 才会起作用。</strong></p>
</li>
<li>
<p>Spring Data JPA 暂只支持在注解中定义抓取属性，不能运行时动态指定。我们可以借助 <a target="_blank" rel="noopener" href="https://github.com/Cosium/spring-data-jpa-entity-graph">https://github.com/Cosium/spring-data-jpa-entity-graph</a> 该库弥补这个问题，或者自己拓展一个基础仓库类。</p>
</li>
</ol>
<p>如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">		<span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate, Pageable pageable, JpaEntityGraph jpaEntityGraph)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate, JpaEntityGraph jpaEntityGraph)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">BaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(BaseRepositoryImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JpaEntityInformation&lt;T, ID&gt; entityInformation;</span><br><span class="line">    <span class="keyword">private</span> EntityPath&lt;T&gt; path;</span><br><span class="line">    <span class="keyword">private</span> Querydsl querydsl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JPAQueryFactory jpaQueryFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseRepositoryImpl</span><span class="params">(JpaEntityInformation&lt;T, ID&gt; entityInformation, EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line">        <span class="keyword">this</span>.entityInformation = entityInformation;</span><br><span class="line">        <span class="keyword">this</span>.jpaQueryFactory = <span class="keyword">new</span> JPAQueryFactory(entityManager);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.path = SimpleEntityPathResolver.INSTANCE.createPath(entityInformation.getJavaType());</span><br><span class="line">            <span class="keyword">this</span>.querydsl = <span class="keyword">new</span> Querydsl(entityManager, <span class="keyword">new</span> PathBuilder&lt;T&gt;(path.getType(), path.getMetadata()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125; 未找到 Q 生成文件，请检查代码&quot;</span>, entityInformation.getJavaType().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate, Pageable pageable, JpaEntityGraph jpaEntityGraph)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(pageable, <span class="string">&quot;Pageable must not be null!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> JPQLQuery&lt;?&gt; countQuery = createCountQuery(predicate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免内存分页，修复 HHH000104: firstResult/maxResults specified with collection fetch; applying in memory! 警告</span></span><br><span class="line">        <span class="comment">// 解决方法如该文章描述分两步查：https://vladmihalcea.com/fix-hibernate-hhh000104-entity-fetch-pagination-warning-message/</span></span><br><span class="line">        SingularAttribute&lt;? <span class="keyword">super</span> T, ?&gt; idAttribute = entityInformation.getIdAttribute();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> idAttribute != <span class="keyword">null</span>;</span><br><span class="line">        JPQLQuery&lt;T&gt; query = querydsl.applyPagination(pageable, doCreateQuery(<span class="keyword">null</span>, predicate).select(ExpressionUtils.path(getDomainClass(), path, idAttribute.getName())));</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; idList = query.fetch();</span><br><span class="line"></span><br><span class="line">        Predicate pagePredicate = ExpressionUtils.in(ExpressionUtils.path(<span class="keyword">this</span>.path.getClass(), idAttribute.getName()), idList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> PageableExecutionUtils.getPage(doCreateQuery(jpaEntityGraph, pagePredicate).select(path).fetch(), pageable, countQuery::fetchCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate, JpaEntityGraph jpaEntityGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doCreateQuery(jpaEntityGraph, predicate).select(path).fetch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@link</span> JPQLQuery&#125; count query for the given &#123;<span class="doctag">@link</span> Predicate&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> predicate, can be &#123;<span class="doctag">@literal</span> null&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the Querydsl count &#123;<span class="doctag">@link</span> JPQLQuery&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> JPQLQuery&lt;?&gt; createCountQuery(<span class="meta">@Nullable</span> Predicate... predicate) &#123;</span><br><span class="line">        <span class="keyword">return</span> doCreateQuery(<span class="keyword">null</span>, predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractJPAQuery&lt;?, ?&gt; doCreateQuery(JpaEntityGraph jpaEntityGraph, <span class="meta">@Nullable</span> Predicate... predicate) &#123;</span><br><span class="line"></span><br><span class="line">        AbstractJPAQuery&lt;?, ?&gt; query = querydsl.createQuery(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (predicate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            query = query.where(predicate);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; hints = <span class="keyword">new</span> HashMap&lt;&gt;(Jpa21Utils.tryGetFetchGraphHints(entityManager, jpaEntityGraph, entityInformation.getJavaType()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; hint : hints.entrySet()) &#123;</span><br><span class="line">            query.setHint(hint.getKey(), hint.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>N+1 Problem</tag>
        <tag>Entity Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 架构初谈</title>
    <url>/spring/Spring-MVC-%E6%9E%B6%E6%9E%84%E5%88%9D%E8%B0%88/</url>
    <content><![CDATA[<p>在学习 Spring MVC 之前，我们先快速回顾下 Spring，Spring 是 Java 企业软件开发的长期实际标准。它向我们中的许多人介绍了很多概念，例如依赖项注入，面向切面的编程（AOP）以及使用普通的 Java 对象（POJO）进行编程。</p>
<p>Spring 框架是由 Rod Johnson为《Expert One-on-One J2EE Design and Development》一书编写的代码演变而来。编写这本书是为了解释 JEE 中的一些复杂性以及如何克服它们。尽管在新的 JEE 规范中（特别是从 JEE 6 开始）已经解决了 JEE 的许多复杂性和问题，但 Spring 框架仍然非常流行。</p>
<a id="more"></a>
<p>该框架由几个模块组成（参见下图），这些模块可以协同工作并相互构建。我们可以选择我们要使用的模块。</p>
<p><img src="../../images/spring-mvc/spring-module.jpg" alt="Spring Module" /></p>
<p>大多数模块都依赖于 Spring Framework 中的某些其他模块。 核心模块是该规则的例外。下图概述了常用模块及其对其他模块的依赖性。</p>
<p><img src="../../images/spring-mvc/spring-module-dependencies.jpg" alt="Spring Module Dependencies" /></p>
<p>Spring Web MVC 是基于 Servlet API 构建的原始 Web 框架，正式名称 “ Spring Web MVC” 来自上述模块中的（spring-webmvc），但通常称为 “ Spring MVC”。</p>
<p>Spring MVC 本质上就是一个 Servlet，这里我们就不得不提一下 Servlet。</p>
<h2 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet</h2>
<p><code>Servlet</code> 是 <code>Server + Applet</code> 的缩写，表示一个服务器应用。<code>Servlet</code> 其实是一套规范，按这套规范编写的代码就可以运行在 Java Servlet 容器中，比如最常见的 <code>Tomcat</code> 容器。</p>
<p><code>Servlet</code> 的结构如图：</p>
<p><img src="../../images/spring-mvc/servlet-structure.png" alt="Servlet Structure" /></p>
<h3 id="genricservlet"><a class="markdownIt-Anchor" href="#genricservlet"></a> GenricServlet</h3>
<p><code>GenricServlet</code> 抽象类是与具体协议无关的，它是 Servlet 的默认实现，它主要做了三件事：</p>
<ol>
<li>实现了 <code>ServletConfig</code> 接口，我们可以直接调用 ServletConfig 里面的方法；</li>
<li>提供了无参的 <code>init</code> 方法；</li>
<li>提供了 <code>log</code> 方法。</li>
</ol>
<p>Servlet 容器初始化时会调用 Servlet 的 <code>init(ServletConfig)</code> 方法，该抽象类接受配置类，并调用自身空实现的无参 <code>init</code> 方法。</p>
<h3 id="httpservlet"><a class="markdownIt-Anchor" href="#httpservlet"></a> HttpServlet</h3>
<p><code>HttpServlet</code> 是用 HTTP 协议[^ HTTP 协议]实现的 Servlet 的基类，Spring MVC 的 <code>DispatcherServlet</code> 就是继承自该类。既然 HttpServlet 是跟协议相关的，当然主要关心的是如何处理请求了，所以 HttpServlet 主要重写了 <code>service</code> 方法。在 service 方法中首先将 <code>ServletRequest</code> 和 <code>ServletResponse</code> 转换为了 <code>HttpServletRequest</code>  和 <code>HttpServletResponse</code>，然后根据 Http 请求的类型不同将请求路由到了不同的处理方法。</p>
<h2 id="spring-mvc-架构"><a class="markdownIt-Anchor" href="#spring-mvc-架构"></a> Spring MVC 架构</h2>
<p>Spring MVC 中核心 Servlet 继承结构如下图所示。</p>
<p><img src="../../images/spring-mvc/DispatcherServlet.png" alt="DispatcherServlet" /></p>
<p><code>GenericServlet、HttpServlet</code> 在前面已经介绍过。</p>
<p><code>XXXAware</code> 接口在 Spring 表示对 XXX 的感知，通俗点解释就是：如果在某个类里面想要使用 Spring 的一些东西,就可以通过实现 <code>XXXAware</code> 接口告诉 Spring，Spring 看到后就会给你送过来，而接收的方式是通过实现接口唯一的方法 set-XXX。</p>
<p><code>EnvironmentCapable</code>，顾名思义，就是具有 Environment 的能力，也就是可以提供 Environment，所以 EnvironmentCapable 唯一的方法是 <code>Environment getEnvironment()</code>，用于实现 EnvironmentCapable 接口的类，就是告诉 Spring 它可以提供 Environment，当 Spring 需要 Environment 的时候就会调用其 <code>getEnvironment</code> 方法跟它要，该类封装了 <code>ServletContext</code>、<code>ServletConfig</code>、<code>JndiProperty</code>、<code>系统环境变量</code>和<code>系统属性</code>。<code>HttpServletBean</code> 抽象类在 <code>init</code> 方法中将配置参数设置到该 servlet 的 Bean 属性中。</p>
<h3 id="httpservletbean"><a class="markdownIt-Anchor" href="#httpservletbean"></a> HttpServletBean</h3>
<p>HttpServletBean 主要参与了创建工作，并没有涉及请求的处理。</p>
<p>该抽象类重写了无参 <code>init</code> 方法，在该实现中首先将 Servlet 中配置的参数使用 BeanWrapper 设置到 Dispatcherservlet 中的相关属性，然后调用模板方法 <code>initservletBean</code>，子类就通过这个方法初始化。</p>
<h3 id="frameworkservlet"><a class="markdownIt-Anchor" href="#frameworkservlet"></a> FrameworkServlet</h3>
<p><code>FrameworkServlet</code> 抽象类主要提供了与 Spring <code>ApplicationContext</code> 的集成，该类重写 <code>initservletBean</code> 并在其中初始化了 <code>WebApplicationContext</code>；</p>
<p>该类重写了除 <code>doHead</code> 外各种请求的处理方法，并将处理都交给 <code>processRequest</code> 方法具体处理，在该处理中初始化了 <code>LocaleContextHolder</code> 和 <code>RequestContextHolder</code> 持有对象，以便我们可以轻松获取区域信息和请求信息，然后调用 <code>doService</code> 方法交给子类真正处理，在请求处理完时发布 <code>ServletRequestHandledEvent</code> 事件，不管请求是成功还是失败；</p>
<p>在 ApplicationContext 初始完毕或刷新时会调用 <code>onRefresh</code> 方法，该方法由子类实现。</p>
<blockquote>
<p>在 FrameServlet 初始化 WebApplicationContext 时，会将 ServletContext 设置其中，监听 ContextRefreshedEvent 事件调用 OnRefresh 方法刷新 web 上下文。</p>
</blockquote>
<h3 id="dispatchservlet"><a class="markdownIt-Anchor" href="#dispatchservlet"></a> DispatchServlet</h3>
<p><code>Dispatcherservlet</code> 是 Spring MVC 最核心的类，整个处理过程的顶层设计都在这里面，它是 <code>FrameworkServlet</code> 的默认实现。</p>
<p>其实现的 <code>OnRefresh</code> 方法主要初始化了 Servlet 需要用到的策略对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 initStrategies 作为实现。</span></span><br><span class="line"><span class="comment"> * 分开写的好处在于职责分离，以便子类可以选择性的覆盖和重用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化这个 servlet 使用的策略对象。</span></span><br><span class="line"><span class="comment"> * 可以在子类中被覆盖，以便进一步初始化策略对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在各自的初始化方法中，都会先从 ApplicationContext 寻找相应 BeanName 的 Bean 实现类，找不到时会从 <code>DispatcherServlet</code> 相对路径的 <code>DispatcherServlet.properties</code> 配置文件中找到默认定义的实现类完全限定名称并加载。</p>
<h4 id="请求处理"><a class="markdownIt-Anchor" href="#请求处理"></a> 请求处理</h4>
<p>通过之前的分析我们知道，Dispatcherservlet 里面执行处理的人口方法应该是 <code>doService</code>, 不过 doService 并没有直接进行处理，而是交给了 <code>doDispatch</code> 进行具体的处理，在 doDispatch 处理前 doService 做了一些事情：</p>
<ul>
<li>首先判断是不是 <code>include</code> 请求，如果是则对 request 的 Attribute 做个快照备份，等 dispatch 处理完之后（如果不是异步调用且未完成）进行还原；</li>
<li>在做完快照后又对 request 设置了一些属性：<code>webApplicationContext</code>，<code>localResolver</code>，<code>themeResolver</code>，<code>themeSource</code> 等</li>
</ul>
<p><code>doDispatch</code> 方法也非常简洁，从顶层设计了整个请求处理的过程。doDispatch 中最核心的代码只要4句，它们的任务分别是：</p>
<ol>
<li>根据 <code>request</code> 从 <code>HandlerMapping</code> 中找到 <code>Handler</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerExecutionChain mappedHandler = getHandler(processedRequest);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据 <code>Handler</code> 找到对应的 <code>HandlerAdapter</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用 <code>HandlerAdapter</code> 处理 <code>Handler</code>；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>调用 <code>processDispatchResult</code> 方法处理上面处理之后的结果（包含找到 View 并渲染输出给用户）</li>
</ol>
<p>对应的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br></pre></td></tr></table></figure>
<p>doDispatch 请求的流程如下：</p>
<p><img src="../../images/spring-mvc/doDispatch.png" alt="doDispatch" /></p>
<p>这里需要解释三个概念：HandlerMapping、 Handler 和 HandlerAdapter。这三个概念的准确理解对于 Spring MVC 的学习非常重要。如果对这三个概念理解得不够透彻，将会严重影响对 Spring MVC 的理解：</p>
<h4 id="handler"><a class="markdownIt-Anchor" href="#handler"></a> Handler</h4>
<p>也就是处理器，它直接对应着 MVC 中的 C 也就是 Controller 层，它的具体表现形式有很多，可以是类,也可以是方法，如果你能想到别的表现形式也可以使用，它的类型是 Object。例如标注了<code>@RequestMapping</code> 的所有方法都可以看成一个 Handler。只要可以实际处理请求就可以是 Handler。</p>
<h4 id="handlermapping"><a class="markdownIt-Anchor" href="#handlermapping"></a> HandlerMapping</h4>
<p>是用来查找 Handler 的，在 Spring MVC 中会处理很多请求，每个请求都需要一个 Handler 来处理，具体接收到一个请求后使用哪个 Handler 来处理呢？这就是 HandlerMapping 要做的事情。</p>
<p>标注了 <code>RequestMapping</code> 的方法，<code>GetMapping、PostMapping、PutMapping、DeleteMapping</code> 是 <code>RequestMapping</code> 的复合注解，就会使用 <code>RequestMappingHandlerMapping</code> 从扫描到的注释方法的地址中查找满足条件的 Handler。</p>
<p>这里的请求也可能是 websocket 请求，所以就会有 <code>WebSocketHandlerMapping</code>。</p>
<h4 id="handleradapter"><a class="markdownIt-Anchor" href="#handleradapter"></a> HandlerAdapter</h4>
<p>从名字上就可以看出它是一个 Adapter，也就是适配器。因为 Spring MVC 中的 Handler 可以是任意的形式，只要能处理请求就 OK，但是 Servlet 需要的处理方法的结构却是固定的，都是以 request 和 response 为参数的方法（如 doService方法）。怎么让固定的 Servlet 处理方法调用灵活的 Handler 来进行处理呢？这就是 HandlerAdapter 要做的事情。</p>
<p>标注了 <code>RequestMapping</code> 的 <code>HandlerMethod</code> 就会使用 <code>RequestMappingHandlerAdapter</code> 来处理 Handler。</p>
<p><code>RequestMappingHandlerAdapter</code> 内部使用 <code>HandlerMethodArgumentResolver</code> 集合处理传入参数，<code>HandlerMethodReturnValueHandler</code> 处理返回结果，<code>HandlerMethodReturnValueHandler</code> 会根据返回资源的类型找到合适的响应体，比如媒体文件会使用渐进式下载形式返回，对象会找到合适的 mediaType 类型，并使用 <code>MessageConvter</code> 处理并返回。我们的 JSON 形式返回就是在这里处理的。</p>
<p>我们也可以调用 <code>setCustomArgumentResolvers</code> 来自定义参数解析，比如解析字符串到日期类，<code>setCustomReturnValueHandlers</code> 来自定义返回值处理。</p>
<hr />
<p>其它组件如下：</p>
<h4 id="handlerexceptionresolver"><a class="markdownIt-Anchor" href="#handlerexceptionresolver"></a> HandlerExceptionResolver</h4>
<p>別的组件都是在正常情况下用来干活的，不过干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在 Spring MVC 中就是 <code>HandlerExceptionresolver</code>。具体来说，此组件的作用是根据异常设置 <code>ModelAndView</code>，之后再交给 <code>render</code> 方法进行渲染。 render 只负责将 ModelAndView 渲染成页面，具体 ModelAndView 是怎么来 render 的并不关心。这也是 Spring MVC 设计优秀的一个表现一一分工明确互不干涉。通过前面 doDispatch 的分析可以知道 HandlerExceptionResolver 只是用于解析对请求做处理的过程中产生的异常，而渲染环节产生的异常不归它管，现在我们就知道原因了：它是在 render 之前工作的，先解析出  ModelAndView 之后 render 才去渲染，当然它就不能处理 render 过程中的异常了。</p>
<h4 id="viewresolver"><a class="markdownIt-Anchor" href="#viewresolver"></a> ViewResolver</h4>
<p>ViewResolver 用来将 String 类型的视图名（有的地方也叫逻辑视图，都指同一个东西）和 <code>Locale</code> 解析为 <code>View</code> 类型的视图。</p>
<p>View 是用来渲染页面的，通俗点说就是要将程序返回的参数填入模板里，生成html（也可能是其他类型）文件。这里有两个关键的问题：</p>
<ul>
<li>使用哪个模板？</li>
<li>用什么技术（或者规则）填入参数？</li>
</ul>
<p>这其实就是 ViewResolver 主要要做的工作, ViewResolver 需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交给不同的视图自己完成。最常使用的 <code>UrlBasedViewResolver</code> 都是针对单一类型试图进行解析，只需要找到使用的模版就可以了。比如，<code>InternalResourceViewResolver</code> 只针对 jsp 类型的视图，<code>FreeMarkerViewResolver</code> 只针对 FreeMarker 视图。</p>
<blockquote>
<p>使用 ResponseBody 注解以 JSON 形式返回会在 Adapter 的 handle 中处理，并不会使用 ViewResolver。</p>
</blockquote>
<h4 id="requesttoviewnametranslator"><a class="markdownIt-Anchor" href="#requesttoviewnametranslator"></a> RequestToViewNameTranslator</h4>
<p><code>ViewResolver</code> 是根据 <code>ViewName</code> 査找 <code>View</code>，但有的 Handler 处理完后并没有设置 View 也没有设置 ViewName，这时就需要从 <code>request</code> 获取 <code>ViewName</code> 了，而如何从 request 获取 ViewName 就是 RequestToViewTranslator 要做的事情。</p>
<h4 id="localeresolver"><a class="markdownIt-Anchor" href="#localeresolver"></a> LocaleResolver</h4>
<p>解析视图需要两个参数：一个是视图名，另一个是 <code>Locale</code>。视图名是处理器返回的（或者使用 RequestTo NameTranslator 解析的默认视图名），Locale 是从哪里来的呢？这就是 LocaleResolver 要做的事情。<br />
LocaleResolver 用于从 request 解析出 Locale。 Locale 是用来做 il8n（国际化）的基础。</p>
<h4 id="themeresolver"><a class="markdownIt-Anchor" href="#themeresolver"></a> ThemeResolver</h4>
<p>解析主题使用，也就是配置不同的样式文件切换不同的主题。</p>
<h4 id="multipartresolver"><a class="markdownIt-Anchor" href="#multipartresolver"></a> MultiPartResolver</h4>
<p>用于处理上传请求，处理方法是将普通的 <code>request</code> 包装成 <code>MultipartHttpServletRequest</code>，后者可以直接调用 <code>getFile</code> 方法获取到 <code>File</code>，如果上传多个文件，还可以调用 <code>getFileMap</code> 得到 <code>Filename → File</code> 结构的 Map，这样就使得上传请求的处理变得非常简单。</p>
<p>[^ HTTP 协议]: HTTP 协议是应用层协议，在 TCP/IP 协议接收到数据之后到达应用层。该协议中的报文结构非常重要。分为请求报文（request message）和响应报文（response message）。这两种类型都包括三部分：首行，头部和主体。请求报文的首行是请求行，包括请求类型、URL 和 HTTP 版本三项内容，响应请求的首行是状态行，包括 HTTP 版本、状态码和简短原因三项内容。™</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 架构初谈</title>
    <url>/spring/Spring-Security-%E6%9E%B6%E6%9E%84%E5%88%9D%E8%B0%88/</url>
    <content><![CDATA[<h2 id="身份验证和访问控制"><a class="markdownIt-Anchor" href="#身份验证和访问控制"></a> 身份验证和访问控制</h2>
<p>应用程序安全性归结为或多或少的两个独立问题：</p>
<p><code>authentication/认证</code>（你是谁？）和 <code>authorization/授权</code>（你可以做什么？）。</p>
<p>有时人们会说“访问控制”而不是“授权”，这可能会造成混淆，但是以这种方式思考可能会有所帮助，因为“授权”在其他地方可能有点言过其重。Spring Security 的体系结构旨在将认证与授权分开，并各自具有策略和扩展点。</p>
<h3 id="authentication身份验证认证"><a class="markdownIt-Anchor" href="#authentication身份验证认证"></a> Authentication（身份验证/认证）</h3>
<p>身份验证的主要策略接口是 <code>AuthenticationManager</code>，它只有一个方法：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AuthenticationManager</code> 可以在 <code>authenticate()</code> 方法中执行以下三项操作之一：</p>
<ol>
<li>如果它可以验证输入是否代表有效的主体，则返回 <code>Authentication</code>（通常使用 <code>authenticated = true</code>）。</li>
<li>如果认为输入代表无效的主体，则抛出 <code>AuthenticationException</code>。</li>
<li>如果无法决策，则返回 <code>null</code>。</li>
</ol>
<p><code>AuthenticationException</code> 是运行时异常。它通常由应用程序以通用方式处理，具体取决于应用程序的用例或目的。换句话说，通常不希望用户代码捕获并处理它。例如，web 程序将呈现一个页面，指出认证失败，后端 HTTP服务将发送401响应，取决于上下文，带有或不带有 <code>WWW-Authenticate</code> 标头。</p>
<p><code>AuthenticationManager</code> 最常用的实现是 <code>ProviderManager</code>，它委派了 <code>AuthenticationProvider</code> 实例链。<code>AuthenticationProvider</code> 有点像 <code>AuthenticationManager</code>，但是它还有一个额外的方法，允许调用者查询是否支持给定的 <code>Authentication</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>supports()</code> 方法中的 <code>Class &lt;?&gt;</code> 参数实际上是 <code>Class &lt;? extends Authentication&gt;</code>（仅会询问它是否支持将内容传递到 <code>authenticate()</code> 方法中）。通过委托给 <code>AuthenticationProviders</code> 链，<code>ProviderManager</code> 可以在同一应用程序中支持多种不同的身份验证机制。如果 <code>ProviderManager</code> 无法识别特定的身份验证实例类型，则将跳过该类型。</p>
<p><code>ProviderManager</code> 具有可选的父级，如果所有提供程序都返回 <code>null</code>，则可以咨询该父级。如果父级不可用，则 <code>null</code> 身份验证将导致 <code>AuthenticationException</code>。</p>
<p>有时，应用程序具有逻辑组的受保护资源（例如，与路径模式 <code>/api/**</code> 匹配的所有 Web 资源），并且每个组可以具有自己的专用 <code>AuthenticationManager</code>。通常，每一个都是 <code>ProviderManager</code>，它们共享一个父级。因此，父级是一种“全局”资源，充当所有提供程序的后备。</p>
<p><img src="../../images/spring-security/authentication.png" alt="ProviderManagers with a common parent" /></p>
<p>图1.使用 <code>ProviderManager</code> 的 <code>AuthenticationManager</code> 层次结构</p>
<h2 id="自定义身份验证管理器"><a class="markdownIt-Anchor" href="#自定义身份验证管理器"></a> 自定义身份验证管理器</h2>
<p>Spring Security 提供了一些配置帮助类，可以在自己的应用程序中便捷的得到通用身份验证管理器功能。最常用的帮助类是 <code>AuthenticationManagerBuilder</code>，它非常适合配置内存中的 JDBC 或 LDAP 用户详情，或者用于添加自定义 <code>UserDetailsService</code>。这是配置全局（父）<code>AuthenticationManager</code> 的应用程序的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   ... <span class="comment">// web stuff here</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(AuthenticationManagerBuilder builder, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    builder.jdbcAuthentication().dataSource(dataSource).withUser(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">      .password(<span class="string">&quot;secret&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例与 Web 应用程序有关，但是 <code>AuthenticationManagerBuilder</code> 的用法更为广泛（有关如何实现 Web 应用程序安全性的详细信息，请参见下文）。请注意，<code>AuthenticationManagerBuilder</code> 使用 <code>@Autowired</code> 注入到<code>@Bean</code> 的方法中-这就是使它构建全局（父）<code>AuthenticationManager</code> 的 原因。相反，如果我们这样做的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationSecurity</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   ... <span class="comment">// web stuff here</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.jdbcAuthentication().dataSource(dataSource).withUser(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">      .password(<span class="string">&quot;secret&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（在配置类中使用方法的 <code>@Override</code>），那么 <code>AuthenticationManagerBuilder</code> 仅用于构建“本地” <code>AuthenticationManager</code>，这是全局的一个子类。在 Spring Boot 应用程序中，您可以将全局变量 <code>@Autowired</code>连接到另一个 <code>bean</code> 中，但是除非你自己明确暴漏出它，否则不能对本地对象执行此操作。</p>
<p>Spring Boot 提供了一个默认的全局 <code>AuthenticationManager</code>（只有一个用户），除非你通过提供自己的<code>AuthenticationManager</code> 类型的 bean 来抢占它。除非你需要自定义全局 <code>AuthenticationManager</code>，否则默认值本身就足够安全，你不必担心太多。</p>
<h2 id="授权或访问控制"><a class="markdownIt-Anchor" href="#授权或访问控制"></a> 授权或访问控制</h2>
<p>身份验证成功后，我们可以继续进行授权，这里的核心策略是 <code>AccessDecisionManager</code>。框架提供了三种实现方式，所有这三种实现都委托给 <code>AccessDecisionVoter</code> 链，有点像 <code>ProviderManager</code> 委托给<code>AuthenticationProviders</code>。</p>
<p><code>AccessDecisionVoter</code> 使用 <code>ConfigAttributes</code> 修饰的身份验证主体和安全 <code>Object</code> 进行投票：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vote</span><span class="params">(Authentication authentication, S object,</span></span></span><br><span class="line"><span class="function"><span class="params">        Collection&lt;ConfigAttribute&gt; attributes)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该 <code>Object</code> 在 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的签名中是完全通用的-它表示用户可能要访问的任何内容（Web 资源或 Java 类中的方法是两种最常见的情况）。<code>ConfigAttributes</code> 也相当通用，用一些元数据来表示安全 <code>Object</code> 的修饰，这些元数据确定访问它所需的权限级别。<code>ConfigAttribute</code> 是一个接口，但是它只有一个通用的方法并返回 <code>String</code>，这些字符串以某种方式编码资源所有者的意图，表明有关允许谁访问它的规则。典型的 <code>ConfigAttribute</code> 是用户角色的名称（如 <code>ROLE_ADMIN</code> 或 <code>ROLE_AUDIT</code>），并且它们通常具有特殊的格式（如 <code>ROLE_</code> 前缀）或表示需要求值的表达式。</p>
<p>大多数人只使用默认的 <code>AccessDecisionManager</code>，它是 <code>AffirmativeBased</code> 的（如果任何选民投票通过，则允许授予访问权限）。任何定制都倾向于在选民中发生，要么添加新选民，要么修改现有选民的投票方式。</p>
<p>使用作为 Spring 表达式语言（SpEL）表达式的 <code>ConfigAttributes</code> 非常常见，例如 <code>isFullyAuthenticated() &amp;&amp; hasRole(‘FOO')</code>。<code>AccessDecisionVoter</code> 支持此功能，可以处理表达式并为其创建上下文。为了扩展可以处理的表达式的范围，需要 <code>SecurityExpressionRoot</code> 的自定义实现，有时还需要 <code>SecurityExpressionHandler</code>。</p>
<h2 id="网络安全"><a class="markdownIt-Anchor" href="#网络安全"></a> 网络安全</h2>
<p>Web 层（用于 UI 和 HTTP 后端）中的 Spring Security 基于 <code>Servlet</code> 过滤器，因此通常首先了解过滤器的作用会很有帮助。下图显示了单个 HTTP 请求的处理程序的典型分层。</p>
<p><img src="../../images/spring-security/filters.png" alt="Filter chain delegating to a Servlet" /></p>
<p>客户端向应用程序发送请求，然后容器根据请求 URI 的路径确定对它应用哪些过滤器和哪个 servlet。一个 servlet 最多只能处理一个请求，但是过滤器形成一个链，因此它们是有序的，实际上，如果过滤器要处理请求本身，则可以否决链的其余部分。过滤器还可以修改下游过滤器和 Servlet 中使用的请求和/或响应。过滤器链的顺序非常重要，Spring Boot 通过两种机制对其进行管理：一种是 <code>Filter</code> 类型的 <code>@Bean</code> 可以具有 <code>@Order</code> 或实现 <code>Ordered</code>，另一个是它们可以成为 <code>FilterRegistrationBean</code> 的一部分，而 FilterRegistrationBean 本身也将顺序作为其 API 的一部分。一些现成的过滤器定义了自己的常量，以帮助表示它们希望相对于彼此的顺序（例如，Spring Session 中的 <code>SessionRepositoryFilter</code> 的 <code>DEFAULT_ORDER</code> 为 <code>Integer.MIN_VALUE + 50</code>，它告诉我们，它喜欢处于过滤器链的前端，但并不排除其他过滤器的出现。</p>
<p>Spring Security 作为链中的单个 <code>Filter</code> 安装，其具体类型为 <code>FilterChainProxy</code>，原因很快就会变得显而易见。在 Spring Boot 应用程序中，安全过滤器是 <code>ApplicationContext</code> 中的 <code>@Bean</code>，默认情况下会安装该过滤器，以便将其应用于每个请求。它安装在 <code>SecurityProperties.DEFAULT_FILTER_ORDER</code> 定义的位置，反过来由 <code>FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 锚定（Spring Boot 应用程序希望过滤器包装请求并修改其行为时期望的最大顺序）。但是，还有更多的功能：从容器的角度来看，Spring Security 是一个过滤器，但是在内部有其他过滤器，每个过滤器都扮演着特殊的角色。如图：</p>
<p><img src="../../images/spring-security/security-filters.png" alt="Spring Security Filter" /></p>
<p>图2. Spring Security 是单个真实的过滤器，但是将处理委托给一系列内部过滤器。实际上，安全性过滤器中甚至还有一层间接层：通常作为 <code>DelegatingFilterProxy</code> 安装在容器中，而不必是 Spring <code>@Bean</code>，该代理类是 Spring Web 提供的 servlet 过滤器，它将所有工作委托给根 ApplicationContext 中的 Spring bean。该代理委托给一个始终为 <code>@Bean</code> 的 <code>FilterChainProxy</code>，通常使用固定名称 <code>springSecurityFilterChain</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingFilterProxy</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(request, response, filterChain)</span> </span>&#123;</span><br><span class="line">        Filter delegate = applicationContet.getBean(<span class="string">&quot;springSecurityFilterChain&quot;</span>)</span><br><span class="line">            delegate.doFilter(request, response, filterChain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个被委托的 Bean 就是 <code>FilterChainProxy</code>，它里面包含所有内部安全性逻辑，这些安全性逻辑在内部排列为一个或多个过滤器链，它们全部由 Spring Security 在同一顶级 <code>FilterChainProxy</code> 中管理，而对于容器来说都是未知的，该类的主要逻辑如下伪代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChainProxy</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(request, response, filterChain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找此请求的所有过滤器</span></span><br><span class="line">        List&lt;Filter&gt; delegates = lookupDelegates(request, response)</span><br><span class="line">            <span class="comment">// 除非委托过滤器类决定停止，否则调用每个筛选器</span></span><br><span class="line">            <span class="keyword">for</span> delegate in delegates &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">continue</span> processing </span><br><span class="line">                    delegate.doFilter(request, response, filterChain)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果所有过滤器都认为ok，则允许应用程序的其余部分运行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">continue</span> processing</span><br><span class="line">            filterChain.doFilter(request, response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Security 过滤器包含一个过滤器链列表，并向与其匹配的第一个链发送请求。下图显示了基于匹配请求路径（<code>/foo/**</code> 在 <code>/**</code> 之前匹配）发生的调度。这是很常见的，但不是匹配请求的唯一方法。此调度过程的最重要特征是，只有一个链处理过请求。</p>
<p><img src="../../images/spring-security/security-filters-dispatch.png" alt="Security Filter Dispatch" /></p>
<p>图3. Spring Security <code>FilterChainProxy</code> 将请求分派到匹配的第一个链。 没有自定义安全配置的普通 Spring Boot 应用程序具有多个（称为n）过滤器链，通常 n = 6。前 (n-1) 个链只是忽略静态资源匹配模式，像 <code>/css/**</code> 和 <code>/images/**</code>，以及错误视图 <code>/error</code>（路径可以由用户通过 <code>SecurityProperties</code> 配置 bean 中 <code>security.ignored</code> 控制）。最后一条链与捕获所有路径<code>/**</code> 相匹配，并且更活跃，包含用于身份验证，授权，异常处理的逻辑，会话处理，请求写入等。默认情况下，此链中总共有11个过滤器，但通常用户不必担心使用什么过滤器以及何时使用。</p>
<blockquote>
<p>容器不知道 Spring Security 内部的所有过滤器这一事实非常重要，尤其是在 Spring Boo t应用程序中，默认情况下，所有 <code>Filter</code> 类型的 <code>@Bean</code> 都会自动向容器注册。因此，如果要向安全链中添加自定义过滤器，则无需将其设置为 <code>@Bean</code> 或将其包装在明确禁用容器注册的 <code>FilterRegistrationBean</code> 中。</p>
</blockquote>
<h2 id="创建和定制过滤器链"><a class="markdownIt-Anchor" href="#创建和定制过滤器链"></a> 创建和定制过滤器链</h2>
<p>Spring Boot 应用程序（带有 <code>/**</code> 请求匹配器的应用程序）中的默认后备过滤器链具有 <code>SecurityProperties.BASIC_AUTH_ORDER</code> 的预定义顺序。您可以通过设置 <code>security.basic.enabled = false</code> 完全关闭它，也可以将其用作后备并仅以较低的顺序定义其他规则。为此，只需添加类型为 <code>WebSecurityConfigurerAdapter</code>（或 <code>WebSecurityConfigurer</code>）的 <code>@Bean</code> 并使用 <code>@Order</code> 装饰类。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">     ...;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 bean 将导致 Spring Security 添加一个新的过滤器链并在回退之前对其进行排序。</p>
<p>许多应用程序对两套资源的访问规则完全不同。例如，承载 UI 和支持 API 的应用程序可能支持基于 cookie 的身份验证以及对 UI 部件的登录页面的重定向，而基于令牌的身份验证则具有针对 API 部件的未经身份验证的请求的 401 响应。 每组资源都有其自己的 <code>WebSecurityConfigurerAdapter</code> 以及唯一的顺序和自己的请求匹配器。 如果匹配规则重叠，则最早的有序过滤器链将获胜。</p>
<h2 id="请求匹配以进行调度和授权"><a class="markdownIt-Anchor" href="#请求匹配以进行调度和授权"></a> 请求匹配以进行调度和授权</h2>
<p>安全过滤器链（或等效的 <code>WebSecurityConfigurerAdapter</code>）具有请求匹配器，该请求匹配器用于确定是否将其应用于 HTTP 请求。一旦决定应用特定的过滤器链，就不再应用其他过滤器链。但是在过滤器链中，可以通过在<code>HttpSecurity</code> 配置器中设置其他匹配器来对授权进行更细粒度的控制。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">      .authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="string">&quot;/foo/bar&quot;</span>).hasRole(<span class="string">&quot;BAR&quot;</span>)</span><br><span class="line">        .antMatchers(<span class="string">&quot;/foo/spam&quot;</span>).hasRole(<span class="string">&quot;SPAM&quot;</span>)</span><br><span class="line">        .anyRequest().isAuthenticated();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置 Spring Security 时最容易犯的一个错误是忘记这些匹配器适用于不同的流程，一个是整个过滤器链的请求匹配器，另一个是仅选择要应用的访问规则。</p>
<h2 id="将应用程序安全规则与执行器规则相结合"><a class="markdownIt-Anchor" href="#将应用程序安全规则与执行器规则相结合"></a> 将应用程序安全规则与执行器规则相结合</h2>
<p>如果您将 Spring Boot Actuator 用于管理端点，则可能希望它们是安全的，默认情况下它们将是安全的。实际上，将执行器添加到安全应用程序后，您会获得一条仅适用于执行器端点的附加过滤器链。它由仅匹配执行器端点的请求匹配器定义，并且其顺序为 <code>ManagementServerProperties.BASIC_AUTH_ORDER</code>，该顺序比默认的SecurityProperties 回退过滤器少 5 个，因此在进行回退处理之前会经过它。</p>
<p>如果您希望将应用程序安全规则应用于执行器端点，则可以添加一个比执行器顺序更早顺序的过滤器链，并带有一个包括所有执行器端点的请求匹配器。如果您喜欢执行器端点的默认安全性设置，那么最简单的方法是在执行器端点之后但在回退之前（例如 <code>ManagementServerProperties.BASIC_AUTH_ORDER + 1</code>）添加自己的过滤器。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(ManagementServerProperties.BASIC_AUTH_ORDER + 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.antMatcher(<span class="string">&quot;/foo/**&quot;</span>)</span><br><span class="line">     ...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Web 层中的 Spring Security 当前与 Servlet API 绑定在一起，因此，它仅在以嵌入式或其他方式在 Servlet 容器中运行应用程序时才真正适用。但是，它不依赖于 Spring MVC 或 Spring Web 堆栈的其余部分，因此可以在任何 servlet 应用程序中使用，例如使用 JAX-RS 的 servlet 应用程序。</p>
</blockquote>
<h2 id="方法安全"><a class="markdownIt-Anchor" href="#方法安全"></a> 方法安全</h2>
<p>除了保护 Web 应用程序安全外，Spring Security 还提供了将访问规则应用于 Java 方法执行的支持。对于 Spring Security，这只是“保护资源”的另一种类型。对于用户而言，这意味着使用相同的 ConfigAttribute 字符串格式（例如角色或表达式）声明访问规则，但在代码中的其他位置。第一步是启用方法安全性，例如在应用程序的顶级配置中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleSecureApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以直接修饰方法资源，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Secured(&quot;ROLE_USER&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">secure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello Security&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例是一种使用安全方法的服务。如果 Spring 创建了这种类型的 <code>@Bean</code>，则它将被代理，并且在实际执行该方法之前，调用者将必须通过安全拦截器。如果访问被拒绝，则调用者将获得 <code>AccessDeniedException</code> 而不是实际的方法结果。</p>
<p>方法上还可以使用其他注释来强制执行安全性约束，尤其是 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code>，它们可以使您编写分别包含对方法参数和返回值的引用的表达式。</p>
<blockquote>
<p>结合使用 Web 安全性和方法安全性并不少见。过滤器链提供了用户体验功能，例如身份验证和重定向到登录页面等，并且方法安全性在更精细的级别上提供了保护。</p>
</blockquote>
<h2 id="使用线程"><a class="markdownIt-Anchor" href="#使用线程"></a> 使用线程</h2>
<p>Spring Security 从根本上讲是线程绑定的，因为它需要使当前经过身份验证的主体可供各种下游使用者使用。基本构件是 <code>SecurityContext</code>，它可以包含一个 <code>Authentication</code>（当用户登录时，它将是经过显式身份验证的<code>Authentication</code>）。您始终可以通过 <code>SecurityContextHolder</code> 中的静态便捷方法来访问和操作 <code>SecurityContext</code>，而该方法又可以简单地操作 <code>TheadLocal</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">Authentication authentication = context.getAuthentication();</span><br><span class="line"><span class="keyword">assert</span>(authentication.isAuthenticated);</span><br></pre></td></tr></table></figure>
<p>用户应用程序代码执行此操作并不常见，但是，如果你需要编写一个自定义的身份验证过滤器，它会很有用（尽管即使如此，Spring Security 中也可以使用基类来避免使用 SecurityContextHolder）。</p>
<p>如果需要访问 Web 端点中当前已认证的用户，则可以在 <code>@RequestMapping</code> 中使用方法参数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(<span class="meta">@AuthenticationPrincipal</span> User user)</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">// do stuff with user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注释将当前的身份验证 (<code>Authentication</code>) 从 <code>SecurityContext</code> 中拉出，并对其调用 <code>getPrincipal()</code> 方法以产生方法参数。身份验证中的主体类型取决于用于验证身份验证的 <code>AuthenticationManager</code>，因此这是获得对用户数据的类型安全引用的有用的小技巧。</p>
<p>如果使用 Spring Security，则 <code>HttpServletRequest</code> 中的 <code>Principal</code> 将为 <code>Authentication</code> 类型，因此您也可以直接使用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/foo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(Principal principal)</span> </span>&#123;</span><br><span class="line">  Authentication authentication = (Authentication) principal;</span><br><span class="line">  User = (User) authentication.getPrincipal();</span><br><span class="line">  ... <span class="comment">// do stuff with user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要编写在不使用 Spring Security 时可以工作的代码，那么这有时会很有用（您在加载 Authentication 类时需要更加谨慎）。</p>
<h2 id="异步处理安全方法"><a class="markdownIt-Anchor" href="#异步处理安全方法"></a> 异步处理安全方法</h2>
<p>由于 <code>SecurityContext</code> 是线程绑定的，因此，如果要执行任何调用安全方法的后台处理，例如使用 <code>@Async</code>，您需要确保传播上下文。</p>
<p>这归结为将 <code>SecurityContext</code> 包装为在后台执行的任务（<code>Runnable</code>，<code>Callable</code> 等）。Spring Security 提供了一些帮助程序，例如 <code>Runnable</code> 和 <code>Callable</code> 的包装器。要将 <code>SecurityContext</code> 传播到 <code>@Async</code> 方法，您需要提供 <code>AsyncConfigurer</code> 并确保 <code>Executor</code> 具有正确的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> <span class="keyword">extends</span> <span class="title">AsyncConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatingSecurityContextExecutorService(Executors.newFixedThreadPool(<span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 过滤器</title>
    <url>/spring/Spring-Security-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p>Spring Security 的 Web 基础结构完全基于标准的 servlet 过滤器。Spring Security 在内部维护一个过滤器链，其中每个过滤器都有特定的责任，过滤器的顺序很重要，因为它们之间存在依赖关系。</p>
<a id="more"></a>
<h2 id="过滤器链"><a class="markdownIt-Anchor" href="#过滤器链"></a> 过滤器链</h2>
<ul>
<li>
<h2 id="delegatingfilterproxy"><a class="markdownIt-Anchor" href="#delegatingfilterproxy"></a> <code>DelegatingFilterProxy</code></h2>
<p>使用 servlet 过滤器时，显然需要在 <code>web.xml</code> 中声明它们，否则 servlet 容器将忽略它们。在 Spring Security 中，过滤器类也是在应用程序上下文中定义的 Spring bean，因此能够利用 Spring 丰富的依赖注入工具和生命周期接口。Spring 的 <code>DelegatingFilterProxy</code> 提供了 <code>web.xml</code> 和应用程序上下文之间的链接。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>请注意，过滤器实际上是 <code>DelegatingFilterProxy</code>，而不是实际实现过滤器逻辑的类。DelegatingFilterProxy 所做的是将 <code>Filter</code> 的方法委托给从 Spring 应用程序上下文中获取的 bean。bean 必须实现 <code>javax.servlet.Filter</code>，它必须与 <code>filter-name</code> 元素中的名称相同。<br />
<code>DelegatingFilterProxy</code> 继承 <code>GenericFilterBean</code>，该抽象类实现 <code>Filter</code> 接口，并提供 Spring 的管理。但是委托类自己不去实现安全过滤，而是将过滤方法委托给 <code>FilterChainProxy</code> 代理类去做。</p>
</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">    Filter delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">            delegateToUse = <span class="keyword">this</span>.delegate;</span><br><span class="line">            <span class="keyword">if</span> (delegateToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                WebApplicationContext wac = findWebApplicationContext();</span><br><span class="line">                <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No WebApplicationContext found: &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;no ContextLoaderListener or DispatcherServlet registered?&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                delegateToUse = initDelegate(wac);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.delegate = delegateToUse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the delegate perform the actual doFilter operation.</span></span><br><span class="line">    invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>delegateToUse</code> 就是 <code>FilterChainProxy</code>,代理类调用自己的 <code>Filter</code> 实现。</p>
<ul>
<li>
<h2 id="filterchainproxy"><a class="markdownIt-Anchor" href="#filterchainproxy"></a> <code>FilterChainProxy</code></h2>
<p>Spring Security 的 Web 基础结构只能通过委托 FilterChainProxy 实例来实现。安全过滤器不应该使用自身。FilterChainProxy 允许我们向 web.xml 添加一个条目，并完全处理应用程序上下文文件以管理我们的 Web 安全 bean。</p>
<p>该类同样继承自 <code>GenericFilterBean</code>，<code>Filter</code> 实现如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> clearContext = request.getAttribute(FILTER_APPLIED) == <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (clearContext) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">            doFilterInternal(request, response, chain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            SecurityContextHolder.clearContext();</span><br><span class="line">            request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        doFilterInternal(request, response, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FirewalledRequest fwRequest = firewall</span><br><span class="line">            .getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">    HttpServletResponse fwResponse = firewall</span><br><span class="line">            .getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line"></span><br><span class="line">    List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filters == <span class="keyword">null</span> || filters.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(UrlUtils.buildRequestUrl(fwRequest)</span><br><span class="line">                    + (filters == <span class="keyword">null</span> ? <span class="string">&quot; has no matching filters&quot;</span></span><br><span class="line">                            : <span class="string">&quot; has an empty filter list&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fwRequest.reset();</span><br><span class="line"></span><br><span class="line">        chain.doFilter(fwRequest, fwResponse);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VirtualFilterChain vfc = <span class="keyword">new</span> VirtualFilterChain(fwRequest, chain, filters);</span><br><span class="line">    vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 firewall 就实现了安全字符过滤，Url编码解码配置，访问方法配置等等安全策略。<br />
真正执行安全过滤的是在其内部类 <code>VirtualFilterChain</code> 中，在该类中依次调用各个安全过滤器。</p>
<h2 id="后处理配置实体"><a class="markdownIt-Anchor" href="#后处理配置实体"></a> 后处理配置实体</h2>
<p>Spring Security 的 Java 配置不会公开它配置的每个对象的每个属性。这简化了大多数用户的配置。毕竟，如果每个属性都被暴露，用户可以使用标准 bean 配置。</p>
<p>虽然有充分的理由不直接公开每个属性，但用户可能仍需要更高级的配置选项。为了解决这个问题，Spring Security引入了 <code>ObjectPostProcessor</code> 的概念，可用于修改或替换 Java Configuration 创建的许多 Object 实例。例如，如果要在 FilterSecurityInterceptor 上配置 filterSecurityPublishAuthorizationSuccess 属性，可以使用以下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http</span><br><span class="line">    .authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O fsi)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 默认只会广播 AuthorizationFailureEvent 事件，如果设置为 true，则同时也会广播 AuthorizedEvent</span></span><br><span class="line">                fsi.setPublishAuthorizationSuccess(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> fsi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤器顺序"><a class="markdownIt-Anchor" href="#过滤器顺序"></a> 过滤器顺序</h2>
<p>过滤器在链中定义的顺序非常重要：</p>
<ul>
<li><code>ChannelProcessingFilter</code>：因为它可能需要重定向到不同的协议</li>
<li><code>SecurityContextPersistenceFilter</code>: 因此，可以在 Web 请求开始时在 SecurityContextHolder 中设置 SecurityContext，并且当 Web 请求结束时（可以使用下一个Web请求准备好），可以将对 SecurityContext 的任何更改复制到 HttpSession。</li>
<li><code>ConcurrentSessionFilter</code>： 因为它需要使用 SecurityContextHolder 的功能，而且更新对应 session 的最后更新时间，以及通过 SessionRegistry 获取当前的 SessionInformation 以检查当前的 session 是否已经过期，过期则会调用 LogoutHandler。</li>
<li>身份验证处理机制 - <code>UsernamePasswordAuthenticationFilter</code>，<code>CasAuthenticationFilter</code>，<code>BasicAuthenticationFilter</code>等 - 以便可以修改SecurityContextHolder 以包含有效的身份验证请求令牌.</li>
<li><code>SecurityContextHolderAwareRequestFilter</code>：使用它将 Spring Security 感知  HttpServletRequestWrapper 安装到您的 servlet 容器中</li>
<li><code>JaasApiIntegrationFilter</code>：如果 JaasAuthenticationToken 位于SecurityContextHolder 中，则会将 FilterChain 作为 JaasAuthenticationToken 中的 Subject 进行处理</li>
<li><code>RememberMeAuthenticationFilter</code>: 如果没有更早的身份验证处理机制更新SecurityContextHolder，并且该请求提供了一个 cookie，使我能够记住我的服务，一个合适的 remembered Authentication 验证对象将会设给 SecurityContextHolder</li>
<li><code>AnonymousAuthenticationFilter</code>，这样如果没有早期的身份验证处理机制更新SecurityContextHolder，那么匿名身份验证对象将被放在那里</li>
<li><code>ExceptionTranslationFilter</code>，用于捕获任何 Spring Security 异常，以便可以返回 HTTP 错误响应或启动相应的 AuthenticationEntryPoint</li>
<li><code>FilterSecurityInterceptor</code>，用于保护 Web URI 并在访问被拒绝时引发异常</li>
</ul>
<h2 id="核心过滤器"><a class="markdownIt-Anchor" href="#核心过滤器"></a> 核心过滤器</h2>
<ul>
<li>
<h3 id="filtersecurityinterceptor"><a class="markdownIt-Anchor" href="#filtersecurityinterceptor"></a> <code>FilterSecurityInterceptor</code></h3>
</li>
</ul>
<p>该过滤器负责处理 HTTP 资源的安全性，它需要一个 <code>AuthenticationManager</code> 和 <code>AccessDecisionManager</code> 的引用。它还提供了适用于不同 HTTP URL 请求的配置属性。<br />
<code>FilterSecurityInterceptor</code> 可以通过两种方式配置配置属性。第一种，是使用命名空间元素 <filter-security-metadata-source>，这里不再说明。第二个选项是编写自己的<code>SecurityMetadataSource</code>，无论使用何种方法。SecurityMetadataSource 负责返回List<ConfigAttribute>，其中包含与单个安全 HTTP URL 关联的所有配置属性。<br />
应该注意的是，FilterSecurityInterceptor.setSecurityMetadataSource() 方法实际上需要FilterInvocationSecurityMetadataSource 的实例。它是一个标记接口，表示它是 <code>SecurityMetadataSource</code> 的子类。它只是表示SecurityMetadataSource了解FilterInvocation。为了简单起见，我们将继续将FilterInvocationSecurityMetadataSource 称为 SecurityMetadataSource，因为这种区别与大多数用户没什么关系。<br />
由命名空间语法创建的SecurityMetadataSource 通过将请求 URL 与配置的 pattern 属性相匹配来获取特定 FilterInvocation 的配置属性。这与命名空间配置的行为方式相同。缺省情况是将所有表达式视为 Apache Ant 路径，并且对于更复杂的情况也支持正则表达式。request-matcher 属性用于指定正在使用的模式的类型。在同一定义中无法混合表达式语法。<br />
始终按照定义的顺序评估模式。因此，在列表中定义的更具体的模式比不太具体的模式更高这一点很重要。</p>
<ul>
<li>
<h3 id="exceptiontranslationfilter"><a class="markdownIt-Anchor" href="#exceptiontranslationfilter"></a> <code>ExceptionTranslationFilter</code></h3>
<code>ExceptionTranslationFilter</code> 位于安全过滤器堆栈中的 <code>FilterSecurityInterceptor</code> 之上。它不执行任何实际的安全实施，但处理安全拦截器抛出的异常并提供合适的 HTTP 响应。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;exceptionTranslationFilter&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.security.web.access.ExceptionTranslationFilter&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;authenticationEntryPoint&quot;</span> ref=<span class="string">&quot;authenticationEntryPoint&quot;</span>/&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;accessDeniedHandler&quot;</span> ref=<span class="string">&quot;accessDeniedHandler&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;authenticationEntryPoint&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;loginFormUrl&quot;</span> value=<span class="string">&quot;/login.jsp&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;accessDeniedHandler&quot;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.security.web.access.AccessDeniedHandlerImpl&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;errorPage&quot;</span> value=<span class="string">&quot;/accessDenied.htm&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h4 id="authenticationentrypoint"><a class="markdownIt-Anchor" href="#authenticationentrypoint"></a> <code>AuthenticationEntryPoint</code></h4>
</li>
</ul>
<p>用户未进行身份验证时请求安全的 HTTP 资源时，会调用 <code>AuthenticationEntryPoint</code>。安全拦截器将在调用堆栈的下方抛出适当的 <code>AuthenticationException</code> 或 <code>AccessDeniedException</code>,触发入口点的 <code>commence</code> 方法。这样做的目的是向用户提供适当的响应，以便开始身份验证。我们在这里使用的是<code>LoginUrlAuthenticationEntryPoint</code>，它将请求重定向到不同的URL（通常是登录页面）。使用的实际实现将取决于您希望在应用程序中使用的身份验证机制。</p>
<ul>
<li>
<h4 id="accessdeniedhandler"><a class="markdownIt-Anchor" href="#accessdeniedhandler"></a> <code>AccessDeniedHandler</code></h4>
如果抛出<code>AccessDeniedException</code>并且用户已经过身份验证，则这意味着此操作没有足够权限。在这种情况下，<code>ExceptionTranslationFilter</code> 将调用第二个策略<code>AccessDeniedHandler</code>。默认情况下，使用 <code>AccessDeniedHandlerImpl</code>，它只向客户端发送403（Forbidden）响应。你也可以实现自己的处理。</li>
<li>
<h4 id="savedrequest和requestcache接口"><a class="markdownIt-Anchor" href="#savedrequest和requestcache接口"></a> <code>SavedRequest</code>和<code>RequestCache</code>接口</h4>
</li>
</ul>
<p><code>ExceptionTranslationFilter</code> 职责的另一个职责是在调用 <code>AuthenticationEntryPoint</code> 之前保存当前请求。这允许在用户进行身份验证后恢复请求,一个典型的例子是用户使用表单登录，然后通过默认的 <code>SavedRequestAwareAuthenticationSuccessHandler</code> 重定向到原始URL。<br />
<code>RequestCache</code> 封装了存储和检索 <code>HttpServletRequest</code> 实例所需的功能。默认使用 <code>HttpSessionRequestCache</code>，它将请求存储在 <code>HttpSession</code> 中。当用户被重定向到原始 URL 时，<code>RequestCacheFilter</code> 的作用是实际从缓存中恢复已保存的请求。</p>
<ul>
<li>
<h3 id="securitycontextpersistencefilter"><a class="markdownIt-Anchor" href="#securitycontextpersistencefilter"></a> <code>SecurityContextPersistenceFilter</code></h3>
<p>根据应用程序的类型，可能需要采用策略来在用户操作之间存储安全上下文。在典型的Web应用程序中，用户登录一次，然后由其 session Id 标识。服务器在会话期间缓存主体信息。在 Spring Security 中，在请求之间存储 <code>SecurityContext</code> 的责任属于<code>SecurityContextPersistenceFilter</code>，它默认将上下文存储为HTTP请求之间的 <code>HttpSession</code> 属性。它为每个请求恢复 <code>SecurityContextHolder</code> 的上下文，并且至关重要的是，在请求完成时清除 <code>SecurityContextHolder</code>。出于安全目的，您不应直接与<code>HttpSession</code> 交互，使用 SecurityContextHolder 即可。<br />
许多其他类型的应用程序（例如，无状态 RESTful Web 服务）不使用 HTTP 会话，并将在每个请求上重新进行身份验证。但是，在链中包含 <code>SecurityContextPersistenceFilter</code> 以确保在每次请求后清除 <code>SecurityContextHolder</code> 仍然很重要。<br />
如前所述，此过滤器有两个主要任务。它负责在 HTTP 请求之间存储 <code>SecurityContext</code> 内容，并在请求完成时清除 <code>SecurityContextHolder</code>。清除存储上下文的 <code>ThreadLocal</code> 是必不可少的，因为否则可能会将一个线程替换为 servlet 容器的线程池，与特定用户的安全上下文仍然附加。然后可以在稍后阶段使用该线程，使用错误的凭证执行操作。<br />
从 Spring Security 3.0 开始，加载和存储安全上下文的工作现在被委托给一个单独的策略接口 <code>SecurityContextRepository</code>。</p>
</li>
<li>
<h3 id="usernamepasswordauthenticationfilter"><a class="markdownIt-Anchor" href="#usernamepasswordauthenticationfilter"></a> <code>UsernamePasswordAuthenticationFilter</code></h3>
<p>我们现在已经看到了 Spring Security Web 配置中始终存在的三个主要过滤器。现在唯一缺少的是实际的身份验证机制，允许用户进行身份验证。此过滤器是最常用的身份验证过滤器，也是最常定制的过滤器。配置它需要三个阶段。</p>
<ul>
<li>使用登录页面的URL来配 <code>LoginUrlAuthenticationEntryPoint</code>，就像我们上面所做的那样，并在 <code>ExceptionTranslationFilter</code> 上设置它。</li>
<li>实现登录页面（使用 JSP 或 MVC 控制器）。</li>
<li>在应用程序上下文中配置 <code>UsernamePasswordAuthenticationFilter</code> 的实例。</li>
<li>将过滤器 bean 添加到过滤器链代理（确保您注意顺序）。</li>
</ul>
</li>
</ul>
<h4 id="认证成功与失败的应用流程"><a class="markdownIt-Anchor" href="#认证成功与失败的应用流程"></a> 认证成功与失败的应用流程</h4>
<p>过滤器调用配置 <code>AuthenticationManager</code> 来处理每个身份验证请求。身份验证成功或身份验证失败后的目标分别由 <code>AuthenticationSuccessHandler</code> 和 <code>AuthenticationFailureHandler</code> 策略接口控制。分别的，过滤器具有这些属性以便您可以完全自定义行为。提供了一些标准实现，如 <code>SimpleUrlAuthenticationSuccessHandler</code>, <code>SavedRequestAwareAuthenticationSuccessHandler</code>, <code>SimpleUrlAuthenticationFailureHandler</code>, <code>ExceptionMappingAuthenticationFailureHandler</code> and <code>DelegatingAuthenticationFailureHandler</code>。查看这些类的 Javadoc 以及 <code>AbstractAuthenticationProcessingFilter</code>，以了解它们的工作原理和支持的功能。</p>
<p>如果认证成功后，创建的 <code>Authentication</code> 对象将被放入 <code>SecurityContextHolder</code>中。然后将调用配置的 <code>AuthenticationSuccessHandler</code>，以将用户重定向或转发到适当的目标。默认情况下，使用 <code>SavedRequestAwareAuthenticationSuccessHandler</code>，这意味着在要求用户登录之前，用户将被重定向到他们请求的原始目标。</p>
<p>如果身份验证失败，将调用配置的 <code>AuthenticationFailureHandler</code>。</p>
<h2 id="请求匹配和-httpfirewall"><a class="markdownIt-Anchor" href="#请求匹配和-httpfirewall"></a> 请求匹配和 HttpFirewall</h2>
<p>Servlet 规约为 HttpServletRequest 定义了一些属性，我们可能希望与之匹配来验证安全。这些是 <code>contextPath</code>,<code>servletPath</code>,<code>pathinfo</code>和<code>queryString</code>。Spring Security只对保护应用程序中的路径感兴趣，因此将忽略 contextPath。但是 serveltPath 和 pathInfo 没有明确规范路径如何定义，比如每段地址是否都可以包含参数。为了防止这些问题， <code>FilterChainProxy</code> 使用 <code>HttpFirewall</code> 策略去检查和包裹请求。默认情况下，未规范化的请求会自动被拒绝，删除路径参数和重复斜杠以进行匹配。因此，必须使用FilterChainProxy 来管理安全过滤器链。<br />
如上所述，默认策略是使用 Ant-style 路径进行匹配，这可能是大多数用户的最佳选择。该策略在 <code>AntPathRequestMatcher</code> 类中实现，该类使用 Spring 的 AntPathMatcher 对servletPath 和 pathInfo 执行不区分大小写的模式匹配，忽略queryString。<br />
如果你需要一个更加强大的模式匹配，你可以使用正则表达式。这种策略的实现是 <code>RegexRequestMatcher</code>。<br />
<code>HttpFirewall</code>还通过拒绝 HTTP 响应标头中的换行字符来阻止 <a target="_blank" rel="noopener" href="https://www.owasp.org/index.php/HTTP_Response_Splitting">HTTP 响应拆分</a>。<br />
默认情况下使用<code>StrictHttpFirewall</code>。此实现拒绝看似恶意的请求。你也可以自定义那些类型的请求应该被拒绝。比如，如果你希望利用 Spring MVC 的矩阵变量，你可以这样配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StrictHttpFirewall <span class="title">httpFirewall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowSemicolon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StrictHttpFirewall 提供有效 HTTP 方法的白名单，允许防止跨站点跟踪（XST）和HTTP 动词篡改。默认有效的方法是&quot;DELETE&quot;, “GET”, “HEAD”, “OPTIONS”, “PATCH”, “POST”, and “PUT”。如果你希望修改有效的有效方法，可以这样配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StrictHttpFirewall <span class="title">httpFirewall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowedHttpMethods(Arrays.asList(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果必须允许任何 HTTP 方法（不推荐），则可以使用StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)。这将完全禁用 HTTP 方法的验证。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型与网络协议入门</title>
    <url>/network/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="了解网络模型的目的"><a class="markdownIt-Anchor" href="#了解网络模型的目的"></a> 了解网络模型的目的</h1>
<p>在网络初期，大多数系统都使用专有软件和协议，这些软件和协议仅允许与同一制造商或可以访问这些协议的制造商的其他设备进行通信。 当时，这已不是什么大问题，因为组织会一直从同一制造商那里购买设备，并且没有在组织外部进行通信的真正方法。 但是，随着时间的流逝，这种情况已经改变，现在需要与其他组织拥有的系统进行通信。</p>
<p>其他组织不太可能拥有同一制造商的设备，因此这些设备无法相互通信。 为了解决这个问题，有人要求创建一个标准模型，并公开提供给所有人使用。 成为标准的两个模型如下：</p>
<ul>
<li><strong>国际标准化组织（ISO）的开放系统互连（OSI）模型</strong></li>
<li><strong>TCP / IP 模型</strong></li>
</ul>
<a id="more"></a>
<h1 id="osi-模型"><a class="markdownIt-Anchor" href="#osi-模型"></a> OSI 模型</h1>
<p>OSI 模型是一个包括七个单独层的网络模型，如下图所示。 这些层中的每一层都与与其相邻的层以及接收设备上的等效层进行通信：</p>
<p><img src="../../images/network/osi.png" alt="OSI 模型" /></p>
<p>顶部三层（应用，表示和会话）称为上层。 底层的四层（传输，网络，数据链路，物理）称为低层。</p>
<p>数据通过发送设备上的 OSI 模型时，将经历一个称为封装的过程。 封装只是从上一层获取数据，向其添加标头（有时是尾部），然后将其传递到重复该过程的下一层。 头层（和尾部）和向下传递到下一层的数据被始发层称为协议数据单元； 在接收层上，它被称为服务数据单元。 下图显示了处理过程中的封装，并在右侧列出了数据单元名称。</p>
<p><img src="../../images/network/osi-encapsulation.jpg" alt="OSI Encapusulation" /></p>
<h2 id="第-7-层-应用层"><a class="markdownIt-Anchor" href="#第-7-层-应用层"></a> 第 7 层 应用层</h2>
<p>需要提及的一点，应用程序不驻留在 OSI 模型的应用程序层上。 实际上，它们位于 OSI 模型之上。 应用层充当应用程序和网络模型之间的接口。 任何支持网络通信的应用程序都将使用网络应用程序编程接口（API）进行开发。 该 API 包含告诉应用程序如何与应用层通信的代码。</p>
<p>应用程序将支持许多应用层协议，而不是应用程序位于应用层。 其中一些常用协议包括以下内容：</p>
<ul>
<li>
<p>简单邮件传输协议（SMTP）</p>
</li>
<li>
<p>邮局协议（POP）</p>
</li>
<li>
<p>Internet 邮件访问协议（IMAP）</p>
</li>
<li>
<p>超文本传输协议（HTTP）</p>
</li>
<li>
<p>域名系统（DNS）</p>
</li>
<li>
<p>安全外壳（SSH）</p>
</li>
<li>
<p>文本传输协议（FTP）</p>
</li>
</ul>
<h2 id="第-6-层-表示层"><a class="markdownIt-Anchor" href="#第-6-层-表示层"></a> 第 6 层 表示层</h2>
<p>表示层从应用程序层获取传递给它的数据，并将其转换为通用格式或语法。一些正在转换的数据将非常复杂，必须将其转换为平面文件，以准备流式传输到接收者。 该序列化的数据流被接收方的设备接收并反序列化并重建为其原始格式。进行此转换的原因是不同系统或应用程序的本机格式可能会有所不同。 通过将数据转换为通用格式，任何接收到数据的设备都可以理解它，并且可以扩展为接收应用程序可以理解的格式。</p>
<p>除了转换数据之外，表示层还提供数据压缩和加密/解密。 该层上使用的一些通用标准包括：</p>
<ul>
<li>JPEG</li>
<li>ASCII</li>
<li>TIFF</li>
<li>GIF</li>
</ul>
<h2 id="第-5-层-会话层"><a class="markdownIt-Anchor" href="#第-5-层-会话层"></a> 第 5 层 会话层</h2>
<p>会话层负责管理设备之间的会话。 会话管理包括建立会话，同步设备之间的通信以及终止会话。</p>
<p>设备在这一层上使将要进行的通信类型达成一致，包括以下内容：</p>
<ul>
<li>单工 Simplex</li>
<li>半双工 Half-duplex</li>
<li>全双工 Full-duplex</li>
</ul>
<p>该层支持的协议包括以下内容：</p>
<ul>
<li>RPC</li>
<li>SQL</li>
<li>NetBIOS</li>
<li>Point-to-Point Tunneling Protocol (PPTP)</li>
</ul>
<h2 id="第-4-层-传输层"><a class="markdownIt-Anchor" href="#第-4-层-传输层"></a> 第 4 层 传输层</h2>
<p>传输层负责主机到主机的通信并在两个设备之间创建逻辑连接。 它包括启动设备之间的连接，设备之间的流控制，相同顺序的传递以及多重通信。</p>
<p>传输层上的两个主要协议如下：</p>
<ul>
<li>传输控制协议 Transmission Control Protocol (TCP)</li>
<li>用户数据报协议 User Datagram Protocol (UDP)</li>
</ul>
<p>这两个协议有一些共同点：</p>
<p>首先，两个协议都包含一个校验和。 此校验和是错误检测的一种方式。 当处理数据以进行发送时，发送设备将执行计算，该计算会基于正在发送的数据生成一个值。 接收设备执行相同的计算。 如果值匹配，则数据正确。</p>
<p>他们的另一个共同特点是能够进行多路通信。 这只是一台机器可以与另一台机器同时进行多个对话的一种复杂的说法。</p>
<p>另一个通用特性是使用逻辑端口号。</p>
<h3 id="逻辑端口"><a class="markdownIt-Anchor" href="#逻辑端口"></a> 逻辑端口</h3>
<p>在我们谈论交换机和路由器的端口时，我们讨论的是物理端口。</p>
<p>逻辑端口是软件中定义的端口。 逻辑端口的目的是允许接收设备识别数据要发送给哪个应用程序或服务。</p>
<p>TCP 和 UDP 标头均包含源端口号和目标端口号。当接收方设备接收到数据时，将检查目标端口号，然后设备会将数据传递给相关的应用程序或服务。</p>
<p>有 65,536 个逻辑端口号可用（编号为 0-65,535）。这些号码由**互联网号码分配局（IANA）**分配，并细分为多个范围：</p>
<ul>
<li>知名端口（0 - 1,023）：这些是分配给常用网络服务的端口</li>
<li>注册端口（1,024 - 49,151）：这些端口号是应开发人员的要求由 IANA 分配给应用程序或服务的</li>
<li>动态或临时端口（49,152 - 65,535）：这些端口不是 IANA 分配的，通常由客户端计算机用作源端口</li>
</ul>
<p>下表提供了一些常见端口及其端口号的详细信息：</p>
<table>
<thead>
<tr>
<th style="text-align:left">端口号</th>
<th style="text-align:left">服务/协议</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left">FTP</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left">SSH</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left">Telnet</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left">SMTP</td>
</tr>
<tr>
<td style="text-align:left">53</td>
<td style="text-align:left">DNS</td>
</tr>
<tr>
<td style="text-align:left">67, 68</td>
<td style="text-align:left">动态主机配置协议（DHCP）</td>
</tr>
<tr>
<td style="text-align:left">80</td>
<td style="text-align:left">HTTP</td>
</tr>
<tr>
<td style="text-align:left">88</td>
<td style="text-align:left">Kerberos</td>
</tr>
<tr>
<td style="text-align:left">110</td>
<td style="text-align:left">邮局协议 v3（POP3）</td>
</tr>
<tr>
<td style="text-align:left">123</td>
<td style="text-align:left">网络时间协议（NTP）</td>
</tr>
<tr>
<td style="text-align:left">137-139</td>
<td style="text-align:left">NetBIOS</td>
</tr>
<tr>
<td style="text-align:left">143</td>
<td style="text-align:left">IMAP</td>
</tr>
<tr>
<td style="text-align:left">161</td>
<td style="text-align:left">简单网络管理协议（SNMP）</td>
</tr>
<tr>
<td style="text-align:left">389</td>
<td style="text-align:left">轻型目录访问协议（LDAP）</td>
</tr>
<tr>
<td style="text-align:left">443</td>
<td style="text-align:left">安全超文本传输协议（HTTPS）</td>
</tr>
<tr>
<td style="text-align:left">3389</td>
<td style="text-align:left">远程桌面协议（RDP）</td>
</tr>
</tbody>
</table>
<p>活动 1：在此活动中，你将确定 PC 所打开的端口以及目标设备所连接的端口：</p>
<ol>
<li>打开命令行</li>
<li>运行 <code>netstat -a</code> 命令（-a 开关显示已连接的端口和侦听端口。由于 UDP 端口不建立连接，因此必须使用此开关查看它们。</li>
</ol>
<p>你应该会收到与以下屏幕截图类似的输出：</p>
<p><img src="../../images/network/netstat-a.jpg" alt="netstat-a" /></p>
<p><code>“Local Address”</code> 列详细说明了您的 IP 地址并指出了已打开的本地端口。</p>
<ol start="3">
<li><code>“Foreign Address”</code> 列详细说明了主机是通过名称还是 IP 地址连接的，并告诉我们目标设备上的端口</li>
<li>请注意，端口以数字或如果是知名端口，则以服务名称的形式详细列出。</li>
</ol>
<h3 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h3>
<p>TCP 被称为面向连接的协议。 这意味着在设备之间传输任何数据之前，需要先建立连接。 通过这样做，<strong>双方互相确定对方有能力接收和发送数据</strong>。 为了形成此连接，TCP 执行称为三向握手的过程，如下图所示。 过程如下：</p>
<ol>
<li><code>SYN</code>：发送设备将同步请求发送到目标计算机。 该同步包括序列号。 出于说明目的，假设序列号为 101。</li>
<li><code>SYN / ACK</code>：接收设备对 SYN 请求的确认进行响应。 该确认基本上是对接收者接下来期望的序列号的确认。 在这种情况下，它是 102。它还将自己的同步请求发送到始发设备。 在此示例中，我们将使用 201。 在此阶段，设备已同意用于通信的参数。</li>
<li><code>ACK</code>：始发设备确认来自接收者设备的同步请求。 同样，这是设备期望接收的下一个序列号。 在这个例子中，这个数字是 202。</li>
</ol>
<p><img src="../../images/network/three-way-handshake.jpg" alt="三次握手" /></p>
<p>握手完成后，数据可以在两个设备之间流动。 <strong>TCP 通过使用序号和确认的过程来保证数据的传递。</strong> 传输的数据分为多个段，每个段都包含一个序列号。 这使收件人可以在收据上重建数据。 另外，它允许接收者识别是否已接收到所有数据。 接收到数据后，接收方设备会将确认发送回接收方。 这种确认基本上是一种告诉始发设备接收者接下来希望接收哪个序列号的方法。 收到确认后，始发设备将下一批数据发送过去。</p>
<p>作为同步过程的一部分，这两个设备将在回送确认之前就将发送多少段达成一致。 通过减少发送的确认数量，这有助于减少网络开销。 这是一个称为滑动窗口的过程，非常灵活。 举例来说，假设他们同意在发送确认作为响应之前可以发送三个段。 如果接收方设备未收到所有三个段，因此未发送确认，则发送设备将在一段时间后意识到尚未收到确认，并将重新发送数据。 如果多次发生，则两个设备将同意使用一个较小的窗口来尝试减少数据丢失和重新发送的要求。</p>
<p>TCP 还包括称为流控制的功能。 此过程旨在减少拥塞。 如果接收方设备在努力跟上接收到的数据量，则可以向发送方发送“未就绪”消息。 清除网卡上的缓冲区后，设备将发送“就绪”消息，并且通信将恢复。</p>
<p>当设备希望停止通信时，它们将遵循四次握手过程，如下图所示：</p>
<ol>
<li>计算机 A 不再需要向计算机 B 发送任何数据，因此它发送 FIN 数据包。</li>
<li>计算机 B 接收 FIN 请求并作为响应发送回 ACK。</li>
<li>一旦计算机 B 没有更多数据则发送自己的 FIN 数据包到计算机 A。</li>
<li>计算机 A 接收 FIN 请求并作为响应发送回 ACK。</li>
</ol>
<p>该过程主要目的为：<code>双方互相确定对方不再需要发送数据。</code></p>
<p><img src="../images/network/four-way-handshake.jpg" alt="四次握手" /></p>
<ol start="5">
<li>一旦完成四次握手，设备将关闭端口。</li>
</ol>
<p>通过使用序列号，流控制和确认，TCP 的使用可确保向目标的传递（当然，只要连接基础结构正常工作）。 但是，这种保证是有代价的。 TCP 报头在发送的每个段中增加了额外的 20-60 字节数据，而确认则增加了带宽消耗，这除了等待确认之外，还导致数据传输速度变慢。 因此，当必须完全传输数据（例如文件共享或数据库事务）时，将使用 TCP。</p>
<h3 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h3>
<p>TCP 是面向连接的协议，而 UDP 是无连接协议。 这意味着在发送数据之前不会进行三次握手。 发送设备从字面上讲是通过有线方式发送数据，并希望目标设备能够接收到它。 它通常被称为尽力而为协议； 数据是否到达那里都没有关系，因为你有时候并不需要接收所有数据，可以容忍数据部分丢失。</p>
<p>这是一个更快的协议，因为它具有较小的标头（仅 8 个字节），并且没有添加到确认信息到带宽中。</p>
<p>UDP 也用于多播和广播传输。 在如此多的设备上发送数据之前，不可能进行三向握手。</p>
<p>在某些情况下，协议会同时使用 TCP 和 UDP，这取决于当时的功能。 DNS 和 DHCP 是这方面的两个完美示例。</p>
<p>总而言之，当数据传输至关重要且时间不受限制时，则应使用 TCP。 如果数据传输不重要和/或时间很紧迫，则应使用 UDP。</p>
<h2 id="第-3-层-网络层"><a class="markdownIt-Anchor" href="#第-3-层-网络层"></a> 第 3 层 网络层</h2>
<p>OSI 模型的网络层负责通过使用 IP 地址对设备进行逻辑寻址。 它还负责为要传输的数据选择路由，即如何从计算机 A 到计算机 B。</p>
<p>路由器[^ router]以及方便的第3层交换机[^ switches]在该层工作。</p>
<p>就网络层上的协议而言，最常见的如下：</p>
<ul>
<li>IP</li>
<li>互联网数据包交换（IPX）</li>
</ul>
<p>IP 是两者中最常见的，并且是所有网络的核心。 IPX 不在这里陈述，因为重点是 IP 寻址。 在此层，协议数据单元称为数据包，其标头将包括源和目标 IP 地址。</p>
<h2 id="第-2-层-数据链路层"><a class="markdownIt-Anchor" href="#第-2-层-数据链路层"></a> 第 2 层 数据链路层</h2>
<p>数据链路层仅在你自己的子网内相关，尽管在一定程度上确实如此，但我们仍然需要它来在子网外传输数据。 数据链路层在子网上的节点之间创建逻辑连接。 如果数据以同一子网中的设备为目的地，则链接将指向该设备； 如果数据以子网外的设备为目的地，则该链接将指向默认网关。 第 2 层上的协议数据单元是帧。</p>
<p>数据链接层的职责包括将数据放置到物理介质上，错误通知和流控制。 通过使用添加到数据的预告片中包括的校验和来执行错误通知。 除预告片外，还添加了标头，其中包括源和目标 MAC 地址。 第二层交换机[^ switches]在这里工作。</p>
<p>该层分为两个子层：</p>
<ul>
<li><strong>逻辑链路控制（LLC）</strong>：LLC 的任务是充当与网络层的接口，并标识所使用的网络层协议（例如 IP 或 IPX），并将该信息存储在帧头中。 发生这种情况是为了在另一端收到数据时，设备知道将其发送到哪个网络层协议。</li>
<li><strong>媒体访问控制（MAC）</strong>：MAC 子层负责控制如何将数据放置到某些媒体上，或者我们如何控制数据对媒体的访问。 MAC 子层可以被多种协议占用； 例如，802.3 和 802.11 驻留在此层上。</li>
</ul>
<h2 id="第-1-层-物理层"><a class="markdownIt-Anchor" href="#第-1-层-物理层"></a> 第 1 层 物理层</h2>
<p>数据以位的形式在该层上进行物理传输。 根据媒体类型和所使用的网卡，发送数据的方法会有所不同。 重要的是，两端都使用相同的方法。 这些信号可以采用电压变化的形式，也可以采用透射光的模式。</p>
<p>在这一层上，没有协议，但是电缆和网卡需要遵守一些标准和准则。 这些标准包括以下内容：</p>
<ul>
<li>电压等级 Voltages</li>
<li>速度 Speeds</li>
<li>布线 Wiring</li>
</ul>
<h1 id="tcp-ip-模型"><a class="markdownIt-Anchor" href="#tcp-ip-模型"></a> TCP / IP 模型</h1>
<p>在学习 TCP / IP 模型时，你会注意到该模型与 OSI 模型有很多相似之处。 它们都采用分层方法，每一层与目标设备上的相邻层以及它们各自的层通信。 像 OSI 模型一样，TCP / IP 模型是开放或非专有的标准，这意味着任何制造商都可以使用它。</p>
<p><img src="../../images/network/tcp-ip.png" alt="Tcp/Ip" /></p>
<p>如上图所示，与 OSI 模型的七个层相比，TCP / IP 模型只有四个层。 这些层如下：</p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ul>
<blockquote>
<p>作为一般经验法则，如果它们是按编号引用的层，例如，第1层，第2层等，而不是第一层，第二层等，则它们通常是指 OSI 模型。 TCP / IP 模型倾向于依靠单词而不是数字。</p>
</blockquote>
<p>封装和解封装也在 TCP / IP 模型中起作用。 随着数据在模型中上下移动，标头和尾部将添加到数据中。 TCP / IP模型有时称为 Internet 协议（IP）套件，因为它是用于跨 Internet 通信的协议的集合。 这些协议一起形成协议栈。 协议栈是协议的集合，这些协议一起工作以执行特定的总体功能。</p>
<h2 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h2>
<p>类似于 OSI 模型中的名称，TCP / IP 模型的应用层充当应用程序自身和网络堆栈之间的接口，而不是应用程序实际所在的位置。 同样，这是通过使用 API 和编程库实现的。 该层执行 OSI 模型中应用层和表示层的功能，包括数据的格式化，压缩和加密。</p>
<p>在应用层上有许多协议正在使用，这些协议可以分为两个区域：</p>
<ul>
<li>用户协议 User protocols</li>
<li>支撑协议 Support protocols</li>
</ul>
<h3 id="用户协议"><a class="markdownIt-Anchor" href="#用户协议"></a> 用户协议</h3>
<p>用户协议通常可以定义为用户与之交互的应用程序所使用的协议。 让我们看一些常见的用户协议：</p>
<h4 id="telnet"><a class="markdownIt-Anchor" href="#telnet"></a> Telnet</h4>
<p>Telnet 是一种从 CLI 远程控制设备的方法，Telnet 在端口 <code>23</code> 上工作，并提供了基于文本的低带宽与其他设备进行通信的方式。 为了使 telne t正常工作，您需要在要向其发送命令的设备上运行 telnet 服务器，并且您必须自己运行 telnet 客户端。</p>
<p>我将告诉您不要使用它，除非作为最后的手段或建立更安全的连接（如 SSH）的手段。 Telnet 开箱即用，而 SSH 需要配置。 您可能想知道为什么我会这样说。 这很简单。 Telnet 以明文形式发送所有数据，包括您的用户名和密码。 因此，攻击者可以窃听此信息。默认情况下，大多数网络设备（例如路由器和交换机）都启用了 Telnet。 尽快将其禁用。</p>
<h4 id="ftp"><a class="markdownIt-Anchor" href="#ftp"></a> FTP</h4>
<p>FTP 的作用恰如其名（超文本传输）。 它使您可以使用端口 <code>20</code> 和 <code>21</code> 将文件从一台设备传输到另一台设备。不要将这种协议误认为是组织的网络共享系统，因为后者更可能是服务器消息块（SMB）。</p>
<p>要使用 FTP，我们需要在服务器上安装一个 FTP 服务器应用程序来托管我们要访问的文件，并且我们必须自己运行 FTP 客户端。 FTP 运行在 TCP 上，您可能还记得，它保证了数据的正确传递。</p>
<h4 id="简单邮件传输协议"><a class="markdownIt-Anchor" href="#简单邮件传输协议"></a> 简单邮件传输协议</h4>
<p>简单邮件传输协议（SMTP）通常提供两种功能。 它允许您从电子邮件客户端（例如 Outlook）向电子邮件服务器发送电子邮件。 它还允许您的电子邮件服务器将邮件从您的电子邮件服务器传输到另一个电子邮件服务器。 这两个功能都是通过端口 <code>25</code> 执行的。</p>
<h3 id="支撑服务"><a class="markdownIt-Anchor" href="#支撑服务"></a> 支撑服务</h3>
<p>支撑协议可以定义为系统本身使用的协议。</p>
<h4 id="主机初始化"><a class="markdownIt-Anchor" href="#主机初始化"></a> 主机初始化</h4>
<p>他提供了一种在没有安装自己的操作系统的情况下通过网络引导计算机的方法。 通过网络引导需要计算机具有支持**预引导执行环境（PXE）**的网卡。 尽管可能必须在系统的 BIOS 中启用它，但大多数现代系统都支持此功能。</p>
<h4 id="远程管理"><a class="markdownIt-Anchor" href="#远程管理"></a> 远程管理</h4>
<p>此服务允许通过使用协议（例如在端口 <code>161</code> 上运行的<strong>简单网络管理协议（SNMP</strong>））来管理设备。SNMP 需要主机上的 SNMP 代理，该代理再与 SNMP 服务器通信。 这些通信包括属性及其值，例如可用磁盘空间，CPU 使用率等。 但是，这不是单向过程，服务器也可以将设置传达回设备以进行远程配置。</p>
<h4 id="域名系统"><a class="markdownIt-Anchor" href="#域名系统"></a> 域名系统</h4>
<p>**域名系统（DNS）<strong>在这里它被归类为支撑服务，并将</strong>完全限定的域名（FQDN）**解析为 IP 地址。 一旦应用层履行了其职责，它将数据传递给传输层。</p>
<h2 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h2>
<p>TCP / IP 模型的传输层执行与 OSI 模型中的对应层完全相同的角色。 即，它负责控制两个主机之间的通信。 回想一下，传输层提供了以下功能：</p>
<ul>
<li>使用校验和来确保数据完整性</li>
<li>使用序列号确保数据以正确的顺序重建</li>
<li>流量控制以确保所接收的数据不会最终堵塞收件人设备</li>
<li>多路复用以允许主机与另一个主机建立多个连接</li>
</ul>
<h2 id="网际层"><a class="markdownIt-Anchor" href="#网际层"></a> 网际层</h2>
<p>网际层映射到 OSI 的网络层。尽管名称不同，但这两个层执行相同的功能。它们都通过使用 IP 地址来提供逻辑寻址。 通过使用 IP 地址（和子网掩码），我们可以确定主机是发送设备的本地主机还是远程网络。 如果目标位于远程网络上，则在通过路由器，路由服务器或第 3 层交换机进行路径选择和数据转发过程中，还将使用 IP 地址。请注意，尽管 TCP / IP 模型未使用编号，但在这里我还是使用术语第3层，这纯粹是出于熟悉。</p>
<p>该层上的三个主要协议如下：</p>
<ul>
<li>IP</li>
<li>Internet 控制报文协议（ICMP）</li>
<li>Internet 组管理协议  (IGMP)</li>
</ul>
<p>设备使用 ICMP 相互发送错误和控制消息。这些消息可以指出，主机不可访问，主机可访问但主机上的端口不可访问，网络不可访问等等。 这些控制消息是通过使用类型和子类型在 ICMP 数据中标识的。<code>ping</code> 和 <code>tracert</code> 命令使用了 ICMP。</p>
<p>IGMP 用于创建设备的逻辑组。这些逻辑组将在多播传输期间和 IPv4 中使用。</p>
<h2 id="网络接口层"><a class="markdownIt-Anchor" href="#网络接口层"></a> 网络接口层</h2>
<p>TCP / IP 模型的网络层映射到 OSI 模型的数据链路层和物理层。因此，它将这两个 OSI 层的功能合并到这一 TCP / IP 层中。</p>
<p>网际层主要负责主机网络外部的通信并路由此数据，而网络接口层则负责链路（基本上是同一子网内的任何事物）上的通信。因此，有时将网络接口层称为链路层。媒体访问控制是在 TCP / IP 模型的网络接口层上执行的，因此可以在此处找到 MAC 地址。此外，物理介质的属性（例如调制和编码）也在此处。 网络接口层中有许多协议和标准。 其中包括 IEEE 802.3 以太网，IEEE 802.11，点对点协议（PPP），地址解析协议（ARP）和帧中继。</p>
<hr />
<p>[^ router]: 在这个相互连接和全球通信的时代，我们必须开始研究网络之间的通信，而不仅仅是同一个子网中的设备之间的通信。 这种通信的一个关键组成部分是路由器。 这种无处不在的网络设备允许网络之间进行有效的通信，无论这些网络是我们组织内部的网络还是世界另一端的远程网络。<br />
[^ switches]: 交换机是一种用于在本地网络中将流量从一台设备转发到另一台设备的设备。 通过将交换机引入我们的网络，我们提供了一种将网络划分为更小，更易于管理和更高效的区域的方法。第 2 层交换机仅支持使用基于 MAC 地址的转发数据，而第 3 层交换机在能够识别接口的 IP 地址方面也提供了额外的支持，并且还提供了使用 IP 地址进行流量路由的功能。 在 VLAN 之间路由流量时，这是必不可少的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>OSI</tag>
        <tag>TCP/IP</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC 与进程间通信</title>
    <url>/network/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8EgRPC/</url>
    <content><![CDATA[<p>随着时间的流逝，进程间通信技术已经发生了巨大的发展。出现了各种这样的技术来满足现代需求并提供更好和更有效的开发体验。让我们看一些最常用的进程间通信技术，并与 gprc 做个比较。</p>
<h2 id="常规-rpc"><a class="markdownIt-Anchor" href="#常规-rpc"></a> 常规 RPC</h2>
<p>RPC 是用于构建客户服务应用程序的流行的进程间通信技术。使用 RPC，客户端可以远程调用方法，就像调用本地方法一样。早期有流行的 RPC 实现，例如通用对象请求代理体系结构（CORBA）和 Java 远程方法调用（RMI），它们用于构建和连接服务或应用程序。但是，大多数此类常规 RPC 实现极其复杂，因为它们建立在诸如 TCP 之类的通信协议之上，这阻碍了不同程序间的交互，而且各自的规范很臃肿。</p>
<p>RPC（Remote Procedure Call）—远程过程调用，是指计算机程序使过程（子程序）在不同的地址空间（通常在共享网络的另一台计算机上）执行时，其编码就像是普通的（本地）过程调用，无需程序员为远程交互明确编码细节。</p>
<a id="more"></a>
<p>RPC 是进程间通信（IPC）的一种形式，因为不同的进程具有不同的地址空间：如果在同一主机上，即使物理地址空间相同，它们也具有不同的虚拟地址空间（Java 虚拟机）；如果它们位于不同的主机上，则物理地址空间是不同的。为了让不同的客户端访问服务器，已经创建了许多标准化的 RPC 系统。其中大多数使用接口描述语言（IDL）来让各种平台调用 RPC。可以使用 IDL 文件生成代码以在客户端和服务器之间建立接口。</p>
<p>在面向对象的编程范例中，RPC 调用由远程方法调用（RMI）表示。</p>
<p>该协议介于 OSI 网络模型的应用层和传输层，这里就要说下 RPC 协议主要内容。</p>
<p>实现 RPC 主要分为 5 个部分：</p>
<ol>
<li>User</li>
<li>User-stub</li>
<li>RPCRuntime</li>
<li>Server-stub</li>
<li>Server</li>
</ol>
<p><img src="../../images/network/rpc-structure.png" alt="RPC结构" />这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。</p>
<p>网络层传输并没有明确的规定，所以就有基于 HTTP/2 的 gRPC，但是大多数还是直接使用 TCP 协议直接传输的。传输的内容格式也没有明确规定，JSON/XML/套接字都有可能。</p>
<h2 id="soap"><a class="markdownIt-Anchor" href="#soap"></a> SOAP</h2>
<p>由于诸如 CORBA 之类的常规 RPC 实现的局限性，微软，IBM 等大型企业设计并大力推广了简单对象访问协议（SOAP）。SOAP 是面向服务的体系结构中的标准通信技术（SOA）以在服务（在 SOA 上下文中通常称为 Web 服务）之间交换基于 XML 的结构化数据，并通过任何基础通信协议（例如 HTTP（最常用））进行通信。使用 SOAP，您可以定义服务接口，该服务的操作以及用于调用这些操作的关联 XML 消息格式。 SOAP 是一种非常流行的技术，但是消息格式的复杂性以及围绕 SOAP 构建的规范的复杂性阻碍了构建分布式应用程序的敏捷性。 因此，在现代分布式应用程序开发的上下文中，SOAP Web 服务被认为是一种遗留技术。 现在，大多数现有的分布式应用程序都在使用 REST 体系结构样式来开发，而不是使用 SOAP。</p>
<h2 id="rest"><a class="markdownIt-Anchor" href="#rest"></a> REST</h2>
<p>表现层状态转化（REST）是一种架构风格， REST 是面向资源的体系结构（ROA）的基础，您可以在其中将分布式应用程序建模为资源的集合，访问这些资源的客户端可以更改这些资源的状态（创建，读取，更新或删除）。</p>
<p>REST 的实际实现是 HTTP，在 HTTP 中，您可以将 RESTful Web 应用建模为使用唯一标识符（URL）可访问的资源的集合。 状态更改操作以 HTTP 谓词（GET，POST，PUT，DELETE，PATCH等）的形式应用于这些资源之上。 资源状态以文本格式表示，例如 JSON，XML，HTML，YAML 等。</p>
<p>使用具有 HTTP 和 JSON 的 REST 架构风格构建应用程序已成为构建微服务的实际方法。 但是，随着微服务及其网络交互的数量激增，RESTful 服务无法满足预期的现代要求。 RESTful 服务有几个关键限制，这些限制限制了将它们用作基于现代微服务的应用程序的消息传递协议的能力。</p>
<h3 id="低效的基于文本的消息协议"><a class="markdownIt-Anchor" href="#低效的基于文本的消息协议"></a> 低效的基于文本的消息协议</h3>
<p>RESTful 服务本质上是建立在基于文本的传输协议（例如 HTTP 1.x）的基础之上的，并利用了人类可读的文本格式（例如 JSON）。 当涉及到服务之间的通信时，使用文本格式（例如 JSON）效率很低，因为该通信的双方都不需要使用这种人类可读的文本格式。</p>
<p>客户端应用程序（源）生成要发送到服务器的二进制内容，然后将二进制结构转换为文本（因为使用 HTTP 1.x，您必须发送文本消息）并通过网络以文本形式（通过 HTTP）发送它到一台机器，该机器在服务（目标）端解析并将其转换为二进制结构。 相反，我们可以轻松地发送二进制格式，该格式可以映射到服务和消费者的业务逻辑。 使用 JSON 的一种流行说法是，它易于使用，因为它是“人类可读的”。 这不是二进制协议的问题，而是更多的工具问题。</p>
<h3 id="应用之间缺乏强类型接口"><a class="markdownIt-Anchor" href="#应用之间缺乏强类型接口"></a> 应用之间缺乏强类型接口</h3>
<p>随着使用完全不同的多语言技术构建的通过网络进行交互的服务的数量不断增加，缺乏明确定义和强类型化的服务定义是一个主要的挫折。 我们在 RESTful 服务中拥有的大多数现有服务定义技术（例如 OpenAPI / Swagger）都是经过深思熟虑的，并未与基础架构样式或消息传递协议紧密集成。</p>
<p>在构建此类分散式应用程序时，这会导致许多不兼容性，运行时错误和互操作性问题。 例如，当您开发 RESTful 服务时，不需要具有在应用程序之间共享的信息的服务定义和类型定义。 相反，您可以在网上查看文本格式或第三方 API 定义技术（例如 OpenAPI）来开发 RESTful 应用程序。 因此，具有现代强类型服务定义技术和为多语言技术生成服务器端和客户端代码核心的框架是关键必要条件。</p>
<h3 id="rest-架构风格难以实施"><a class="markdownIt-Anchor" href="#rest-架构风格难以实施"></a> REST 架构风格难以实施</h3>
<p>作为一种体系结构样式，REST 具有很多“良好实践”，您需要遵循这些“良好实践”才能提供真正的 RESTful 服务。 但是，它们不是作为实施协议（例如 HTTP）的一部分实施的，这使得在实施阶段很难实施它们。 因此，在实践中，大多数声称为 RESTful 的服务并未正确遵循 REST 风格的基础。 因此，大多数所谓的 RESTful 服务仅仅是通过网络公开的 HTTP 服务。 因此，开发团队必须花费大量时间来维护 RESTful 服务的一致性和纯度。</p>
<p>由于进程间通信技术在构建现代云本机应用程序中存在所有这些局限性，因此开始寻求发明更好的消息协议。</p>
<h2 id="grpc-的诞生"><a class="markdownIt-Anchor" href="#grpc-的诞生"></a> gRPC 的诞生</h2>
<p>Google 一直在使用一种称为 Stubby 的通用 RPC 框架来连接成千上万的微服务，这些微服务跨多个数据中心运行并使用不同的技术构建，它的核心 RPC 层旨在处理每秒数百亿个请求的互联网规模。 Stubby 具有许多出色的功能，但由于它与 Google 内部基础架构紧密相关，因此尚未标准化用作通用框架。</p>
<p>2015 年，Google 发布了 gRPC 作为开源 RPC 框架； 它是一个标准化的，通用的，跨平台的 RPC 基础结构。 gRPC 旨在提供与 Stubby 相同的可伸缩性，性能和功能，但可以为整个社区提供。</p>
<p>从那时起，随着 Netflix，Square，Lyft，Docker，Cisco 和 CoreOS 等主要公司的大规模采用，gRPC 的普及在过去几年中急剧增长。 后来，gRPC 加入了 Cloud Native Computing Foundation（CNCF），这是最受欢迎的开源软件基金会之一，致力于使云原生计算具有通用性和可持续性。 gRPC 从 CNCF 生态系统项目中获得了很大的吸引力。</p>
<h2 id="为什么选择-grpc"><a class="markdownIt-Anchor" href="#为什么选择-grpc"></a> 为什么选择 gRPC</h2>
<p>gRPC 被设计为一种互联网规模的进程间通信技术，可以克服常规进程间通信技术的大多数缺点。由于 gRPC 的优势，大多数现代应用程序和服务器越来越多地将其进程间通信协议转换为 gRPC。那么，当有很多其他选项可用时，为什么有人会选择 gRPC 作为通信协议呢？ 让我们更仔细地看一下 gRPC 带来的一些关键优势</p>
<h2 id="grpc-的优点"><a class="markdownIt-Anchor" href="#grpc-的优点"></a> gRPC 的优点</h2>
<p>gRPC 带来的优势是 gRPC 越来越被采用的关键。 这些优点包括：</p>
<ul>
<li>高效的进程间通信</li>
</ul>
<p>gRPC 不使用 JSON 或 XML 之类的文本格式，而是使用基于协议缓冲区的二进制协议与 gRPC 服务和客户端进行通信。 同样，gRPC 在 HTTP / 2 之上实现协议缓冲区，这使得进程间通信的速度甚至更快。 这使 gRPC 成为最高效的进程间通信技术之一。</p>
<ul>
<li>它具有简单，定义明确的服务接口和架构</li>
</ul>
<p>gRPC 促进了合同优先的方法来开发应用程序。 您首先定义服务接口，然后再处理实现细节。 因此，与用于 RESTful 服务定义的 OpenAPI / Swagger 和用于 SOAP Web 服务的 WSDL 不同，gRPC 提供了简单但一致，可靠，可扩展的应用程序开发体验。</p>
<ul>
<li>它是强类型的</li>
</ul>
<p>由于我们使用协议缓冲区定义 gRPC 服务，因此 gRPC 服务协定明确定义了将用于应用程序之间通信的类型。 这使分布式应用程序开发更加稳定，因为静态类型有助于克服在构建跨多个团队和技术的云本机应用程序时遇到的大多数运行时和互操作性错误。</p>
<ul>
<li>多语言支持</li>
</ul>
<p>gRPC 旨在与多种编程语言一起使用。 带有协议缓冲区的 gRPC 服务定义与语言无关。 因此，您可以选择自己喜欢的语言，但可以与任何现有的 gRPC 服务或客户端进行互操作。</p>
<ul>
<li>它具有双工流</li>
</ul>
<p>gRPC 具有对客户端或服务器端流的本机支持，该支持包含在服务定义本身中。 这使开发流服务或流客户端变得更加容易。 与传统的 RESTful 消息传递样式相比，构建常规的请求-响应样式消息传递以及客户端和服务器端流传输的能力是一个关键优势。</p>
<ul>
<li>它具有内置产品功能</li>
</ul>
<p>gRPC 为产品提供内置支持，例如身份验证，加密，弹性（最后期限和超时），元数据交换，压缩，负载平衡，服务发现等。</p>
<ul>
<li>它与云原生生态系统集成</li>
</ul>
<p>gRPC 是 CNCF 的一部分，大多数现代框架和技术都提供了对 gRPC 的本地支持。 例如，CNCF 下的许多项目（例如 Envoy）都支持 gRPC 作为通信协议。 对于指标和监控等跨领域功能，大多数此类工具都支持 gRPC（例如，使用 Prometheus 监控 gRPC 应用程序。</p>
<ul>
<li>它已经成熟并被广泛采用</li>
</ul>
<p>gRPC 通过在 Google 上进行的艰苦的测试而变得成熟，许多其他大型科技公司（例如 Square，Lyft，Netflix，Docker，Cisco 和 CoreOS）都采用了 gRPC 。</p>
<p>与任何技术一样，gRPC 也具有某些缺点。 在应用程序开发期间了解这些缺点非常有用。 因此，让我们看一下 gRPC 的一些局限性。</p>
<h2 id="grpc-的缺点"><a class="markdownIt-Anchor" href="#grpc-的缺点"></a> gRPC 的缺点</h2>
<p>在选择 gRPC 来构建应用程序时，需要注意一些 gRPC 的缺点。 这些包括以下内容：</p>
<ul>
<li>它可能不适合外部服务</li>
</ul>
<p>当您想通过 Internet 向外部客户端公开应用程序或服务时，gRPC 可能不是最合适的协议，因为大多数外部使用者都刚接触 gRPC 和 REST / HTTP。合同驱动的 gRPC 服务的强类型性质可能会阻碍您向外部各方公开服务的灵活性，并且消费者获得的控制权将大大降低。</p>
<ul>
<li>彻底的服务定义更改是一个复杂的开发过程</li>
</ul>
<p>模式（Schema）修改在现代服务间通信用例中非常普遍。 当 gRPC 服务定义发生重大变化时，通常我们需要为客户端和服务器重新生成代码。 这需要合并到现有的持续集成过程中，并且可能使整个开发生命周期复杂化。 但是，大多数 gRPC 服务定义更改都可以在不破坏服务合同的情况下得到满足，并且只要不引入重大更改，gRPC 就会使用不同版本的协议与客户端和服务器愉快地进行互操作。 因此在大多数情况下不需要代码重新生成。</p>
<ul>
<li>生态系统比较小</li>
</ul>
<p>与传统的 REST / HTTP 协议相比，gRPC 生态系统仍然相对较小。 浏览器和移动应用程序中对 gRPC 的支持仍处于原始阶段。</p>
<p>在开发应用程序时，您必须注意这些限制。 因此，显然，gRPC 不是您应该用于所有进程间通信需求的技术。 相反，您需要评估业务用例和需求并选择适当的消息传递协议。</p>
<h2 id="grpc-与其他协议graphql-和-thrift"><a class="markdownIt-Anchor" href="#grpc-与其他协议graphql-和-thrift"></a> gRPC 与其他协议：GraphQL 和 Thrift</h2>
<p>我们已经详细讨论了 REST 的一些关键限制，这些限制为 gRPC 的诞生奠定了基础。 类似地，有许多新兴的进程间通信技术可以满足相同的需求。 因此，让我们看一些流行的技术，并将其与 gRPC 进行比较。</p>
<h3 id="apache-thrift"><a class="markdownIt-Anchor" href="#apache-thrift"></a> Apache Thrift</h3>
<p>Apache Thrift 是一个类似于 gRPC 的 RPC 框架（最初在 Facebook 开发，后来捐赠给 Apache）。 它使用自己的接口定义语言，并支持多种编程语言。 Thrift 允许您在定义文件中定义数据类型和服务接口。 通过将服务定义作为输入，Thrift 编译器为客户端和服务器端生成代码。 Thrift 传输层为网络 I / O 提供抽象，并将 Thrift 与系统的其余部分解耦，这意味着它可以在任何传输实现（例如 TCP，HTTP 等）上运行。</p>
<p>如果将 Thrift 与 gRPC 进行比较，您会发现两者都遵循相同的设计和使用目标。 但是，两者之间有几个重要的区别：</p>
<ul>
<li>协议</li>
</ul>
<p>gRPC 比 Thrift 更超前，提供对 HTTP / 2 的一流支持。 它在 HTTP / 2 上的实现利用该协议的功能来实现效率并支持诸如流的消息传递模式。</p>
<ul>
<li>流</li>
</ul>
<p>gRPC 服务定义本身支持双向流（客户端和服务器），这是服务定义本身的一部分。</p>
<ul>
<li>采用和社区</li>
</ul>
<p>在采用方面，gRPC 似乎发展势头良好，并且已成功围绕 CNCF 项目建立了良好的生态系统。 同样，社区资源，例如良好的文档，外部演示文稿和示例用例，对于 gRPC 来说是很常见的，与 Thrift 相比，采用过程更加流畅。</p>
<h3 id="graphql"><a class="markdownIt-Anchor" href="#graphql"></a> GraphQL</h3>
<p>GraphQL 是另一种技术（由 Facebook 发明并标准化为一种开放技术），在构建进程间通信中变得非常流行。 它是 API 的查询语言，是用于使用现有数据完成这些查询的运行时。 GraphQL 通过允许客户端确定所需的数据，所需的数据以及所需的格式，为传统的客户端-服务器通信提供了根本不同的方法。 相反，gRPC 与支持客户机和服务器之间通信的远程方法具有固定的约定。</p>
<p>GraphQL 更适合直接暴露给消费者的外部服务或 API，在这些环境中，客户端需要对来自服务器的数据进行更多控制。 例如，在我们的在线零售应用程序场景中，假设 ProductInfo 服务的使用者仅需要有关产品的特定信息，而不需要产品的整个属性集，并且使用者还需要一种方法来指定他们想要的信息。 借助 GraphQL，您可以对服务进行建模，从而使消费者可以使用 GraphQL 查询语言来查询服务并获取所需的信息。</p>
<p>在大多数 GraphQL 和 gRPC 实用的用例中，GraphQL 被用于面向外部的服务/ API，而支持 API 的内部服务是使用 gRPC 实现的。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>进程通信</tag>
        <tag>gRPC</tag>
        <tag>SOAP</tag>
        <tag>RPC</tag>
        <tag>Thrift</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引初探</title>
    <url>/persistence/db/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>索引是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。<br />
索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。</p>
<span id="more"></span>
<h1 id="索引的类型"><a class="markdownIt-Anchor" href="#索引的类型"></a> 索引的类型</h1>
<p>索引有很多种类型，可以为不同的场景提供更好的性能。在 <code>MySQL</code> 中，案引是存储引擎层而不是服务器层实现的，所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<p>下面列举 <code>MySQL</code> 常见的索引类型，以及他们的优缺点。</p>
<h2 id="b-tree-索引"><a class="markdownIt-Anchor" href="#b-tree-索引"></a> B-Tree 索引</h2>
<p>当人们讨论索引的时候，如果没有特别指明类型，那多半说的是 B-Tree 索引，术语 <code>B-Tree</code> 并不特别指它的存储结构就是 <code>B-Tree</code>，<code>InnoDB</code> 使用的就是它的变种 <code>B+Tree</code>。</p>
<blockquote>
<p>B 树是二叉树的升级版，又叫平衡多路查找树，它的结点可以有很多子节点，二叉树最多只有 2 个子节点。</p>
<p>B+ 树是应文件系统所需而产生的一种 B 树的变形树，只有最底层的叶子节点保存数据，非叶子节点只保存索引，不保存实际的数据。</p>
<p>B+ 数中每个叶子节点都包含指向下一个叶子结点的顺序访问指针，方便叶子结点的范围遍历，节点的链接也方便了磁盘的顺序 IO。</p>
</blockquote>
<p><code>B-Tree</code> 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。下图展示了 <code>B-Tree</code> 索引的抽象表示，大致表示了 <code>InnoDB</code> 索引是如何工作的。</p>
<p><img src="../../../images/db/b+tree_index.png" alt="B+Tree 索引" /></p>
<p>B-Tree 索引能够加快访问数据的速度，因为存储引起不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根结点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。</p>
<p>叶子结点比较特别，他们的指针指向的是被索引的数据，而不是其它的节点页。下图绘制了一个节点和其对应的叶子节点，其实在根节点和叶子节点之间可能有很多层节点页，树的深度和表的大小直接相关。</p>
<p>**B-Tree 对索引列是顺序组织存储的，所以很适合范围查找数据。**例如，在一个基于文本域的索引树上，像“找出所有以 I 到 K 开头的名字”这样的查找效率会非常高。</p>
<p>假如有如下一张表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People (</span><br><span class="line">    last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    dob <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender enum(<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>表中的每一行数据，索引中包含了 last_name、first_name 和 dob 列中的值，下图展示了该索引是如何组织数据存储的。</p>
<p><img src="../../../images/db/tree_item.png" alt="索引树中的部分条目" /></p>
<p>请注意，**索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。**看一下最后两个条目，两个人的姓和名都一样，则根据他们的出生日期来排列顺序。</p>
<p>可以使用 B-Tree 索引的查询类型。 B-Tree 索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找，前面所述的索引对如下类型的查询有效。</p>
<p><em><strong>全值匹配</strong></em></p>
<p>全值匹配指的是和索引中的所有列进行匹配，例如前面提到的索引可用于查找姓名为 Cuba Allen，出生于 1960-01-01 的人。</p>
<p><em><strong>匹配最左前缀</strong></em></p>
<p>前面提到的索引可用于查找所有姓为 Allen 的人，即只使用索引的第一列。</p>
<p><em><strong>匹配列前缀</strong></em></p>
<p>也可以只匹配某一列值的开头部分。例如前面提到的索引可用于查找所有以 J 开头的姓的人。这里也只使用索引的第一列。</p>
<p><em><strong>匹配范围值</strong></em></p>
<p>例如前面提到的索引可用于查找姓在 Allen 和 Barrymore 之间的人。这里也只使用了索引的第一列。</p>
<p><em><strong>精确匹配某一列并范围匹配另外一列</strong></em></p>
<p>前面提到的索引也可用于査找所有姓为 Allen，并且名字是字母 K 开头(比如 Kim、Karl 等)的人。即第一列 last_name 全匹配，第二列 first_name 范围匹配。</p>
<p><em><strong>只访问索引的查询</strong></em></p>
<p>B-Tree 通常可以支持“只访问索引的査询”，即査询只需要访问索引，而无须访问数据行。后面我们将单独讨论这种“覆盖索引”的优化。</p>
<p>因为索引树中的节点是有序的，所以除了按值査找之外，索引还可以用于査询中的 <code>ORDER BY</code> 操作(按顺序査找)。一般来说，如果 <code>B-Tree</code> 可以按照某种方式査找到值，那么也可以按照这种方式用于排序。所以，如果 <code>ORDER BY</code> 子句满足前面列出的几种査询类型，则这个索引也可以满足对应的排序需求。</p>
<p>下面是一些关于 B-Tree 索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始査找，则无法使用索引。例如上面例子中的索引无法用于査找名字为 Bill 的人，也无法査找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法査找姓氏以某个字母结尾的人。</li>
<li>不能跳过索引中的列。也就是说，前面所述的索无法用于査找姓为 Smith 并且在某个特定日期出生的人。如果不指定名 (first name)，则 MYSQL 只能使用索引的第一列。</li>
<li>如果査询中有某个列的范围査询，则其右边所有列都无法使用索引优化査找。例如有査询 <code>WHERE last name=' Smith' AND first name LIKE'1%' AND dob='1976 12-23'</code>，这个査询只能使用索引的前两列，因为这里 <code>LIKE</code> 是一个范围条件(但是服务器可以把其余列用于其他目的)。如果范围査询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。</li>
</ul>
<h3 id="为什么使用-b-tree-btree"><a class="markdownIt-Anchor" href="#为什么使用-b-tree-btree"></a> 为什么使用 B-Tree (B+Tree)</h3>
<p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析 B-/+Tree 作为索引的效率。</p>
<h4 id="局部性原理与磁盘预读"><a class="markdownIt-Anchor" href="#局部性原理与磁盘预读"></a> 局部性原理与磁盘预读</h4>
<p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘 I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p><strong>当一个数据被用到时，其附近的数据也通常会马上被使用。</strong></p>
<p><strong>程序运行期间所需要的数据通常比较集中。</strong></p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高 I/O 效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h4 id="b-tree-索引的性能分析"><a class="markdownIt-Anchor" href="#b-tree-索引的性能分析"></a> B-/+Tree 索引的性能分析</h4>
<p>从使用磁盘 I/O 次数评价索引结构的优劣性：根据 B-Tree 的定义，可知检索一次最多需要访问 h 个结点。数据库系统的设计者巧妙的利用了磁盘预读原理，<strong>将一个结点的大小设为等于一个页面（默认 16 kb）</strong>，这样每个结点只需要一次 I/O 就可以完全载入。为了达到这个目的，在实际实现 B-Tree 还需要使用如下技巧：</p>
<p>每次新建结点时，直接申请一个页面的空间，这样可以保证一个结点的大小等于一个页面，加之计算机存储分配都是按页对齐的，就实现了一个 node 只需一次 I/O。</p>
<p>**B-Tree 中一次检索最多需要 h-1 次 I/O（根结点常驻内存），渐进复杂度为 O(h)=O(log<sub>d</sub>N)。**一般实际应用中，出读 d 是非常大的数字，通常超过 100，因此 h 非常小。</p>
<p>综上所述，用 B-Tree 作为索引结构效率是非常高的。</p>
<p>而红黑树结构，h 明显要深得多。由于逻辑上很近的结点（父子结点）物理上可能离得很远，无法利用局部性原理。所以即使红黑树的 I/O 渐进复杂度也为 O(h)，但是查找效率明显比 B-Tree 差得多。</p>
<h2 id="哈希索引"><a class="markdownIt-Anchor" href="#哈希索引"></a> 哈希索引</h2>
<p>哈希索引 (hash index) 基于哈希表实现，只有精确匹配索引所有列的査询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码 (hash code)，哈希码是个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>因为索自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引査找的速度非常快。然而，哈希索引也有它的限制：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li>
<li>哈希索引也不支持部分索引列匹配査找，因为哈希索始终是使用索引列的全部内容来计算哈希值的。例如，在数据列 (A,B) 上建立哈希索引，如果査询只有数据列 A，则无法使用该索引。</li>
<li>哈希索引只支持等值比较査询，包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>(注意 <code>&lt;&gt;</code> 和 <code>&lt;=&gt;</code> 是不同的操作，该操作是 NULL-safe equals)。也不支持任何范围査询，例如 <code>WHERE price&gt;100</code>。</li>
<li>访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。当出现哈希冲突的时候，存储引檠必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。</li>
</ul>
<p>InnoDB 引擎有一个特殊的功能叫做“<strong>自适应哈希索引 (adaptive hash index)</strong>”。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速的哈希査找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。</p>
<p>**创建自定义哈希索引。**如果我们即想使用 B-Tree 的优势，又想使用哈希索引增加速度，可以创建一个单独的列来存放数据的伪哈希索引。这和真正的哈希索引不是一回事，因为还是使用 B-Tree 进行查找，但是它使用哈希值而不是键本身进行索引査找。你需要做的就是在査询的 WHERE 子句中手动指定使用哈希函数。</p>
<p>如果采用这种方式，不要使用 <code>SHA1()</code> 或 <code>MD5()</code> 这种哈希函数，因为他们计算出的哈希值会非常长，浪费空间。它们设计目标是最大程度消除冲突，如果我们的数据量不是特别大，可以使用 <code>CRC32()</code> 这样的函数或者自己编写哈希函数，最简单的就是取前面这种强哈希函数的一部分。CRC32() 返回的是 32 位的整数,当索引有 93000 条记录时出现冲突的概率是 1%。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONV(RIGH(MD5(<span class="string">&#x27;HTTP://www.mysql.com/&#x27;</span>),<span class="number">16</span>),<span class="number">16</span>,<span class="number">10</span>)<span class="keyword">AS</span> HASH64</span><br></pre></td></tr></table></figure>
<h2 id="空间数据索引r-tree"><a class="markdownIt-Anchor" href="#空间数据索引r-tree"></a> 空间数据索引（R-Tree）</h2>
<p><code>MYISAM</code> 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无须前缀査询。空间索引会从所有维度来索引数据。査询时，可以有效地使用任意维度来组合查询。必须使用 MYSQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。 MYSQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。开源关系数据库系统中对 GIS 的解决方案做得比较好的是 Postgresql 的 POSTGIS。</p>
<h2 id="全文索引"><a class="markdownIt-Anchor" href="#全文索引"></a> 全文索引</h2>
<p>全文索引是一种特殊类型的索引，它査找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的 WHERE 条件匹配。<br />
在相同的列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突，全文索引适用于 MATCH AGAINST 操作,而不是普通的 WHERE 条件操作。</p>
<h1 id="索引的优点"><a class="markdownIt-Anchor" href="#索引的优点"></a> 索引的优点</h1>
<p>索引可以让服务器快速地定位到表的指定位置。但是这并不是索引的唯一作用，到目前为止可以看到，根据创建索引的数据结构不同，索引也有一些其他的附加作用。<br />
最常见的 <code>B-Tree</code> 索引，按照顺序存储数据，所以 MYSQL 可以用来做 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。因为数据是有序的，所以 B-Tree 也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些査询只使用索引就能够完成全部査询。据此特性，总结下来索引有如下三个优点:</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机 I/O 变为顺序 I/O。</li>
</ol>
<h1 id="高性能索引策略"><a class="markdownIt-Anchor" href="#高性能索引策略"></a> 高性能索引策略</h1>
<h2 id="独立的列"><a class="markdownIt-Anchor" href="#独立的列"></a> 独立的列</h2>
<p>我们通常会看到一些查询不当地使用索引，或者使得 MYSQL 无法使用已有的索引。如果查询中的列不是独立的，则 MYSQL 就不会使用索引。<strong>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</strong></p>
<h2 id="前缀索引和索引选择性"><a class="markdownIt-Anchor" href="#前缀索引和索引选择性"></a> 前缀索引和索引选择性</h2>
<p>有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是前面提到过的<strong>模拟哈希索引</strong>。但有时候这样做还不够，还可以做些什么呢？</p>
<p>通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**索引的选择性是指，不重复的索引值（也称为基数, cardinality）和数据表的记录总数（#T）的比值,范围从 1/#T 到 1 之间。**索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MYSQL 在查找时过滤掉更多的行唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。<br />
一般情况下某个列前缀的选择性也是足够高的，足以满足査询性能。对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MYSQL 不允许索引这些列的完整长度。<br />
<strong>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长(以便节约空间)。</strong></p>
<blockquote>
<p>有时侯后缀索引(suffix index)也有用途(例如，找到某个域名的所有电子邮件地址)。 <strong>MYSQL 原生并不支持反向索引</strong>，但是可以把字符串反转后存储，并基于此建立前缀索引。</p>
</blockquote>
<h2 id="多列索引"><a class="markdownIt-Anchor" href="#多列索引"></a> 多列索引</h2>
<p><strong>在多个列上建立独立的单列索引大部分情况下并不能提高 MYSQL 的査询性能。</strong> <strong>MYSQL 5.0 和更新版本引入了一种叫“索引合并”(index merge)的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。更早版本的 MYSQL 只能使用其中某一个单列索引。</strong></p>
<h2 id="选择合适的索引列顺序"><a class="markdownIt-Anchor" href="#选择合适的索引列顺序"></a> 选择合适的索引列顺序</h2>
<p>**对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。**这个建议有用吗？在某些场景可能有帮助，但通常不如避免随机 IO 和排序那么重要，考虑问题需要更全面(场景不同则选择不同，没有一个放之四海皆准的法则。这里只是说明,，这个经验法则可能没有你想象的重要)。</p>
<p>如果是从诸如 <code>pt-gery-digest</code> 这样的工具的报告中提取“最差”査询，那么再按上述办法选定的索引顺序往往是非常高效的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pt-query-digest --processlist h=192.168.10.11,u=root,p=root --interval=0.01 --output slowlog &gt; slowsql.log</span><br></pre></td></tr></table></figure>
<p><strong>尽可能将需要做范围査询的列放到索引的后面，以便优化器能使用尽可能多的索引列来进行最左匹配。</strong></p>
<h2 id="聚簇索引"><a class="markdownIt-Anchor" href="#聚簇索引"></a> 聚簇索引</h2>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，**但 <code>InnoDB</code> 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。**索引和数据存入同一个 .idb 文件中。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中，索引列包含的是整数值。</p>
<p><img src="../../../images/db/clustered_index.png" alt="Clustered index" /></p>
<p><strong>InnoDB 将通过主键聚集数椐</strong>，这也就是上图中的“被索引的列”就是主键列。</p>
<blockquote>
<p>默认情况下 Innodb 会使用定义的主键来作为聚簇索引，没有主键的话会使用所有列都不为空的第一个唯一索引，再没有的话会生成一个隐藏的基于行 ID 的聚簇索引，行 ID 就是插入顺序。</p>
</blockquote>
<p>聚集的数据有一些重要的优点：</p>
<ul>
<li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个 B-Tree 中，因此从聚簇索引中获取数据通常比在非聚簇索引中査找要快。</li>
<li>使用覆盖索引扫描的査询可以直接使用页节点中的主键值。</li>
</ul>
<p>如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了 I/O 密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插人速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用 <code>OPTIMIZE TABLE</code> 命令重新组织一下表。</li>
<li>更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时侯。</li>
<li>**<u>二级索引(非聚簇索引)</u>**可能比想象的要更大，因为在二级索引中既包含了为其指定的列，索引的叶子节点还包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引査找，而不是一次。</li>
</ul>
<p>最后一点可能让人有些疑惑，为什么二级索引需要两次索引査找？答案在于二级索引中保存的“行指针”的实质。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。</p>
<p><strong>这意味着通过二级索引査找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中査找到对应的行。这里做了重复的工作：两次 B-Tree 査找而不是一次。对于 InnoDB，自适应哈希索能够减少这样的重复工作。这就是所谓的“回表查询”。也就是说聚簇索引叶子结点存放主键和数据，非聚簇索引（其它索引）叶子结点存放的是引用行的主键列而非数据的指针。</strong></p>
<h3 id="innodb-数据分布"><a class="markdownIt-Anchor" href="#innodb-数据分布"></a> InnoDB 数据分布</h3>
<p>假设有如下表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout test (</span><br><span class="line">	col1 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  col2 <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(CO11),</span><br><span class="line">  KEY(CO12)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>假设该表的主键取值为 1~10000，按照随机顺序插入并使用 OPTIMIZE TABLE 命令做了优化。换句话说，数据在磁盘上的存储方式已经最优，但行的顺序是随机的。列 coL2 的值是从 1~100 之间随机赋值，所以有很多重复的值。</p>
<p>InnoDB 的数据分布。因为 InnoDB 支持聚簇索引，所以使用非常不同的方式存储同样的数据。 InnoDB 以如图所示的方式存储数据。</p>
<p><img src="../../../images/db/innodb_layout.png" alt="InnoDB layout" /></p>
<p>聚簇索引的每一个叶子节点都包含了主键值、事务 ID、用于事务和 MVCC 的回滚指针以及所有的剩余列 (在这个例子中是 coL2)。如果主键是一个列前缀索引, InnoDB 也会包含完整的主键列和剩下的其他列。</p>
<p>InnoDB 二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。</p>
<p><strong>上图展示了 B-Tree 的聚簇索引的叶子节点结构</strong>，<strong>下图是非叶子节点</strong>，它包含了索引列和一个指向下级节点的指针（下一级节点可以是非叶子节点，也可以是叶子节点）。这对聚簇索引和二级索引都适用。</p>
<p><img src="../../../images/db/secondary_Indexes.png" alt="Secondary Indexes" /></p>
<h3 id="在-innodb-表中按主键顺序插入行"><a class="markdownIt-Anchor" href="#在-innodb-表中按主键顺序插入行"></a> 在 InnoDB 表中按主键顺序插入行</h3>
<p><strong>在 Mysql 中最简单的就是使用自增的主键列，这样可以保证行按顺序写入，对于根据主键做关联操作的性能也会更好。</strong></p>
<p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于 I/O 密集型的应用。例如，<strong><u>从性能的角度考虑，使用 UUID 来作为聚簇索引则会很糟糕：它使得聚簇索引的插人变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。</u></strong></p>
<p>缺点如下：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机 I/O。</li>
<li>因为写入是乱序的，InnoDB 不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。</li>
</ul>
<h2 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引"></a> 覆盖索引</h2>
<p>索引确实是一种査找数据的高效方式，但是 MYSQL 也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含要査询的数据，那么还有什么必要再回表査询呢？<strong>如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称之为“覆盖索引”。</strong></p>
<p>覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果査询只需要扫描索引而无须回表，会带来多少好处：</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那 MYSQL 就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于 IO 密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中。</li>
<li>因为索引是按照列值顺序存储的(至少在单个页内是如此)，所以对于 I/O 密集型的范围査询会比随机从磁盘读取每一行数据的 I/O 要少得多。对于某些存储引擎，例如 <code>MyISAM</code> 和 <code>Percona Xtradb</code>，甚至可以通过 <code>OPTIMIZE</code> 命令使得索引完全顺序排列，这让简单的范围查询能使用完全顺序的索引访问。</li>
<li>一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。</li>
<li>由于 InnoDB 的聚簇索引，覆盖索引对 InnoDB 表特别有用。 InnoDB 的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖査询，则可以避免对主键索引的二次查询。</li>
</ul>
<p>不是所有类型的索引都可以成为覆盖索引。<strong>覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引副等都不存储索引列的值,所以 MySQL 只能使用 B-Tree 索引做覆盖索引。</strong></p>
<p>当发起一个**被索引覆盖的査询(也叫做索引覆盖査询)**时，在 <code>EXPLAIN</code> 的 <code>Extra</code> 列可以看到 <code>“Using index”</code> 的信息。</p>
<p>对于部分需要查询不包含所有索引的字段时，我们可以通过**<u>延迟关联（deferred join</u>）**来利用覆盖索引的优势。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> products</span><br><span class="line">	  <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">JOIN</span> ( </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>	     <span class="keyword">SELECT</span> prod_id </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>       <span class="keyword">FROM</span> product </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>	     <span class="keyword">WHERE</span> actor <span class="operator">=</span> <span class="string">&#x27;SEAN_CARREY&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%APOLLO%&#x27;</span> </span><br><span class="line">	  <span class="operator">-</span><span class="operator">&gt;</span>     ) <span class="keyword">AS</span> t1 <span class="keyword">ON</span> ( t1.prod_id <span class="operator">=</span> products.prod_id );</span><br></pre></td></tr></table></figure>
<p>在 prod_id 和 actor 上我们设置了索引，在查询的一阶段 Mysql 可以使用覆盖索引，从子查询中先找到符合条件的 prod_id，然后根据 prod_id 值在外层查询匹配所有需要的列值。这样优化的效果取决于 WHERE 条件匹配的行数，匹配的行数越多且使用到索引越多越优化。</p>
<p>在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的査询。不过，可以更进一步优化 InnoDB。<strong>回想一下，InnoDB 的二级索引的叶子节点都包含了主键的值，这意味着 InnoDB 的二级索引可以有效地利用这些“额外”的主键列来覆盖査询。</strong><br />
例如， sakila.actor 使用 InnoDB 存储引擎，并在 last_name 字段有二级索引，虽然该索引的列不包括主键 actor_id，但也能够用于对 actor_id 做覆盖査询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id, last_name <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> last_name <span class="operator">=</span><span class="string">&#x27;HOPPER&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">           id: <span class="number">1</span> </span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">type</span>: SIMPLE </span><br><span class="line">        <span class="keyword">table</span>: actor </span><br><span class="line">         <span class="keyword">type</span>: <span class="keyword">ref</span> </span><br><span class="line">possible_keys: idx_actor_last_name</span><br><span class="line">          key: idx_actor_last_name</span><br><span class="line">          key_len: <span class="number">137</span> </span><br><span class="line">          <span class="keyword">ref</span>: const </span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">2</span> </span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">index</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面提到的很多限制都是由于存储引擎 API 设计所导致的。 <strong>MySQL 5.6 版本引入了 “索引条件推送(index condition pushdown)” 将过滤条件传到存储引擎层，可以减少传递到服务器层的数据量，这个优化默认开启。</strong></p>
</blockquote>
<h2 id="使用索引扫描来做排序"><a class="markdownIt-Anchor" href="#使用索引扫描来做排序"></a> 使用索引扫描来做排序</h2>
<p>MySQL 有两种方式可以生成有序的结果；通过排序操作，或者按索引顺序扫描，<strong>如果 <code>EXPLAIN</code> 出来的 <code>type</code> 列的值为 <code>“index”</code>，则说明 MySQL 使用了索引扫描来做排序（不要和 Extra 列的 “Using index” 搞混淆了）</strong>。</p>
<p><strong>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL 才能够使用索引来对结果做排序。如果査询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。</strong><br />
ORDER BY 子句和查找型査询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL 都需要执行排序操作，而无法利用索引排序。</p>
<p>有一种情况下 ORDER BY 子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果 WHERE 子句或者 J0IN 子句中对这些列指定了常量，就可以“弥补”索引的不足。</p>
<p>例如， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">Sakila 示例数据库的表</a> rental 在列 (rental_date, Inventory_id, customer_id) 上有名为 rental_date 的索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>				 <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> </span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span>			   <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
<p>MYSQL 可以使用 rental_date 索引为下面的査询做排序，从 EXPLAIN 中可以看到没有出现文件排序 (Using filesort) 操作；</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">				 type: ref </span><br><span class="line">possible keys: rental_date </span><br><span class="line">					key: rental_date </span><br><span class="line">				 rows: <span class="number">1</span> </span><br><span class="line">				Extra: Using where</span><br></pre></td></tr></table></figure>
<p>下面是一些不能使用索引做排序的查询：</p>
<ul>
<li>
<p>下面这个查询使用了两种不同的排序方向，但是索引列都是正序排序的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>, customer_id <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询的 ORDER BY 子句中引用了一个不在索引中的列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, staff_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询的 WHERE 和 ORDER BY 中的列无法组合成索引的最左前缀：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>下面这个查询在索引列的第一列上是范围条件，所以 MYSQL 无法使用索引的其余列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个査询在 inventory_id 列上有多个等于条件。对于排序来说，这也是一种范围查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">... <span class="keyword">WHERE</span> rental_date<span class="operator">=</span><span class="string">&#x27;2005-05-25&#x27;</span> <span class="keyword">AND</span> inventory_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面这个例子理论上是可以使用索引进行关联排序的，但由于优化器在优化时将 file_actor 表当作关联的第二张表，所以实际上无法使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id, title <span class="keyword">FROM</span> sakila.film_actor </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.film <span class="keyword">USING</span>(film_id ) <span class="keyword">ORDER</span> <span class="keyword">BY</span> actor_id;</span><br></pre></td></tr></table></figure>
<h2 id="冗余和重复索引"><a class="markdownIt-Anchor" href="#冗余和重复索引"></a> 冗余和重复索引</h2>
<p>MySQL 允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL 需要单独维护重复的索引，并且优化器在优化査询的时侯也需要逐个地进行考虑，这会影响性能。</p>
<p>冗余索引和重复索引有一些不同。如果创建了索引(A)，再创建索引(A,B)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当作索引(A)来使用(这种冗余只是对 B-Tree 索引来说的)。但是如果再创建索引(B,A)，则不是冗余索引，索引(B) 也不是，因为B不是索引(A,B)的最左前缀列。另外，其他不同类型的索引(例如哈希索引或者全文索引)也不会是 B-Tree 索引的冗余索引，无论覆盖的索引列是什么。</p>
<p>解决冗余索引和重复索引的方法很简单，删除这些索引就可以，但首先要做的是找出这样的索引。Percona Tookit 中的 <code>pt-duplicate-key-checker</code> 可以帮我们分析表结构找出冗余和重复的索引。</p>
<h2 id="未使用的索引"><a class="markdownIt-Anchor" href="#未使用的索引"></a> 未使用的索引</h2>
<p>这样的索引完全是累赘，建议考虑删除。</p>
<p>定位未使用的索引最简单有效的办法是在 Percona Server 或者 MariaDB 中先打开 User statistics 服务器变量，</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> userstat<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后让服务正常运行一段时间，再通过 INFOMATION_SCHEMA.INDEX_STATISTICS 就能查到每个索引的使用频率。</p>
<p>另外，还可以使用 Percona Toolkit 中的 <code>pt-index-usage</code>，该工具可以读取査询日志，并对日志中的每条査询进行 EXPLAIN 操作，然后打印出关于索引和查询的报告。这个工具不仅可以找出哪些索引是未使用的，还可以了解査询的执行计划一一例如在某些情况有些类似的査询的执行方式不一样，这可以帮助你定位到那些偶尔服务质量差的査询，优化它们以得到一致的性能表现。该工具也可以将结果写入到  MYSQL 的表中，方便查询结果。</p>
<h2 id="索引和锁"><a class="markdownIt-Anchor" href="#索引和锁"></a> 索引和锁</h2>
<p>索引可以让査询锁定更少的行。如果你的査询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然 InnoDB 的行锁效率很高，内存使用也很少，但是锁定行的时侯仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。但这只有当 InnoDB 在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在 InnoDB 检索到数据并返回给服务器层以后，MySQL 服务器才能应用 WHERE 子句。这时已经无法避免锁定行了：InnoDB 已经锁住了这些行，到适当的时候オ释放。在 MySQL5.1 和更新的版本中，InnoDB 可以在服务器端过滤掉行后就释放锁，但是在早期的 MYSQL 版本中, InnoDB 只有在事务提交后オ能释放锁。</p>
<p>通过下面的例子再次使用数据库 Sakila 很好地解释了这些情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id<span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| actor_id |</span><br><span class="line">+----------+</span><br><span class="line">|        2 |</span><br><span class="line">|        3 |</span><br><span class="line">|        4 |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<p>这条査询仅仅会返回 2-4 之间的行，但是实际上获取了 1~4 之间的行的排他锁。InnoDB 会锁住第 1 行，这是因为 MySQL 为该查询选择的执行计划是索引范围扫描：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">&lt;</span><span class="number">5</span> <span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br><span class="line">| id | select_type | table | type  | key     | Extra                    | </span><br><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br><span class="line">|  1 | SIMPLE      | actor | range | PRIMARY | Using where; Using index | </span><br><span class="line">+----+-------------+-------+-------+---------+--------------------------+ </span><br></pre></td></tr></table></figure>
<p>换句话说，底层存储引擎的操作是“从索引的开头开始获取满足条件 actor_id&lt;5 的记录”，服务器并没有告诉 InnoDB 可以过滤第 1 行的  WHERE 条件。注意到 EXPLAIN 的 Extra 列出现了“Using where”，这表示 MySQL 服务器将存储引擎返回行以后再应用 WHERE 过滤条件。</p>
<p>下面的第二个査询就能证明第 1 行确实已经被锁定，尽管第一个査询的结果中并没有这个第 1 行。保持第一个连接打开，然后开启第二个连接并执行如下査询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>; </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<p>这个查询将会挂起，直到第一个事务释放第 1 行的锁。</p>
<p>关于 InnoDB、索引和锁有一些很少有人知道的细节：InnoDB 在二级索引上使用共享(读)锁，但访问主键索引需要排他(写)锁。这消除了使用覆盖索引的可能性，并且使得 SELECT FOR UPDATE 比 L0CK IN SHARE MODE 或非锁定査询要慢很多。</p>
<h2 id="避免多个范围条件"><a class="markdownIt-Anchor" href="#避免多个范围条件"></a> 避免多个范围条件</h2>
<p>EXPLAIN 输出中 type 为 range 的代表范围查询，比如下面这种查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">&gt;</span> <span class="number">45</span>;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span><span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">				 id: <span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> type: SIMPLE </span><br><span class="line">			<span class="keyword">table</span>: actor </span><br><span class="line">			 type: <span class="keyword">range</span></span><br></pre></td></tr></table></figure>
<p>但是下面这条查询呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">99</span>);</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span><span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">				 id: <span class="number">1</span> </span><br><span class="line"><span class="keyword">select</span> type: SIMPLE </span><br><span class="line">			<span class="keyword">table</span>: actor </span><br><span class="line">			 type: <span class="keyword">range</span></span><br></pre></td></tr></table></figure>
<p>从 EXPLAIN 的结果是无法区分这两者的，但可以从值的范围和多个等于条件来得出不同。在我们看来，第二个查询就是多个等値条件查询。<br />
我们不是挑剔：这两种访问效率是不同的。对于范围条件查询，MySQL 无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询”则没有这个限制。</p>
<h2 id="更新索引统计信息"><a class="markdownIt-Anchor" href="#更新索引统计信息"></a> 更新索引统计信息</h2>
<p>可以使用 <code>SHOW INDEX FROM</code> 命令来査看索引的基数(Cardinality)。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW INDEX FROM sakila.actor;</span></span><br><span class="line">******************* 1.row *******************</span><br><span class="line">	  	 Table: actor </span><br><span class="line">  Non_unique: 0 </span><br><span class="line">    Key_name: PRIMARY </span><br><span class="line">Seq_in_index: 1 </span><br><span class="line"> Column_name: actor_id </span><br><span class="line">   Collation: A </span><br><span class="line"> Cardinality: 200 </span><br><span class="line">    Sub_part: NULL </span><br><span class="line">      Packed: NULL </span><br><span class="line">        Null:</span><br><span class="line">  Index_type: BTREE</span><br><span class="line">     Comment:</span><br></pre></td></tr></table></figure>
<p>这里需要特别提及的是索引列的<strong>基数(Cardinality)</strong>，<strong>其显示了存储引擎估算索引列有多少个不同的取值</strong>。引擎估算索引列有多少个不同的取值。在 MySQL5.0 和更新的版本中，还可以通过 <code>INFORMATION_SCHEMA.STATISTICS</code> 表很方便地査询到这些信息。</p>
<p>InnoDB 会在表首次打开，或者执行 <code>ANALYZE TABLE</code>，抑或表的大小发生非常大的变化(大小变化超过十六分之一或者新插入了 20 亿行都会触发)的时候计算索引的统计信息。</p>
<p>InnoDB 在打开某些 INFORMATION_SCHEMA 表，或者使用 SHOW TABLE STATUS 和 SHOW INDEX，抑或在 MYSQL 客户端开启自动补全功能的时侯都会触发索引统计信息的更新。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>在 MySQL 中，大多数情况下都会使用 B-Tree 索引。其他类型的索引大多只适用于特殊的目的。如果在合适的场景中使用索引，将大大提高査询的响应时间。本章将不再介绍更多这方面的内容了，最后值得总的回顾一下这些特性以及如何使用 B-Tree 索引。<br />
在选择索引和编写利用这些索引的査询时，有如下三个原则始终需要记住：</p>
<ol>
<li>单行访问是很慢的。特别是在机械硬盘存储中(SSD 的随机 I/O 要快很多，不过这点仍然成立)。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li>
<li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序 IO 不需要多次磁盘寻道，所以比随机 I/O 要快很多(特别是对机械硬盘)。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且 GROUP BY 查询也无须再做排序和将行按组进行聚合计算了。</li>
<li>索引覆盖査询是很快的。如果一个索引包含了査询需要的所有列，那么存储引擎就不需要再回表査找行。这避免了大量的单行访向，而上面的第 1 点已经写明单行访问是很慢的。</li>
</ol>
<p>**那如何判断一个系统创建的索引是合理的呢？**一般来说，我们建议按响应时间来对査询进行分析。找出那些消耗最长时间的査询或者那些给服务器带来最大压力的査询，然后检査这些査询的 schema、SQL 和索引结构，判断是否有査询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用随机 I/O 访问数据，或者是有太多回表査询那些不在索引中的列的操作。</p>
<p>如果仍然想找到那些索引不是很合适的査询并在它们成为问题前进行优化，则可以使用 <code>pt-query-digest</code> 的查询审査“review’”功能，分析其 EXPLAIN 出来的执行计划。</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>索引</tag>
        <tag>B+Tree</tag>
        <tag>B-Tree</tag>
        <tag>覆盖索引</tag>
        <tag>聚簇索引</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Docker 的网络</title>
    <url>/cloud-native/%E5%85%B3%E4%BA%8E-Docker-%E7%9A%84%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="docker-容器网络"><a class="markdownIt-Anchor" href="#docker-容器网络"></a> <code>Docker</code> 容器网络</h2>
<p><code>Docker</code> 从容器中提取了基础的主机连接网络。 这样做为应用程序提供了一定程度的运行时环境不可知性，并允许基础结构管理器调整实现以适合操作环境。 连接到 <code>Docker</code> 网络的容器将获得一个唯一的 IP 地址，该 IP 地址可以为连接到同一 <code>Docker</code> 网络的其他容器进行路由。</p>
<p>但这种方法的主要问题是，在容器内运行的任何软件都没有简洁的方法来确定依赖的宿主机的 IP 地址，这阻止了容器将其服务端点通告给容器网络外部的其他服务。</p>
<p><code>Docker</code> 还将网络视为第一类实体。 这意味着它们具有自己的生命周期，并且不受任何其他对象的约束。 您可以使用 <code>docker network</code> 子命令直接定义和管理它们。</p>
<a id="more"></a>
<p>运行 docker network ls 会将打印所有网络表格信息到终端。 结果应如下所示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">63d93214524b        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">6eeb489baff0        host                host                <span class="built_in">local</span></span><br><span class="line">3254d02034ed        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>Docker</code> 包括三个网络，每个网络由不同的驱动程序提供。 名为 <code>bridge</code> 的网络是默认网络，由网桥驱动程序提供。 桥驱动程序为同一机器上运行的所有容器提供容器间连接。<code>host</code> 网络由 <code>host</code> 驱动程序提供，该驱动程序指示 <code>Docker</code> 不要为连接的容器创建任何特殊的网络命名空间或资源。 主机网络上的容器与主机的网络堆栈交互，就像非容器进程一样。最后，<code>none</code> 网络使用 <code>null</code> 驱动程序。 连接到无网络的容器自身外部将没有任何网络连接。</p>
<p>网络的范围可以采用三个值：<code>local</code>，<code>global</code> 或 <code>swarm</code>。这表明是将网络限制在网络所在的计算机上（<code>local</code>），还是在集群的每个节点上创建网络，而不是在它们之间路由（<code>global</code>），还是无缝地跨接参与 <code>Docker</code> 群的所有主机（多主机） 或整个群集）。 如您所见，所有默认网络都具有 <code>local</code> 范围，并且将无法直接与路由在不同计算机上运行的容器之间通信。</p>
<p>默认 <code>bridge</code> 网络保持与旧 <code>Docker</code> 的兼容性，并且无法利用现代 <code>Docker</code> 功能（包括服务发现或负载平衡），处于同一网络环境下的 <code>docker</code> 容器，可以通过 <code>hostname</code> 互相发现，默认容器的 hostname 和容器名相同，可以只用 <code>--hostname</code> 指定容器主机名。</p>
<h2 id="超越-bridge-网络"><a class="markdownIt-Anchor" href="#超越-bridge-网络"></a> 超越 <code>bridge</code> 网络</h2>
<p>默认情况下，桥接网络已经可以满足你的需求。桥接网络非常适合单服务部署，例如运行内容管理系统或博客的 <code>LAMP</code> 或大多数本地开发任务。但如果你正在运行旨在容忍机器故障的多服务器环境，则需要能够在不同机器上的容器之间无缝路由流量，桥接网络做不到。</p>
<p><code>Docker</code> 提供了一些开箱即用的选项来处理这种用例。 最佳选择取决于构建网络的环境，如果在 <code>Linux</code> 主机上使用 <code>Docker</code> 并且可以控制主机网络，则可以使用 <code>macvlan</code> 或 <code>ipvlan</code> 网络驱动程序提供的底层网络。 底层网络为每个容器创建第一类的网络地址。 这些身份可从连接主机的同一网络中发现和路由。 机器上运行的每个容器看起来就像网络上的一个独立节点。</p>
<p>如果您正在运行 <code>Mac</code> 的 <code>Docker</code> 或 <code>Windows</code> 的 <code>Docker</code> 或在托管云环境中运行，那么这些选项将不起作用。 此外，底层网络配置取决于主机网络，因此定义很少可移植。 最受欢迎的多主机容器网络选项是 <code>overlay</code> 网络。</p>
<p><code>overlay</code> 网络驱动程序在启用了 <code>swarm</code> 模式的 <code>Docker</code> 引擎上可用。 <code>overlay</code> 网络的结构与桥接网络相似，但是逻辑网桥组件可感知多主机，并且可以在集群中每个节点路由容器间连接。</p>
<p>就像在桥接网络上一样，<code>overlay</code> 网络上的容器也不能从集群外部直接路由。 但是容器间的通信很简单，并且网络定义基本上独立于主机网络环境。</p>
<p>在某些情况下，您会有一些特殊的网络要求，但底层网络或 <code>overlay</code> 网络无法满足这些要求。 也许您需要能够调整主机网络配置，或者确保容器在完全网络隔离的情况下运行。 在这种情况下，您应该使用一种特殊的容器网络。</p>
<h2 id="特殊容器网络host-和-none"><a class="markdownIt-Anchor" href="#特殊容器网络host-和-none"></a> 特殊容器网络：<code>host</code> 和 <code>none</code></h2>
<p><code>host</code> 和 <code>none</code>。 这些并不是真正的网络。 相反，它们是具有特殊含义的网络附件类型。</p>
<p>在 <code>docker run</code> 命令上指定 <code>--network host</code> 选项时，您正在告诉 <code>Docker</code> 创建一个没有任何特殊网络适配器或网络名称空间的新容器。 无论结果容器中运行的是哪种软件，对主机网络的访问程度都将与容器外部运行的软件相同。 由于没有网络名称空间，因此所有用于调整网络堆栈的内核工具都可用于修改（只要修改过程可以这样做）。</p>
<p>在 <code>host</code> 网络上运行对于系统服务或其他基础结构组件很有用。 但这在多租户环境中不合适，因此不应将其用于第三方容器。 因此，您通常不希望将容器连接到网络。 本着构建最低特权系统的精神，应尽可能使用 <code>none</code> 网络。</p>
<p>在 <code>none</code> 网络上创建容器会指示 <code>Docker</code> 不要为新容器设置任何已连接的虚拟以太网适配器。 它将具有自己的网络名称空间，因此将被隔离，但是如果没有跨越名称空间边界连接的适配器，它将无法使用网络在容器外部进行通信。 以这种方式配置的容器仍将具有自己的回环接口，因此多进程容器仍可以使用与本地主机的连接进行进程间通信。</p>
<p>桥接网络使用网络地址转换（<code>NAT</code>）来使所有出站容器通信以及桥接网络外部的目的地看起来像是来自主机本身。 这意味着您在容器中运行的服务软件与世界其他地区以及大多数客户和客户所在的网络部分是隔离的。</p>
<h2 id="使用-nodeport-发布处理入站流量"><a class="markdownIt-Anchor" href="#使用-nodeport-发布处理入站流量"></a> 使用 <code>NodePort</code> 发布处理入站流量</h2>
<p><code>Docker</code> 容器网络都是关于容器之间的简单连接和路由的。 将那些容器中运行的服务与外部网络客户端连接起来需要额外的步骤。 由于容器网络通过网络地址转换连接到更广泛的网络，因此您必须专门告诉 <code>Docker</code> 如何从外部网络接口转发流量。 您需要在主机接口上指定 <code>TCP</code> 或 <code>UDP</code> 端口以及目标容器和容器端口，类似于通过家庭网络上的 <code>NAT</code> 屏障转发流量。</p>
<p><code>NodePort 发布</code> 是我们在这里用来匹配 <code>Docker</code> 和其他生态系统项目的术语。 节点部分是对主机的推断，通常是较大机器集群中的节点。</p>
<p>端口发布配置是在容器创建时提供的，以后不能更改。 <code>docker run</code> 和 <code>docker create</code> 命令提供 <code>-p</code> 或 <code>--publish list</code> 选项。 与其他选项一样，<code>-p</code> 选项采用以冒号分隔的字符串参数。 该参数指定主机接口，要转发的主机上的端口，目标端口和端口协议。 以下所有参数均等效：</p>
<ul>
<li><code>0.0.0.0:8080:8080/tcp</code></li>
<li><code>8080:8080/tcp</code></li>
<li><code>8080:8080</code></li>
</ul>
<p>直接使用 <code>port</code> 时未指定主机端口号，会随机从主机端口中分配一个端口号，可以使用 <code>docker port 容器名</code>来查看具体分配端口号，或 <code>docker ps</code> 也可以看到端口映射情况，不过 <code>docker port</code> 可以使用容器端口号缩小查找范围：<code>docker port 容器名 容器端口号</code>。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>网络是一个广泛的主题，需要几本书才能正确覆盖。 这里主要解释了 <code>Docker</code> 提供的的单主机的网络实施：</p>
<ul>
<li><code>Docker</code> 网络是第一类实体，可以像容器，卷和镜像一样被创建，索引和删除。</li>
<li>桥接网络是一种特殊的网络，它允许使用内置的容器名称解析来直接进行容器间网络通信。</li>
<li><code>Docker</code> 默认提供另外两个特殊网络：<code>host</code> 和 <code>none</code>。</li>
<li>使用 <code>none</code> 驱动程序创建的网络会将容器与网络隔离。</li>
<li><code>host</code> 网络上的容器将具有对主机上网络设施和接口的完全访问权限。</li>
<li>使用 <code>NodePort</code> 发布将网络流量转发到主机端口与目标容器端口。</li>
<li><code>Docker</code> 网桥网络不提供任何网络防火墙或访问控制功能。</li>
<li>可以为每个容器自定义网络名称解析堆栈。 可以自定义 <code>DNS</code> 服务器，搜索域和静态主机。</li>
<li>网络管理可以使用第三方工具和 <code>Docker none</code> 网络进行外部化。</li>
</ul>
]]></content>
      <categories>
        <category>Devops</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>logstash 学习</title>
    <url>/middleware/logstash-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<hr />
<blockquote>
<p>logstash 版本（6.2）</p>
</blockquote>
<hr />
<h2 id="配置中的-codec-到底是什么"><a class="markdownIt-Anchor" href="#配置中的-codec-到底是什么"></a> 配置中的 <code>codec</code> 到底是什么</h2>
<p><code>codec</code> 属性用来配置编解码插件，它负责对输入输出的内容表现形式进行处理，插件本质上是个流式过滤器。<br />
以下是常用的插件:</p>
<ul>
<li><code>json</code></li>
</ul>
<blockquote>
<p>读取JSON格式的内容，在JSON数组中为每个元素创建一个事件</p>
</blockquote>
<ul>
<li><code>line</code></li>
</ul>
<blockquote>
<p>从行读取文本数据</p>
</blockquote>
<ul>
<li><code>plain</code></li>
</ul>
<blockquote>
<p>读取原始内容，不会进行转化</p>
</blockquote>
<ul>
<li><code>rubydebug</code></li>
</ul>
<blockquote>
<p>将输出打印到 logstash 的事件中</p>
</blockquote>
<a id="more"></a>
<p>所有的插件请查看：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html#codec-plugins">https://www.elastic.co/guide/en/logstash/current/codec-plugins.html#codec-plugins</a></p>
<h2 id="使用配置文件"><a class="markdownIt-Anchor" href="#使用配置文件"></a> 使用配置文件</h2>
<ul>
<li>
<p><code>conf</code> 文件<br />
定义Logstash处理管道的管道配置文件</p>
</li>
<li>
<p><code>pipelines.yml</code> 文件<br />
pipeline 文件用于在单个实例中配置多个管道处理数据，是 logstash 的设置文件，每个管道拥有自己独立的线程，输入从管道中接受输入事件并按固定大小单位（batch size）存放到管道序列中（默认在内存，可以持久化到硬盘），过滤，输出从管道中消费序列，可以通过配置 <code>batch size</code> 和 <code>管道工作线程</code> 提高性能。具体参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/tuning-logstash.html"> Tuning and Profiling Logstash Performance</a></p>
</li>
<li>
<p>过滤增强插件</p>
</li>
</ul>
<ul>
<li>
<p><code>Grok</code> 过滤插件<br />
可以将非结构的数据转换成结构化的数据便于查询，Grok 通过组合<code>文本匹配模式(text pattern)</code>来匹配你的内容的方式工作。</p>
<ul>
<li>支持的匹配模式请查看<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns">https://github.com/elastic/logstash/blob/v1.4.2/patterns/grok-patterns</a></li>
<li>可以对文本内容进行格式转化，支持 <code>int</code> 和 <code>float</code>。</li>
<li>支持自定义模式，正则等</li>
<li>支持增加、移除、重写字段，tag 等</li>
<li>具体详见：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html">plugins-filters-grok</a></li>
</ul>
</li>
<li>
<p><code>Geoip</code> 增强过滤插件<br />
通过你指定的ip地址列，查询额外的地址信息：经纬度，国家，区域，编码等。</p>
</li>
<li>
<p><code>mutate</code> 过滤转换插件<br />
对事件字段执行一般转换。您可以重命名，删除，替换和修改事件中的字段</p>
</li>
<li>
<p>更多插件请查看：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html">Output Plugins</a></p>
</li>
</ul>
<h2 id="启动服务"><a class="markdownIt-Anchor" href="#启动服务"></a> 启动服务</h2>
<ul>
<li>启动参数
<ul>
<li>
<p><code>--node.name NAME</code><br />
指定 logstash 实例的名称，默认为当前的主机名。</p>
</li>
<li>
<p><code>-f, --path.config CONFIG_PATH</code><br />
从特定文件或目录加载 Logstash 配置。如果给出一个目录，那么该目录中的所有文件将按字典顺序连接，然后解析为单个配置文件。<br />
您可以指定通配符（globs），并且任何匹配的文件将按照上述顺序加载。例如，您可以使用通配符功能按名称加载特定文件：</p>
<blockquote>
<p>bin/logstash --debug -f ‘/tmp/{one,two,three}’</p>
</blockquote>
<p>使用此命令，Logstash会连接三个配置文件/ tmp / one，/ tmp / two和/ tmp / three，并将它们解析为单个配置。</p>
</li>
<li>
<p><code>-e, --config.string CONFIG_STRING</code><br />
使用给定的字符串作为配置数据。与配置文件相同的语法。</p>
</li>
<li>
<p><code>-t, --config.test_and_exit</code><br />
修改配置文件不重启服务：</p>
<blockquote>
<p>bin/logstash -f first-pipeline.conf -t</p>
</blockquote>
</li>
<li>
<p><code>-r, --config.reload.automatic</code><br />
测试，转换配置文件，并打印错误：</p>
<blockquote>
<p>bin/logstash -f first-pipeline.conf -r</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="使用-docker-获取镜像"><a class="markdownIt-Anchor" href="#使用-docker-获取镜像"></a> 使用 docker 获取镜像</h2>
<p>发布的镜像存放在 <a target="_blank" rel="noopener" href="https://www.docker.elastic.co/">www.docker.elastic.co</a>，源码放在<a target="_blank" rel="noopener" href="https://github.com/elastic/logstash-docker/tree/6.2">GitHub</a>.</p>
<blockquote>
<p>默认版本安装 X-PACK<br />
oss 版本不安装 X-PACK。</p>
</blockquote>
<h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3>
<p>容器的管道配置文件目录：<code>/usr/share/logstash/pipeline/</code><br />
配置文件目录：<code>/usr/share/logstash/config/</code></p>
<h3 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h3>
<p><code>PIPELINE_WORKERS</code> 对应 <code>pipeline.workers</code><br />
<code>LOG_LEVEL</code> 对应 <code>log.level</code><br />
<code>XPACK_MONITORING_ENABLED</code> 对应 <code>XPACK_MONITORING_ENABLED</code><br />
等</p>
<h2 id="kafka-input-plugin-插件配置"><a class="markdownIt-Anchor" href="#kafka-input-plugin-插件配置"></a> Kafka input plugin 插件配置</h2>
<h3 id="元数据字段"><a class="markdownIt-Anchor" href="#元数据字段"></a> 元数据字段</h3>
<ul>
<li>[@metadata][kafka][topic]：消息来源处的原始 Kafka topic。</li>
<li>[@metadata][kafka][consumer_group]：消费者组</li>
<li>[@metadata][kafka][partition]：此讯息的分区信息。</li>
<li>[@metadata][kafka][offset]: 此消息的原始记录偏移量。</li>
<li>[@metadata][kafka][key]：Record key, 如果有的话。</li>
<li>[@metadata][kafka][timestamp]：kafka broker 收到此消息时的时间戳。</li>
</ul>
<p>如何使用：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  kafka &#123;    </span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">    decorate_events =&gt; <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;    </span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;<span class="string">&quot;[@metadata][index]&quot;</span> =&gt; <span class="string">&quot;%&#123;[kafka][topic]&#125;&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    index =&gt; <span class="string">&quot;kafka-%&#123;[@metadata][index]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span></span><br><span class="line">    <span class="built_in">..</span>.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用的配置选项"><a class="markdownIt-Anchor" href="#常用的配置选项"></a> 常用的配置选项</h3>
<ul>
<li>
<p><strong>auto_commit_interval_ms</strong>：消费者的 offset 提交 kafka 时间频率。<br />
单位：<code>毫秒</code><br />
默认值：<code>5000</code></p>
</li>
<li>
<p><strong>bootstrap_servers</strong>：用于建立群集初始连接的 Kafka 实例的 URL 列表。<br />
格式如下：<code>&quot;host1:port1,host2:port2&quot;</code><br />
默认值：<code>&quot;localhost:9092&quot;</code></p>
</li>
<li>
<p><strong>client_id</strong>：发出请求时传递给服务器的 id 字符串。这样做的目的是通过允许包含逻辑应用程序名称，能够跟踪 ip / port 之外的请求源。<br />
默认值：<code>&quot;logstash&quot;</code></p>
</li>
<li>
<p><strong>decorate_events</strong>：是否添加 kafka 的元数据。<br />
默认值：<code>false</code></p>
</li>
<li>
<p><strong>group_id</strong>：此用户所属组的标识符。消费者组是由多个处理器组成的单个逻辑用户。主题中的消息将分发给具有相同 group_id 的所有 Logstash 实例<br />
默认值：<code>&quot;logstash&quot;</code></p>
</li>
<li>
<p><strong>topics</strong>：要订阅的主题列表。<br />
-默认值：<code>[&quot;logstash&quot;]</code></p>
</li>
<li>
<p><strong>topics_pattern</strong>：要订阅的主题正则表达式模式。使用此配置时，topics 配置将被忽略。</p>
</li>
<li>
<p><strong>id</strong>：在有多个 kafka input 时，在这种情况下添加命名标识将有助于在使用监视 API 时监视 Logstash。</p>
</li>
</ul>
<h2 id="elasticsearch-output-plugin-插件配置"><a class="markdownIt-Anchor" href="#elasticsearch-output-plugin-插件配置"></a> Elasticsearch output plugin 插件配置</h2>
<h3 id="常用的配置选项-2"><a class="markdownIt-Anchor" href="#常用的配置选项-2"></a> 常用的配置选项</h3>
<ul>
<li><strong>action</strong> ：告示 Elasticsearch 要做的操作</li>
<li>默认值是 <code>index</code>
<ul>
<li>index ：索引一个文档</li>
<li>delete ：通过 id 删除文档</li>
<li>create ：索引一个文档，如果 id 已经存在索引中则创建失败</li>
<li>update ：通过 id 更新文档。如果文档不存在时如何处理，请查看<code>upsert</code>选项。</li>
</ul>
</li>
<li><strong>document_id</strong>：指定索引文档的 id。</li>
<li>没有默认值，默认<code>Elasticsearch</code>会创建随机 id</li>
<li><s><strong>document_type</strong>：指定索引文档的类型。</s></li>
<li>下个版本将被移除，原因见注脚。</li>
<li><strong>hosts</strong>：设置远程实例的<code>host</code>,给定数组的 host 会对请求负载均衡。</li>
<li>默认值：<code>[&quot;127.0.0.1&quot;]</code><br />
<strong>网址中出现的任何特殊字符必须是 URL 转义的！例如，这意味着＃应该是％23。</strong></li>
<li><strong>index</strong>：指定索引的名称。</li>
<li>默认值：<code>&quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot;</code><br />
完整的属性请查看：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html#plugins-outputs-elasticsearch-document_type">https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html#plugins-outputs-elasticsearch-document_type</a></li>
</ul>
<hr />
<p>下面放一个从 kafka 收集数据，输出到 Elasticsearch 的配置：</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> &#123;</span><br><span class="line">  kafka &#123;</span><br><span class="line">  	<span class="attr">group_id</span> =&gt; <span class="string">&quot;test-consumer-group&quot;</span></span><br><span class="line">    <span class="attr">topics</span> =&gt; [<span class="string">&quot;test&quot;</span>]</span><br><span class="line">    <span class="attr">bootstrap_servers</span> =&gt; <span class="string">&quot;127.0.0.1:9092&quot;</span></span><br><span class="line">    <span class="attr">codec</span> =&gt; json</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> &#123;</span><br><span class="line">  stdout &#123; <span class="attr">codec</span> =&gt; rubydebug &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">elasticsearch</span> &#123;</span><br><span class="line">    <span class="attr">hosts</span> =&gt; [<span class="string">&quot;127.0.0.1:9200&quot;</span>]</span><br><span class="line">    <span class="attr">document_id</span> =&gt; <span class="string">&quot;%&#123;id&#125;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>%&#123;id&#125;</code> 解释：<br />
假设我的输入数据格式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;level&quot;</span>:<span class="string">&quot;info&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>:<span class="string">&quot;Hii&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>:<span class="string">&quot;2017-02-02T08:32:09.535Z&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>document_id =&gt; &quot;%&#123;id&#125;&quot;</code>及使用数据的 id 作为文档索引。</p>
<hr />
<p>注：开始时，我们把“index”类比为sql数据库的“database”，“type”类比为“table”。<br />
但是这是个错的认知，在 SQL 数据库中，表格彼此独立。一个表中的列与另一个表中的相同名称的列没有关系。但是映射类型（type）中的字段不是这种情况。<br />
在 Elasticsearch 索引中，在不同映射类型（type）中具有相同名称的字段在内部由相同的 Lucene 字段支持。<br />
这会导致你希望删除一个类型中的字段时另一个类型的相同字段会出错。<br />
最重要的是，存储同一索引中具有很少或没有共同字段的不同实体会导致稀疏数据并干扰 Lucene 高效压缩文档的能力。<br />
<strong>解决方法：</strong></p>
<ol>
<li>为每一个文档类型创建索引</li>
<li>自己定义一个 type 字段</li>
</ol>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Logstash</tag>
        <tag>Kafka</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream 使用</title>
    <url>/java/Java8-Stream%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="流的创建"><a class="markdownIt-Anchor" href="#流的创建"></a> 流的创建</h2>
<h3 id="空流"><a class="markdownIt-Anchor" href="#空流"></a> 空流</h3>
<p>如果创建空流，则应使用 <code>Stream.empty()</code> 方法。</p>
<p>通常情况下创建空流的目的是避免返回 null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Stream&lt;String&gt; <span class="title">streamOf</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list == <span class="keyword">null</span> || list.isEmpty() ? Stream.empty() : list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从数组或集合创建流"><a class="markdownIt-Anchor" href="#从数组或集合创建流"></a> 从数组或集合创建流</h3>
<p>我们可以从数组使用 <code>stream()</code> 或者 <code>of()</code> 方法来创建流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure>
<p>返回以指定数组作为源的顺序Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>返回其元素为指定值的顺序有序流。</p>
<blockquote>
<p>Stream 的 <code>of</code> 方法内部还是使用 Arrays <code>stream</code> 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">stream = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在集合的接口上 java8 添加了默认的 <code>stream()</code> 方法允许使用任何集合作为元素源创建 Stream <T>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br></pre></td></tr></table></figure>
<p>如果想要多个流合并成单个流，可以使用流的 <code>concat</code> 方法：</p>
<blockquote>
<p>可以在里面嵌套使用方法，但是注意 java8 的流不能复用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Object&gt; concatStream = Stream.concat(Stream.concat(collection1.stream(), collection2.stream()), collection3.stram());</span><br></pre></td></tr></table></figure>
<h3 id="静态工厂方法创建流"><a class="markdownIt-Anchor" href="#静态工厂方法创建流"></a> 静态工厂方法创建流</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从 startInclusive（包括）到 endExclusive（不包括）的递增步长返回顺序排序的 IntStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(T seed, UnaryOperator&lt;T&gt; f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回通过将函数 f 迭代应用于初始元素种子而生成的无限顺序有序流，生成由种子，f(seed)，f(f(seed)) 等组成的流。</p>
<h3 id="构建器-生成器-迭代器生成流"><a class="markdownIt-Anchor" href="#构建器-生成器-迭代器生成流"></a> 构建器、生成器、迭代器生成流</h3>
<ul>
<li>
<p>构建器</p>
<p>使用构建器时，应在语句的右侧部分另外指定所需类型，否则 build() 方法将创建 Stream <Object> 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamBuilder =</span><br><span class="line">  Stream.&lt;String&gt;builder().add(<span class="string">&quot;a&quot;</span>).add(<span class="string">&quot;b&quot;</span>).add(<span class="string">&quot;c&quot;</span>).build();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成器 - 可用于生成无限流</p>
<p>generate() 方法接受 Supplier <T> 以生成元素。由于结果流是无限的，开发人员应指定所需的大小，否则 generate() 方法将一直有效，直到达到内存限制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamGenerated =</span><br><span class="line">  Stream.generate(() -&gt; <span class="string">&quot;element&quot;</span>).limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器 - 可用于生成无限流</p>
<p>iterate() 方法有两个参数：种子和函数。 种子是流的第一个元素。通过将函数应用于第一元素来生成第二元素。通过在第二个元素上应用函数来生成第三个元素。</p>
<p>因此，元素是：<code>seed, f(seed), f(f(seed)), f(f(f(seed)))....</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">2L</span>, n  -&gt;  n  + <span class="number">1</span>)</span><br><span class="line">    .filter(Main::isOdd)</span><br><span class="line">    .limit(<span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::printf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码返回以下执行结果：</p>
<p>3 5 7 9 11</p>
</li>
</ul>
<h3 id="创建无尽流"><a class="markdownIt-Anchor" href="#创建无尽流"></a> 创建无尽流</h3>
<p>我们已经知道了流可以分为中间和终端操作。我们也可以利用流的惰性话来创建一个无尽流。<br />
我们创建一个从 0 开始每次加 2 的无限流，在调用终端操作前限制它的长度。<br />
**在调用终端操作前执行 limit 操作是至关重要的。**不然程序将无限制的运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// given</span></span><br><span class="line">Stream&lt;Integer&gt; infiniteStream = Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// when</span></span><br><span class="line">List&lt;Integer&gt; collect = infiniteStream</span><br><span class="line">  .limit(<span class="number">10</span>)</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">assertEquals(collect, Arrays.asList(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>));</span><br></pre></td></tr></table></figure>
<p>我们使用 iterate() 方法创建一个无限流。然后调用 limit() 转换和 collect() 终端操作。由于 Stream 的惰性，我们将拥有无限序列的前 10 个元素组成的集合。</p>
<h4 id="创建自定义元素的无限流"><a class="markdownIt-Anchor" href="#创建自定义元素的无限流"></a> 创建自定义元素的无限流</h4>
<p>假设我们想创建一个无限的随机 UUID 流。<br />
使用 Stream API 实现此目的的第一步是创建这些随机值的供应商（Supplier）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;UUID&gt; randomUUIDSupplier = UUID::randomUUID;</span><br></pre></td></tr></table></figure>
<p>当我们定义好供应商时，我们可以使用 generate() 方法创建无限流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;UUID&gt; infiniteStreamOfRandomUUID = Stream.generate(randomUUIDSupplier);</span><br></pre></td></tr></table></figure>
<p>然后我们可以从流中获取一些元素。如果你希望程序在有限时间内完成，请记得使用 limit() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;UUID&gt; randomInts = infiniteStreamOfRandomUUID</span><br><span class="line">.skip(<span class="number">10</span>)</span><br><span class="line">.limit(<span class="number">10</span>)</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>我们使用 skip() 转换来丢弃前 10 个结果并采用接下来的 10 个元素。我们可以通过将 Supplier 接口的函数传递给 Stream 上的 generate() 方法来创建任何自定义类型元素的无限流。</p>
<h3 id="字符串流"><a class="markdownIt-Anchor" href="#字符串流"></a> 字符串流</h3>
<p>String 也可以用作创建流的源。</p>
<p>借助 String 类的 chars() 方法。由于 JDK 中没有接口 CharStream，因此 IntStream 用于表示字符流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream streamOfChars = <span class="string">&quot;abc&quot;</span>.chars();</span><br></pre></td></tr></table></figure>
<p>以下示例根据指定的 RegEx 将 String 拆分为子字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; streamOfString =</span><br><span class="line">  Pattern.compile(<span class="string">&quot;, &quot;</span>).splitAsStream(<span class="string">&quot;a, b, c&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="文件流"><a class="markdownIt-Anchor" href="#文件流"></a> 文件流</h3>
<p>Java NIO 类 Files 允许通过 lines() 方法生成文本文件的 Stream <String>。文本的每一行都成为流的一个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">&quot;C:\\file.txt&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; streamOfStrings = Files.lines(path);</span><br><span class="line">Stream&lt;String&gt; streamWithCharset = </span><br><span class="line">  Files.lines(path, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>可以将 Charset 指定为 lines() 方法的参数。</p>
<blockquote>
<p>Java 8 流不能重用。</p>
<p>流管道，是源流，中间操作和终端操作组成的链。</p>
<p>每个流只能使用一个终端操作。</p>
<p>中间操作是惰性的。这意味着只有在执行终端操作时才会调用它们。</p>
<p>减少流大小的中间操作应放在应用于每个元素的操作之前。因此，在流管道的顶部保留skip()，filter()，distinct() 等方法。</p>
</blockquote>
<h2 id="流的归约"><a class="markdownIt-Anchor" href="#流的归约"></a> 流的归约</h2>
<p>API 有许多终端操作，它们将流聚合到类型或原始类型，例如 <code>count()</code>，<code>max()</code>，<code>min()</code>，<code>sum()</code>，但这些操作根据预定义的实现工作。如果开发人员需要定制 Stream 的归约机制呢？有两种方法可以实现这一点 - <code>reduce()</code> 和 <code>collect()</code>方法。</p>
<h3 id="reduce-方法"><a class="markdownIt-Anchor" href="#reduce-方法"></a> reduce 方法</h3>
<p>这种方法有三种变体，它们的传参和返回类型不同。它们可以具有以下参数：</p>
<p><strong>identity(标识)</strong> - 累加器的初始值或者如果流为空且没有任何可累积的默认值;</p>
<p><strong>accumulator(累加器)</strong> - 一个指定元素聚合逻辑的函数。累加器为每个减少步骤创建一个新值。</p>
<p><strong>combiner(结合器)</strong> - 聚合累加器结果的函数。仅在并行模式下从不同线程归约累加器结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reducedParams = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">  .reduce(<span class="number">10</span>, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">     log.info(<span class="string">&quot;combiner was called&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">U result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>结果与未使用结合器中的结果相同，都为 16 (10 + 1 + 2 +3)，并且没有日志，这意味着没有调用该组合器。要使组合器工作，流应该是并行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reducedParallel = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).parallelStream()</span><br><span class="line">    .reduce(<span class="number">10</span>, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">       log.info(<span class="string">&quot;combiner was called&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这里的结果是不同的（36），并且组合器被调用两次。操作并行进行。首先（10 + 1 = 11; 10 + 2 = 12; 10 + 3 = 13;）。现在组合器可以合并这三个结果。它需要两次迭代（12 + 13 = 25; 25 + 11 = 36）。</p>
<h3 id="collect-方法"><a class="markdownIt-Anchor" href="#collect-方法"></a> collect 方法</h3>
<blockquote>
<p>参考 java8-stream 学习</p>
</blockquote>
<p>Collector <code>toMap</code> 方法，可以允许将流转换为 Map 类型，并提供了 key 相同时的合并方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toMap(keyMapper, valueMapper, mergeFunction)</span><br></pre></td></tr></table></figure>
<h2 id="并行流"><a class="markdownIt-Anchor" href="#并行流"></a> 并行流</h2>
<p>在 Java 8 之前，并行化很复杂。 <code>ExecutorService</code> 和 <code>ForkJoin</code> 的出现简化了开发人员的生活，但是他们仍然应该记住如何创建一个特定的执行器，如何运行它，使用 <code>fork/join</code> 框架，您必须指定问题的细分方式（分区）等等。Java 8 引入了一种函数风格的新方式来实现并行机制。</p>
<p>在使用集合的应用程序中实现并行性的一个难点是集合不是线程安全的，这意味着多线程无法在不<strong>引入线程干扰</strong>或<strong>内存一致性错误</strong>的情况下操作集合。 <code>Collections</code> 框架提供了同步包装器，它将自动同步添加到任意集合，使其成为线程安全的。 但是，同步会引入线程争用。 您希望避免线程争用，因为它会阻止线程并行运行。 聚合操作和并行流使您可以实现与非线程安全集合的并行性，前提是您在操作集合时不要修改集合。</p>
<p>API 允许创建并行流，以并行模式执行操作。当流的源是 <code>Collection</code> 或数组时，可以在<code>parallelStream()</code> 方法的帮助下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Product&gt; streamOfCollection = productList.parallelStream();</span><br><span class="line"><span class="keyword">boolean</span> isParallel = streamOfCollection.isParallel();</span><br><span class="line"><span class="keyword">boolean</span> bigPrice = streamOfCollection</span><br><span class="line">  .map(product -&gt; product.getPrice() * <span class="number">12</span>)</span><br><span class="line">  .anyMatch(price -&gt; price &gt; <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>如果流的源不同于 <code>Collection</code> 或数组，则应使用 <code>parallel()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStreamParallel = IntStream.range(<span class="number">1</span>, <span class="number">150</span>).parallel();</span><br><span class="line"><span class="keyword">boolean</span> isParallel = intStreamParallel.isParallel();</span><br></pre></td></tr></table></figure>
<p>内部，<code>Stream API</code> 自动使用 <code>ForkJoin</code> 框架并行执行操作。默认情况下，将使用公共线程池，并且没有办法（至少现在）为它分配一些自定义线程池。</p>
<blockquote>
<p>并行流内部使用了默认的 <code>ForkJoinPool</code>，它默认的线程数量就是你的处理器数量，这个值是由 <code>Runtime.getRuntime().availableProcessors()</code> 得到的。<br />
但是你可以通过系统属性 <code>java.util.concurrent.ForkJoinPool.common.parallelism</code> 来改变线程池大小，如下所示: <code>System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;12&quot;);</code> 这是一个全局设置，因此它将印象代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让 <code>ForkJoinPool</code> 的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议不要修改它。</p>
</blockquote>
<p>在并行模式下使用流时，避免阻塞操作并在任务需要相同的执行时间时使用并行模式（如果一个任务比另一个任务持续时间长，则可能会减慢整个应用程序的工作流程）。</p>
<p>可以使用 <code>sequential()</code> 方法将并行模式的流转换回顺序模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStreamSequential = intStreamParallel.sequential();</span><br><span class="line"><span class="keyword">boolean</span> isParallel = intStreamSequential.isParallel();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 并行流的顺序是由流来源的 <code>Spliterator</code> 的属性决定的，比如 <code>List</code>、<code>LinkedHashSet</code> 实现的 <code>Spliterator</code> 就包含 <code>Spliterator.ORDERED</code> 属性，我们可以通过调用 <code>Stream.unordered()</code> 无序处理以加快并行速度。</p>
<p><code>Stream forEach</code> 在并行流下不保证顺序，但是我们可以使用 <code>forEachOrdered</code>  使具有顺序的流顺序输出。</p>
</blockquote>
<h2 id="新的流式写法"><a class="markdownIt-Anchor" href="#新的流式写法"></a> 新的流式写法</h2>
<h3 id="do-while"><a class="markdownIt-Anchor" href="#do-while"></a> Do-While</h3>
<p>假设在我们的代码里有这样一个简单的 do…while 循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们想要实现类似于标准 do-while 循环的功能时，我们需要使用 <code>limit()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integers = Stream</span><br><span class="line">  .iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>);</span><br><span class="line">integers</span><br><span class="line">  .limit(<span class="number">10</span>)</span><br><span class="line">  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>我们用较少的代码实现了相同功能，但是使用 limit() 函数并没有 doWhile 那样容易阅读。</p>
<h3 id="ifelse"><a class="markdownIt-Anchor" href="#ifelse"></a> if/else</h3>
<h4 id="在-foreach-中使用-ifelse"><a class="markdownIt-Anchor" href="#在-foreach-中使用-ifelse"></a> 在 forEach() 中使用 if/else</h4>
<p>首先，让我们创建一个 Integer 数组，然后在 Integer 流的 forEach() 方法中使用传统的 if / else 逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ints = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">ints.stream()</span><br><span class="line">   .forEach(i -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span> (i.intValue() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">           Assert.assertTrue(i.intValue() % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Assert.assertTrue(i.intValue() % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>我们的 forEach 方法包含 if-else 逻辑，它使用 Java 模运算符验证 Integer 是奇数还是偶数。</p>
<h4 id="使用-filter-作为-ifelse"><a class="markdownIt-Anchor" href="#使用-filter-作为-ifelse"></a> 使用 filter 作为 if/else</h4>
<p>其次，让我们看一下使用 Stream filter() 方法的更优雅的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; evenIntegers = ints.stream()</span><br><span class="line">    .filter(i -&gt; i.intValue() % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">Stream&lt;Integer&gt; oddIntegers = ints.stream()</span><br><span class="line">    .filter(i -&gt; i.intValue() % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">evenIntegers.forEach(i -&gt; Assert.assertTrue(i.intValue() % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">oddIntegers.forEach(i -&gt; Assert.assertTrue(i.intValue() % <span class="number">2</span> != <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>上面我们使用 Stream filter() 方法实现了 if / else 逻辑，将整数列表分成两个 Streams，一个用于偶数整数，另一个用于奇数整数。</p>
<h4 id="使用-partitioningby-分割为两部分"><a class="markdownIt-Anchor" href="#使用-partitioningby-分割为两部分"></a> 使用 partitioningBy 分割为两部分</h4>
<p>我们也可以使用约减操作的 <code>partitioningBy</code> 分割将结果分割成两部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; integerMap = </span><br><span class="line">  ints.stream().collect(Collectors.partitioningBy(i -&gt; i.intValue() % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样我们会得到 true 的 偶数数组和 false 的奇数数组。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stream</tag>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Java8 修复代码烂味道</title>
    <url>/java/Java8-%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81%E7%83%82%E5%91%B3%E9%81%93/</url>
    <content><![CDATA[<p>在学习 Java8 时发现一些写法真的很优秀，用了就有种回不去的感觉，很好的处理了 Java 代码上的烂味道。</p>
<h4 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h4>
<p>在任何使用内部类的地方都使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lamdba表达式</a> 进行重构，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以更简洁的写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.sort((o1,o2) -&gt; o1.length() - o2.length());</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="静态类"><a class="markdownIt-Anchor" href="#静态类"></a> 静态类</h4>
<p>通常我们用 Util 或者 Helper 命名结尾的类来包含静态方法，现在我们可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">interface 来支持静态方法</a>，类可能比接口更好用，但是如果方法是无状态且设计出来为了重写了，可能方法存在接口中更好。</p>
<h4 id="嵌套的-forif-语句"><a class="markdownIt-Anchor" href="#嵌套的-forif-语句"></a> 嵌套的 for/if 语句</h4>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">Stream API</a> 设计出来就是为了更高效的查询 Collections，当你看到下面的代码时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Field&gt; validFields = <span class="keyword">new</span> ArrayList&lt;Field&gt;();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (meetsCriteria(field)) &#123;</span><br><span class="line">        validFields.add(field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> validFields;</span><br></pre></td></tr></table></figure>
<p>你应该考虑使用 Stream API代替，这种情况，使用 filter 和 collect 代替更合适：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> fields.stream()</span><br><span class="line">             .filter(<span class="keyword">this</span>::meetsCriteria)</span><br><span class="line">             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>对于循环内部的 if 语句可以使用 anyMatch 或者 findFirst 进行重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String current : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.equals(wanted)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>可以重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> strings.stream()</span><br><span class="line">              .anyMatch(current -&gt; current.equals(wanted));</span><br></pre></td></tr></table></figure>
<p>和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String current : strings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.equals(wanted)) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>可以重构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> strings.stream()</span><br><span class="line">              .filter(current -&gt; current.equals(wanted))</span><br><span class="line">              .findFirst()</span><br><span class="line">              .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这里的 orElse null 看起来非常难看，我们会在后面进行重构。</p>
<h4 id="一个-collection-多个操作"><a class="markdownIt-Anchor" href="#一个-collection-多个操作"></a> 一个 Collection 多个操作</h4>
<p>为了高效执行代码，我们通常会在一个 Collection 或者多个 Collection 中执行多个操作来取得结果，考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 收集登录消息</span></span><br><span class="line">List&lt;LogLine&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">    lines.add(<span class="keyword">new</span> LogLine(message));</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 排序</span></span><br><span class="line">Collections.sort(lines);</span><br><span class="line"> <span class="comment">// 记录他们</span></span><br><span class="line"><span class="keyword">for</span> (LogLine line : lines) &#123;</span><br><span class="line">    line.log(LOG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分离的步骤可以让我们看清每一步的操作，但在调用 Collection.sort 时我们就该考虑到使用 Streams API，如果我们这样做，就可以将这些多个操作合并为一个 stream ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">messages.stream()</span><br><span class="line">    	.map(LogLine::<span class="keyword">new</span>)</span><br><span class="line">        .sorted()</span><br><span class="line">        .forEach(logLine -&gt; logLine.log(LOG));</span><br></pre></td></tr></table></figure>
<p>这样做不仅削减了一个 Collection，而且可读性更高，代码执行效率也高。</p>
<h4 id="使用-iterator-remove-元素"><a class="markdownIt-Anchor" href="#使用-iterator-remove-元素"></a> 使用 Iterator remove 元素</h4>
<p>在 java8 之前的代码可能像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = strings.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String current = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (current.endsWith(“jnilib”)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，代码可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">strings.removeIf (current -&gt; current.endsWith(“jnilib”));</span><br></pre></td></tr></table></figure>
<p>同样的代码不仅看起来可读性高，而且执行效率更高。</p>
<h4 id="null-检查"><a class="markdownIt-Anchor" href="#null-检查"></a> Null 检查</h4>
<p>NullPointerException 严重影响着 Java 开发人员的工作，为了避免遇到空指针异常我们都会对可能出现 Null 的地方进行检查，采用 Optional 意味着我们可以更明确的知道一个方法期望的返回类型和消除不必要的 Null 检查，考虑我们前面的 orElse(null) ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findString</span> <span class="params">(String wanted)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> strings.stream()</span><br><span class="line">                  .filter(current -&gt;current.equals(wanted))</span><br><span class="line">                  .findFirst()</span><br><span class="line">                  .orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何调用 findString 的代码都必须检查值是否为空，如果是的话需要采取适当的行动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String foundString = findString(wantedString);</span><br><span class="line"><span class="keyword">if</span> (foundString == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> “Did not find value” and</span><br><span class="line">    wantedString;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> foundString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来有些丑以及繁琐，如果我们使用 Optional 代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;String&gt; <span class="title">findString</span><span class="params">(String wanted)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> strings.stream()</span><br><span class="line">                  .filter(current -&gt;current.equals(wanted))</span><br><span class="line">                  .findFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们可以更优雅的处理值找不到的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> findString(wantedString)</span><br><span class="line">       .orElse(“Did notfind value” and wantedString);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>替代 Java 中繁琐的 If 语句</title>
    <url>/java/%E6%9B%BF%E4%BB%A3-Java-%E4%B8%AD%E7%B9%81%E7%90%90%E7%9A%84-If-%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="案例分析"><a class="markdownIt-Anchor" href="#案例分析"></a> 案例分析</h2>
<p>我们经常遇到涉及很多条件的业务逻辑，每个都需要不同的处理。我们以 Calculator 类为例。我们将有一个方法，它接受两个数字和一个运算符作为输入，并根据操作返回结果：</p>
  <a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a + b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;multiply&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a * b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;divide&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a / b;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;subtract&quot;</span>.equals(operator)) &#123;</span><br><span class="line">        result = a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用 switch 语句实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateUsingSwitch</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">        result = a + b;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// other cases    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在典型的开发中，if 语句可能会变得更大，更复杂。此外，当存在复杂条件时，switch 语句不适合。</p>
<p>嵌套决策结构的另一个副作用是它们变得难以管理。例如，如果我们需要添加一个新的运算符，我们必须添加一个新的 if 语句并实现该操作。</p>
<h2 id="重构"><a class="markdownIt-Anchor" href="#重构"></a> 重构</h2>
<p>让我们探索替代选项，将上面的复杂if语句替换为更简单和易于管理的代码。</p>
<ul>
<li>
<h3 id="工厂类"><a class="markdownIt-Anchor" href="#工厂类"></a> 工厂类</h3>
</li>
</ul>
<p>很多时候我们遇到决策结构，最终在每个分支中执行类似的操作。这提供了提取工厂方法的机会，该工厂方法返回给定类型的对象并基于具体对象行为执行操作。<br />
对于上述用例，我们定义一个 Operation 接口，它仅有一个 apply 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法接受两个数字，输出结果。让我们定义一个类来执行加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Addition</span> <span class="keyword">implements</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现一个工厂类，它根据给定的运算符返回 Operation 的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Operation&gt; operationMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        operationMap.put(<span class="string">&quot;add&quot;</span>, <span class="keyword">new</span> Addition());</span><br><span class="line">        operationMap.put(<span class="string">&quot;divide&quot;</span>, <span class="keyword">new</span> Division());</span><br><span class="line">        <span class="comment">// more operations</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Operation&gt; <span class="title">getOperation</span><span class="params">(String operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(operationMap.get(operator));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，在 Calculator 类中，我们可以查询工厂以获取相关操作并应用源数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateUsingFactory</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span> </span>&#123;</span><br><span class="line">    Operation targetOperation = OperatorFactory</span><br><span class="line">        .getOperation(operator)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="function">nwe <span class="title">IllegalArgumentException</span><span class="params">(<span class="string">&quot;Invalid Operator&quot;</span>)</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> targetOperation.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们已经看到了如何将责任委托给工厂类提供的松散耦合对象。但是有可能嵌套的 if 语句只是转移到了工厂类，这违背了我们的目的。<br />
或者，我们可以在 Map 中维护一个对象存储库，可以查询该存储库以进行快速查找。</p>
<ul>
<li>
<h3 id="使用枚举"><a class="markdownIt-Anchor" href="#使用枚举"></a> 使用枚举</h3>
除了使用 Map 之外，我们还可以使用 Enum 来标记特定的业务逻辑。之后，我们可以在嵌套的 if 语句或 switch case 语句中使用它们。或者，我们也可以将它们用作对象的工厂并制定策略以执行相关的业务逻辑。<br />
这也会减少嵌套 if 语句的数量，并将责任委托给单个 Enum 值。<br />
让我们看如何实现它，首先，定义一个枚举：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operator &#123;</span><br><span class="line">    ADD, MULTIPLY, SUBTRACT, DIVIDE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以观察到，这些值是不同运算符的标签，将进一步用于计算。我们总是可以选择在嵌套的 if 语句或 switch case<br />
中使用这些值作为不同的条件，<br />
但是让我们设计一种将逻辑委托给 Enum 本身的替代方法。 我们将为每个 Enum 值定义方法并进行计算。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operator &#123;</span><br><span class="line">    ADD &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// other operators</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">apply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法称作 <code>Constant-specific methods</code>， 参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/enums.html">枚举</a><br />
然后在 Calculator 类中，我们可以定义一个方法来执行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operator operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.apply(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以通过使用 <code>Operator＃valueOf()</code> 方法将String 值转换为 Operator 来调用该方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCalculateUsingEnumOperator_thenReturnCorrectResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="keyword">int</span> result = calculator.calculate(<span class="number">3</span>, <span class="number">4</span>, Operator.valueOf(<span class="string">&quot;ADD&quot;</span>));</span><br><span class="line">    assertEquals(<span class="number">7</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h3>
我们还可以设计一个 <code>Calculator＃calculate</code> 方法来接受可以在输入上执行的命令。这将是替换嵌套 if 语句的另一种方法。<br />
首先定义我们的 Command 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们实现一个 AddCommand：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instance variables</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddCommand</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们在 Calculator 中添加一个接收和执行 Command 的新方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> command.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以通过实例化 <code>AddCommand</code> 调用计算并将其发送到 <code>Calculator＃calculate</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCalculateUsingCommand_thenReturnCorrectResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="keyword">int</span> result = calculator.calculate(<span class="keyword">new</span> AddCommand(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">    assertEquals(<span class="number">10</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="规则引擎"><a class="markdownIt-Anchor" href="#规则引擎"></a> 规则引擎</h3>
</li>
</ul>
<p>当我们最终编写大量嵌套 if 语句时，每个条件都描述了一个业务规则，必须对其进行评估才能处理正确的逻辑。规则引擎从主代码中分离了这种复杂性。 RuleEngine 评估规则并根据输入返回结果。<br />
让我们通过设计一个简单的 RuleEngine 来演示一个例子，该 RuleEngine 通过一组规则处理 Expression 并返回所选规则的结果。首先，我们将定义一个 Rule 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rule</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Expression expression)</span></span>;</span><br><span class="line">    <span class="function">Result <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，让我们实现一个 RuleEngine：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleEngine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Rule&gt; rules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        rules.add(<span class="keyword">new</span> AddRule());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">process</span><span class="params">(Expression expression)</span> </span>&#123;</span><br><span class="line">        Rule rule = rules</span><br><span class="line">          .stream()</span><br><span class="line">          .filter(r -&gt; r.evaluate(expression))</span><br><span class="line">          .findFirst()</span><br><span class="line">          .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Expression does not matches any Rule&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> rule.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RuleEngine 接受 Expression 对象并返回 Result。现在，让我们将 Expression 类设计为一组包含两个 Integer 对象的 Operator，它将被应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer x;</span><br><span class="line">    <span class="keyword">private</span> Integer y;</span><br><span class="line">    <span class="keyword">private</span> Operator operator;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后让我们定义一个自定义的 AddRule 类，它仅在指定 ADD 操作时进行求值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRule</span> <span class="keyword">implements</span> <span class="title">Rule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">evaluate</span><span class="params">(Expression expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> evalResult = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (expression.getOperator() == Operator.ADD) &#123;</span><br><span class="line">            <span class="keyword">this</span>.result = expression.getX() + expression.getY();</span><br><span class="line">            evalResult = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evalResult;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在将使用 Expression 调用 RuleEngine ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenNumbersGivenToRuleEngine_thenReturnCorrectResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Expression expression = <span class="keyword">new</span> Expression(<span class="number">5</span>, <span class="number">5</span>, Operator.ADD);</span><br><span class="line">    RuleEngine engine = <span class="keyword">new</span> RuleEngine();</span><br><span class="line">    Result result = engine.process(expression);</span><br><span class="line"> </span><br><span class="line">    assertNotNull(result);</span><br><span class="line">    assertEquals(<span class="number">10</span>, result.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream 学习</title>
    <url>/java/Java8-Stream%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Java 8 提供了一个新的 API（称为”流“，Stream），它支持大数据的并行操作，其思路和在数据库查询语言中的思路相似 – 用更高级的方式表达想要的东西，而由”实现“（在这里是 Streams 库）来选择最佳低级执行机制。这样就可以避免用 <code>synchronized</code> 来编写代码，这一行代码不仅容器出错，而且在多核 CPU 上执行所需的成本比想象要高<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h2 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h2>
<blockquote>
<p>是函数式编程（functional programming）的一种 Java 实现</p>
</blockquote>
<blockquote>
<p>强调将计算过程分解成可复用的函数，主要使用 map 方法和 reduce 方法组合而成的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MapReduce">MapReduce</a> 算法，最好的实现 Apache Hadoop</p>
</blockquote>
<a id="more"></a>
<h2 id="streams-和-collections-的不同"><a class="markdownIt-Anchor" href="#streams-和-collections-的不同"></a> Streams 和 Collections 的不同</h2>
<ul>
<li><strong>不储存元素。</strong> Stream 不是储存元素的数据结构；相反的，它通过管道对源就像数据结构、数组、构造方法、IO 流的元素进行操作。</li>
<li><strong>纯粹的方法，也叫无副作用 (no side effect)。</strong> Stream 上的操作会产生结果，但不会修改其来源。例如，过滤从集合获取的流会生成一个没有过滤元素的新 Stream，而不是从源集合中删除元素。</li>
<li><strong>惰性化。</strong> 许多流操作（例如过滤，映射或重复移除）可以被惰性化实现，从而为优化提供机会。流操作分为中间 (intermediate) 操作和终端 (terminal) 操作，中间操作总是惰性的。</li>
<li><strong>可能没有限制。</strong> 尽管集合的大小有限，但流不需要。诸如 limit(n) 或 findFirst() 之类的短路操作可以允许无限流上的计算在有限的时间内完成。</li>
<li><strong>一次性。</strong> 流的元素在流的生命周期中仅访问过一次。像 Iterator 一样，必须生成一个新的流来重新访问源的相同元素。</li>
</ul>
<blockquote>
<p>集合和流，它们有不同的关注点，集合主要关注集合的有效管理和访问。<br />
相反，流不直接提供访问和操作元素的手段，而是关注于声明性地描述它们的来源和将在该来源上进行的计算操作。如果流操作没有你想要的功能，你可以使用 iterator() 或 spliterator() 来遍历操作。</p>
</blockquote>
<blockquote>
<p>外部迭代器是客户端主动调用迭代的，内部迭代器是由内部迭代器自身迭代的。枚举，增强 for 循环还是使用 iterator() 来进行遍历，它们同属于外部遍历器，java8 集合的 forEach 和 stream 的 forEach() 属于内部遍历器，流的内部遍历器可以使用到流的并行（parallel）特性，从而加快速度。</p>
</blockquote>
<p>流操作分为中间操作（intermediate operations）和终端操作（terminal operations），结合形成流管道。流管道由源（例如集合，数组，生成器函数或 I/O 通道）组成; 随后是零个或多个中间操作，例如 <code>Stream.filter</code> 或 <code>Stream.map</code> 和诸如 <code>Stream.forEach</code> 或 <code>Stream.reduce</code> 之类的终端操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>类型</th>
<th>返回类型</th>
<th>使用的类型/函数式接口</th>
<th>函数描述符</th>
</tr>
</thead>
<tbody>
<tr>
<td>filter</td>
<td>中间</td>
<td>Stream<T></td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>distinct</td>
<td>中间 (有状态 - 无界)</td>
<td>Stream<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>中间 (有状态 - 有界)</td>
<td>Stream<T></td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>limit</td>
<td>中间 (有状态 - 有界)</td>
<td>Stream<T></td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>中间</td>
<td>Stream<T></td>
<td>Function&lt;T, R&gt;</td>
<td>T -&gt; R</td>
</tr>
<tr>
<td>flatMap</td>
<td>中间</td>
<td>Stream<T></td>
<td>Function&lt;T, Stream<R>&gt;</td>
<td>T -&gt; Stream<R></td>
</tr>
<tr>
<td>sorted</td>
<td>中间 (有状态 - 无界)</td>
<td>Stream<T></td>
<td>Comparator<T></td>
<td>(T, T) -&gt; int</td>
</tr>
<tr>
<td>anyMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>noneMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>allMatch</td>
<td>终端</td>
<td>boolean</td>
<td>Predicate<T></td>
<td>T -&gt; boolean</td>
</tr>
<tr>
<td>findAny</td>
<td>终端</td>
<td>Optional<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>findFirst</td>
<td>终端</td>
<td>Optional<T></td>
<td></td>
<td></td>
</tr>
<tr>
<td>forEach</td>
<td>终端</td>
<td>void</td>
<td>Consumer<T></td>
<td>T -&gt; void</td>
</tr>
<tr>
<td>collect</td>
<td>终端</td>
<td>R</td>
<td>Collector&lt;T, A, R&gt;</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>终端 (有状态 - 有界)</td>
<td>Optional<T></td>
<td>BinaryOperator<T></td>
<td>(T, T) -&gt; T</td>
</tr>
<tr>
<td>count</td>
<td>终端</td>
<td>long</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="intermediate-operations中间操作"><a class="markdownIt-Anchor" href="#intermediate-operations中间操作"></a> Intermediate operations（中间操作）</h2>
<p><strong>中间操作返回一个新的流（Stream<T>）。</strong></p>
<p>他们总是惰性的，执行诸如 <code>filter()</code> 之类的中间操作实际上并不执行任何过滤，而是创建一个新的流，该流在遍历时包含与给定谓词相匹配的初始流的元素。在管道的终端操作被执行时对源的流水遍历才会开始。</p>
<p>中间操作进一步分为无状态和有状态操作。无状态操作（如 <code>filter</code> 和 <code>map</code>）在处理新元素时不会保留先前看到的元素的状态 – 每个元素可以独立于其他元素上的操作进行处理。有状态的操作（如 <code>distinct</code> 和 <code>sorted</code>）可能会在处理新元素时结合之前看到的元素的状态。</p>
<p>有状态的操作可能需要在生成结果之前处理整个输入。例如，只有在查看了流的所有元素之后，才能对排序流产生任何结果。因此，在并行计算中，一些包含有状态中间操作的管道可能需要对数据进行多次传递，或者可能需要缓存重要数据。只包含无状态中间操作的流水线可以一次处理，无论是顺序处理还是并行处理，只需最少的数据缓冲。</p>
<p>常用的一些操作：</p>
<h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h3>
<p><strong>返回由给定函数作用于此流的元素后产生的结果组成的流。</strong><br />
 给定函数为无干涉，无状态的操作作用于每个元素。不然之后的操作结果可能不会很准确。</p>
<ul>
<li>
<h4 id="无干涉"><a class="markdownIt-Anchor" href="#无干涉"></a> 无干涉</h4>
无干涉主要是指在流操作期间不去修改<strong>源流</strong>。</li>
</ul>
<p>+ #### 无状态<br />
无状态是指我们在处理时不产生中间状态，操作不依赖之前的状态。</p>
<h3 id="distinct"><a class="markdownIt-Anchor" href="#distinct"></a> distinct</h3>
<p><code>distinct</code> 保证输出的流中包含唯一的元素，它是通过 <code>Object.equals(Object)</code> 来检查是否包含相同的元素。它是一个有状态的中间操作。</p>
<blockquote>
<p>在并行流中对无序数组去重效率更高，对于有序数组可以使用 <code>unordered()</code> 无序检索提高速度，或者使用<code>sequential()</code>来实现串行。</p>
<p>相反有序数组更适合使用串行流。</p>
</blockquote>
<h3 id="peek"><a class="markdownIt-Anchor" href="#peek"></a> peek</h3>
<p><code>peek</code> 产生一个和原流相同的流，并在遍历流的过程中去消费每个元素。</p>
<blockquote>
<p>使用 peek 的主要目的是**“看，不要动”**。<br />
此方法主要用于支持调试，您希望在元素流经管道中的某个点时看到这些元素：请谨慎使用此方法作为副作用，因为它有可能会修改源流。</p>
</blockquote>
<h3 id="flatmap"><a class="markdownIt-Anchor" href="#flatmap"></a> flatMap</h3>
<p>返回一个流，该流包含将原流的<em>每个元素替换为映射函数应用于每个元素而生成的映射流的内容</em>的结果。每个映射流都将其内容放入此流后关闭。（如果映射流为空，则使用空流代替）<br />
简而言之，扁平化多个流为一个新流。</p>
<blockquote>
<p>flatMap() 操作具有对流的元素应用一对多转换，然后将生成的元素展平为新流的效果。</p>
</blockquote>
<h4 id="example"><a class="markdownIt-Anchor" href="#example"></a> example</h4>
<p>orders 是采购订单流，并且每个采购订单都包含一系列采购列，则以下内容会生成包含所有订单中的所有采购列的流：</p>
<p><code>orders.flatMap(order -&gt; order.getLineItems().stream())...</code></p>
<p>如果 path 是文件的路径，那么下面的内容会生成包含在该文件中的单词流：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8);</span><br><span class="line">Stream&lt;String&gt; words = lines.flatMap(line -&gt; Stream.of(line.split(<span class="string">&quot; +&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>上面 flatmap 中的映射函数使用的正则比较简单，具体单词划分的正则不是这样。</p>
<h3 id="count"><a class="markdownIt-Anchor" href="#count"></a> count</h3>
<p>返回此流中元素的数量。这是一个简写，相当于：</p>
  <figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> mapToLong(e -&gt; <span class="number">1</span>L).<span class="built_in">sum</span>();</span><br></pre></td></tr></table></figure>
<h2 id="terminal-operations终端操作"><a class="markdownIt-Anchor" href="#terminal-operations终端操作"></a> Terminal operations（终端操作）</h2>
<blockquote>
<p>终端操作返回确定类型的结果</p>
</blockquote>
<p>如 <code>Stream.forEach</code> 或 <code>IntStream.sum</code>，可能会遍历流以产生结果或副作用(side-effect)。终端操作执行后，流管道被视为消耗，并不能再使用；如果你需要再次遍历相同的数据源，则必须返回到数据源以获取新的流。在几乎所有情况下，终端操作都非常急切，在返回之前完成数据源的遍历和管道的处理。只有终端操作 <code>iterator()</code> 和 <code>spliterator()</code> 不是。</p>
<h3 id="副作用side-effect"><a class="markdownIt-Anchor" href="#副作用side-effect"></a> 副作用（side-effect）</h3>
<p>副作用可能会违反无状态要求和对线程安全产生危害。<br />
许多计算可能会产生副作用，但是可以更安全有效地表达，而不会产生副作用，例如使用 <code>归约</code> 而不是 <code>可变累加器</code>。少量流操作（例如 <code>forEach()</code> 和 <code>peek()</code>）只能通过副作用操作，应该小心使用。比如我们在对流操做以期望得到想要的结果，而无意修改了原始流，便产生了副作用。</p>
<p>常见的副作用包括：</p>
<ul>
<li>修改任何外部变量或对象属性（例如，全局变量或流作用域外部的变量）</li>
<li>打印日志</li>
<li>文件读写</li>
<li>网络请求</li>
<li>触发外部事件</li>
<li>调用其它由副作用的方法</li>
<li>等等</li>
</ul>
<h3 id="归约reduction-operations"><a class="markdownIt-Anchor" href="#归约reduction-operations"></a> 归约（Reduction operations）</h3>
<p>归约操作（也称为折叠）将一系列输入元素，通过重复应用组合操作（例如查找一组数字的和或最大值）或将元素累加到列表中来将它们组合为单个汇总结果。</p>
<p>流类具有多种形式的<strong>通用归约操作</strong>，称为 <code>reduce()</code> 和 <code>collect()</code>，以及多个<strong>专用简化形式</strong>，如 <code>sum()</code>，<code>max()</code> 或 <code>count()</code>。</p>
<h4 id="规约方法的优势与并行化"><a class="markdownIt-Anchor" href="#规约方法的优势与并行化"></a> 规约方法的优势与并行化</h4>
<p>相比于逐步迭代求和，使用 <code>reduce</code> 的好处在于，这里的迭代被内部迭代抽象掉了，这让内部实现得以选择并行执行 reduce 操作。而迭代式求和要更新共享变量 sum，这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争抵消了并行本应带来的性能提升，这种计算的并行化需要另一种办法：将输入分块，分块求和，最后再合并起来。参见：<a href="#">Post not found: ForkJoin-框架入门 ForkJoin 框架</a><br />
但现在重要的是要认识到，可变的累加器模式对于并行化来说是思路一条。需要一种新的模式，这正是 reduce 所提供的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = numbers.parallelStream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<p>但要并行执行这段代码也要付出一定代价：传递给 reduce 的 Lambda 不能更改状态（如实例变量），而且操作作必须满足结合律才可以按任意顺序执行。</p>
<h4 id="可变归约mutable-reduction"><a class="markdownIt-Anchor" href="#可变归约mutable-reduction"></a> 可变归约（Mutable reduction）</h4>
<p>可变归约操作将输入元素累加到<strong>可变结果容器</strong>中，例如 <code>Collection</code> 或 <code>StringBuilder</code>，因为它处理流中的元素。</p>
<p>可变归约操作称为 <code>collect()</code>，因为它将所需结果一起收集到结果容器（如集合）中。 收集操作需要三个功能：构造结果容器的新实例的供应者函数，将输入元素并入结果容器的累加器函数以及将一个结果容器的内容合并到另一个结果容器的组合函数。</p>
<ul>
<li>供应器 (supplier())</li>
<li>累加器 (accumulator())</li>
<li>组合器 (combiner())</li>
<li>修整器 (finisher()) <em>可省略</em></li>
</ul>
<blockquote>
<p>归约 (reduce) 方法旨在把两个值结合起来生成一个新值，它是一个不可变的规约。与此相反，collect 方法的设计就是要改变容器，从而累加要输出的结果。错误的使用归约方法可能导致并行工作不正常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">            BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (T element : stream) &#123;</span><br><span class="line">   strings.add(element.toString());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>我们可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strings = stream.collect(() -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(),</span><br><span class="line">                                        (c, e) -&gt; c.add(e.toString()),</span><br><span class="line">                                        (c1, c2) -&gt; c1.addAll(c2));</span><br></pre></td></tr></table></figure>
<p>简写作：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = stream.map(Object::toString)</span><br><span class="line">                                    .collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>
<p>在这里，我们的供应器是 <code>ArrayList</code> 构造函数，累加器将字符串化的元素添加到 <code>ArrayList</code>，组合器只是简单地使用 <code>addAll</code> 将字符串从一个容器复制到另一个容器中。<br />
<code>collect</code> 的供应器，累加器和组合器三个方面紧密耦合。我们可以使用抽象的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html">Collector</a> 来包含三个方面，上面的代码可以重写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = stream.map(Object::toString)</span><br><span class="line">                                  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h5 id="collector-收集器接口"><a class="markdownIt-Anchor" href="#collector-收集器接口"></a> Collector 收集器接口</h5>
<p>使用收集器对流的元素执行可变归约操作。收集器封装了用作收集参数的函数 (供应器，累加器，组合器），从而允许重用收集策略和组合收集操作，例如多级分组或分区。</p>
<h5 id="收集器collectors实现类"><a class="markdownIt-Anchor" href="#收集器collectors实现类"></a> 收集器（Collectors）实现类</h5>
<p><strong>Collectors 是 Collector 接口的实现类，它里面包含了常用的收集策略。</strong><br />
常见的策略以静态工厂方法的形式提供，包括：</p>
<ul>
<li>将元素累加到集合中；<br />
<code>toList</code> <code>toMap</code> <code>toSet</code> <code>toCollection</code></li>
<li>使用 <code>StringBuilder</code> 连接字符串：<code>joining</code></li>
<li>计算关于总和，最小值，最大值或平均值等元素的摘要信息；
<ul>
<li>求和 <code>counting()</code> <code>collectingAndThen</code></li>
<li>汇总 <code>summarizingDouble</code> <code>summingDouble</code>…</li>
<li>最大值、最小值 <code>maxBy</code> <code>minBy</code></li>
<li>平均值 <code>averagingDouble</code> <code>averagingInt</code>…</li>
</ul>
</li>
<li>计算“数据透视表”摘要，例如“卖方最大价值交易”等。
<ul>
<li>分组 <code>groupingBy</code></li>
<li>分割 <code>partitioningBy</code></li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将用户姓名归约成一个集合</span></span><br><span class="line">List&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把用户姓名归约到 TreeSet 集中</span></span><br><span class="line">Set&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象转换为字符串并将它们用逗号分隔连接起来</span></span><br><span class="line">String joined = things.stream()</span><br><span class="line">        .map(Object::toString)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算输入员工的工资总和 </span></span><br><span class="line"><span class="keyword">int</span> total = employees.stream()</span><br><span class="line">                .collect(Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入员工按部门分组</span></span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按部门分组计算工资总额 </span></span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把学生分成及格和不及格数组</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">                .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>多核 CPU 的每个处理器内核都有独立的高速缓存。加锁需要这些高速缓存同步运行，然而这又需要在内核间进行较慢的缓存一致性协议通信。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Streams</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>Map.merge()</title>
    <url>/data-structure/Map.merge()/</url>
    <content><![CDATA[<h1 id="mapmerge"><a class="markdownIt-Anchor" href="#mapmerge"></a> Map.merge()</h1>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)">Map.merge()</a> 在键值范围中可能是功能最丰富的操作。而且还比较晦涩，很少使用。 merge() 可以解释如下：如果键值不存在（if absent），将新值放在给定键下；否则使用给定值更新现有键（UPSERT）。让我们从最基本的示例开始：计算唯一单词的出现次数。Java 8 之前的实现比较麻烦：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> prev = map.get(word);</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.put(word, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(word, prev + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是，它可以工作，并且对于给定的输入会产生所需的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = List.of(<span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Buzz&quot;</span>, <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;Buzz&quot;</span>, <span class="string">&quot;Fizz&quot;</span>, <span class="string">&quot;Fizz&quot;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#123;Bar=<span class="number">1</span>, Fizz=<span class="number">2</span>, Foo=<span class="number">3</span>, Buzz=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>让我们尝试对其进行重构以避免条件逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    map.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">    map.put(word, map.get(word) + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>真好！ <code>putIfAbsent()</code> 必不可少，否则，代码将在首次出现以前未知的单词时中断。另外，我在 <code>map.put()</code> 中发现 <code>map.get(word)</code> 有点别扭。让我们也摆脱它！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    map.putIfAbsent(word, <span class="number">0</span>);</span><br><span class="line">    map.computeIfPresent(word, (w, prev) -&gt; prev + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>仅当存在相关单词时，<code>computeIfPresent()</code> 才调用给定的转换，否则什么都不做。我们通过将键初始化为零来确保键存在，因此后面的增加转换始终有效。我们可以做得更好吗？通过减少额外的初始化，但是我不建议这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt;</span><br><span class="line">        map.compute(word, (w, prev) -&gt; prev != <span class="keyword">null</span> ? prev + <span class="number">1</span> : <span class="number">1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>compute()</code> 与 <code>computeIfPresent()</code> 类似，但是无论给定键是否存在都被调用。如果键的值不存在，则 <code>prev</code> 参数为 <code>null</code>。将 if 判断隐藏在 lambda 中的三元表达式远非最佳。这是 <code>merge()</code> 运算符的亮点。在向您展示最终版本之前，让我们看一下 <code>Map.merge()</code> 的默认简化实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value, BiFunction&lt;V, V, V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码段价值一千个字。 <code>merge()</code> 在两种情况下工作。如果给定的键不存在，它将变成 <code>put(key，value)</code>。但是，如果给定键已经具有某个值，那么我们的 <code>remappingFunction</code> 会合并（移除）旧的值和给定值。此功能可如下使用：</p>
<ul>
<li>使用新值覆盖旧值：<code>(old, new) -&gt; new</code></li>
<li>保留旧值：<code>(old, new) -&gt; old</code></li>
<li>以某种方式合并两者，例如：<code>(old, new) -&gt; old + new</code></li>
<li>甚至删除旧值：<code>(old, new) -&gt; null</code></li>
</ul>
<p>如您所见，merge() 非常通用。那么我们的问题使用 merge() 怎么做？非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">words.forEach(word -&gt;</span><br><span class="line">        map.merge(word, <span class="number">1</span>, (prev, one) -&gt; prev + one)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>解释如下：如果单词不存在，该单词初始值为 1，否则将 1 添加到现有值。我将参数之一命名为 “one”，因为在我们的示例中，它始终是……1。遗憾的是 <code>remappingFunction</code> 需要两个参数，其中第二个是我们将要更新（新增或修改）的值。从技术上讲，我们已经知道此值，因此 <code>(word, 1, prev -&gt; prev + 1)</code> 将更容易理解。但是没有这样的 API。</p>
<p>好的，但是 merge() 真的有用吗？假设您有一个帐户操作（省略了构造函数，getter 和其他有用的属性）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String accNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigDecimal amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及针对不同帐户的一系列操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> operations = List.of(</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;10&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1200&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;-4&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;8&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;800&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;-1500&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;2&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;123&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;-6.5&quot;</span>)),</span><br><span class="line">    <span class="keyword">new</span> Operation(<span class="string">&quot;456&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;-600&quot;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们想计算每个帐户的余额（总操作金额）。没有 <code>merge()</code>，这将很麻烦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balances = <span class="keyword">new</span> HashMap&lt;String, BigDecimal&gt;();</span><br><span class="line"> </span><br><span class="line">operations.forEach(op -&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> key = op.getAccNo();</span><br><span class="line">    balances.putIfAbsent(key, BigDecimal.ZERO);</span><br><span class="line">    balances.computeIfPresent(key, (accNo, prev) -&gt; prev.add(op.getAmount()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是在 merge() 的帮助下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">operations.forEach(op -&gt;</span><br><span class="line">        balances.merge(op.getAccNo(), op.getAmount(), </span><br><span class="line">                (soFar, amount) -&gt; soFar.add(amount))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用方法引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">operations.forEach(op -&gt;</span><br><span class="line">        balances.merge(op.getAccNo(), op.getAmount(), BigDecimal::add)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我觉得这很可读。对于每个操作，将给定数量添加到给定编号。结果符合预期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">123</span>=<span class="number">9.5</span>, <span class="number">456</span>=-<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> <code>ConcurrentHashMap</code></h2>
<p>当您意识到 ConcurrentHashMap 中正确实现了 Map.merge() 时，它会更加有用。这意味着我们可以原子地执行插入或更新操作。而且线程安全。</p>
<hr />
<p><a target="_blank" rel="noopener" href="https://www.nurkiewicz.com/2019/03/mapmerge-one-method-to-rule-them-all.html">原文链接</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类加载器</title>
    <url>/java/jvm/Java-Class-Loaders/</url>
    <content><![CDATA[<h2 id="类加载"><a class="markdownIt-Anchor" href="#类加载"></a> 类加载</h2>
<p>在 Java 类或接口编译为 Class 二进制字节码后，当我们用到该类或接口时，虚拟机就会将描述类的数据加载到<strong>方法区内存</strong>中，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<p><strong>类型的加载、连接和初始化过程发生在程序运行期间。</strong></p>
<p>Java 虚拟机中类加载的全过程包含：加载、验证、准备、解析和初始化，这里我们只介绍加载一个阶段。</p>
<p><img src="../../../images/java/java_execute.gif" alt="字节码验证器" /></p>
<h2 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h2>
<p>加载阶段，虚拟机规范要求虚拟机主要完成一下 3 件事情：</p>
<ol>
<li>通过一个类的完全限定名称来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</li>
<li>在内存中生成一个代表类的 <code>java.lang.Class</code> 对象，作为方法区的这个类的各种数据的访问入口。</li>
</ol>
<blockquote>
<p><strong>HotSpot 虚拟机是将生成的该 Class 对象放在了方法区中，而不是堆中。</strong></p>
</blockquote>
<a id="more"></a>
<p>虚拟机规范并未指明二进制字节流要从一个 Class 文件中获取，准确说根本没有指明从哪里获取、怎样获取，我们可以从：</p>
<ul>
<li>从 ZIP 包中读取，比如 JAR、EAR、WAR。</li>
<li>从网络中获取，比如 Applet。</li>
<li>运行时计算生成，这种场景使用最多的就是动态代理技术，在 <code>java.lang.reflect.Proxy</code> 中，使用了 <code>ProxyGenerator.generateProxyClass</code> 来为特定接口生成形式为 “*$Proxy” 的代理类二进制字节流。</li>
<li>由其它文件生成，典型场景就是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库中读取…</li>
</ul>
<h2 id="类加载器简介"><a class="markdownIt-Anchor" href="#类加载器简介"></a> 类加载器简介</h2>
<p>类加载用于实现类的加载动作，虚拟机把这个加载动态交给外部去实现，以便应用程序自己决定如何获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>对于任意一个类，都需要加载它的类和这个类本身一同确立在 Java 虚拟机中的唯一性，每个类加载，都拥有一个独立的类名称空间。对于不同类加载器加载的同一个 Class 文件，这两个类也必定不相等。这里的相等是指 Class 对象的 equals、 isAssignableFrom、isInstance 方法返回的结果。</p>
<p>每个 Class 对象都包含对定义它的 ClassLoader 的引用。</p>
<p>数组类的类对象不是由类加载器创建的，而是由 Java 虚拟机直接创建的。<strong>Class.getClassLoader()</strong> 返回的数组类的类加载器与其元素类型的类加载器相同；如果元素类型是基本类型，则数组类与引导类加载器关联。</p>
<p>支持并发加载类的类加载器称为并行加载类加载器，需要通过调用 <code>ClassLoader.registerAsParallelCapable</code> 方法在类初始化时注册自己。请注意，ClassLoader 类默认注册为并行。但是，它的子类如果具有并行能力，仍然需要注册自己。</p>
<p>在委托模型不是严格分层的环境中，类加载器需要具有并行能力，否则类加载会导致死锁，因为加载器锁在类加载过程的持续时间内保持不变（请参阅 <code>loadClass</code> 方法）。</p>
<p>通常，Java 虚拟机以与平台相关的方式从本地文件系统加载类。例如，在 UNIX 系统上，虚拟机从 <a href="#CLASSPATH"><code>CLASSPATH</code></a>   环境变量定义的目录中加载类。</p>
<p>但是，某些类可能不是源自文件；它们可能来自其他来源，例如网络，或者它们可以由应用程序构建。方法 <code>defineClass</code> 将字节数组转换为类 Class 的实例，可以使用 <code>Class.newInstance</code> 创建此新定义的类的实例。</p>
<p>例如，应用程序可以创建网络类加载器以从服务器下载类文件。示例代码可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader loader = <span class="keyword">new</span> NetworkClassLoader(host, port);</span><br><span class="line">Object main = loader.loadClass(<span class="string">&quot;Main&quot;</span>, <span class="keyword">true</span>).newInstance();</span><br><span class="line">			. . .</span><br></pre></td></tr></table></figure>
<p>网络类加载器子类必须定义方法 <code>findClass</code> 和 <code>loadClassData</code> 以从网络加载类。一旦下载了构成类的字节，就应该使用 <code>defineClass</code> 方法创建一个类实例。示例实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    String host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">      <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">      <span class="comment">// load the class data from the connection</span></span><br><span class="line">      . . .</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类加载器类型"><a class="markdownIt-Anchor" href="#类加载器类型"></a> 类加载器类型</h2>
<p>让我们首先学习如何使用各种类加载器使用一个简单示例加载不同的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClassLoaders</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Classloader of this class:&quot;</span></span><br><span class="line">       + PrintClassLoader.class.getClassLoader());</span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">&quot;Classloader of Logging:&quot;</span></span><br><span class="line">       + Logging.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Classloader of ArrayList:&quot;</span></span><br><span class="line">       + ArrayList.class.getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行时，上面的方法打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class loader of this class:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">Class loader of Logging:sun.misc.Launcher$ExtClassLoader@<span class="number">3</span>caeaf62</span><br><span class="line">Class loader of ArrayList:<span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里有三种不同的类加载器：应用程序，扩展和引导程序（显示为 null）。</p>
<p>应用程序类加载器加载包含示例方法的类。<strong>应用程序或系统类加载器在类路径中加载我们自己的文件</strong>。</p>
<p>接下来，扩展程序加载 Logging 类。<strong>扩展类加载器加载类，它们是标准核心 Java 类的扩展</strong>。</p>
<p>最后，bootstrap 加载 ArrayList 类。<strong>引导或原始类加载器是所有其他加载器的父级。</strong></p>
<p>我们可以看到最后输出，对于 ArrayList，它在输出中显示为 null。<strong>这是因为对于 HotSpot 虚拟机的引导类加载器是用本地代码（native code）而不是 Java 编写的 - 因此它不会显示为 Java 类。</strong></p>
<p>现在让我们更详细地讨论每个类加载器。</p>
<h3 id="引导bootstrap类加载器"><a class="markdownIt-Anchor" href="#引导bootstrap类加载器"></a> 引导（Bootstrap）类加载器</h3>
<p>Java 类由 <code>java.lang.ClassLoader</code> 的实例加载。但是，类加载器本身就是类。因此，问题是，谁加载 <code>java.lang.ClassLoader</code> 本身？</p>
<p>这就需要介绍到 引导或原始类加载器。它主要负责加载 JDK 内部类，通常是 <code>rt.jar</code> 和位于<code>$JAVA_HOME/jre/lib</code> 目录中的其他核心库。此外，<strong>引导类加载器充当所有其他 ClassLoader 实例的父级。</strong></p>
<p><strong>此引导类加载器是核心 JVM 的一部分，并使用本地代码（native code）编写</strong>，如上说述，不同的 JVM 平台可能具有此特定类加载器的不同实现。</p>
<h3 id="扩展类加载器"><a class="markdownIt-Anchor" href="#扩展类加载器"></a> 扩展类加载器</h3>
<p>**扩展类加载器是引导类加载器的子类，负责加载标准核心 Java 类的扩展，**以便它可供平台上运行的所有应用程序使用。</p>
<p>扩展类加载器从 JDK 扩展目录加载，通常是 <code>$JAVA_HOME/lib/ext</code> 目录或 <code>java.ext.dirs</code> 系统属性中提到的任何其他目录。</p>
<h3 id="应用程序类加载器"><a class="markdownIt-Anchor" href="#应用程序类加载器"></a> 应用程序类加载器</h3>
<p>应用程序类加载器负责将所有应用程序级别的类加载到 JVM 中，由于这个类加载器是 ClassLoader 中的 getSystemClassLoader 方法的返回值，所以一般也称为系统类加载器。</p>
<p>**它负责加载在用户类路径环境变量 - classpath 或 -cp 命令行选项中找到的文件。**开发者可以直接使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h2 id="类加载机如何工作"><a class="markdownIt-Anchor" href="#类加载机如何工作"></a> 类加载机如何工作？</h2>
<p>类加载器是 Java 运行时环境的一部分。当 JVM 请求类时，类加载器会尝试使用完全限定的类名来定位类并将类定义加载到运行时。</p>
<p><code>java.lang.ClassLoader.loadClass()</code> 方法负责将类定义加载到运行时。它尝试基于完全限定名称加载类。</p>
<p>如果尚未加载该类，它会将请求委托给父类加载器。此过程以递归方式发生。</p>
<p>最终，如果父类加载器没有找到该类，则子类将调用 <code>java.net.URLClassLoader.findClass()</code> 方法来查找文件系统本身中的类。</p>
<p>如果最后一个子类加载器也无法加载该类，则会抛出 <code>java.lang.NoClassDefFoundError</code> 或 <code>java.lang.ClassNotFoundException</code>。</p>
<p>如下代码说述：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected synchronized Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span> throws ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先检查请求的类是否已经被加载过</span></span><br><span class="line">    Class c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != null) &#123;</span><br><span class="line">                c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = find<span class="constructor">BootstrapClassOrNull(<span class="params">name</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出 ClassNotFoundException</span></span><br><span class="line">            <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// 在父类加载器无法加载的时候</span></span><br><span class="line">            <span class="comment">// 再调用本身的 findClass 方法来进行类加载</span></span><br><span class="line">            c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双亲委派模型"><a class="markdownIt-Anchor" href="#双亲委派模型"></a> 双亲委派模型</h3>
<p>类加载器遵循委托模型，<strong>在请求查找类或资源时，<code>ClassLoader</code> 实例将类或资源的搜索委托给父类加载器，父类则委托给引导类加载器。</strong></p>
<p>只有当引导类加载器和扩展类加载器在加载类时不成功时，系统类加载器才会尝试加载类本身。</p>
<p>类加载器双亲委派模型如下图所示：</p>
<p><img src="../../../images/java/jvm/parents-delegation-model.png" alt="Parents Delegation Model" /></p>
<h2 id="上下文类加载器"><a class="markdownIt-Anchor" href="#上下文类加载器"></a> 上下文类加载器</h2>
<p>就像我们之前学到的一样，<strong>JVM 中的类加载器遵循层次模型，这样每个类加载器都有一个父级，除了引导类加载器。</strong></p>
<p>但是，有时当 JVM 核心类需要动态加载应用程序开发人员提供的类或资源时，我们可能会遇到问题。</p>
<p>例如，JNDI 服务，JNDI 现在已经是 Java 的标准服务，核心功能由 rt.jar 中的引导类加载。但 JNDI 的目的就是对资源进行集中管理和查找，这些 JNDI 类可能会加载由独立供应商实现的 JNDI 接口提供者（部署在应用程序类路径中）SPI 的代码。此方案要求引导类加载器（父类加载器）加载应用程序加载器（子类加载器）可见的类，但启动类不可能“认识”这些代码，怎么办？</p>
<p>为了解决该问题，Java 设计团队引出了一个不太优雅的实现；线程上下文类加载器（Thread Context ClassLoader）。</p>
<p><code>java.lang.Thread</code> 类有一个方法 <code>getContextClassLoader()</code>，**它返回特定线程的 <code>ContextClassLoader</code>。**在加载资源和类时，<code>ContextClassLoader</code> 由线程的创建者提供。</p>
<p>如果创建线程时未设置该值，则默认从父线程的类加载器上下文继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，JNDI 服务就可以使用这个线程上下文加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载器的动作。</p>
<p>Java 中所有设计 SPI 的加载动作基本上都采用这种方式，例如 JNDI，JDBC，JAXB 和 JBI 等。</p>
<h2 id="非标准的加载模型"><a class="markdownIt-Anchor" href="#非标准的加载模型"></a> 非标准的加载模型</h2>
<p>Sun 公司所提出的模块化规范在与 JCP 组织的模块化之争中落败给 JSR-291（OSGI R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGI 已经成为业界“事实上”的 Java 模块化标准，而 OSGI 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGI 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。</p>
<p><strong>OSGi 中，类加载器不再是双亲委派模型下的树状结构，而是进一步发展为更加复杂的网状结构。</strong></p>
<hr />
<h2 id="二进制名称完全限定名称"><a class="markdownIt-Anchor" href="#二进制名称完全限定名称"></a> 二进制名称（完全限定名称）</h2>
<p>作为 ClassLoader 中的方法的 String 参数提供的任何类名必须是由 <strong>Java™ 语言规范</strong>定义的二进制名称。 有效类名的示例包括：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;java.lang.String&quot;</span></span><br><span class="line"><span class="string">&quot;javax.swing.JSpinner$DefaultEditor&quot;</span></span><br><span class="line"><span class="string">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot;</span></span><br><span class="line"><span class="string">&quot;java.net.URLClassLoader$3$1&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="classpath"><a class="markdownIt-Anchor" href="#classpath"></a> CLASSPATH</h2>
<p>就像为系统配置 <code>PATH</code> 属性定义可执行文件的目录一样，<code>CLASSPATH</code> 就是为程序，包括 JDK 定义类的路径，就像它的字面意思 PATH of Class。</p>
<p>一般项目 CLASSPATH 可能包含两部分：</p>
<ul>
<li>Jar 包依赖文件（依赖的 CLASS 文件位置）</li>
<li>当前代码包的顶层路径（当前 CLASS 文件位置）</li>
</ul>
<p>使用 maven 时，默认会将代码构建到 <code>target/classes</code>，同时也会包含依赖包的代码，它可能看起来如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-classpath &quot;/Users/zeral/Program/spring/spring-boot/smart-train-api/target/classes:/Users/zeral/Program/spring/spring-boot/smart-train-api/libs/CimLog.jar:/Users/zeral/Program/spring/spring-boot/smart-train-api/libs/ojdbc6.jar:/Users/zeral/.m2/repository/cglib/cglib/3.1/cglib-3.1.jar:/Users/zeral/.m2/repository/org/ow2/asm/asm/4.2/asm-4.2.jar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ClassLoader</tag>
        <tag>JVM</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 入门</title>
    <url>/middleware/Kafka%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img src="../../images/message/kafka/kafka.png" alt="Kafka" /></p>
<blockquote>
<p><code>Kafka</code> 是为了解决 <code>LinkedIn</code> 数据管道问题应用而生的，它的设计目的是提供一个高性能的消息<br />
系统，可以处理多种数据类型，并能够实时提供纯净且结构化的用户活动数据和系统度量指标。</p>
</blockquote>
<p>数据为我们所做的每一件事都提供了动力。<em>—— Jeff Weiner, LinkedIn CEO</em></p>
<h2 id="一-基础环境搭建可选"><a class="markdownIt-Anchor" href="#一-基础环境搭建可选"></a> 一、基础环境搭建（可选）</h2>
<h3 id="手动安装"><a class="markdownIt-Anchor" href="#手动安装"></a> 手动安装</h3>
<p><code>Kafka</code> 依赖于 <code>Zookeeper</code> 的分布式节点选举功能，安装 <code>Kafka</code> 需安装 <code>Jdk</code>、<code>Zookeeper</code>、<code>Scala</code> 组件。(<a target="_blank" rel="noopener" href="https://www.confluent.io/blog/removing-zookeeper-dependency-in-kafka/">Kafka 正在逐渐削弱对 Zookeeper 的依赖，逐渐演变为自管理互相发现的模式</a>)</p>
<a id="more"></a>
<p>从 <code>Apache</code> 官网中心下载 <code>Zookeeper</code> 组件，然后安装 <code>Zookeeper</code> 环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建zookeeper的数据目录data</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mdkir /usr/<span class="built_in">local</span>/zookeeper/data</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改zookeeper配置文件zoo.cfg中的参数信息(指定数据目录、zookeeper暴露端口号)</span></span><br><span class="line">tickTime=2000</span><br><span class="line">dataDir=/usr/local/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动zookeeper服务,其会加载zoo.cfg作为其配置文件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/<span class="built_in">local</span>/zookeeper/bin/zkServer.sh starts</span></span><br></pre></td></tr></table></figure>
<p>在安装好 <code>Java</code> 和 <code>Zookeeper</code> 之后就可以进行安装 <code>Kafka</code> 消息中间件，可以从 <code>Apache Kafka</code> 官网下载 <code>kafka</code> 消息中间件，然后进行配置安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建<span class="built_in">log</span>目录用于临时存放kafka中间件日志信息</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir /tmp/kafka-logs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kafka broker启动时需要加载server.properties配置文件,指定kafka连接zookeeper地址</span></span><br><span class="line">zookeeper.connect=localhost:2181</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动kafka-server-start服务</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> /usr/<span class="built_in">local</span>/kakfa/bin/kafka-server-start.sh -daemon</span></span><br><span class="line">/usr/local/kafka/config/server.properties</span><br></pre></td></tr></table></figure>
<p>搭建好基础环境后对 <code>kafka</code> 消息中间件进行测试，创建新的 <code>topic</code> 并使用 <code>kafka-console-producer</code> 发<br />
送消息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用kafka工具创建topic, 在参数中指定zookeeper的地址、replication-factor复制比例、及分区大小</span></span><br><span class="line">sam@elementoryos:~/kafka/kafka-install$ ./bin/kafka-topics.sh --create --bootstrap-server localhost:9092</span><br><span class="line">\ --replication-factor 1 --partitions 1 --topic stream</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前broker中所有的topic列表</span></span><br><span class="line">sam@elementoryos:~/kafka/kafka-install$ ./bin/kafka-topics.sh --list --bootstrap-server localhost:9092</span><br><span class="line">__consumer_offsets</span><br><span class="line">_schemas</span><br><span class="line">avro-stream stream </span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用生产者客户端生产消息</span></span><br><span class="line">sam@elementoryos:~/kafka/kafka-install$ bin/kafka-console-producer.sh </span><br><span class="line">\ --broker-list localhost:9092 --topic stream </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">this<span class="string">&#x27;s the first message </span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">this<span class="string">&#x27;s another message from kafka </span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用消费者客户端消费,目前暂时使用--bootstrap-server客户端无法接收到消息,--zookeeper可以正常接收</span></span><br><span class="line">sam@elementoryos:~/kafka/kafka-install$ bin/kafka-console-consumer.sh </span><br><span class="line">\ --bootstrap-server localhost:9092 </span><br><span class="line">\ --topic stream --from-beginning </span><br><span class="line">this&#x27;s the first message </span><br><span class="line">this&#x27;s another message from kafka</span><br></pre></td></tr></table></figure>
<h3 id="docker-镜像使用"><a class="markdownIt-Anchor" href="#docker-镜像使用"></a> Docker 镜像使用</h3>
<p>Kafka 未提供官方的镜像，我们可以使用：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/confluentinc/cp-kafka">confluentinc Kafka</a> 或 <a target="_blank" rel="noopener" href="https://hub.docker.com/r/wurstmeister/kafka">wurstmeister Kafka</a> 作为构建镜像使用：<br />
使用时注意，如果不在同一主机中的客户端想要发送或者接收消息从该 Kafka 服务，需将该配置 <code>KAFKA_ADVERTISED_HOST_NAME</code>设为 Docker 主机对外的 IP 地址。具体解释见：<a target="_blank" rel="noopener" href="https://www.confluent.io/blog/kafka-listeners-explained/">kafka-listeners-explained</a>，简而言之：客户端使用消息代理返回的元信息进行消息发送和接收时的连接，这个元信息来源于该配置。</p>
<h2 id="二-broker-和-topic-部分配置参数"><a class="markdownIt-Anchor" href="#二-broker-和-topic-部分配置参数"></a> 二、<code>broker</code> 和 <code>topic</code> 部分配置参数</h2>
<p><code>broker</code> 端常用配置信息：</p>
<p>1.<code>broker.id</code>：每个 <code>broker</code> 都需要一个标识符，使用 <code>broker.id</code> 来表示，它的默认值为 0 。其可以被设置成任何其它任意整数。这个值在整个 <code>kafka</code> 集群中必须是唯一的。</p>
<p>2.<code>port</code> 以及 <code>zookeeper.connect</code> 配置：<code>kafka</code> 默认是监听 <code>9092</code> 端口，修改 <code>port</code> 配置参数可以将其设置成任意其它可用的端口。若在端口号在 <code>1024</code> 以下，需要使用 <code>root</code> 权限启动 <code>kafka</code>。<code>zookeeper.connect</code> 是配置连接 <code>zookeeper</code> 的配置信息，默认连接 <code>zookeeper</code> 的 <code>2181</code> 端口。若为 <code>zookeeper</code> 集群，则使用<code>,</code>对 <code>zookeeper</code> 进行分割。</p>
<p>3.<code>log.dirs</code> 以及 <code>auto.create.topics.enable</code> 配置：<code>kafka</code> 会将所有消息都保存磁盘上，存放这些日志片段的目录就是通过 <code>log.dirs</code> 指定的，它是一组用逗号分割的本地文件系统路径。若 <code>auto.create.topics.enable</code> 配置值为 <code>true</code>，处于以下三种情况时 <code>kafka</code> 会自动创建主题：当一个生产者开始往主题写入消息时、当一个消费者开始从主体读取消息时、当任意一个客户端向主体发送原<br />
数据时。</p>
<p>4.<code>num.recovert.threads.per.data.dir</code>：<code>kafka</code> 会使用可配置线程池来处理日志片段，默认情况下每个日志目录只使用一个线程，因为这些线程只是在服务器启动和关闭时会用到。在进行恢复时使用并行操作可能会省下数小时的时间，设置此参数需要注意，所配置的数字对应的是log.dirs指定的单个日志目录。</p>
<p><code>topic</code> 常用配置参数：</p>
<p>1.<code>number.partions</code>：该参数指定了新创建的主题将包含多少个分区，若启用了主题自动创建功能（该功能默认是启用的），主题分区的个数就是该参数指定的值（其默认值为 1 ）。可以增加主题分区的个数，但不能减少分区的个数。<code>Kafka</code> 集群通过分区对主题进行横向扩展，所以当有新的 <code>broker</code> 加入集群时，可以通过分区个数实现集群的负载均衡。</p>
<p>2.<code>log.retention.ms</code>：<code>kafka</code> 通常根据时间来决定数据可以被保留多久，默认使用 <code>log.retention.hours</code> 参数来配置时间，默认值为  <code>168</code> 小时也就是一周。除此之外，还有其他两个参数 <code>log.retention.minutes</code> 和 <code>log.retention.ms</code>，这 3 个参数的作用是一样的，都是决定消息多久以后会被删除。</p>
<p>3.<code>log.retention.bytes</code>：另一种方式是通过保留的消息字节数来判断消息是否过期，它的值通过参数 <code>log.retention.bytes</code> 来指定，作用在每一个分区上。也就是说，如果有一个包含 8 个分区的主题，并且 <code>log.retention.bytes</code> 被设置为1GB，那么这个主题最多可以保留8GB的数据。当主题分区个数增加时，整个主题可以保留的数据也随之增加。</p>
<p>4.<code>log.segment.bytes</code>：当消息到达 <code>broker</code> 时，它们被追加到分区的当前日志片段上。当日志片段大小达到 <code>log.segment.bytes</code> 指定的上限时，当前日志片段就会被关闭，一个新的日志片段被打开，前一个日志片段等待过期（其默认过期时间为 10 天）。</p>
<p>5.<code>log.segment.ms</code>：另一个可以控制日志片段关闭时间的是 <code>log.segment.ms</code>，它指定过了多长时间之后日志片段就被关闭，<code>log.segment.bytes</code> 和 <code>log.segment.ms</code> 这两个参数之间不存在互斥问题，日志片段会在大小或时间达到上限时被关闭，就看哪个条件先得到满足。</p>
<p>6.<code>message.max.bytes</code>：<code>broker</code> 通过设置 <code>message.max.bytes</code> 参数来限制单个消息的大小，默认值是 <code>1MB</code>。若生产者尝试发送的消息超过这个大小，不仅消息不会被接收还会返回 <code>broker</code> 返回的错误消息。在消费者客户端设置的 <code>fetch.message.max.bytes</code> 必须与服务器设置的消息大小进行协调，如果这个值比 <code>message.max.bytes</code> 小，那么消费者就无法消费 比较大的消息。</p>
<h2 id="三-kafka-基础术语"><a class="markdownIt-Anchor" href="#三-kafka-基础术语"></a> 三、Kafka 基础术语：</h2>
<p><code>kafka</code> 的数据单元称为消息 (Message)，与数据库里的一个&quot;数据行&quot;或者一条“记录”类似，为了提高效率消息被分批写入 <code>kafka</code>，批次就是一组消息（使用单独线程处理）。</p>
<p><img src="../../images/message/kafka/kafka-producer-consumer.png" alt="kafka-producer-consumer" /></p>
<p><code>kafka</code> 的消息通过 <code>topic</code>（主题）进行分类，主题好比数据库中的表。<code>topic</code> 可以被分为若干分区，一个分区就是一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序读取。由于一个主题一般包含几个分区，因此无法在整个主题范围内保证消息的顺序，但可以保证在单个分区的顺序。</p>
<p><strong><code>kafka</code> <code>broker</code> 是如何持久化数据的？<strong>总的来说，<code>kafka</code> 使用消息日志（<code>log</code>）来保存数据的，一个日志就是磁盘上一个只能追加（<code>append only</code>）消息的物理文件。因为只能追加写入，故避免了缓慢的</strong>随机 <code>I/O</code></strong> 操作，改为性能更好的顺序 <code>I/O</code> 操作，这也是实现<code>kafka</code> 高吞吐量特性的一个重要手段。为了避免日志写满磁盘空间，<code>kafka</code> 必然要定期地删除消息以回收磁盘。其通过 <code>log segment</code> 机制，在 <code>kafka</code> 底层一个日志又近一步细分成多个日志片段，消息被追加写到当前新的日志段中。<code>kafka</code> 在后台通过定时任务会定期检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p>
<p><img src="../../images/message/kafka/consumer-offset.png" alt="consumer-offset" /></p>
<p><code>kafka</code> 中分区机制指的是将每个主题划分多个分区（<code>partition</code>），每个分区是一组有序的消息日志。也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。</p>
<p><img src="../../images/message/kafka/partitioned_log.png" alt="img" /></p>
<p><code>offset</code> 消费者位移：每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（<code>consumer offset</code>）。上面的位移表示的是分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就固定了。而消费者位移则会随着消息消费而发生变化，毕竟它是消费者消费进度的指示器。另外每个消费者都有着自己的消费者位移，因此一定要区分这两类位移的区别。</p>
<p>kafka 消费者会往一个叫做 <code>_consumer_offset</code> 的特殊主题发送消息，消息里包含每个分区的偏移量。在发生 <code>rebalance</code> 之后，为了能够继续之前的工作，消费者需要读取每一个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。当提交 <code>commit</code> 的偏移量小于客户端处理的最后一条消息的偏移量，消息会被重新处理导致重复。若提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息将会丢失。</p>
<h2 id="四-kafka-整合-confluentio-schema-registry"><a class="markdownIt-Anchor" href="#四-kafka-整合-confluentio-schema-registry"></a> 四、kafka 整合 <a target="_blank" rel="noopener" href="http://confluent.io">confluent.io</a> schema registry</h2>
<p>使用 <code>apache avro</code> 实现在生产者与消费者中对消息内容进行序列化与反序列化，<code>Avro</code> 是一种与编程语言无关的序列化格式。<code>Doug Cutting</code> 创建了这个项目，目的是提供一种共享数据文件的方式。</p>
<p><code>Avro</code> 数据通过与语言无关的 <code>schema</code> 来定义，<code>schema</code> 通过 <code>JSON</code> 来描述，数据被序列化为二进制或者 <code>JSON</code> 文件，不过一般会使用二进制文件。<code>Avro</code> 在读写文件时需要用到 <code>schema</code>，<code>schema</code> 一般会被内嵌在数据文件里。<code>Avro</code> 有一个很有意思的特性是，当负责写消息的应用程序使用了新的 <code>schema</code>，负责读消息的应用程序可以继续处理消息而无须做任何改动，这个特性使得它特别适合用在像 <code>kafka</code> 这样的消息系统上。</p>
<p><code>confluent</code> 在其共有平台发布了 <code>confluent schema registry</code> 工具，作为注册表 <code>schema</code> 的实现。可以从 <a target="_blank" rel="noopener" href="https://www.confluent.io/download/">https://www.confluent.io/download/</a> 进行下载，之后在服务器上启动 <code>schema registry</code> 服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sam@elementoryos: ~/kafka_schema_registry/confluent-tools-kafka$ bin/schema-registry-start </span><br><span class="line">\ etc/schema-registry/schema-registry.properties</span><br><span class="line">[2019-11-12 00 :13:01,160] INFO Logging initialized @1547ms to org.eclipse.jetty.util.log.Slf4jLog (org.eclipse.jetty.util.log:193)</span><br></pre></td></tr></table></figure>
<p>然后将需要进行序列化实体的 <code>schema</code> 注册到 <code>schema registry</code> 中，最终其会返回一个 <code>id</code> 表示注册成功。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sam@elementoryos: curl -X POST -H &quot;Content-Type:application/vnd.schemaregistry.v1+json&quot; --data</span><br><span class="line">\ &#x27;&#123;&quot;schema&quot;: &quot;&#123;\&quot;type\&quot;: \&quot;record\&quot;, \&quot;name\&quot;: \&quot;Customer\&quot;, \&quot;fields\&quot;: [&#123;\&quot;name\&quot;: \&quot;customerName\&quot;, \&quot;type\&quot;: \&quot;string\&quot;&#125;, &#123;\&quot;name\&quot;:\&quot;customerId\&quot;,\&quot;type\&quot;:\&quot;int\&quot;&#125;]&#125;&quot;&#125;&#x27;</span><br><span class="line">\ http://192.168.170.130:8081/subjects/avro-stream-value/versions</span><br><span class="line">&#123;&quot;id&quot;:21&#125;</span><br></pre></td></tr></table></figure>
<p>注册完成后，就可以分别在生产者和消费者的代码示例中使用 <code>avro</code> 进行序列化对象。同时在生产者和消费者的 <code>properties</code> 指定属性 <code>kafkaProperties.put(&quot;schema.registry.url&quot;, &quot;http://192.168.170.130:8081&quot;)。</code></p>
<h2 id="五-kafka-生产者向-kafka-写入数据"><a class="markdownIt-Anchor" href="#五-kafka-生产者向-kafka-写入数据"></a> 五、kafka 生产者—向 kafka 写入数据</h2>
<p>向 <code>kafka</code> 发送数据从创建 <code>ProducerRecord</code> 对象开始，其包含目标主题、要发送的内容，还可以指定键或分区。在发 <code>ProducerRecord</code> 对象时，生产者要把键和值对象序列化成字节数组，这样其就可以在网络上传输。</p>
<p>接下来，将数据传给分区器。如果之前在 <code>ProducerRecord</code> 对象中指定了分区，那么分区器不会做任何事情，直接把指定的分区返回。若没有指定分区，那么分区器会根据 <code>ProducerRecord</code> 对象的键来选择一个分区。选好分区后，生产者就知道该往哪个主体和分区发送这条记录了。紧接着，这条记录会被添加到一个记录批次里，这个批次里的所有消息被发送到相同的主题和分区上。有一个单独的线程负责把<br />
这些记录批次发送到相应的 <code>broker</code> 上。</p>
<p>服务器在收到这些消息时会返回一个响应，如果消息成功写入 <code>kafka</code>，就返回一个 <code>RecordMetaData</code> 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，则会返回一个错误，生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息。</p>
<p><img src="../../images/message/kafka/producer-write.png" alt="producer-write" /></p>
<h2 id="六-kafka-消费者从-kafka-读取数据"><a class="markdownIt-Anchor" href="#六-kafka-消费者从-kafka-读取数据"></a> 六、kafka 消费者—从 kafka 读取数据</h2>
<p><code>kakfa</code> 消费者从属于消费者群组，一个群组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。若消费者组中消费者的数量与主题分区的数量相等，则每一个消费者单独消费一个分区。当消费者组中消费者数量大于主题分区的数量，多余的消费者不会被分配到任何数据分区。引入消费者组的概念主要是为了提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量<br />
（TPS）。消费者组里面的所有消费者实例不仅&quot;瓜分&quot;订阅主体的数据，而且更酷的是它们还能彼此协助。</p>
<p><code>Rebalance</code> 概念：群组中的消费者共同读取主题的分区，一个新的消费者加入群组时，它读取的是原本由其他消费者读取的消息。当一个消费者被关闭或发生崩溃时，它就离开群组，原本由它读取的分区将由群组里的其它消费者来读取。分区的所有权从一个消费者转移到另一个消费者，这样的行为被称为再均衡，在 <code>rebalance</code> 时会产生 <code>stop the world</code> 的问题。</p>
<p><code>kafka</code> 检测方式：消费者通过向被指派为群组协调器的 <code>broker</code>（不同的群组可以有不同的协调器）发送心跳来维持他们和群组的从属关系。只要消费者以正常的时间发送心跳，就被认为是活跃的，说明它还在读分区里的消息。如果消费者停止发送心跳的时间足够长，会话就会过期，群组协调器认为它已经死亡，就会触发一次再均衡。</p>
<p>分配分区的过程：当消费者要加入群组时，它会向群组协调器发送一个 <code>JoinGroup</code> 的请求。第一个加入群组的消费者将成为“群主”。群主从协调器那里获得群组的成员列表（列表中包含了所有最近发送过心跳的消费者，它们被认为是活跃的），并负责给每一个消费者分配分区。它使用了一个实现了 <code>PartitionAssign</code> 接口的类来决定哪些分区应该被分配给哪个消费者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="comment">// 当从kafka server中poll 200条记录,当处理了50条记录时,可以立即进行提交</span></span><br><span class="line">currentOffsets.put(<span class="keyword">new</span> TopicPartition(record.topic(), record.partition()), <span class="keyword">new</span> OffsetAndMetadata(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metadata&quot;</span>)); </span><br><span class="line">consumer.commitAsync(currentOffsets, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>提交特定的偏移量调用的是 <code>commitAsync</code>()，不过调用 <code>commitSync()</code> 也是完全可以的。当然，在提交特定偏移量时，仍然要处理可能发生的错误。</p>
<p><code>kafka</code> 的再均衡监听器：消费者在退出和进行分区再均衡之前，会做一些清理工作。需要在消费者失去对一个分区的所有权之前提交最后一个已处理记录的偏移量。如果消费者准备了一个缓冲区用于处理偶发的事件，那么在失去分区所有权之前，需要处理在缓冲区累积下来的记录。你可能还需要关闭文件句柄、数据库连接等。</p>
<p><code>ConsumerRebalanceListener</code> 有两个需要实现的方法：</p>
<p>1 ）<code>public void onPartitionRevoked(Collection&lt;TopicPartition&gt; partitions)</code> 方法会在再均衡开始之前和消费者停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取了。</p>
<p>2 ）<code>public void onPartitionsAssigned(Collection&lt;TopicPartition&gt; partitions)</code> 方法会在重新分配分区之后和消费者开始读取消息之前被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在consumer订阅主体topic时设定回调类HandleRebalance </span></span><br><span class="line">consumer.subscribe(topics, <span class="keyword">new</span> HandleRebalance());</span><br></pre></td></tr></table></figure>
<p>从特定偏移量处开始处理记录：使用 <code>poll()</code> 方法从各个分区的最新偏移量处开始处理消息，有时候我们也需要从特定的偏移量处开始读取消息。<code>seekToBeginning(Collection&lt;TopicPartition&gt; tp)</code> 和 <code>seekToEnd(Collection&lt;TopicPartition&gt; tp)</code> 这两个方法。若循环运行在主线程中，可以在 <code>ShutdownHook</code> 里调用该方法，需记住 <code>consumer.wakeup()</code> 是消费者唯一一个可以从其他线程里安全调用的方法。调用 <code>consumer.wakeup()</code> 可以退出 <code>poll()</code> 并抛出 <code>WakeupException</code> 异常，或者如果调用 <code>consumer.wakeup()</code> 时线程没有等待轮询，那么异常将在下一轮 <code>poll()</code> 时抛出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">      	consumer.wakeUp();     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="七-深入理解kafka运行机制"><a class="markdownIt-Anchor" href="#七-深入理解kafka运行机制"></a> 七、深入理解kafka运行机制</h2>
<p><code>kafka</code> 使用 <code>zookeeper</code> 来维护集群成员的信息，每个 <code>broker</code> 都有一个唯一标识符，这个标识符可以在配置文件中指定，也可以自动生成。在 <code>broker</code> 启动时，它通过创建临时节点把自己的 <code>id</code> 注册到 <code>zookeeper</code> 上。控制器 <code>controller</code> 机制：控制器负责分区首领的选举，集群里第一个启动的 <code>broker</code> 通过在 <code>zookeeper</code> 里创建一个临时节点 <code>controller</code> 让自己成为控制器。当其它的 <code>broker</code> 进行创建时，会收到一个&quot;节点已存在&quot;的异常，然后&quot;意识&quot;到控制器节点已存在，也就是说集群里已经有一个控制器了（结合 <code>zookeeper</code> 进行结点选举）。</p>
<ol>
<li><code>kafka</code> 中复制是如何进行实现的？</li>
</ol>
<p><code>kafka</code> 使用主题来组织数据，每个主题被分为若干个分区，每个分区有多个副本。那些副本被保存在 <code>broker</code> 上，每个 <code>broker</code> 可以保存成百上千个属于不同主题和分区的副本。副本分为两种类型：首领 (<code>master</code>) 副本，为保持一致性，<code>kafka</code> 中所有生产者请求和消费者请求都会经过这个副本。跟随者 (<code>follower</code>) 副本，其主要是从 <code>master</code> 复制消息并与 <code>master</code> 上内容保持一致，若 <code>master</code> 节点崩溃，参与节点选举并提升为新首领（<code>follower</code> 副本不参与读、写）。</p>
<p>与 <code>master</code> 的同步实现：<code>follower</code> 为了与首领同步，向首领发送获取数据的请求，<code>master</code> 通过查看每个 <code>follower</code> 请求的最新偏移量，就可以知道每个跟随者复制的进度。如果跟随者在 <code>10s</code> 内没有请求任何消息，或者虽然在请求消息，但在 10s 内没有请求最新的数据，那么它就会被认为是不同步的。跟随者的正常不活跃时间或在成为不同步副本之前的时间是通过 <code>replica.lag.time.max.ms</code> 参数来配置<br />
的。</p>
<ol start="2">
<li><code>kafka</code> 是如何处理来自生产者和消费者的请求？</li>
</ol>
<p>生产请求和获取请求都必须发送给分区的首领副本，客户端使用元数据请求包含了客户端感兴趣的主题列表。服务器端的响应中指明了这些主题所包含的分区、每个分区都有哪些副本、以及哪个副本是 <code>master</code> 节点。客户端一般会缓存这些信息，并直接往目标 <code>broker</code> 上发送请求和获取请求（时间间隔通过 <code>metadata.max.age.ms</code> 来配置）。</p>
<p>在生产者配置中存在 <code>acks</code> 这个配置参数——该参数指定了需要多少个 <code>broker</code> 确认才可以认为一个消息写入是成功的，<code>acks=all</code> 需要所有 <code>broker</code> 收到消息才会成功；<code>acks=0</code> 意味着生产者在把消息发出去之后，完全不需要等待 <code>broker</code> 的响应。</p>
<p>客户端发送消费请求时向 <code>broker</code> 获取主题分区里具有特定偏移量的消息，客户端还可以指定为 <code>broker</code> 返回的数据分配足够的内存。否则， <code>broker</code> 返回的大量数据有可能耗尽客户端的内存。</p>
<ol start="3">
<li><code>kafka</code> 的存储细节，如文件格式和索引？</li>
</ol>
<p><code>kafka</code> 的基本存储单元是分区，分区无法在多个 <code>broker</code> 间进行再细分，也无法在同一个 <code>broker</code> 的多个磁盘上进行再细分。在配置 <code>kafka</code> 时候，管理员指定了一个用于存储分区的目录清单——也就是 <code>log.dirs</code> 参数的值，该参数一般会包含每个挂载点的目录。</p>
<p>文件管理部分，<code>kafka</code> 管理员为每个主题配置了数据保留期限，规定数据被删除之前可以保留多长时间，或者清理数据之前可以保留的数据量大小。通常分区被分成若干个片段，默认情况下，每个片段包含 <code>1GB</code> 或一周的数据，以较小的那个为准。在 <code>broker</code> 往分区写入数据时，如果达到片段上限，就关闭当前文件，并打开一个新文件。当前正在写入数据非片段叫作活跃片段，活动片段永远不会被删除。</p>
<p>消息和偏移量保存在文件里，其格式除了键、值和偏移量外，消息里还包含了消息大小、校验和、消息格式版本号、压缩算法（Zstd、Snappy、GZip 或 LZ4）和时间戳。时间戳可以是生产者发送消息的时间，也可以是消息到达 <code>broker</code> 的时间，可以配置。为了能快速从任意可用偏移量位置开始读取消息，<code>kafka</code> 为每个分区维护了一个索引，索引把偏移量映射到片段文件和偏移量在文件里的位置。</p>
<p>清理工作原理：若 <code>kafka</code> 启动时启用了清理功能（通过配置 <code>log.cleaner.enabled</code> 参数），每个 <code>broker</code> 会启动一个清理管理器线程或多个清理线程，它们负责执行清理任务，清理掉键重复的只保留一条，或清理 <code>value</code> 为空的消息等。这个线程会选择污浊率（污浊消息占分区总大小的比例）较高的分区进行清理。</p>
<p>为了清理分区，清理线程会读取分区的污浊部分，并在内存里创建一个 <code>map</code>。<code>map</code> 里的每个元素包含了消息键的散列值和消息的偏移量，键的散列值是 16B，加上偏移量总共是 24B。如果要清理一个 1GB 的日志偏移量，并假设每个消息大小为 1KB，那么这个片段就包含一百万个消息，而我们只需要 24MB 的 map 就可以清理这个片段（若有重复的键，可以重用散列项，从而使用更少的内存）。</p>
<h2 id="八-常见问题"><a class="markdownIt-Anchor" href="#八-常见问题"></a> 八、常见问题</h2>
<h3 id="为什么选择-kafka"><a class="markdownIt-Anchor" href="#为什么选择-kafka"></a> 为什么选择 Kafka？</h3>
<img src="../../images/message/kafka/ecosystem.jpg" alt="img312" style="zoom: 67%;" />
<p>有很多发布/订阅的消息系统，为什么我们要选择 Kafka？</p>
<h4 id="多生产者"><a class="markdownIt-Anchor" href="#多生产者"></a> 多生产者</h4>
<p>Kafka 能够无缝地处理多个生产者，而不用管客户端是否使用多个主题或同一主题。 这使得系统非常适合从许多前端系统聚合数据并使其保持一致。例如，一个通过许多微服务为用户提供内容的网站可以拥有一个页面视图主题，所有服务都可以使用通用格式写入该页面视图，然后，消费者应用程序可以为站点上的所有应用程序接收单个页面视图，而无需从每个应用程序多个主题协调消费。</p>
<h4 id="多消费者"><a class="markdownIt-Anchor" href="#多消费者"></a> 多消费者</h4>
<p>除了多种生产商之外，Kafka 还专为多个消费者设计，以读取任何单一的消息流而不会互相干扰。这与许多队列系统相反，其中一旦消息由一个客户端消费，其它客户端将不可消费。多个 Kafka 消费者可以选择作为消费组的一部分运行并共享流，确保整个组仅处理给定消息一次。</p>
<h4 id="基于文件的保留"><a class="markdownIt-Anchor" href="#基于文件的保留"></a> 基于文件的保留</h4>
<p>Kafka 不仅可以处理多个消费者，而且持久（<strong>Durable</strong>）的消息保留意味着消费者并不总是需要实时工作。 消息已提交给磁盘，并将按可配置的保留规则保留数据。可以在每个主题的基础上选择这些选项，允许根据消费者需求进行不同的消息流，以具有不同的保留量。持久（Durable）的保留意味着如果消费者落后，由于处理缓慢或处理中出问题，则没有丢失数据的危险。这也意味着可以在消费者身上进行维护，在短时间内离线应用程序，不用担心备份生产者或丢失的消息。消费者可以停止，并且消息将保留在 Kafka。 这允许它们重新启动并拾取它们离开的处理消息，而无需担心数据丢失。</p>
<blockquote>
<p><strong>Durable</strong> 一般在消息队列中指主题（Topic）订阅本身的持久化，如果订阅是持久的，即使消费者断开消费，订阅也会存在，到重新连接时将选择从丢失处继续消费。相反非持久化订阅在断开时该订阅将不存在。</p>
<p><strong>Persistent</strong>  一般指将消息从内存持久化到硬盘。</p>
</blockquote>
<h4 id="扩展性"><a class="markdownIt-Anchor" href="#扩展性"></a> 扩展性</h4>
<p>Kafka 的灵活可伸缩性使其易于处理任何数量的数据。 用户可以以单个代理作为概念证明，扩展到三个代理的小型开发集群，随着时间的推移和数据的增长而增加一组或甚至数百个代理，并逐渐走向真实的生产环境。 集群在线时可以执行扩展，不会影响整个系统的可用性。 这也意味着多个代理集群可以接管单个代理的故障，并继续服务客户。需要容忍更多同时故障的集群可以配置更高的复制因子。</p>
<h4 id="高性能"><a class="markdownIt-Anchor" href="#高性能"></a> 高性能</h4>
<p>所有这些功能都汇集在一起，使 Apache Kafka 成为发布/订阅消息系统，在高负载下具有出色的性能。生产者，消费者和代理都可以水平扩展，以便轻松处理非常大的信息流，在提供高可用的同时也保证了低延迟的消息传递。</p>
<h3 id="kafka-适合什么样的使用场景"><a class="markdownIt-Anchor" href="#kafka-适合什么样的使用场景"></a> Kafka 适合什么样的使用场景？</h3>
<h4 id="消息代理"><a class="markdownIt-Anchor" href="#消息代理"></a> 消息代理</h4>
<p>Kafka 可以很好地替代传统消息代理。消息代理的使用有多种原因（将消费处理与数据生产者分离，缓冲未处理的消息等）。与大多数消息系统相比，Kafka 具有更好的吞吐量，内置的分区，复制和容错能力，这使其成为大规模消息处理应用程序的理想解决方案。</p>
<p>根据我们的经验，消息传递的使用通常吞吐量较低，但是可能需要较低的端到端延迟，并且通常取决于 Kafka 提供的强大的持久性保证。</p>
<p>在这个领域，Kafka 可以与传统的消息传递系统（例如 <a target="_blank" rel="noopener" href="http://activemq.apache.org/">ActiveMQ</a> 或 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a>）相提并论。</p>
<h4 id="网站活动跟踪"><a class="markdownIt-Anchor" href="#网站活动跟踪"></a> 网站活动跟踪</h4>
<p>Kafka 最初的用例是能够将用户活动跟踪管道重建为一组实时的发布-订阅供给。这意味着将网站活动（页面浏览量，搜索或用户可能采取的其他操作）发布到中心主题，每种活动类型只有一个主题。这些供给可用于一系列用例的订阅，包括实时处理，实时监控，以及加载到 Hadoop 或脱机数据仓库系统中以进行脱机处理和报告。</p>
<p>活动跟踪通常量很大，因为每个用户页面视图都会生成许多活动消息。</p>
<h4 id="指标metrics"><a class="markdownIt-Anchor" href="#指标metrics"></a> 指标（Metrics）</h4>
<p>Kafka 通常用于操作监控数据。这涉及汇总来自分布式应用程序的统计信息，以生成集中的操作数据提要。</p>
<h4 id="日志聚合"><a class="markdownIt-Anchor" href="#日志聚合"></a> 日志聚合</h4>
<p>许多人使用 Kafka 替代日志聚合解决方案。日志聚合通常从服务器收集物理日志文件，并将它们放在中央位置（也许是文件服务器或  HDFS）以进行处理。Kafka 提取了文件的详细信息，并将日志或事件数据作为消息流进行了更清晰的抽象。这允许较低延迟的处理，并更容易支持多个数据源和分布式数据消费。与以日志为中心的系统（例如 Scribe 或 Flume）相比，Kafka 具有同样出色的性能，由于复制而提供的更强的持久性保证以及更低的端到端延迟。</p>
<h4 id="流处理"><a class="markdownIt-Anchor" href="#流处理"></a> 流处理</h4>
<p>Kafka 的很多用户使用多个阶段组成的处理管道处理数据，从 Kafka 主题中消费原始输入数据，然后将其聚合，增强或以其他方式转换为新主题，以供进一步消费或后续处理。例如，用于推荐新闻文章的处理管道可能会从 RSS 供给中检索文章内容，并将其发布到“文章”主题中。进一步的处理可能会使该内容规范化或删除重复数据，并将清洗后的文章内容发布到新主题中；最后的处理阶段可能会尝试向用户推荐此内容。这样的处理管道基于各个主题创建实时数据流的图形。从 0.10.0.0 开始，Apache Kafka 中提供了一个轻量但功能强大的流处理库，称为 <a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation/streams">Kafka Streams</a>，可以执行上述数据处理。除了 Kafka Streams，替代的开源流处理工具包括 <a target="_blank" rel="noopener" href="https://storm.apache.org/">Apache Storm</a> 和 <a target="_blank" rel="noopener" href="http://samza.apache.org/">Apache Samza</a>。</p>
<h4 id="事件溯源event-sourcing"><a class="markdownIt-Anchor" href="#事件溯源event-sourcing"></a> 事件溯源（Event Sourcing）</h4>
<p><a target="_blank" rel="noopener" href="http://martinfowler.com/eaaDev/EventSourcing.html">事件溯源</a>是应用程序设计的一种样式，其中状态更改以时间顺序的记录序列记录下来。 Kafka 对非常大的存储日志数据的支持使其成为使用这种样式构建的应用程序的绝佳后端。</p>
<h4 id="提交日志commit-log"><a class="markdownIt-Anchor" href="#提交日志commit-log"></a> 提交日志（Commit Log）</h4>
<p>Kafka 可以用作分布式系统的一种外部提交日志。该日志有助于在节点之间复制数据，并充当故障节点恢复其数据的重新同步机制。Kafka 中的<a target="_blank" rel="noopener" href="https://kafka.apache.org/documentation.html#compaction">日志压缩</a>功能有助于支持此用法。在这种用法中，Kafka 类似于 <a target="_blank" rel="noopener" href="https://bookkeeper.apache.org/">Apache BookKeeper</a> 项目。</p>
<h3 id="如何保证消息顺序"><a class="markdownIt-Anchor" href="#如何保证消息顺序"></a> 如何保证消息顺序？</h3>
<p>Kafka 可以保证同一个分区里的消息是有序的。也就是说，如果生产者按照一定的顺序发送消息，broker 就会按照这个顺序把它们写入分区，消费者也会按照同样的顺序读取它们。</p>
<p><strong>使用单个分区能最大程度保证消息的顺序，或者消息使用相同的 key。还需注意下面的配置。</strong></p>
<h4 id="生产者"><a class="markdownIt-Anchor" href="#生产者"></a> 生产者</h4>
<p><code>retries</code> ：生产者从服务器收到错误时的重试次数</p>
<p><code>max.in.flight.requests.per.connection</code> ：生产者在收到服务器响应之前可以发送多少个批次消息。值越高，占用越多内存，吞吐量提升。</p>
<p>消息是否写入成功也是非常关键的，如果把 <code>retries</code> 设为非零整数，同时把 <code>max.in.flight.requests.per.connection</code> 设为比 1 大的数，那么第一批消息写入失败，而第二批写入成功，broker 重试第一个批次。此时第一个批次写入成功，那么两个批次的顺序就反了。</p>
<p>为了保证写入的顺序，不建议把 <code>retries</code> 设为 0。可以把 <code>max.in.flight.requests.per.connection</code> 设为 <strong>1</strong> ，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker。不过这样的会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下。</p>
<h3 id="如何保证消息被消费-exactly-once"><a class="markdownIt-Anchor" href="#如何保证消息被消费-exactly-once"></a> 如何保证消息被消费 Exactly-Once</h3>
<p>由于各种故障，消息传递系统无法保证生产者和使用者应用程序之间的消息传递。根据客户端应用程序与此类系统交互的方式，可能会出现以下消息语义：</p>
<ul>
<li>如果消息传递系统永远不会复制消息，但可能会漏掉偶尔的消息，则我们称 <em><strong>最多一次 (at-most-once)</strong></em></li>
<li>如果它永远不会丢失一条消息，但可能会重复一条消息，则我们至少将其 <em><strong>至少一次 (at-least-once)</strong></em>**</li>
<li>如果它发送所有消息时总是不重复，那将是 <em><strong>恰好一次 (exactly-once)</strong></em> 要保证消息只发送一次，得保证生产者发送给服务器的消息只成功一次，消费者也只消费一次。Kafka 代理和客户端应用引入事物可确保进行一次准确的交付。</li>
</ul>
<h4 id="生产者-2"><a class="markdownIt-Anchor" href="#生产者-2"></a> 生产者</h4>
<p><img src="../../images/message/kafka/produce-message.png" alt="img" /></p>
<p><code>acks</code> ：该参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有影响。</p>
<ul>
<li><code>acks=0</code> 不需要确认</li>
<li><code>acks=1</code> 需要集群首领确认。首领确认纪录后失败，如果跟随者还没复制，则记录可能丢失。</li>
<li><code>acks=all</code> 集群首领及其追随者都确认后，才会收到成功响应。安全性更高，吞吐率下降。 <code>enable.idempotence</code> ：当设置为 “true” 时，生产者将确保每个消息的仅有一个副本被写入流中。如果为 “false”，则生产者由于代理失败等原因而重试，可能会将重试消息的副本写入流中。 请注意，启用幂等性要求 <code>max.in.flight.requests.per.connection</code> 小于或等于 5，重试大于 0， <code>ack</code> 必须为 “<strong>all</strong>”。 如果用户未明确设置这些值，则将选择合适的值。 如果设置了不兼容的值，则将引发 ConfigException。</li>
</ul>
<h5 id="幂等操作"><a class="markdownIt-Anchor" href="#幂等操作"></a> 幂等操作</h5>
<p>由于生产者出错重试会导致消息重复，所以为了生产者成功提交的消息恰好一次，可以使用幂等操作来保证。如果发生导致生产者重试的错误，则相同的消息（仍由生产者多次发送）将仅写入到代理上的 Kafka 日志一次。对于单个分区，幂等生产者发送消除了由于生产者或代理错误而产生重复消息的可能性。要启用此功能并为每个分区获取一次精确的语义（即没有重复，没有数据丢失和有序的语义），请将生产者配置为 <code>enable.idempotence = true</code> 。</p>
<h5 id="事物"><a class="markdownIt-Anchor" href="#事物"></a> 事物</h5>
<p>生产者通过设定事物 Id ( <code>transactional.id</code> )，然后开启事物。</p>
<h4 id="消费者"><a class="markdownIt-Anchor" href="#消费者"></a> 消费者</h4>
<h5 id="事物-2"><a class="markdownIt-Anchor" href="#事物-2"></a> 事物</h5>
<p><code>isolation.level</code> ：控制如何读取事务写入的消息。如果设置为 <code>read_committed</code> ，consumer.poll() 将仅返回已提交的事务性消息。如果设置为 <code>read_uncommitted</code> （ <strong>默认</strong> ），consumer.poll() 将返回所有消息，甚至是已中止的事务性消息。非事务性消息在两种方式下都返回。</p>
<h5 id="手动提交"><a class="markdownIt-Anchor" href="#手动提交"></a> 手动提交</h5>
<p><code>enable.auto.commit</code> ：该属性决定是否自动提交偏移量，默认为 true。为了避免数据出现重复和丢失，可以通过手动提交的方式自行提交偏移量。</p>
<h3 id="是什么使-kafka-如此之快"><a class="markdownIt-Anchor" href="#是什么使-kafka-如此之快"></a> 是什么使 Kafka 如此之快</h3>
<h4 id="低延迟消息传递"><a class="markdownIt-Anchor" href="#低延迟消息传递"></a> 低延迟消息传递</h4>
<p>Kafka 通过顺序 IO 操作日志避免了长时间的磁盘寻道；</p>
<p>零复制原则，避免了内核上下文和应用上下文的文件读取和发送，直接在系统内核上下文中进行文件读取和发送，避免了上下文切换的时间消耗和内存占用。</p>
<p>传统数据复制方法</p>
<p><img src="../../images/message/kafka/data-copying.gif" alt="Traditional data copying approach" /></p>
<p>零复制使用 <code>java.nio.channels.FileChannel.transferTo()</code></p>
<p><img src="../../images/message/kafka/zero-copying.gif" alt="Data copy with transferTo" /></p>
<h4 id="批处理数据和压缩"><a class="markdownIt-Anchor" href="#批处理数据和压缩"></a> 批处理数据和压缩</h4>
<p>通过批量读写来优化吞吐量，并将同一批次的消息高效压缩在一起传输，在日志中也同样保持压缩，仅由使用者解压缩。支持的压缩算法：Zstd、Snappy、GZip 或 LZ4。</p>
<h4 id="水平扩展"><a class="markdownIt-Anchor" href="#水平扩展"></a> 水平扩展</h4>
<p>首先让我们了解什么是垂直扩展。可以说，对于传统的数据库服务器，当负载增加时，一种解决方法是添加更多资源，例如：CPU，RAM，SSD 等。这称为垂直扩展。它具有以下几个缺点：</p>
<ul>
<li>每个硬件都有局限性，不能无限地向上扩展。</li>
<li>如果机器出现故障怎么办？通常需要停机。</li>
</ul>
<p><strong>水平扩展</strong>通过添加更多机器来解决相同的问题。 Kafka 能够为单个主题提供数千个分区，并将其分布在数千台计算机中，这意味着 Kafka 可以处理巨大的负载。</p>
<h2 id="九-开源监控工具"><a class="markdownIt-Anchor" href="#九-开源监控工具"></a> 九、开源监控工具</h2>
<h3 id="cmak"><a class="markdownIt-Anchor" href="#cmak"></a> <a target="_blank" rel="noopener" href="https://github.com/yahoo/CMAK">CMAK</a>(Cluster Manager for Apache Kafka, previously known as Kafka Manager)</h3>
<p>分类：<em>WEB UI 服务</em></p>
<p>特性：可管理集群、监控集群状态（主题、消费者、偏移量、消息代理、复制副本、分区副本）、<strong>运行首选副本选举</strong>、创建/删除/修改主题及分区、<strong>分区主题重新分配</strong>、<strong>JMX 监控</strong>…</p>
<h3 id="kafdrop"><a class="markdownIt-Anchor" href="#kafdrop"></a> <a target="_blank" rel="noopener" href="https://github.com/obsidiandynamics/kafdrop">kafdrop</a></h3>
<p>分类：<em>WEB UI 服务</em></p>
<p>特性：查看 Kafka 代理（主题和分区分配以及控制器状态）、查看主题（分区数，复制状态和自定义配置）、<strong>查看消息（JSON，纯文本和 Avro 编码）</strong>、查看消费者分组（每个分区的消费偏移量，合并和每个分区的滞后）、创建新主题、查看 ACLs…</p>
<h3 id="kafka-tool"><a class="markdownIt-Anchor" href="#kafka-tool"></a> <a target="_blank" rel="noopener" href="https://www.kafkatool.com/index.html">Kafka Tool</a></h3>
<p>分类：<em>GUI 应用</em></p>
<p>特性：快速查看所有 Kafka 集群，包括其代理，主题和消费者、<strong>查看分区中消息的内容并支持添加新消息</strong>、查看消费者的偏移量、支持 JSON 和 XML 等格式显示消息、添加和删除主题以及其他管理功能、<strong>将单个消息从您的分区保存到本地硬盘驱动器</strong>、Kafka Tool 可在Windows，Linux 和 Mac OS 上运行</p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存泄漏</title>
    <url>/java/Java-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1. 引言</h1>
<p><code>Java</code> 的核心优势之一是借助 <code>JVM</code> 内置的垃圾收集器（或简称 <code>GC</code>）的自动内存管理。GC 隐式地负责分配和释放内存，因此能够处理大多数内存泄漏问题。</p>
<p>尽管 GC 有效地处理了很大一部分内存，但它不能保证针对内存泄漏的万无一失的解决方案。 GC 非常聪明，但并非完美无缺。即使在有责任心的开发人员的应用程序中，内存泄漏仍然可能存在。</p>
<p>在某些情况下，应用程序会生成大量多余的对象，从而耗尽关键的内存资源，有时会导致整个应用程序的故障。</p>
<p>内存泄漏是 <code>Java</code> 中的真正问题。在本教程中，<strong>我们将看到导致内存泄漏的潜在原因是什么，如何在运行时识别它们，以及如何在应用程序中对其进行处理。</strong></p>
<a id="more"></a>
<p><img src="../../images/java/jvm/gc-mark-sweep.gif" alt="Mark &amp; sweep GC" /></p>
<h1 id="2-什么是内存泄漏"><a class="markdownIt-Anchor" href="#2-什么是内存泄漏"></a> 2. 什么是内存泄漏</h1>
<p>内存泄漏指<strong>当堆中存在不再使用的对象，但是垃圾回收器无法将其从内存中删除的情况</strong>，因此不必要地对其进行了维护。</p>
<p>内存泄漏很严重，因为它会<strong>阻塞内存资源并随着时间的推移降低系统性能</strong>。如果不加以处理，该应用程序最终将耗尽其资源，最终以致命的 <code>java.lang.OutOfMemoryError</code> 终止。</p>
<p>堆内存中有两种不同类型的对象-已引用和未引用。引用对象是那些在应用程序中仍具有活动引用的对象，而未引用的对象则没有任何活动引用。</p>
<p>垃圾收集器会定期删除未引用的对象，但是它永远不会收集仍在引用的对象。这是可能发生内存泄漏的地方：</p>
<p><img src="../../images/java/jvm/memory_Leak_In_Java.png" alt="Memory Leak" /></p>
<p><strong>Symptoms of a Memory Leak</strong></p>
<ul>
<li>当应用程序长时间连续运行时，性能严重下降</li>
<li>应用程序中的 <code>OutOfMemoryError</code> 堆错误</li>
<li>自发和奇怪的应用程序崩溃</li>
<li>该应用程序偶尔会用完连接对象</li>
</ul>
<p>让我们仔细看看其中一些场景以及如何处理它们。</p>
<h1 id="3-java-中的内存泄漏类型"><a class="markdownIt-Anchor" href="#3-java-中的内存泄漏类型"></a> 3. Java 中的内存泄漏类型</h1>
<p>在任何应用程序中，由于多种原因都会发生内存泄漏。在本节中，我们将讨论最常见的那些。</p>
<h2 id="31-静态字段的内存泄漏"><a class="markdownIt-Anchor" href="#31-静态字段的内存泄漏"></a> 3.1 静态字段的内存泄漏</h2>
<p>可能导致潜在内存泄漏的第一种情况是大量使用静态变量。</p>
<p>在 Java 中，静态字段的寿命通常与正在运行的应用程序的整个寿命匹配（除非 ClassLoader 符合垃圾收集的条件）。</p>
<p>让我们创建一个填充静态列表的简单 Java 程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            list.add(Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 1&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> StaticTest().populateList();</span><br><span class="line">        Log.info(<span class="string">&quot;Debug Point 3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果我们在程序执行过程中分析堆内存，那么我们将看到在调试点 1 和 2 之间，按预期，堆内存增加了。</p>
<p>但是，当我们在调试点 3 保留 populateList() 方法时，堆内存尚未被垃圾回收，正如我们在此 VisualVM 响应中看到的那样：</p>
<p><img src="../../images/java/jvm/memory-with-static.png" alt="Memory with static" /></p>
<p>但是，在上面的程序的第 2 行中，如果我们仅删除关键字 static，那么它将对内存使用量带来巨大的变化，此 Visual VM 响应显示：</p>
<p><img src="../../images/java/jvm/memory-without-static.png" alt="Memory without static" /></p>
<p>调试点之前的第一部分几乎与我们在静态情况下获得的结果相同。但是这一次我们离开 populateList() 方法之后，<strong>列表的所有内存都被垃圾回收了，因为我们没有对其的任何引用。</strong></p>
<p>因此，我们需要非常注意静态变量的使用。如果将集合或大型对象声明为静态，那么它们会在应用程序的整个生命周期中保留在内存中，从而阻塞了本来可以在其他地方使用的重要内存。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>尽量减少使用静态变量</li>
<li>使用单例时，依赖于延迟加载对象而不是急于加载的实现</li>
</ul>
<h2 id="32-未关闭资源"><a class="markdownIt-Anchor" href="#32-未关闭资源"></a> 3.2 未关闭资源</h2>
<p>每当我们建立新连接或打开流时，JVM 就会为这些资源分配内存。一些示例包括数据库连接，输入流和会话对象。</p>
<p>忘记关闭这些资源可能会阻塞内存，从而使它们无法进入 GC。甚至在发生异常的情况下也会发生这种情况，该异常会阻止程序执行到达处理关闭这些资源的代码语句。</p>
<p>在任何一种情况下，资源留下的开放连接都会消耗内存，如果我们不处理它们，它们可能会降低性能，甚至可能导致 <code>OutOfMemoryError</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = OutOfMemoryError.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenURL_whenUnclosedStream_thenOutOfMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException, URISyntaxException </span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    URLConnection conn </span><br><span class="line">      = <span class="keyword">new</span> URL(<span class="string">&quot;http://norvig.com/big.txt&quot;</span>).openConnection();</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">      <span class="keyword">new</span> InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (br.readLine() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        str += br.readLine();</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看从 URL 加载大文件时应用程序的内存情况：</p>
<p><img src="../../images/java/jvm/unclosed-streams-memory-leak.png" alt="Java unclosed streams memory leak" /></p>
<p>如我们所见，堆使用率随着时间逐渐增加 – 这是由于不关闭流而导致的内存泄漏的直接影响。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>始终使用 <code>finally</code> 块关闭资源</li>
<li>关闭资源的代码（即使在 <code>finally</code> 块中）本身也不应该有任何异常</li>
<li>使用 <code>Java 7+</code> 时，我们可以利用 <code>try-with-resources</code> 块</li>
</ul>
<h2 id="33-equals-和-hashcode-实现不当"><a class="markdownIt-Anchor" href="#33-equals-和-hashcode-实现不当"></a> 3.3 <em>equals</em> 和 <em>hashcode()</em> 实现不当</h2>
<p>在定义新类时，一个非常普遍的疏忽是没有为 <code>equals()</code> 和 <code>hashCode()</code> 方法编写适当的重写方法。</p>
<p><code>HashSet</code> 和 <code>HashMap</code> 在许多操作中使用这些方法，如果未正确覆盖它们，则它们可能成为潜在内存泄漏问题的根源。</p>
<p>让我们以一个简单的 <code>Person</code> 类为例，并将其用作 <code>HashMap</code> 中的键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们将重复的 <code>Person</code> 对象插入使用此键的 <code>Map</code> 中。</p>
<p>请记住，<code>Map</code> 不能包含重复的键：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenMap_whenEqualsAndHashCodeNotOverridden_thenMemoryLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Person, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;jon&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertFalse(map.size() == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用 <code>Person</code> 作为键。由于 <code>Map</code> 不允许使用重复的键，因此，作为键插入的大量重复的 <code>Person</code> 对象不应增加内存。</p>
<p>但是，由于我们尚未定义适当的 <code>equals()</code> 方法，因此重复的对象堆积并增加了内存，这就是为什么我们在内存中看到多个对象的原因。为此，<code>VisualVM</code> 中的堆内存如下所示：</p>
<p><img src="../../images/java/jvm/before_implementing_equals_and_hashcode.png" alt="Before implementing equals and hashcode" /></p>
<p>但是，如果我们正确地重写了<code>equals()</code> 和 <code>hashCode()</code> 方法，则此 <code>Map</code> 中将仅存在一个 <code>Person</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> person.name.equals(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + name.hashCode();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>正确覆盖 <code>equals()</code> 和 <code>hashCode()</code> 之后，同一程序的堆内存如下所示：</p>
<p><img src="../../images/java/jvm/afterimplementing_equals_and_hashcode.png" alt="After implementing equals and hashcode" /></p>
<p><strong>如果不重写这些方法，则发生内存泄漏的可能性非常高</strong>，因为 <code>Hibernate</code> 无法比较对象，并会使用重复的对象填充其缓存。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>根据经验，定义新实体时，请始终覆盖 <code>equals()</code> 和 <code>hashCode()</code> 方法</li>
<li>不仅要覆盖，而且还必须以最佳方式覆盖这些方法</li>
</ul>
<h2 id="34-使用非静态内部类"><a class="markdownIt-Anchor" href="#34-使用非静态内部类"></a> 3.4 使用非静态内部类</h2>
<p>这是在非静态内部类（匿名类）的情况下发生的。为了进行初始化，这些内部类始终需要封闭类的实例。</p>
<p>默认情况下，每个非静态内部类都有对其包含类的隐式引用。如果我们在应用程序中使用此内部类的对象，<strong>则即使在包含类的对象超出范围后，也不会对其进行垃圾回收。</strong></p>
<p>考虑一个类其中包含对大量笨重对象的引用，并且具有一个非静态内部类。现在，当我们创建内部类的对象时，内存模型如下所示：</p>
<p><img src="../../images/java/jvm/inner_Classes_That_Reference_Outer_Classes.png" alt="Inner Classes That Reference Outer Classes" /></p>
<p>但是，如果仅将内部类声明为静态，则相同的内存模型如下所示：</p>
<p><img src="../../images/java/jvm/static_Classes_That_Reference_Outer_Classes.png" alt="Static Classes That Reference Outer Classes" /></p>
<p>发生这种情况是因为内部类对象隐式持有对外部类对象的引用，从而使其成为垃圾回收的无效候选对象。对于匿名类，也会发生同样的情况。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>如果内部类不需要访问包含的类成员，请考虑将其转换为静态类</li>
</ul>
<h2 id="35-通过-finalize-方法"><a class="markdownIt-Anchor" href="#35-通过-finalize-方法"></a> 3.5 通过 <em>finalize()</em> 方法</h2>
<p>使用终结器是潜在的内存泄漏问题的另一个来源。每当覆盖类的 <code>finalize()</code> 方法时，<strong>该类的对象不会立即被垃圾收集</strong>。取而代之的是， <code>GC</code> 将它们排入队列以进行最终确定，这将在以后的某个时间点进行。</p>
<p>另外，如果用 <code>finalize()</code> 方法编写的代码不是很优化，并且终结器队列无法跟上 <code>Java</code> 垃圾收集器的速度，那么迟早，我们的应用程序注定会遇到 <code>OutOfMemoryError</code>。</p>
<p>为了说明这一点，让我们考虑一下我们有一个覆盖了 <code>finalize()</code> 方法的类，并且该方法需要一点时间来执行。</p>
<p><img src="../../images/java/jvm/finalize_method_overridden.png" alt="finalize method overridden" /></p>
<p>但是，如果只删除覆盖的 <code>finalize()</code> 方法，则同一程序将给出以下响应：</p>
<p><img src="../../images/java/jvm/finalize_method_not_overridden.png" alt="finalize method not overridden" /></p>
<p><strong>如何预防？</strong></p>
<ul>
<li>我们应该始终避免使用终结器</li>
</ul>
<h2 id="36-字符串常量池"><a class="markdownIt-Anchor" href="#36-字符串常量池"></a> 3.6 字符串常量池</h2>
<p>在 <code>Java 7</code> 之前，<code>JVM</code> 将 <strong><code>Java</code> 字符串池放置在永久代 <code>PermGen</code> 空间中，该空间的大小是固定的 - 无法在运行时扩展，并且不适合进行垃圾回收。</strong></p>
<p>默认的字面量创建方法和 String 的 <code>intern</code> 方法会在字符串常量池保留字符串。</p>
<p>在 <code>PermGen</code>（而不是堆 <code>Heap</code>）中保留 <code>String</code> 的风险是，如果我们保留过多的 <code>String</code>，我们可能会从 <code>JVM</code> 中获得 <code>OutOfMemory</code> 错误。</p>
<p>从 <code>Java 7</code> 开始，<code>Java</code> 字符串池**存储在 <code>Heap</code> 空间中，该空间由 <code>JVM</code> 进行垃圾回收。**这种方法的优点是减少了 <code>OutOfMemory</code> 错误的风险，因为未引用的字符串将从池中删除，从而释放内存。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>
<p>解决此问题的最简单方法是升级到最新的 Java 版本</p>
</li>
<li>
<p>或者要在 6 之前使用大量字符串或长字符串，请增加 <code>PermGen</code> 空间的大小，以避免任何潜在的 <code>OutOfMemoryErrors</code>：</p>
<p><code>-XX:MaxPermSize=512m</code></p>
</li>
</ul>
<h2 id="37-使用-threadlocal"><a class="markdownIt-Anchor" href="#37-使用-threadlocal"></a> 3.7 使用 <em>ThreadLocal</em></h2>
<p><em><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html">ThreadLocal</a></em> 是一种使我们能够将状态隔离到特定线程，从而使我们能够实现线程安全的结构。</p>
<p>使用此构造时，<strong>每个线程将保留对其 <em>ThreadLocal</em> 变量副本的隐式引用，并将维护自己的副本，只要线程是活动的。</strong></p>
<p><img src="../../images/java/jvm/thread-local.png" alt="ThreadLocal" /></p>
<blockquote>
<p>实线代表强引用，虚线代表弱引用（<code>WeakReference</code>）</p>
<p>JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在 java 中，用 <code>java.lang.ref.WeakReference</code> 类来表示。可以在缓存中使用弱引用。</p>
</blockquote>
<p>尽管有其优点，但使用 <em><code>ThreadLocal</code></em> 变量还是有争议的，因为如果使用不当，它们会导致内存泄漏。</p>
<p><strong><em>ThreadLocal</em> 导致内存泄漏</strong></p>
<p>一旦持有线程不再存活，就应该对 <em>ThreadLocals</em> 进行垃圾回收。但是，将 <em>ThreadLocals</em> 与现代应用程序服务器一起使用时会出现问题。</p>
<p>现代应用程序服务器使用线程池来处理请求，而不是创建新请求（例如，对于 <code>Apache Tomcat</code> 为 <a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-7.0-doc/config/executor.html"><code>Executor</code></a>）。此外，他们还使用单独的类加载器。</p>
<p>由于应用程序服务器中的<a target="_blank" rel="noopener" href="https://www.baeldung.com/thread-pool-java-and-guava">线程池</a>使用线程重用的概念，因此它们永远不会被垃圾回收 - 而是被重用以满足另一个请求。</p>
<p>现在，如果任何类创建了一个 <code>ThreadLocal</code> 变量，但未明确删除它，那么即使在 Web 应用程序停止后，该对象的副本也将与工作线程一起保留，从而阻止垃圾回收该对象。</p>
<p>从上图中可以看出，<code>ThreadLocalMap</code> 使用 <code>ThreadLocal</code> 的弱引用作为 <code>key</code>，如果一个 <code>ThreadLocal</code> 不存在外部<strong>强引用</strong>时，<code>Key(ThreadLocal)</code> 势必会被 <code>GC</code> 回收，这样就会导致 <code>ThreadLocalMap</code> 中 <code>key</code> 为 <code>null</code>， 而 <code>value</code> 还存在着强引用，只有 <code>thead</code> 线程退出以后，<code>value</code> 的强引用链条才会断掉。</p>
<p>但如果当前线程再迟迟不结束的话，这些 <code>key</code> 为 <code>null</code> 的 <code>Entry</code> 的 <code>value</code> 就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<p>永远无法回收，造成内存泄漏。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>
<p>在不再使用 <em>ThreadLocal</em> 时清理是一个好习惯 - <em>ThreadLocal</em> 提供了<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#remove()"><em>remove()</em></a> 方法，该方法将删除此变量的当前线程值</p>
</li>
<li>
<p><strong>不要使用 <code>ThreadLocal.set(null)</code> 来清除值</strong> - 实际上并不会清除值，而是查找与当前线程关联的 <code>Map</code> 并将键值对分别设置为当前线程和 <code>null</code></p>
</li>
<li>
<p>最好将 <em>ThreadLocal</em> 视为需要在 <em>finally</em> 块中关闭的资源，以确保即使在发生异常的情况下也始终关闭该资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(System.nanoTime());</span><br><span class="line">    <span class="comment">//... further processing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="38-过期引用"><a class="markdownIt-Anchor" href="#38-过期引用"></a> 3.8 过期引用</h2>
<p>虽然绝大多数情况下我们在编写代码时不必考虑内存的回收，但是一旦我们自身管理了这些内存，垃圾回收可能就无法正常工作。让我们先来看一下一个简单的 Stack 类的实现，看看能不能找出内存泄漏的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么它的问题在哪里？如果堆栈增大然后缩小，弹出的对象被外部程序引用，那么即使使用该堆栈的程序没有引用该对象，从堆栈弹出的对象也不会被垃圾回收。 这是因为虽然弹出了对象的引用，但是堆栈自身还保留对这些对象的<strong>过时引用 （obsolete reference）</strong>。<strong>所以垃圾回收器永远不会回收这部分对象。</strong></p>
<p>垃圾收集语言中的内存泄漏（更适当地称为<strong>无意的对象保留 unintentional object retentions</strong>）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p>
<p>此类问题的<strong>解决方法</strong>很简单：一旦引用过时，则将其清空。 就我们的 <code>Stack</code> 类而言，对某个项目的引用在从堆栈中弹出后便会过时。 正确的 <code>pop</code> 方法版本如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>; <span class="comment">// 消除过期对象引用</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>清空好处</strong>：如果它们以后又被错误地引用，程序立即抛出 <code>NullPointerException</code> 异常，而不是悄悄地做继续做错误的事情。尽可能快地发现程序中的错误是有好处的。<br />
<strong>清空对象引用应该是例外而不是规范</strong>，不是所有的对象结束引用都需要手动清空，GC 自身能很好的做到，<strong>除非我们自身管理了内存时，才需要警惕。</strong></p>
<p>在 <code>JDK</code> 中，已经有现成的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Stack.html"><code>Stack</code></a> 类供我们使用，来看看它是怎么实现 <code>pop</code> 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek(); <span class="comment">//这个方法将栈顶的元素取出来，但并不会把栈顶元素弹出</span></span><br><span class="line">        removeElementAt(len - <span class="number">1</span>); <span class="comment">//这是 Stack 父类的方法,将栈顶元素弹出</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">&quot; &gt;= &quot;</span> +</span><br><span class="line">                                                     elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount--;</span><br><span class="line">        <span class="comment">// 可以看到，jdk 的实现就是显式地把引用清空，以此告诉 GC 将过期引用回收</span></span><br><span class="line">        elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何预防？</strong></p>
<ul>
<li>如果我们自身管理了对象的内存，<strong>首先应该尽可能的将变量定义在狭窄的范围内</strong></li>
<li>消除过时引用的最佳方法是让包含引用的变量超出范围</li>
<li>如果我们清楚知道该对象已经不再使用，可以手动清空对象使 GC 清楚可以被回收</li>
</ul>
<h2 id="39-未正确使用缓存"><a class="markdownIt-Anchor" href="#39-未正确使用缓存"></a> 3.9 未正确使用缓存</h2>
<p>一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 <code>WeakHashMap</code> 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，<code>WeakHashMap</code> 才有用。这点和 <code>ThreadLocal</code> 很像。</p>
<p>更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程（也许是 <code>ScheduledThreadPoolExecutor</code>）或将新的项添加到缓存时顺便清理。<code>LinkedHashMap</code> 类使用它的 <code>removeEldestEntry</code> 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 <code>java.lang.ref</code>。</p>
<p><strong>如何预防？</strong></p>
<ul>
<li>使用成熟的缓存实现类</li>
<li>如果简单实用，可以使用 <code>WeakHashMap</code> 或者定期清理缓存或设置过期时间等策略</li>
</ul>
<h2 id="310-监听器和其它回调"><a class="markdownIt-Anchor" href="#310-监听器和其它回调"></a> 3.10 监听器和其它回调</h2>
<p>如果你实现了一个API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（<code>weak references</code>），例如，仅将它们保存在 <code>WeakHashMap</code>的键（<code>key</code>）中。</p>
<p>比如 JDK 中虚拟机状态监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VMState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> VirtualMachineImpl vm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listeners</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;WeakReference&lt;VMListener&gt;&gt; listeners = <span class="keyword">new</span> ArrayList&lt;WeakReference&lt;VMListener&gt;&gt;();</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何预防？</strong></p>
<ul>
<li>自身管理对象内存时，要正确实现对象的管理操作</li>
<li>使用弱引用以便不使用时让 <code>GC</code> 回收</li>
</ul>
<h1 id="4-处理内存泄漏的其他策略"><a class="markdownIt-Anchor" href="#4-处理内存泄漏的其他策略"></a> 4. 处理内存泄漏的其他策略</h1>
<p>尽管在处理内存泄漏时没有一种万能的解决方案，但是有一些方法可以使这些泄漏最小化。</p>
<h2 id="41-启用分析"><a class="markdownIt-Anchor" href="#41-启用分析"></a> 4.1 启用分析</h2>
<p>Java Profiler 是监视和诊断通过应用程序的内存泄漏的工具。他们分析了我们应用程序内部发生的事情 - 例如，内存分配方式。</p>
<p><strong>使用分析器，我们可以比较不同的方法并找到可以最佳利用资源的领域。</strong></p>
<p>在之前的例子中，我们一直使用 <code>Java VisualVM</code>。还有其它不同类型的 <code>Profiler</code>，例如 <code>Mission Control</code>，<code>JProfiler</code>，<code>YourKit</code> 和 <code>Netbeans Profiler</code> 等。</p>
<h2 id="42-详细垃圾回收"><a class="markdownIt-Anchor" href="#42-详细垃圾回收"></a> 4.2 详细垃圾回收</h2>
<p>通过启用详细的垃圾收集，我们可以跟踪 <code>GC</code> 的详细信息。为此，我们需要将以下内容添加到我们的 <code>JVM</code> 配置中：</p>
<p><code>-verbose:gc</code></p>
<p>通过添加此参数，我们可以看到 <code>GC</code> 内部发生的情况的详细信息：</p>
<p><img src="../../images/java/jvm/verbose-garbage-collection.jpg" alt="verbose garbage collection" /></p>
<h2 id="43-使用引用对象避免内存泄漏"><a class="markdownIt-Anchor" href="#43-使用引用对象避免内存泄漏"></a> 4.3 使用引用对象避免内存泄漏</h2>
<p>我们还可以诉诸于 <code>java.lang.ref</code> 包内置的 Java 引用对象来处理内存泄漏。使用 <code>java.lang.ref</code> 包，而不是直接引用对象，通过使用对对象的特殊引用，使它们易于垃圾回收。</p>
<p>在引入引用类之前，只有强引用可用。例如，下面的代码行展示了一个强引用 <code>obj</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>obj 引用存储在堆中的对象。只要 obj 引用存在，垃圾收集器就永远不会释放用于保存该对象的存储。一个对象可以被多种引用类型引用。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">对应类</th>
<th style="text-align:center">特征</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center"></td>
<td style="text-align:center">强引用的对象被引用时不会被 GC 回收</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">SoftReference</td>
<td style="text-align:center">如果物理内存充足则不会被 GC 回收，如果物理内存不充足则会被 GC 回收。</td>
<td><strong>实现内存敏感型数据缓存</strong></td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">WeakReference</td>
<td style="text-align:center">一旦被 GC 扫描到则会被回收</td>
<td><strong>用于实现规范化的映射</strong>。如果映射仅包含特定值的一个实例，则称为规范化。比如 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/WeakHashMap.html"><em><code>WeakHashMap</code></em></a></strong>；<br /><strong>解决 Lapsed Listener 问题</strong>，上面所述监听器回调问题</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">PhantomReference</td>
<td style="text-align:center">不会影响对象的生命周期，形同于无，任何时候都可能被 GC 回收</td>
<td>**确定何时从内存中删除对象，**这有助于安排对内存敏感的任务。例如，我们可以等待一个大对象被删除再加载另一个对象。<br />**避免使用 <em>finalize</em> 方法，并改进 finalization 过程</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">FinalReference</td>
<td style="text-align:center">用于收尾机制(finalization)</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="44-基准测试"><a class="markdownIt-Anchor" href="#44-基准测试"></a> 4.4 基准测试</h2>
<p>我们可以通过执行基准测试来衡量和分析 Java 代码的性能。这样，我们可以比较替代方法执行相同任务的性能。这可以帮助我们选择更好的方法，并且可以帮助我们节省内存。</p>
<h2 id="45-代码评测"><a class="markdownIt-Anchor" href="#45-代码评测"></a> 4.5 代码评测</h2>
<p>最后，我们通过最经典的，古老的方式来进行简单的代码演练。</p>
<p>在某些情况下，即使是这种简单的方法也可以帮助消除一些常见的内存泄漏问题。</p>
<h1 id="5-结论"><a class="markdownIt-Anchor" href="#5-结论"></a> 5. 结论</h1>
<p>内存泄漏很难解决，要找到它们需要对 Java 语言进行复杂的掌握和命令。在处理内存泄漏时，没有一种千篇一律的解决方案，因为泄漏可能通过各种多样的事件发生。</p>
<p>但是，如果我们采用最佳实践并定期执行严格的代码演练和分析，则可以最大程度地减少应用程序中内存泄漏的风险。</p>
<p>与往常一样，可以在 <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-perf">GitHub</a> 上获得用于生成本教程中描述的 VisualVM 响应的代码段。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Memory Leak</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 日期类</title>
    <url>/java/Java-%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    <content><![CDATA[<p>Java 的 API 提供了很多有用的组件，能帮我们构建复杂的应用。比如日期处理，Java 从 1.0，就提供了 <code>java.util.Date</code> 类用于支持日期和时间的处理，不过由于该 API 设计的缺陷，产生了糟糕的易用性。随着 1.0 退出舞台，Date 类中的很多方法都被废弃了，Java 1.1 使用 <code>java.util.Calendar</code> 类取而代之，很不幸，Calendar 类也有类似的问题和设计缺陷，导致使用这些方法写出的代码非常容易出错。</p>
<p>所有这些缺陷和不一致导致用户们转投第三方的日期和时间库，比如 <code>Joda-Time</code>。为了解决这些问题，Oracle 决定在原生的 Java API 中提供高质量的日期和时间支持。你会看到 Java 8 在 <code>java.time</code> 包中整合了很多 Joda-Time 的特性。</p>
<p>在开始介绍日期类之前，我们先陈述几个经常出现的名次：</p>
<p><em><strong>UTC</strong></em></p>
<p><strong>协调世界时</strong>，是最主要的<strong>世界时间标准</strong>，基于原子钟。</p>
<a id="more"></a>
<blockquote>
<p>在 UTC 中，大约每一年或两年会多出一秒，称为“闰秒”，添加到一天的最后一秒，并且总是在 12 月 31 日或 6 月 30 日。</p>
</blockquote>
<p><em><strong>GMT</strong></em></p>
<p><strong>格林尼治标准时间，代表时区</strong>，标准时间为 UTC+0，是之前的民间标准，根据地球的自转和公转来计算时间，在欧洲国家和非洲国家用做当地标准时间。</p>
<blockquote>
<p>GMT 因为是根据地球的转动来计算时间的，而地球的自转目前正在缓速变慢，所以 UTC 比 GMT 更加精准。但是一些计算机的标准是根据格林尼治标准时间（GMT）定义的，所以大多数计算机时钟不够精确。</p>
<p>在民用领域可以认为两者相同。</p>
</blockquote>
<p><em><strong>CST</strong></em></p>
<p><strong>北美中部时区，代表时区</strong>，标准时间为 UTC-6。</p>
<blockquote>
<p>这种缩写的时区代表一片区域，但是由于没有明确的标准，CST 概念来说在中国也代表中国标准时间。具体缩写的定义可以查看 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html#SHORT_IDS">ZoneId.SHORT_IDS</a> 定义。</p>
<p>所以 java 提供了明确的时区表示方法，具体可用的时区字符串 Id 可以通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html#getAvailableZoneIds--">ZoneId.getAvailableZoneIds()</a> 方法查看。</p>
</blockquote>
<p><em><strong>ISO 8601</strong></em></p>
<p>代表国际标准的日期和时间表示方法。</p>
<p>日期格式一般为：<strong>yyyy-MM-dd</strong>；</p>
<p>带时区的日期一般格式为：<strong>yyyy-MM-dd’T’HH:mm:ss.SSSZ</strong>。</p>
<blockquote>
<p>在 Java 中定义了一些参见的格式化表示方法，在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">DateTimeFormatter</a> 有具体的静态格式化类表示。</p>
</blockquote>
<p><em><strong>UNIX 纪元（Epoch）</strong></em></p>
<p>代表 1970 年 1 月 1 日 0 时 0 分 0 秒 GMT 午夜</p>
<h2 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h2>
<p><strong>Date 类表示特定的时刻，精度为毫秒，该类反映的是协调世界时（UTC），不反映时区。</strong></p>
<p>该类在使用时有几点需要注意：</p>
<ul>
<li>该时刻表示的当前时间与纪元的差（以毫秒为单位）；</li>
<li>年代表与 <strong>1900</strong> 的差</li>
<li>一个月由 0 到 11 之间的整数表示；0 是一月，1 是二月，以此类推；</li>
<li>日期（一个月中的一天）由 1 到 31 之间的整数表示；</li>
<li>小时用 0 到 23 之间的的整数表示；</li>
<li>分钟用 0 到 59 之间的整数表示；</li>
<li>秒用 0 到 61 之间的整数表示；值 60 和 61 仅在闰秒出现；</li>
<li><strong>使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a> 格式化显示，该类非线程安全。</strong></li>
<li><strong>该类是可变类，线程不安全。</strong></li>
</ul>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<h4 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h4>
<p>创建当前时刻：<code>new Date()</code>，相当于：<code>new Date(System.currentTimeMillis())</code>，使用纪元时间与当前时间毫秒差创建日期。</p>
<p>使用 Java8 Instant 转换：<code>Date.from(Instant instant)</code>，内部还是使用纪元时间差，其它日期对象转换思想相同。</p>
<h4 id="日期"><a class="markdownIt-Anchor" href="#日期"></a> 日期</h4>
<p>Date 实现了 <code>Comparable</code> 接口，可以使用 <code>compareTo</code> 直接比较两个对象；</p>
<p>使用 <code>after</code> 和 <code>before</code> 实例方法；</p>
<h4 id="文本间转换"><a class="markdownIt-Anchor" href="#文本间转换"></a> 文本间转换</h4>
<p>使用 <code>DateFormat</code> 抽象类静态方法转换简单的 ISO 格式：</p>
<blockquote>
<p>该抽象类非线程安全，由于使用了成员变量 calendar 维护内部时间状态，导致 format 等方法依赖状态。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat dateInstance = DateFormat.getDateInstance();</span><br><span class="line">String format = dateInstance.format(date);</span><br><span class="line">Date parse = dateInstance.parse(format);</span><br><span class="line">System.out.println(parse + <span class="string">&quot; DateInstance format：&quot;</span> + format);</span><br><span class="line"><span class="comment">// Sun May 31 00:00:00 CST 2020 DateInstance format：2020-5-31</span></span><br><span class="line"></span><br><span class="line">DateFormat dateTimeInstance = DateFormat.getDateTimeInstance();</span><br><span class="line">String format1 = dateTimeInstance.format(date);</span><br><span class="line">Date parse1 = dateInstance.parse(format1);</span><br><span class="line">System.out.println(parse1 + <span class="string">&quot; DateTimeInstance format：&quot;</span> + format1);</span><br><span class="line"><span class="comment">// Sun May 31 00:00:00 CST 2020 DateTimeInstance format：2020-5-31 21:04:03</span></span><br><span class="line"></span><br><span class="line">DateFormat instance = DateFormat.getInstance();</span><br><span class="line">String format2 = instance.format(date);</span><br><span class="line">Date parse2 = instance.parse(format2);</span><br><span class="line">System.out.println(parse2 + <span class="string">&quot; Instance format：&quot;</span> + format2);</span><br><span class="line"><span class="comment">// Sun May 31 21:04:00 CST 2020 Instance format：20-5-31 下午9:04</span></span><br><span class="line"></span><br><span class="line">DateFormat timeInstance = DateFormat.getTimeInstance();</span><br><span class="line">String format3 = timeInstance.format(date);</span><br><span class="line">Date parse3 = timeInstance.parse(format3);</span><br><span class="line">System.out.println(parse3 + <span class="string">&quot; TimeInstance format：&quot;</span> + format3);</span><br><span class="line"><span class="comment">// Thu Jan 01 21:04:03 CST 1970 TimeInstance format：21:04:03</span></span><br></pre></td></tr></table></figure>
<p>或使用 <code>DateFormat</code> 实现类 <code>SimpleDateFormat</code> 基于 Pattern 形式转换：</p>
<blockquote>
<p>该类非线程安全，原因和 DateFormat 相同。</p>
</blockquote>
<table>
<thead>
<tr>
<th>字符</th>
<th>日期或时间元素</th>
<th>Presentation</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>Era 年代</td>
<td>Text</td>
<td>AD</td>
</tr>
<tr>
<td>y</td>
<td>年</td>
<td>Year</td>
<td>1996; 96</td>
</tr>
<tr>
<td>Y</td>
<td>Week year</td>
<td>Year</td>
<td>2009; 09</td>
</tr>
<tr>
<td>M</td>
<td>一年中的月份 (上下文敏感)</td>
<td>Month</td>
<td>July; Jul; 07</td>
</tr>
<tr>
<td>L</td>
<td>一年中的月份 (独立格式)</td>
<td>Month</td>
<td>July; Jul; 07</td>
</tr>
<tr>
<td>w</td>
<td>一年中的周</td>
<td>Number</td>
<td>27</td>
</tr>
<tr>
<td>W</td>
<td>一月中的周</td>
<td>Number</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>一年中的天</td>
<td>Number</td>
<td>189</td>
</tr>
<tr>
<td>d</td>
<td>一月中的天</td>
<td>Number</td>
<td>10</td>
</tr>
<tr>
<td>F</td>
<td>每月的星期几</td>
<td>Number</td>
<td>2</td>
</tr>
<tr>
<td>E</td>
<td>Day name in week</td>
<td>Text</td>
<td>Tuesday; Tue</td>
</tr>
<tr>
<td>u</td>
<td>星期几 (1 = 星期一, …, 7 = 星期天)</td>
<td>Number</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>Am/pm 标记</td>
<td>Text</td>
<td>PM</td>
</tr>
<tr>
<td>H</td>
<td>小时 (0-23)</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>k</td>
<td>小时 (1-24)</td>
<td>Number</td>
<td>24</td>
</tr>
<tr>
<td>K</td>
<td>基于上午/下午表示的时间 am/pm (0-11)</td>
<td>Number</td>
<td>0</td>
</tr>
<tr>
<td>h</td>
<td>基于上午/下午表示的时间 am/pm (1-12)</td>
<td>Number</td>
<td>12</td>
</tr>
<tr>
<td>m</td>
<td>分钟</td>
<td>Number</td>
<td>30</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
<td>Number</td>
<td>55</td>
</tr>
<tr>
<td>S</td>
<td>毫秒</td>
<td>Number</td>
<td>978</td>
</tr>
<tr>
<td>z</td>
<td>时区</td>
<td>一般时区</td>
<td>Pacific Standard Time; PST; GMT-08:00</td>
</tr>
<tr>
<td>Z</td>
<td>时区</td>
<td>RFC 822 时区</td>
<td>-0800</td>
</tr>
<tr>
<td>X</td>
<td>时区</td>
<td>ISO 8601 时区</td>
<td>-08; -0800;  -08:00</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&quot;</span>);</span><br><span class="line">String format = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">Date parse = simpleDateFormat.parse(format);</span><br></pre></td></tr></table></figure>
<h2 id="calendar"><a class="markdownIt-Anchor" href="#calendar"></a> Calendar</h2>
<p>该类是一个抽象类，和 Date 一样，代表特定的时刻，该类提供了一些操作日历字段的方法，比如获得下一周的日期。</p>
<p>该类使用时需要注意一下几点：</p>
<ul>
<li>支持指定时区和区域构造日历。最常见的实现是 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/GregorianCalendar.html">GregorianCalendar</a>，代表公历；</li>
<li>该时刻表示的当前时间与纪元的差（以毫秒为单位）；</li>
<li>年份不再从 1900 年开始，月份依旧从 0 开始计算；</li>
<li><strong>没有专门的文本格式转换，通过 Date 作为中转</strong>；</li>
<li><strong>该类是可变类，线程不安全。</strong></li>
</ul>
<h3 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h3>
<h4 id="创建-2"><a class="markdownIt-Anchor" href="#创建-2"></a> 创建</h4>
<ul>
<li>使用静态工厂方法获取基于系统时区的当前时刻：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar rightNow = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<ul>
<li>使用静态内部类构建器构建时间日历：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Calendar.Builder()</span><br><span class="line">        .setCalendarType(<span class="string">&quot;iso8601&quot;</span>)</span><br><span class="line">        .setWeekDate(<span class="number">2013</span>, <span class="number">1</span>, MONDAY)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Date</code> 转 <code>Calendar</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Calendar calendar = <span class="keyword">new</span> Calendar.Builder().setInstant(d).build();</span><br></pre></td></tr></table></figure>
<h4 id="比较"><a class="markdownIt-Anchor" href="#比较"></a> 比较</h4>
<p>该类同样实现了 <code>Comparable</code> 接口，可以使用 <code>compareTo</code> 直接比较两个对象；</p>
<p>使用 <code>after</code> 和 <code>before</code> 实例方法；</p>
<h4 id="修改字段"><a class="markdownIt-Anchor" href="#修改字段"></a> 修改字段</h4>
<p>通过 <code>set(int field, int value)</code> 修改<strong>当前日历对象</strong>字段，第一个参数为字段类型，定义在类的静态常量中：</p>
<p><code>ERA</code>, <code>YEAR</code>, <code>MONTH</code>(<code>JANUARY</code>, <code>FEBRUARY</code>, <code>MARCH</code>, <code>APRIL</code>, <code>MAY</code>, <code>JUNE</code>, <code>JULY</code>, <code>AUGUST</code>, <code>SEPTEMBER</code>, <code>OCTOBER</code>, <code>NOVEMBER</code>, <code>DECEMBER</code>, <code>UNDECIMBER</code>), <code>WEEK_OF_YEAR</code>, <code>WEEK_OF_MONTH</code>, <code>DATE</code>, <code>DAY_OF_MONTH</code>, <code>DAY_OF_YEAR</code>, <code>DAY_OF_WEEK</code>(<code>SUNDAY</code>, <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, <code>SATURDAY</code>), <code>DAY_OF_WEEK_IN_MONTH</code>, <code>AM_PM</code>, <code>HOUR</code>, <code>HOUR_OF_DAY</code>, <code>MINUTE</code>, <code>SECOND</code>, <code>MILLISECOND</code>, <code>ZONE_OFFSET</code>, <code>DST_OFFSET</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar rightNow = Calendar.getInstance();</span><br><span class="line">rightNow.set(Calendar.MONTH, Calendar.JANUARY);</span><br></pre></td></tr></table></figure>
<p>或者 <code>set(int year, int month, int date, int hourOfDay, int minute)</code> 和 <code>set(int year, int month, int date)</code> 等。</p>
<p>增加或降低字段值：<code>add(int field, int amount)</code>；</p>
<p>滚动增加或减小某个单位值，不影响前一个字段值：<code>roll(int field, boolean up)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a calendar</span></span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// displays the current calendar</span></span><br><span class="line">System.out.println(<span class="string">&quot;Month is &quot;</span> + cal.get(Calendar.MONTH));</span><br><span class="line"><span class="comment">// Month is 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// roll month</span></span><br><span class="line">cal.roll(Calendar.MONTH, <span class="keyword">true</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Month is &quot;</span> + cal.get(Calendar.MONTH));</span><br><span class="line"><span class="comment">// Month is 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// roll downwards</span></span><br><span class="line">cal.roll(Calendar.MONTH, <span class="keyword">false</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Month is &quot;</span> + cal.get(Calendar.MONTH));</span><br><span class="line"><span class="comment">// Month is 4</span></span><br></pre></td></tr></table></figure>
<h2 id="new-package-javatime"><a class="markdownIt-Anchor" href="#new-package-javatime"></a> new package java.time</h2>
<p>该包中定义的类代表基本的日期时间概念，包括瞬间，持续时间，日期，时间，时区和时间段。它们基于 ISO 日历系统（公历）。所有的类都是<strong>不可变的并且是线程安全的</strong>。</p>
<p>每个日期实例都是由方便获取的字段 API 组成。对于较低级别的字段访问，可以参考 <code>java.time.temporal</code> 包。每个类都支持打印和解析为各种日期和时间，具体参阅 <code>java.time.format</code> 包以获取自定义选项。</p>
<p><code>java.time.chrono</code> 包包含日历中立 API <code>ChronoLocalDate</code>，<code>ChronoLocalDateTime</code>，<code>ChronoZonedDateTime</code> 和 <code>Era</code>，这些类可以用来构建地区化的日历系统，比如农历等，系统内置提供了 4 中日历系统，分别是：</p>
<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>
<h2 id="package-javatimetemporal"><a class="markdownIt-Anchor" href="#package-javatimetemporal"></a> package java.time.temporal</h2>
<p>我们可以使用字段、单位和日期时间调节器来访问日期和时间。</p>
<p>该程序包在基本程序包上扩展，以提供更多功能来满足更强大的用例。支持包括：</p>
<ul>
<li>日期时间单位，例如年，月，日和小时</li>
<li>日期时间字段，例如一年中的某月，一周中的某日或一天中的某小时</li>
<li>日期时间调整功能</li>
<li>周的不同定义</li>
</ul>
<h3 id="字段和单位"><a class="markdownIt-Anchor" href="#字段和单位"></a> 字段和单位</h3>
<p>日期和时间以字段和单位表示。单位用于测量时间量，例如年，天或分钟。所有单位都实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html"><code>TemporalUnit</code></a>。众所周知的单位集在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html"><code>ChronoUnit</code></a> 中定义，例如 DAYS。该单位中也定义了一些常用的单位操作 API，例如：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#addTo-R-long-">addTo</a></strong>(R temporal, long amount) - 添加指定时间段</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#between-java.time.temporal.Temporal-java.time.temporal.Temporal-">between</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> temporal1Inclusive, <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> temporal2Exclusive) - 比较两个时间对象之间的时间</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#isSupportedBy-java.time.temporal.Temporal-">isSupportedBy</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> temporal) - 指定时间对象是否支持此单位</li>
</ul>
<p>字段用于表示较大日期时间的一部分，例如年，一年中的月或一分钟中的秒。所有字段都实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html"><code>TemporalField</code></a>。在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html"><code>ChronoField</code></a> 中定义了一组众所周知的字段，例如 HOUR_OF_DAY。其他字段由 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/JulianFields.html"><code>JulianFields</code></a>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html"><code>WeekFields</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/IsoFields.html"><code>IsoFields</code></a> 定义。该字段也有一些常用的 API，例如：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#getFrom-java.time.temporal.TemporalAccessor-">getFrom</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">TemporalAccessor</a> temporal) - 从指定的时间对象获取此字段的值</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#isSupportedBy-java.time.temporal.TemporalAccessor-">isSupportedBy</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">TemporalAccessor</a> temporal) - 检查时间对象是否支持此字段</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html#range--">range</a></strong>() - 获取此字段的有效范围</li>
</ul>
<p>字段的一种用法是从时间对象中获取没有便利方法的字段。例如，获取月中的某天很常见，以至于 <code>LocalDate</code> 上有一个名为 <code>getDayOfMonth()</code> 的方法。但是，对于更特殊的字段，必须使用该字段。例如，获取月中的周数，date.get(ChronoField.ALIGNED_WEEK_OF_MONTH)。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html"><code>Temporal</code></a> 作为支持字段的日期时间类型的抽象。其方法支持获取字段的值、创建修改字段值后的新日期时间以及查询其他信息（通常用于提取偏移量或时区）。</p>
<h3 id="调整和查询"><a class="markdownIt-Anchor" href="#调整和查询"></a> 调整和查询</h3>
<p>日期时间问题中的关键部分是将日期调整为新的相关值，例如“每月的最后一天”或“下一个星期三”。这些被建模为调整基准日期时间的函数。该函数实现 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjuster.html"><code>TemporalAdjuster</code></a> 并在 Temporal 上运行。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html"><code>TemporalAdjusters</code></a> 中提供了一组常用功能。例如，要查找给定日期后一周中某天的第一次出现，请使用 TemporalAdjusters.next(DayOfWeek)，例如 date.with(next(MONDAY))。</p>
<p>TemporalAdjuster 函数接口有一些常见的静态实现：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dayOfWeekInMonth</td>
<td>创建一个新的日期，它的值为同一个月中每一周的第几天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfMonth</td>
<td>创建一个新的日期，它的值为当月的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfNextMonth</td>
<td>创建一个新的日期，它的值为下月的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfNextYear</td>
<td>创建一个新的日期，它的值为明年的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstDayOfYear</td>
<td>创建一个新的日期，它的值为当年的第一天</td>
</tr>
<tr>
<td style="text-align:left">firstInMonth</td>
<td>创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的值</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfMonth</td>
<td>创建一个新的日期，它的值为当月的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfNextMonth</td>
<td>创建一个新的日期，它的值为下月的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfNextYear</td>
<td>创建一个新的日期，它的值为明年的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastDayOfYear</td>
<td>创建一个新的日期，它的值为今年的最后一天</td>
</tr>
<tr>
<td style="text-align:left">lastInMonth</td>
<td>创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的值</td>
</tr>
<tr>
<td style="text-align:left">next/previous</td>
<td>创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期</td>
</tr>
<tr>
<td style="text-align:left">nextOrSame/previousOrSame</td>
<td>创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期，如果该日期已经符合要求，直接返回该对象</td>
</tr>
</tbody>
</table>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html"><code>TemporalAmount</code></a> 接口模拟相对时间量，比如常用的实现类 <code>Duration</code>，<code>Period</code>。</p>
<p>除了调整日期时间外，还提供了一个接口以启用通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQuery.html"><code>TemporalQuery</code></a> 进行查询。查询接口的最常见实现是方法引用。可以使用主要时间对象类上的 <code>from(TemporalAccessor)</code> 方法，例如 <code>LocalDate::from</code> 或 <code>Month::from</code>。在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQueries.html"><code>TemporalQueries</code></a> 中作为静态方法提供了进一步的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ZonedDateTime now = ZonedDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now: 2020-06-11T00:00:39.096326+08:00[Asia/Shanghai]</span></span><br><span class="line">System.out.format(<span class="string">&quot;Now: %s%n&quot;</span>, now);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> LocalDate localDate = now.query(TemporalQueries.localDate());</span><br><span class="line"><span class="keyword">final</span> LocalDate toLocalDate = now.toLocalDate();</span><br><span class="line"><span class="keyword">final</span> LocalDate fromLocalDate = now.query(LocalDate::from);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(localDate.isEqual(toLocalDate) &amp;&amp; localDate.isEqual(fromLocalDate));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TemporalUnit unit = now.query(TemporalQueries.precision());</span><br><span class="line"><span class="keyword">final</span> Chronology chronology = now.query(TemporalQueries.chronology());</span><br><span class="line"><span class="keyword">final</span> ZoneId zone = now.query(TemporalQueries.zoneId());</span><br><span class="line"><span class="keyword">final</span> ZoneOffset offset = now.query(TemporalQueries.offset());</span><br><span class="line"></span><br><span class="line"><span class="comment">// TemporalUnit: Nanos, Chronology: ISO, ZoneId: Asia/Shanghai, ZoneOffset: +08:00</span></span><br><span class="line">System.out.format(<span class="string">&quot;TemporalUnit: %s, Chronology: %s, ZoneId: %s, ZoneOffset: %s %n&quot;</span>, unit, chronology, zone, offset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Month month = now.query(Month::from);</span><br><span class="line"><span class="keyword">final</span> MonthDay monthDay = now.query(MonthDay::from);</span><br><span class="line"><span class="keyword">final</span> YearMonth yearMonth = now.query(YearMonth::from);</span><br><span class="line"><span class="keyword">final</span> DayOfWeek dayOfWeek = now.query(DayOfWeek::from);</span><br><span class="line"><span class="keyword">final</span> ZoneId zoneId = now.query(ZoneId::from);</span><br><span class="line"><span class="keyword">final</span> ZoneOffset zoneOffset = now.query(ZoneOffset::from);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Month: JUNE, MonthDay: --06-11, YearMonth: 2020-06, DayOfWeek: THURSDAY, zoneId: Asia/Shanghai, zoneOffset: +08:00</span></span><br><span class="line">System.out.format(<span class="string">&quot;Month: %s, MonthDay: %s, YearMonth: %s, DayOfWeek: %s, zoneId: %s, zoneOffset: %s %n&quot;</span>, month, monthDay, yearMonth, dayOfWeek, zoneId, zoneOffset);</span><br></pre></td></tr></table></figure>
<h3 id="周"><a class="markdownIt-Anchor" href="#周"></a> 周</h3>
<p>不同的语言环境对星期有不同的定义。例如，在欧洲，一周通常从星期一开始，而在美国，则从星期日开始。 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/WeekFields.html"><code>WeekFields</code></a> 类为这种区别建模。IOS 定义星期一为一周开始，一周至少需要四天。</p>
<p>ISO 日历系统定义了一个额外的基于周的年划分。这定义了基于从一年整个星期一到星期一的一年，它是在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/IsoFields.html"><code>IsoFields</code></a> 中建模的。</p>
<h2 id="日期和时间"><a class="markdownIt-Anchor" href="#日期和时间"></a> 日期和时间</h2>
<p>日期和时间类的接口都提供了一致的设计，所以再很多 API 上都做了通用的处理，比如一致的方法前缀：</p>
<ul>
<li><code>of</code> - 静态工厂方法</li>
<li><code>parse</code> - 侧重于解析的静态工厂方法</li>
<li><code>get</code> - 获取值或其它</li>
<li><code>is</code> - 检查是否为真</li>
<li><code>with</code> - 等同于 setter 的不可变修改，返回新的副本</li>
<li><code>plus</code> - 增加一定数量的单位</li>
<li><code>minus</code> - 减少一定数量的单位</li>
<li><code>to</code> - 将一个对象转换为另一个对象</li>
<li><code>at</code> - 将一个对象结合到该对象中，例如 <code>date.atTime(time)</code></li>
</ul>
<p>这里主要以 Insant 展开介绍。</p>
<h3 id="instant"><a class="markdownIt-Anchor" href="#instant"></a> Instant</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html"><code>Instant</code></a> 实质上是一个数字时间戳。可以从时钟（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html"><code>Clock</code></a>）中获取当前的瞬时信息。这对于时间点的记录和持久化很有用，存储的结果与 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#currentTimeMillis--"><code>System.currentTimeMillis()</code></a>` 相关联。</p>
<h4 id="创建-3"><a class="markdownIt-Anchor" href="#创建-3"></a> 创建</h4>
<p>从 <code>Date</code> 获取：<code>new Date().toInstant()</code>；</p>
<p>使用静态工厂方法：</p>
<ul>
<li>从系统时钟（Clock）构建：<code>Instant.now()</code>，<code>Instant.now(Clock clock)</code></li>
<li>根据纪元差毫秒构建构建：<code>Instant.ofEpochMilli(long epochMilli)</code></li>
<li>使用标准 ISO 格式字符串构建：<code>Instant.parse(CharSequence text)</code>，格式例如：2007-12-03T10:15:30.00Z</li>
<li>从 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html">TemporalAccessor</a> 实现类构建，该类可以为 Instant 或支持 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html#INSTANT_SECONDS"><code>INSTANT_SECONDS</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html#NANO_OF_SECOND"><code>NANO_OF_SECOND</code></a> 字段的实现类，比如：<code>ZonedDateTime</code></li>
</ul>
<h4 id="比较-2"><a class="markdownIt-Anchor" href="#比较-2"></a> 比较</h4>
<p>使用前需明确该对象支持的单位或字段类型，API 文档中有说明支持的类型；</p>
<p>或者使用：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#isSupported-java.time.temporal.TemporalUnit-">isSupported</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit) 和 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#isSupported-java.time.temporal.TemporalUnit-">isSupported</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit) 判断</p>
<ul>
<li>
<p>比较与指定 Temporal 实现类指定单位的差：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#until-java.time.temporal.Temporal-java.time.temporal.TemporalUnit-">until</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html">Temporal</a> endExclusive, <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit)</p>
</li>
<li>
<p>使用 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#isAfter-java.time.Instant-">isAfter</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">Instant</a> otherInstant) 或 isBefore(Instant otherInstant) 或 <strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#compareTo-java.time.Instant-">compareTo</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html">Instant</a> otherInstant)</p>
</li>
</ul>
<h4 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h4>
<p>获取时间的字段值前同样得确认是否支持，这些方法通常以 <code>get*</code> 单位的形式存在，或者直接通过：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#get-java.time.temporal.TemporalField-">get</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field)</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#get-java.time.temporal.TemporalField-">getLong</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field)</li>
<li>构建查询获取：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#query-java.time.temporal.TemporalQuery-">query</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalQuery.html">TemporalQuery</a><R> query)</li>
</ul>
<p>获取字段的有效值范围：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#range-java.time.temporal.TemporalField-">range</a>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field)</p>
<h4 id="调整"><a class="markdownIt-Anchor" href="#调整"></a> 调整</h4>
<p>所有的修改方法都返回新的副本：</p>
<ul>
<li>调整字段值：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#with-java.time.temporal.TemporalField-long-">with</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalField.html">TemporalField</a> field, long newValue)</li>
<li>截断操作会将小于该单位的字段都设置为 0：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#truncatedTo-java.time.temporal.TemporalUnit-">truncatedTo</a>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html">TemporalUnit</a> unit)</li>
<li>增加或减少某个字段：<code>plus*</code>、<code>minus*</code></li>
<li>通过 TemporalAdjuster 函数接口实现调整：<strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#with-java.time.temporal.TemporalAdjuster-">with</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjuster.html">TemporalAdjuster</a> adjuster)</li>
</ul>
<h3 id="localdate"><a class="markdownIt-Anchor" href="#localdate"></a> LocalDate</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html"><code>LocalDate</code></a> 存储没有时间的日期，也不附带时区信息。它会存储 <code>yyyy-MM-dd</code> 格式的日期，可以用来存储生日。</p>
<h3 id="localtime"><a class="markdownIt-Anchor" href="#localtime"></a> LocalTime</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html"><code>LocalTime</code></a> 存储没有日期的时间。它将存储类似于 <code>HH:mm:ss</code> 格式的时间。</p>
<h3 id="localdatetime"><a class="markdownIt-Anchor" href="#localdatetime"></a> LocalDateTime</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html"><code>LocalDateTime</code></a> 存储日期和时间。它将存储类似于 <code>yyyy-MM-dd HH:mm:ss</code> 格式的时间。</p>
<h3 id="zoneddatetime"><a class="markdownIt-Anchor" href="#zoneddatetime"></a> ZonedDateTime</h3>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html"><code>ZonedDateTime</code></a> 存储带有时区的日期和时间。如果要考虑到 ZoneId（例如“欧洲/巴黎”）对日期和时间进行准确的计算，这将很有用。如果可能，建议使用没有时区的简单类。时区的广泛使用往往会增加应用程序的复杂性。</p>
<p>该类存储类似于 <code>yyyy-MM-dd HH:mm:ss.zzz</code> 格式的时间。可通过上面所述时间类通过：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html#atZone-java.time.ZoneId-">atZone</a>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html">ZoneId</a> zone) 添加时区而来。</p>
<p>下图对 ZoneDateTime 的组成部分进行了说明。</p>
<p><img src="../../images/java/zoneDateTime.jpg" alt="zoneDateTime" /></p>
<h2 id="持续时间和周期"><a class="markdownIt-Anchor" href="#持续时间和周期"></a> 持续时间和周期</h2>
<h3 id="duration"><a class="markdownIt-Anchor" href="#duration"></a> Duration</h3>
<p>持续时间是沿时间线以纳秒为单位的时间的简单度量。</p>
<p>此类以秒和纳秒为单位对时间量进行建模。也可以使用其他基于持续时间的单位（例如分钟和小时）来访问它。</p>
<h4 id="创建-4"><a class="markdownIt-Anchor" href="#创建-4"></a> 创建</h4>
<p>目前为止, 我们看到的所有类都实现了 <code>Temporal</code> 接口, <code>Temporal</code> 接口定义了如何读取和操纵为时间建模的对象的值。</p>
<p><code>Duration</code> 类的静态工厂方法 <code>between</code> 就可以为两个 Temporal 对象创建持续时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration d1 = Duration.between(time1, time2); </span><br><span class="line">Duration d1 = Duration.between(dateTime1, dateTime2); </span><br><span class="line">Duration d2 = Duration.between(instant1, instant2);</span><br></pre></td></tr></table></figure>
<p>也可以使用静态工厂从其它时间单位创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>); </span><br><span class="line">Duration threeMinutes = Duration.of(<span class="number">3</span>, ChronoUnit.MINUTES);  </span><br></pre></td></tr></table></figure>
<h3 id="period"><a class="markdownIt-Anchor" href="#period"></a> Period</h3>
<p>周期以对人类有意义的单位表示时间量。例如年、月或天。</p>
<h4 id="创建-5"><a class="markdownIt-Anchor" href="#创建-5"></a> 创建</h4>
<p>使用静态工厂方法创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Period tenDays = Period.between(LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">8</span>), LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>));</span><br><span class="line"></span><br><span class="line">Period tenDays = Period.ofDays(<span class="number">10</span>); </span><br><span class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>); </span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<hr />
<p><code>Duration</code> 类和 <code>Period</code> 类共享了很多相似的方法，参见下表所示。</p>
<table>
<thead>
<tr>
<th>方 法 名</th>
<th>是否是静态方法</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>between</td>
<td>是</td>
<td>创建两个时间点之间的 interval</td>
</tr>
<tr>
<td>from</td>
<td>是</td>
<td>由一个临时时间点创建 interval</td>
</tr>
<tr>
<td>of</td>
<td>是</td>
<td>由它的组成部分创建 interval 的实例</td>
</tr>
<tr>
<td>parse</td>
<td>是</td>
<td>由字符串创建 interval 的实例</td>
</tr>
<tr>
<td>addTo</td>
<td>否</td>
<td>创建该 interval 的副本,并将其?加到某个指定的 temporal 对象</td>
</tr>
<tr>
<td>get</td>
<td>否</td>
<td>读取该 interval 的状态</td>
</tr>
<tr>
<td>isNegative</td>
<td>否</td>
<td>检查该 interval 是否为负值,不包含零</td>
</tr>
<tr>
<td>isZero</td>
<td>否</td>
<td>检查该 interval 的时长是否为零</td>
</tr>
<tr>
<td>minus</td>
<td>否</td>
<td>通过减去一定的时间创建该 interval 的副本</td>
</tr>
<tr>
<td>multipliedBy</td>
<td>否</td>
<td>将 interval 的值乘以某个标量创建该 interval 的副本</td>
</tr>
<tr>
<td>negated</td>
<td>否</td>
<td>以忽略某个时长的方式创建该 interval 的副本</td>
</tr>
<tr>
<td>plus</td>
<td>否</td>
<td>以增加某个指定的时长的方式创建该 interval 的副本</td>
</tr>
<tr>
<td>subtractFrom</td>
<td>否</td>
<td>从指定的 temporal 对象中减去该 interval</td>
</tr>
</tbody>
</table>
<h2 id="打印输出及解析日期"><a class="markdownIt-Anchor" href="#打印输出及解析日期"></a> 打印输出及解析日期</h2>
<p>处理日期和时间对象时，格式化以及解析日期-时间对象是另一个非常重要的功能。新的 <code>java.time.format</code> 包就是特别为这个目的而设计的。</p>
<p>这个包中，最重要的类是 <strong><code>DateTimeFormatter</code></strong>。创建格式器最简单的方法是通过它的静态工厂方法以及常量。</p>
<p>它包含了 IOS 格式定义的常见格式，像 <code>BASIC_ISO_DATE</code> 和 <code>ISO_LOCAL_DATE</code>  这样的常量是 DateTimeFormatter 类的预定义实例。</p>
<p>所有的 DateTimeFormatter 实例都能用于以一定的格式创建代表特定日期或时间的字符串。比如，下面的这个例子中，我们使用了两个不同的格式器生成了字符串:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>);  </span><br><span class="line">String s1 = date.format(DateTimeFormatter.BASIC_ISO_DATE);	&lt;-- <span class="number">20140318</span></span><br><span class="line">String s2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE);  &lt;-- <span class="number">2014</span>-<span class="number">03</span>-<span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过解析代表日期或时间的字符串重新创建该日期对象。所有的日期和时间API 都提供了表示时间点或者时间段的工厂方法,你可以使用工厂方法parse达到重创该日期对象的目的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date1 = LocalDate.parse(<span class="string">&quot;20140318&quot;</span>, DateTimeFormatter.BASIC_ISO_DATE); </span><br><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">&quot;2014-03-18&quot;</span>, DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure>
<p>和老的 <em><code>java.util.DateFormat</code></em> 相比较，所有的 <code>DateTimeFormatter</code> 实例<strong>都是线程安全的</strong>。所以，我们能够以单例模式创建格式器实例，就像 DateTimeFormatter 所定义的那些常量，并能在多个线程间共享这些实例。DateTimeFormatter 类还支持一个静态工厂方法,它可以按照某个特定的模式创建格式器，代码清单如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;dd/MM/yyyy&quot;</span>);</span><br><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>, <span class="number">3</span>, <span class="number">18</span>); </span><br><span class="line">String formattedDate = date1.format(formatter); </span><br><span class="line">LocalDate date2 = LocalDate.parse(formattedDate, formatter);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Object 由内及外</title>
    <url>/java/jvm/Java-Object-%E7%94%B1%E5%86%85%E5%8F%8A%E5%A4%96/</url>
    <content><![CDATA[<h2 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1. 引言</h2>
<p>Java 对象需要占用多少内存，这是一个经常被提及的问题。在缺少 <code>sizeof</code> 运算符的情况下，人们不禁想知道代码对其占用空间的影响。在本文中，我们将尝试窥视 Java 对象内部并查看其背后的内容。</p>
<h2 id="2-探讨更深入的设计与实现方面的问题"><a class="markdownIt-Anchor" href="#2-探讨更深入的设计与实现方面的问题"></a> 2. 探讨更深入的设计与实现方面的问题</h2>
<p>Deeper Design and Implementation Questions (DDIQ)，在某些章节中，您可能会看到其中包含有关设计/实现问题的更多讨论。这些并不能保证回答所有问题，但他们确实尝试回答最常见的问题。答案基于个人的理解，因此可能是不准确，不完整或两者兼而有之。</p>
<span id="more"></span>
<h2 id="3-方法论考虑"><a class="markdownIt-Anchor" href="#3-方法论考虑"></a> 3. 方法论考虑</h2>
<p>这篇文章针对 <code>Hotspot JVM</code>，OpenJDK 及其衍生版本的默认 JVM。如果你不知道运行的是哪种 JVM，则很可能就是 <code>Hotspot</code>。</p>
<h3 id="31-工具"><a class="markdownIt-Anchor" href="#31-工具"></a> 3.1 工具</h3>
<p>为了正确地做到这一点，我们需要工具。当我们分析工具时，重要的是要了解工具可以做什么和不能做什么。</p>
<ol>
<li>
<p><strong>堆转储</strong>。转储 Java 堆并检查它可能很诱人。这似乎取决于以下信念：堆转储是运行时堆的低级表示。不幸的是，事实并非如此：它是从实际的 Java 堆重构而来的（虚幻的）幻想。如果查看 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html">HPROF 数据格式</a>，您将看到它实际上是多么高级：它没有谈论字段偏移，也没有直接告诉标头任何东西，唯一的安慰就是那里的对象大小，<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8005604">这也是一个谎言</a>。堆转储对于检查对象的整个图引用及其内部连接非常有用，但检查对象本身太粗糙了。</p>
</li>
<li>
<p><strong>通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/ThreadMXBean.html"><code>MXBeans</code></a> 测量可用或已分配的内存</strong>。我们当然可以分配多个对象，并查看它们占用了多少内存。分配足够的对象后，我们可以消除由 <code>TLAB 分配</code>（及其退役），后台线程中的虚假分配等导致的异常值。但是，这并不能使我们在查看对象内部时有任何保真度：我们只能观察到对象的外观大小。这是进行研究的一种好方法，但是您需要正确地制定和测试假设，以得出能够解释每个结果的明智的对象模型。</p>
</li>
<li>
<p><strong>诊断 JVM 标志</strong>。因为 JVM 本身负责创建对象，所以可以肯定它知道对象的布局，而且我们“仅”需要从那里得到它。 <code>-XX：+ PrintFieldLayout</code> 可以很容易的实现。不幸的是，该标志仅在 <code>debug JVM 版本</code>下可用。</p>
</li>
<li>
<p><strong>深入对象内部的工具</strong>。幸运的是，使用 <code>Class.getDeclaredFields</code> 并询问 <code>Unsafe.objectFieldOffset</code> 可以使您知道字段所在的位置。这涉及到多个注意事项：首先，它使用反射功能侵入了大多数类，可能会被禁止使用；第二，<code>Unsafe.objectFieldOffset</code> 不会正式回答偏移量，而是一些 “cookie”，可以将其传递给其他 Unsafe 方法来使用。也就是说，它“通常是有效的”，因此，除非我们做至关重要的事情时才可以使用它侵入代码。某些工具（尤其是 <a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/code-tools/jol/"><code>JOL</code></a> ）可以为我们做到这一点。</p>
</li>
</ol>
<p>在本文中，我们将使用 <code>JOL</code>，因为我们希望看到 Java 对象的更精细的结构。对于我们的需求，使用 <code>JOL-CLI</code> 可执行 jar 包更合适，可以在这里找到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://repo.maven.apache.org/maven2/org/openjdk/jol/jol-cli/0.10/jol-cli-0.10-full.jar -O jol-cli.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar jol-cli.jar</span></span><br><span class="line">Usage: jol-cli.jar &lt;mode&gt; [optional arguments]*</span><br><span class="line"></span><br><span class="line">Available modes:</span><br><span class="line">   internals: Show the object internals: field layout and default contents, object header</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对于对象目标，我们将尽可能尝试使用各种 JDK 类本身。这样可以轻松验证整个过程，因为您只需要 JOL CLI JAR 和您喜欢的 JDK 安装即可运行测试。在更复杂的情况下，我们将转到 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/">JOL 示例</a>，其中涵盖了此处的一些内容。作为最后的说明手段，我们将使用其它示例类。</p>
<blockquote>
<p>JOL 实例中的代码已经演示了大部分情景，可以自己动手运行并查看这些代码。</p>
</blockquote>
<h3 id="32-jdks"><a class="markdownIt-Anchor" href="#32-jdks"></a> 3.2 JDKs</h3>
<p>JDK 8 仍然是世界上部署最广泛的 JDK 版本。因此，我们也会在这里使用它。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line">openjdk version &quot;1.8.0_252&quot;</span><br><span class="line">OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_252-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.252-b09, mixed mode)</span><br></pre></td></tr></table></figure>
<h2 id="4-数据类型及其表示"><a class="markdownIt-Anchor" href="#4-数据类型及其表示"></a> 4. 数据类型及其表示</h2>
<p>我们需要从一些基础知识开始。在几乎每个 JOL “内部”运行中，您都会看到以下输出（为简便起见，在以后的调用中将省略此输出）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/bin/java -jar jol-cli.jar internals java.lang.Object</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> Field sizes by <span class="built_in">type</span>: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br></pre></td></tr></table></figure>
<p>这意味着 Java 引用占用 4 个字节（启用<a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/23-compressed-references/">指针压缩</a>），<code>boolean</code> / <code>byte</code> 占用 1 个字节，<code>char</code> / <code>short</code> 占用 2 个字节，<code>int</code> / <code>float</code> 占用 4 个字节，<code>double</code> / <code>long</code> 占用 8 个字节。当作为数组元素呈现时，它们占据相同的空间。</p>
<p>为什么这很重要？因为 Java 语言规范没有说明有关数据表示的任何内容，仅说明了这些类型接受的值。原则上，可以为所有原语分配 8 个字节，只要对它们的存储范围超过其规范即可。在当前的 Hotspot 中，除 <code>boolean</code> 外，几乎所有数据类型都与它们的值域完全匹配。例如，指定为支持 <code>int</code> 从 <code>-2147483648</code> 到 <code>2147483647</code> 的值，该值正好适合 4 字节带符号的表示形式。</p>
<p>如上所述，有一个奇怪的地方，那就是 <code>boolean</code>。原则上，其值域仅包含两个值：<code>true</code> 和 <code>false</code>，因此可以用 1 位表示。所有 <code>boolean</code> 字段和数组元素仍然占据 1 个完整字节，这有两个原因：Java 内存模型保证了对于单个字段/元素不存在<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.6">单词撕裂</a>的情况，这对于 1 位布尔字段来说很难做到，并且字段偏移量以字节为单位进行内存寻址，这使得寻址布尔型字段很尴尬。因此，这里每个布尔值占用 1 个字节是一个实际的折衷方案。</p>
<h2 id="5-mark-word标记信息"><a class="markdownIt-Anchor" href="#5-mark-word标记信息"></a> 5. Mark Word（标记信息）</h2>
<p>回到实际的对象结构。让我们从最基本的 <code>java.lang.Object</code> 示例开始。 JOL 将打印此：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/java -jar jol-cli.jar internals java.lang.Object</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Objects are 8 bytes aligned.</span></span><br><span class="line"></span><br><span class="line">Instantiated the sample instance via default constructor.</span><br><span class="line"></span><br><span class="line">java.lang.Object object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      0     4        (object header)              01 00 00 00 # Mark word</span><br><span class="line">      4     4        (object header)              00 00 00 00 # Mark word</span><br><span class="line">      8     4        (object header)              00 10 00 00 # (not mark word)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>它显示前 12 个字节是对象头。不幸的是，它没有更详细地解析其内部结构，因此，我们需要深入研究 Hotspot 源代码以弄清楚这一点。在这里，你会注意到对象头<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/oop.hpp#l52">包括两部分</a>：<em><code>mark word</code> 和 <code>class word</code></em>。Class word 包含对象类型的信息：它链接到描述该类的本机结构。我们将在下一节中讨论这一部分。其余的元数据保存在 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/markWord.hpp#l33">mark word</a> 中。</p>
<p>mark word 有多种用途：</p>
<ol>
<li>存储用于 GC 的元数据（分代年龄和转发数据）</li>
<li>存储身份标识 hash code</li>
<li>存储锁标志位信息</li>
</ol>
<p>请注意，每个对象都必须有一个 mark word，因为它处理每个 Java 对象特有的事物。</p>
<h3 id="51-存储用于-gc-的转发数据"><a class="markdownIt-Anchor" href="#51-存储用于-gc-的转发数据"></a> 5.1 存储用于 GC 的转发数据</h3>
<p>GC 需要移动对象时，它们至少需要临时记录对象的新位置。mark word 将对此进行编码，以用于 GC 代码，以协调重定位和更新引用工作。这会将 mark word 锁定为与 Java 引用一样宽。GC 转发数据在 mark word 中实现所需要的最小内存量：32 位平台为 4 字节，而 64 位平台为 8 字节。</p>
<p>不幸的是，我们无法显示展示来自 Java 应用程序（而 JOL 是 Java 应用程序）进行 GC 转发的 mark word，因为要么在我们取消阻止 full GC 时就已经消失了。要么并发 GC 障碍阻止我们看到旧对象。</p>
<h3 id="52-存储-gc-分代年龄"><a class="markdownIt-Anchor" href="#52-存储-gc-分代年龄"></a> 5.2 存储 GC 分代年龄</h3>
<p>但是，我们可以演示对象分代年龄位！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-32/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_19_Promotion</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 32-bit HotSpot VM.</span></span><br><span class="line"></span><br><span class="line">Fresh object is at d2d6c0f8</span><br><span class="line">*** Move  1, object is at d31104a0</span><br><span class="line">  (object header)  09 00 00 00 (00001001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  2, object is at d3398028</span><br><span class="line">  (object header)  11 00 00 00 (00010001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  3, object is at d3109688</span><br><span class="line">  (object header)  19 00 00 00 (00011001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  4, object is at d43c9250</span><br><span class="line">  (object header)  21 00 00 00 (00100001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  5, object is at d41453f0</span><br><span class="line">  (object header)  29 00 00 00 (00101001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  6, object is at d6350028</span><br><span class="line">  (object header)  31 00 00 00 (00110001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br><span class="line">*** Move  7, object is at a760b638</span><br><span class="line">  (object header)  31 00 00 00 (00110001 00000000 00000000 00000000)</span><br><span class="line">                                 ^^^^</span><br></pre></td></tr></table></figure>
<p>请注意，每一步移动都是如何向上计数的。那就是记录对象的年龄。奇怪的是，经过 7 次移动后，它在第 6 次停止。这是由于 <code>InitialTenuringThreshold = 7</code> 的默认设置。如果增加该值，则该对象将经历更多的移动，直到到达老年代为止。默认最多移动 15 次（1111），可以修改参数 <code>-XX:MaxTenuringThreshold</code> 调小。</p>
<h3 id="53-身份标识信息"><a class="markdownIt-Anchor" href="#53-身份标识信息"></a> 5.3 身份标识信息</h3>
<p>每个 Java 对象都有一个<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode--">哈希码</a>。如果用户没有为其定义，则使用*<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#identityHashCode-java.lang.Object-">身份哈希码</a>*。由于身份哈希码在为给定对象计算后不应更改，因此我们需要将其存储在某个位置。在 Hotspot 中，它直接存储在目标对象的 <code>mark word</code> 中。根据身份哈希码接受的精度，可能需要多达 4 个字节来存储。</p>
<blockquote>
<p><strong>DDIQ：当我们也需要存储 GC 转发数据时，该如何工作？</strong></p>
<p>答案很狡猾：当 GC 移动对象时，它实际上处理对象的两个副本，一个在旧位置，一个在新位置。新对象带有所有原始头信息。旧对象仅用于满足 GC 需求，因此我们可以使用 GC 元数据覆盖旧对象头信息。</p>
</blockquote>
<blockquote>
<p><strong>DDIQ：为什么我们需要存储身份哈希码？这如何影响用户指定的哈希码？</strong></p>
<p>哈希码应该具有两个属性：a) 良好的散列分布，这意味着不同对象的值或多或少是不同的；b) 幂等，意味着具有相同关键对象组件的对象具有相同的哈希码。注意后者暗示如果对象没有更改那些关键对象组件，则其哈希码也不应更改。</p>
<p>对于身份哈希码，无法保证是否<em>存在</em>用于计算哈希码的字段，即使我们有一些字段，也无法得知这些字段的实际稳定性。考虑一下没有字段的 <code>java.lang.Object</code>：它的哈希码是什么？分配的两个对象几乎是彼此的镜像：它们具有相同的元数据，它们具有相同（即空）的内容。关于它们的唯一区别是分配的地址，但是即使那样，仍然有两个麻烦。第一，地址具有非常低的熵，尤其是像大多数 Java GC 所采用的那样，是来自 bump-ptr 分配器，因此它的分布不均。其次，GC 会移动对象，因此地址不是幂等的。从性能的角度来看，返回恒定值也是行不通的。</p>
<p>因此，当前的实现从内部 PRNG（“良好分布”）计算身份哈希码，并为每个对象存储它（“幂等”）。</p>
</blockquote>
<p>可以通过相关的 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_15_IdentityHashCode.java#l41">JOLSample_15_IdentityHashCode</a> 清楚地看到由身份哈希码引起的 mark word 变化。使用 64 位 VM 运行它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_15_IdentityHashCode</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_15_IdentityHashCode$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION              VALUE</span><br><span class="line">      0     4        (object header)          01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)          00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)          97 ef 00 f8 (10010111 11101111 00000000 11111000) (-134156393)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">hashCode: 2f333739</span><br><span class="line"></span><br><span class="line">**** After identityHashCode()</span><br><span class="line">org.openjdk.jol.samples.JOLSample_15_IdentityHashCode$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION              VALUE</span><br><span class="line">      0     4        (object header)          01 39 37 33 (00000001 00111001 00110111 00110011) (859257089)</span><br><span class="line">      4     4        (object header)          2f 00 00 00 (00101111 00000000 00000000 00000000) (47)</span><br><span class="line">      8     4        (object header)          97 ef 00 f8 (10010111 11101111 00000000 11111000) (-134156393)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>请注意，哈希码值为 <code>2f333739</code>。计算机内部为小端字节序，<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html">低位字节在前，高位字节在后</a>，可以使用代码 <code>ByteOrder.nativeOrder()</code> 查看系统机器字节序。你现在可以在对象头中找到它：<code>01 39 37 33 2f</code>。 <code>01</code> 是 mark word 标记，其余是用 little-endian 小端字节序编写的身份哈希码。而且，我们还有 3 个字节的备用空间！</p>
<h3 id="54-锁信息"><a class="markdownIt-Anchor" href="#54-锁信息"></a> 5.4 锁信息</h3>
<p>Java 同步采用了<a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">复杂的状态机</a>。由于可以同步每个 Java 对象，因此锁定状态应与任何 Java 对象相关联。mark word 维护了大部分状态。</p>
<p>这些锁定转换的不同部分可以在对象头中看到。例如，当 Java 锁定偏向特定线程时，我们需要在相关对象附近记录有关该偏向锁 (Biased Lock) 的信息。这由相关的 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_13_BiasedLocking.java#l41">JOLSample_13_BiasedLocking</a> 示例演示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_13_BiasedLocking</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_13_BiasedLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           05 00 00 00 (00000101 00000000 00000000 00000000)  # No lock</span><br><span class="line">      4     4        (object header)           00 00 00 00</span><br><span class="line">      8     4        (object header)           c0 07 08 00</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_13_BiasedLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           05 b0 00 80 (00000101 11010000 00000000 01111011) # Biased lock</span><br><span class="line">      4     4        (object header)           b8 7f 00 00  # Biased lock</span><br><span class="line">      8     4        (object header)           c0 07 08 00</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_13_BiasedLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           05 b0 00 80 (00000101 11010000 00000000 01111011) # Biased lock</span><br><span class="line">      4     4        (object header)           b8 7f 00 00 # Biased lock</span><br><span class="line">      8     4        (object header)           c0 07 08 00</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>偏向锁指向线程的本地指针：<code>b0 00 80 b8 7f</code>。</p>
<p>没有偏向的情况下锁定时，会发生 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_14_FatLocking.java#l41">JOLSample_14_FatLocking</a> 如下锁升级情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_14_FatLocking</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        01 00 00 00 (00000001 00000000 00000000 00000000) # No lock</span><br><span class="line">      4     4        (object header)        00 00 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** Before the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        58 29 ad 04 (01011000 00101001 10101101 00000100) # Lightweight lock</span><br><span class="line">      4     4        (object header)        00 70 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        4a c1 80 e1 (01001010 11000001 10000000 11100001) # Heavyweight lock</span><br><span class="line">      4     4        (object header)        f6 7f 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION            VALUE</span><br><span class="line">      0     4        (object header)        4a c1 80 e1 (01001010 11000001 10000000 11100001) # Heavyweight lock</span><br><span class="line">      4     4        (object header)        f6 7f 00 00</span><br><span class="line">      8     4        (object header)        5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After System.gc()</span><br><span class="line">org.openjdk.jol.samples.JOLSample_14_FatLocking$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION             VALUE</span><br><span class="line">      0     4        (object header)         09 00 00 00 (00001001 00000000 00000000 00000000) # Lock recycled</span><br><span class="line">      4     4        (object header)         00 00 00 00</span><br><span class="line">      8     4        (object header)         5a ef 00 f8</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>各种情况下锁结构如下：</p>
<p><img src="../../../images/java/jvm/lock.png" alt="Mark Word Lock" /></p>
<p>在这里，我们看到了锁的通常升级过程：第一个对象未记录任何锁信息，然后被其他线程获取，并升级为轻量级锁，然后主线程争用它，锁发生膨胀，升级为重量级锁，然后在线程释放锁后，锁定信息仍保持为重量级锁。最后，在 GC 时的安全点后，对象恢复为无锁状态。</p>
<p><img src="../../../images/java/jvm/lock-upgrade.png" alt="Java 锁升级" /></p>
<h3 id="55-观察身份-hashcode-禁用偏向锁"><a class="markdownIt-Anchor" href="#55-观察身份-hashcode-禁用偏向锁"></a> 5.5 观察：身份 Hashcode 禁用偏向锁</h3>
<p>但是，如果我们需要在偏向锁定生效时存储身份哈希码，该怎么办？很简单：身份哈希码优先，并且对该对象/类的偏向锁定被禁用。可以从相关示例 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_26_IHC_BL_Conflict.java">JOLSample_26_IHC_BL_Conflict</a> 中看到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jdk8-64/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed oop with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using compressed klass with 3-bit <span class="built_in">shift</span>.</span></span><br><span class="line"></span><br><span class="line">**** Fresh object</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                 VALUE</span><br><span class="line">      0     4        (object header)             05 00 00 00 (00000101 00000000 00000000 00000000) # No lock</span><br><span class="line">      4     4        (object header)             00 00 00 00 (00000000 00000000 00000000 00000000)</span><br><span class="line">      8     4        (object header)             5a ef 00 f8 (01011010 11101111 00000000 11111000)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                VALUE</span><br><span class="line">      0     4        (object header)            05 e0 80 c7 (00000101 11100000 10000000 11000111) # Biased lock</span><br><span class="line">      4     4        (object header)            f7 7f 00 00 (11110111 01111111 00000000 00000000) # Biased lock</span><br><span class="line">      8     4        (object header)            5a ef 00 f8 (01011010 11101111 00000000 11111000)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                VALUE</span><br><span class="line">      0     4        (object header)            05 e0 80 c7 (00000101 11100000 10000000 11000111) # Biased lock</span><br><span class="line">      4     4        (object header)            f7 7f 00 00 (11110111 01111111 00000000 00000000) # Biased lock</span><br><span class="line">      8     4        (object header)            5a ef 00 f8 (01011010 11101111 00000000 11111000)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">hashCode: 4cc77c2e</span><br><span class="line"></span><br><span class="line">**** After the hashcode</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION               VALUE</span><br><span class="line">      0     4        (object header)           01 2e 7c c7 (00000001 00101110 01111100 11000111) # Hashcode</span><br><span class="line">      4     4        (object header)           4c 00 00 00 (01001100 00000000 00000000 00000000) # Hashcode</span><br><span class="line">      8     4        (object header)           5a ef 00 f8 (01011010 11101111 00000000 11111000) </span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** With the second lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION        		VALUE</span><br><span class="line">      0     4        (object header)    		80 59 9e 02 (10000000 01011001 10011110 00000010) # Lightweight lock</span><br><span class="line">      4     4        (object header)    		00 70 00 00 (00000000 01110000 00000000 00000000) # Lightweight lock</span><br><span class="line">      8     4        (object header)    		5a ef 00 f8 (01011010 11101111 00000000 11111000) </span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">**** After the second lock</span><br><span class="line">org.openjdk.jol.samples.JOLSample_26_IHC_BL_Conflict$A object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION              VALUE</span><br><span class="line">      0     4        (object header)          01 2e 7c c7 (00000001 00101110 01111100 11000111) # Hashcode</span><br><span class="line">      4     4        (object header)          4c 00 00 00 (01001100 00000000 00000000 00000000) # Hashcode</span><br><span class="line">      8     4        (object header)          5a ef 00 f8 (01011010 11101111 00000000 11111000) </span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>刚开始对象通过偏向锁定的宽限期后为无锁状态，可偏向（…101）。第一次进入代码同步块时，<strong>偏向锁通过 CAS 操作将线程 ID 置换到 mark word 中。在释放锁后，偏向锁仍然会保留在对象头中，以便于减少单个线程未竞争情况下时锁定和解锁的 CAS 操作。</strong></p>
<p>一旦我们调用了对象的 hashcode 方法，将触发 <code>identity hashcode</code> 的计算（我们的对象没有重写 <code>Object.hashcode</code>），<em>偏向锁被撤销为无锁</em>，线程 ID 置换为 hashcode。</p>
<p>第二次执行到方法对象同步时，由于存放了 hashcode，这时检查到为不可偏向的无锁标志，虚拟机会将当前的 <code>mark word</code> 备份到当前线程方法的栈桢的 <code>Lock Record</code> 中，并通过 <code>CAS</code> 操作将 <code>Lock Record</code> 指针更新到对象的 <code>mark word</code> 中，如果 CAS 操作成功，那么该线程就获取了该对象上的锁，并且对象的 mark word 锁标记变为 00，表示该对象处于轻量级锁状态。<strong>在代码退出同步块时，轻量级锁释放，再通过 CAS 操作把对象当前的 mark word 和线程中复制的替换回来。</strong></p>
<p><img src="../../../images/java/jvm/light-weight-lock-before-cas.png" alt="轻量级锁 CAS 操作之前堆栈与对象的状态" /></p>
<p><img src="../../../images/java/jvm/light-weight-after-cas.png" alt="轻量级锁 CAS 操作之后堆栈与对象的状态" /></p>
<h2 id="6-class-word"><a class="markdownIt-Anchor" href="#6-class-word"></a> 6. Class Word</h2>
<p>从机器的角度来看，每个对象只是一堆字节。在某些情况下，我们想知道在运行时处理的对象的<strong>类型</strong>是什么。需要的非详尽清单：</p>
<ul>
<li>运行时类型检查</li>
<li>确定对象的大小</li>
<li>找出虚拟/接口调用的目标。</li>
</ul>
<p>Class word 也可以被压缩。即使类指针不是 Java 堆引用，它们仍然可以享受类似的优化。</p>
<h3 id="61-运行时类型检查"><a class="markdownIt-Anchor" href="#61-运行时类型检查"></a> 6.1 运行时类型检查</h3>
<p>Java 是一门类型安全的语言，所以在很多地方都需要运行时类型检查。Class word 携带有关我们拥有的对象的实际类型的数据，这使编译器可以发出运行时类型检查。这些运行时检查的效率取决于元数据类型的形状。</p>
<p>如果元数据以简单的形式编码，则编译器甚至可以直接在代码流中内联那些检查。在 Hotspot 中，Class word 持有指向 <a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/oop.hpp#l57">VM <code>Klass</code> 实例的本机指针</a>(Klass Pointer)，该实例包含大量元信息，包括它<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/klass.hpp#l120">继承的超类的类型，实现的接口等</a>，它还带有 <em>Java 镜像</em> - <code>java.lang.Class</code> 的<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/klass.hpp#l138">关联实例</a>。这种间接方式允许将 <code>java.lang.Class</code> 实例视为常规对象，并在 GC 期间不更新每个 class word 的情况下移动它们：<code>java.lang.Class</code> 可以移动，而 <code>Klass</code> 始终保持在同一位置。</p>
<h3 id="62-确定对象大小"><a class="markdownIt-Anchor" href="#62-确定对象大小"></a> 6.2 确定对象大小</h3>
<p>确定对象大小采用相似的方法。与运行时类型检查无法静态地知道对象的类型相比，分配确实或多或少地精确地知道了分配对象的大小：它由使用的构造函数的类型，使用的数组初始化器等定义。因此，在这些情况下，不需要通过 class word 进行访问。</p>
<p>但是，本机代码中有一些情况（最著名的是垃圾收集器）想要使用以下代码遍历<a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/5-tlabs-and-heap-parsability/">可解析堆</a>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HeapWord* cur = heap_start;</span><br><span class="line"><span class="keyword">while</span> (cur &lt; heap_used) &#123;</span><br><span class="line">  object o = (object)cur;</span><br><span class="line">  <span class="built_in">do_object</span>(o);</span><br><span class="line">  cur = cur + o-&gt;<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此，本机代码需要提前知道当前（未确定类型）object 的大小。因此，对于本机代码，如何安排类元数据非常重要。在 Hotspot 中，我们可以遍历 class word 访问<a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk/jdk/file/19afeaa0fdbe/src/hotspot/share/oops/klass.hpp#l89">布局助手</a>，这将为我们提供有关对象大小的信息。</p>
<h3 id="63-找出虚方法接口调用的目标"><a class="markdownIt-Anchor" href="#63-找出虚方法接口调用的目标"></a> 6.3 找出虚方法/接口调用的目标</h3>
<p>当运行时需要在对象实例上调用虚拟/接口方法时，它需要确定目标方法在哪里。虽然大多数时间<a target="_blank" rel="noopener" href="https://shipilev.net/blog/2015/black-magic-method-dispatch/">可以优化</a>，但在某些情况下，<a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/16-megamorphic-virtual-calls/">我们需要</a>进行实际的调度。该调度的性能还取决于类元数据的距离，因此不能忽略这一点。</p>
<h2 id="7-对象头数组长度"><a class="markdownIt-Anchor" href="#7-对象头数组长度"></a> 7. 对象头：数组长度</h2>
<p>数组带有另一小部分元数据：数组长度。由于数组元素类型仅编码对象类型，因此我们需要将数组长度存储在其他位置。</p>
<p>可以通过相关的 <a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/code-tools/jol/file/tip/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_25_ArrayAlignment.java#l41">JOLSample_25_ArrayAlignment</a> 查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ jdk8-<span class="number">64</span>/bin/java -cp jol-samples.jar org.openjdk.jol.samples.JOLSample_25_ArrayAlignment</span><br><span class="line"># Running <span class="number">64</span>-bit HotSpot VM.</span><br><span class="line"># Using compressed oop with <span class="number">3</span>-bit shift.</span><br><span class="line"># Using compressed klass with <span class="number">3</span>-bit shift.</span><br><span class="line"></span><br><span class="line">[J object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              d8 0c <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>   <span class="keyword">long</span> [J.&lt;elements&gt;                N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br><span class="line">                      </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">0</span>   <span class="keyword">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">1</span>   <span class="keyword">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">     <span class="number">17</span>     <span class="number">7</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">7</span> bytes external = <span class="number">7</span> bytes total</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">2</span>   <span class="keyword">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">     <span class="number">18</span>     <span class="number">6</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">6</span> bytes external = <span class="number">6</span> bytes total</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">3</span>   <span class="keyword">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">     <span class="number">19</span>     <span class="number">5</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">5</span> bytes external = <span class="number">5</span> bytes total</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[B object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                  VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>        (object header)              <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>        (object header)              <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Mark word</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>        (object header)              <span class="number">68</span> <span class="number">07</span> <span class="number">00</span> <span class="number">00</span>  # Class word</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (object header)              08 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  # Array length</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">byte</span> [B.&lt;elements&gt;                N/A</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure>
<p>偏移 +12 处有一个插槽，用于承载阵列长度。当我们分配 0…8 个元素的 byte[] 数组时，该插槽不断变化。将 arraylength 与数组实例一起携带有助于计算对象遍历器的实际大小，并且还可以进行有效的范围检查，以使数组长度非常接近。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://shipilev.net/jvm/objects-inside-out/#_introduction"><em>原文链接</em></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Mark Word</tag>
        <tag>Class Word</tag>
        <tag>Klass</tag>
        <tag>GC 分代</tag>
      </tags>
  </entry>
  <entry>
    <title>JMS vs AMQP</title>
    <url>/middleware/JMS-vs-AMQP/</url>
    <content><![CDATA[<p>关于 <code>JMS</code> 和 <code>AMQP</code> 在消息和代理上的一些说明。</p>
<p>如今，AMQP 越来越受欢迎。因此，我认为这是一个很好的机会，以了解它如何与旧的 JMS 匹配。</p>
<hr />
<h1 id="jms"><a class="markdownIt-Anchor" href="#jms"></a> JMS</h1>
<p>包括 Java RMI 在内的远程过程调用（<code>RPC</code>）系统基本都是是同步的 – 调用者必须阻塞并等待，直到被调用的方法完成执行，因此，如果不使用多个线程，则无法开发松耦合的企业应用程序。换句话说，<code>RPC</code> 系统要求客户端和服务器同时可用。然而，在某些应用中，这种紧密耦合可能是不可能的或奢望的。面向消息的中间件 - <code>Message Oriented Middleware（MOM）</code>系统为此类问题提供了解决方案。它们基于异步交互模型，并提供可通过网络访问的消息队列的抽象。</p>
<a id="more"></a>
<p>由 Sun Microsystems 和其他几家公司在 Java Community Process 下以 <a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=914">JSR 914</a> 设计的 <code>Java Message Service（JMS）</code>是第一个获得业界广泛支持的企业消息 <strong><code>API</code></strong>。Java 消息服务（JMS）旨在简化开发异步发送和接收业务数据和事件的业务应用程序的过程。它定义了一个通用的企业消息传递 API，该 API 旨在为各种企业在消息产品上提供轻松高效地支持。 JMS 支持两种消息传递模型：<strong>点对点（队列）</strong> 和 <strong>发布-订阅（主题）</strong>。</p>
<p>JMS 定义了一组接口和语义，这些接口和语义允许 Java 应用程序与其他消息传递实现进行通信。JMS 实现被称为 JMS 提供程序 - provider。 JMS 通过最小化 Java 开发人员使用企业消息产品必须学习的概念集来简化学习过程，同时，它使消息传递应用程序的可移植性最大化。</p>
<p>下图描述了生产和消费消息的高层视图。</p>
<p><img src="../../images/message/jms.gif" alt="Producing and consuming messages" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JMS 是用于与面向消息的中间件通信的标准 Java API。</p>
<p>JMS 是 Java <code>J2EE</code> 的一部分，由 <a target="_blank" rel="noopener" href="https://jcp.org/aboutJava/communityprocess/final/jsr914/index.html"><code>JSR 914</code></a> 定义。它被认为是健壮和成熟的。</p>
<p>JMS 允许两个不同的 Java 应用程序进行通信，这些应用程序可能正在使用 JMS 客户端，即能够进行通信，也保证解耦。</p>
<p>如果您正在寻找 JMS 消息代理，则您的代码中可能需要 <code>ActiveMQ</code> 或 <code>HornetQ</code> 客户端。ActiveMQ 更受欢迎。</p>
<p>因此，JMS 允许 Java 组件仅用几行代码就可以可靠地发送和接收消息，实现低耦合。</p>
<p>可以用最少的代码，甚至根本不更改代码，就可以用一个 <code>JMS 代理</code>替换另一个。</p>
<h1 id="amqp"><a class="markdownIt-Anchor" href="#amqp"></a> AMQP</h1>
<p><code>AMQP</code>（代表“<code>高级消息队列协议</code> - <code>Advanced Message Queuing Protocol</code>”）是一种开放标准的应用程序层协议。它支持符合要求的客户端应用（application）和消息中间件代理（messaging middleware broker）之间进行通信。</p>
<p>AMQP 的工作过程如下图：消息（message）被发布者（publisher）发送给交换机（exchange），交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后 AMQP 代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<p><img src="../../images/message/amqp-message-routing.png" alt="enter image description here" /></p>
<p>发布者（publisher）发布消息时可以给消息指定各种消息属性（message meta-data）。有些属性有可能会被消息代理（brokers）使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。</p>
<p>从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP 模块包含了一个消息确认（message acknowledgements）的概念：当一个消息从队列中投递给消费者后（consumer），消费者会通知一下消息代理（broker），这个可以是自动的也可以由处理消息的应用的开发者执行。当“消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（acknowledgement）。</p>
<p>在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</p>
<p>队列，交换机和绑定统称为 AMQP实体（AMQP entities）。</p>
<h2 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h2>
<p>AMQP 提供统一消息服务的应用层高级消息队列规范，基于此规范的客户端与消息中间件可传递消息，并不受客户端不同产品和不同开发语言等条件的限制。</p>
<p>如果你想使用 AMQP，则可以选择 <code>RabbitMQ</code>，<code>Qpid</code> 或 <code>StormMQ</code>。</p>
<p>AMQP 提供了有关如何构造消息的描述。它没有提供有关如何发送消息的 API。</p>
<h1 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h1>
<p>好吧…… JMS 是一个 API，AMQP 是一个协议。</p>
<p>早在定义 JMS 时，JMS 实际上就没有在 JMS 客户端和 JMS 消息传递服务器之间强制使用协议。</p>
<p>实现 JMS API 的 JMS 客户端可以使用任何协议与 JMS 服务器进行通信。但是，JMS 客户端需要确保与 JMS API 兼容。而已。</p>
<p>另一方面，AMQP 只是消息客户端和消息中间件之间的协议。因此，JMS 客户端可以使用 AMQP 作为协议与消息传递服务器进行通信。</p>
<p>实际上，它已经存在，例如，ActiveMQ 正在提供对 AMQP 1.0 的支持。</p>
<p><strong>简而言之，AMQP 定义了消息的组成，JMS 定义了 Java 程序间消息通讯接口。</strong></p>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html">Getting Started with Java Message Service</a>  JMS 入门</li>
<li><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/jms-vs-amqp-eran-shaham/">JMS vs AMQP</a></li>
<li><a target="_blank" rel="noopener" href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">AMQP Model Explained</a> AMQP 模型解释</li>
</ol>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>AMQP</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 入门</title>
    <url>/middleware/Elasticsearch%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img src="../../images/middleware/elasticsearch/1280px-Elasticsearch_logo.svg.png" alt="Elasticsearch logo" /></p>
<p>ElasticSearch 是基于 Apache Lucene 的分布式搜索和分析引擎，为所有类型的数据提供近乎实时的搜索和分析。</p>
<h1 id="什么是-elasticsearch"><a class="markdownIt-Anchor" href="#什么是-elasticsearch"></a> 什么是 Elasticsearch？</h1>
<h2 id="数据输入文档和索引"><a class="markdownIt-Anchor" href="#数据输入文档和索引"></a> 数据输入：文档和索引</h2>
<p>Elasticsearch 是一个分布式文档存储。 Elasticsearch 不会将信息存储为列数据的行，而是存储已序列化为 JSON 文档的复杂数据结构。当集群中有多个 Elasticsearch 节点时，存储的文档会分布在整个集群中，并且可以从任何节点立即访问。</p>
<p>存储文档后，将在 1 秒钟内几乎实时地对其进行索引并可搜索。 Elasticsearch 使用称为<strong>倒排索引</strong>的数据结构，该结构支持非常快速的全文本搜索。倒排索引列出了出现在任何文档中的每个唯一单词，并标识了每个单词出现的所有文档。</p>
<p>索引可以认为是文档的优化集合，每个文档都是字段 (<code>field</code>) 的集合，这些字段是包含数据的键值对。默认情况下，Elasticsearch 对每个字段中的所有数据建立索引，并且每个索引字段都具有专用的优化数据结构。例如，文本字段存储在倒排索引中，数字字段和地理字段存储在 BKD 树中。使用按字段数据结构组合并返回搜索结果的能力使 Elasticsearch 如此之快。</p>
<p>Elasticsearch 还具有无模式的能力，这意味着无需显式指定如何处理文档中可能出现的每个不同字段即可对文档建立索引。启用动态映射后，Elasticsearch 自动检测并向索引添加新字段。这种默认行为使索引和浏览数据变得容易-只需开始建立索引文档，Elasticsearch 就会检测布尔值，浮点数和整数值，日期和字符串并将其映射到适当的 Elasticsearch 数据类型。</p>
<p>但是，最终，您比 Elasticsearch 更了解您的数据以及如何使用它们。您可以定义规则来控制动态映射，也可以显式定义映射以完全控制字段的存储和索引方式。</p>
<span id="more"></span>
<p>定义自己的映射使您能够：</p>
<ul>
<li>区分全文字符串字段和精确值字符串字段</li>
<li>执行特定于语言的文本分析</li>
<li>优化字段以进行部分匹配</li>
<li>使用自定义日期格式</li>
<li>使用无法自动检测到的数据类型，例如 <code>geo_point</code> 和 <code>geo_shape</code></li>
</ul>
<p>为不同的目的以不同的方式对同一字段建立索引通常很有用。例如，您可能希望将一个字符串字段索引为全文搜索的文本字段和索引关键字，以便对数据进行排序或汇总(定义映射时对字段使用 <code>fields</code> 定义额外的类型)。或者，您可能选择使用多个语言分析器来处理包含用户输入的字符串字段的内容。</p>
<h2 id="数据输出搜索和分析"><a class="markdownIt-Anchor" href="#数据输出搜索和分析"></a> 数据输出：搜索和分析</h2>
<p>尽管您可以将 Elasticsearch 用作文档存储并检索文档及其元数据，但真正的强大之处在于能够轻松访问基于 <code>Apache Lucene</code> 搜索引擎库构建的全套搜索功能。</p>
<p>Elasticsearch 提供了一个简单、一致的 REST API，用于管理您的集群以及索引和搜索数据。为了进行测试，您可以轻松地直接从命令行或通过 Kibana 中的开发者控制台提交请求。在您的应用程序中，您可以为您选择的语言使用 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">Elasticsearch客户端</a> ：Java，JavaScript，Go，.NET，PHP，Perl，Python 或 Ruby。</p>
<h3 id="搜索数据"><a class="markdownIt-Anchor" href="#搜索数据"></a> 搜索数据</h3>
<p>Elasticsearch REST API 支持<strong>结构化查询</strong>，<strong>全文查询</strong>和<strong>结合了两者的复杂查询</strong>。结构化查询类似于您可以在 <code>SQL</code> 中构造的查询类型。例如，您可以搜索索引中的 <code>gender</code> 和 <code>age</code> 字段，<code>employee</code> 然后按 <code>hire_date</code> 字段对匹配项进行排序。全文查询会找到所有与查询字符串匹配的文档，并按***相关性***对它们进行返回（它们与您的搜索词的匹配程度如何）。</p>
<p>除了搜索单个词项（<code>term</code>）外，您还可以执行短语搜索（<code>phrase searches</code>），相似性搜索（<code>similarity searches</code>）和前缀搜索（<code>prefix searches</code>），并获得自动完成建议。</p>
<p>是否要搜索地理空间或其他数字数据？Elasticsearch 在支持高性能地理和数字查询的优化数据结构中索引非文本数据。</p>
<p>您可以使用 Elasticsearch 全面的 JSON 样式查询语言（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Query DSL</a>）访问所有这些搜索功能。您还可以构造 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-overview.html">SQL样式的查询</a> 以在 Elasticsearch 内部本地搜索和聚合数据，并且 JDBC 和 ODBC 驱动程序使范围广泛的第三方应用程序可以通过 SQL 与 Elasticsearch 进行交互。</p>
<h1 id="分析数据"><a class="markdownIt-Anchor" href="#分析数据"></a> 分析数据</h1>
<p>文本分析是将非结构化文本（例如电子邮件的正文或产品说明）转换为针对搜索优化的结构化格式的过程。当索引或搜索文本（<code>text</code>）字段类型时，Elasticsearch 执行文本分析，然后将其添加到倒排索引中以便进行搜索。</p>
<p>Elasticsearch 对每个分析的文本字段都要经过许多步骤，该过程由 <a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"><em>分析器（analyzer）</em></a> 执行，经历以下步骤：</p>
<ul>
<li>
<p><em>字符过滤</em> — 使用字符过滤器（<code>Character filters</code>）转换或过滤字符，<strong>单词过滤器有零个或多个，按顺序处理。</strong></p>
</li>
<li>
<p><em>分词</em> — 使用分词器（<code>Tokenizer</code>）将文本分成一个或多个词元（<code>token</code>），<strong>将这些令牌存储到索引中</strong>。</p>
</li>
<li>
<p><em>词元过滤</em> — 词元过滤器（<code>Token filters</code>）接收词元流，并可以添加，删除或更改词元。例如，小写（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-lowercase-tokenfilter.html"><code>lowercase</code></a>）词元过滤器会将所有词元转换为小写，停顿词（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-stop-tokenfilter.html"><code>stop</code></a>）元过滤器会从词元流中删除常见的词（停顿词），同义词（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-synonym-tokenfilter.html"><code>synonym</code></a>）词元过滤器将同义词引入词元流，<strong>可以有零个或多个，按顺序处理</strong>。</p>
</li>
<li>
<p><em>词元索引</em> — 将这些词元存储到倒排索引中。</p>
</li>
</ul>
<p><img src="../../images/middleware/elasticsearch/elasticsearch-analyzer.png" alt="elasticsearch-analyzer" /></p>
]]></content>
      <categories>
        <category>Middleware</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA 快速适配多种数据库</title>
    <url>/persistence/JPA-%E5%BF%AB%E9%80%9F%E9%80%82%E9%85%8D%E5%A4%9A%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>部分项目可能需要同时适配多种不同的数据库，比如常见的 Mysql、Oracle、Mssql 这几种数据库。首先我们准备测试数据库环境。</p>
<h2 id="测试数据库准备"><a class="markdownIt-Anchor" href="#测试数据库准备"></a> 测试数据库准备</h2>
<p>为了快速测试，我们使用 Docker 快速搭建数据库环境，对应的 Docker Compose 文件内容如下：</p>
<a id="more"></a>
<ul>
<li>
<p><strong>Mysql</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:<span class="number">8.0</span>.<span class="number">20</span></span><br><span class="line">    volumes:</span><br><span class="line">        - ./mysql/data/:/var/lib/mysql/</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_USER=root</span><br><span class="line">      - MYSQL_ALLOW_EMPTY_PASSWORD=yes</span><br><span class="line">      - MYSQL_DATABASE=mysql</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">3306</span>:<span class="number">3306</span></span><br><span class="line">    command: mysqld --lower_case_table_names=<span class="number">1</span> --skip-ssl --character_set_server=utf8mb4 --explicit_defaults_for_timestamp</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Oracle</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services: </span><br><span class="line">  oracle-db:</span><br><span class="line">    image: oracleinanutshell/oracle-xe-<span class="number">11</span>g:latest</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - ./mysql/data/:/u01/app/oracle/</span><br><span class="line">    environment:</span><br><span class="line">      - ORACLE_PWD=oracle  <span class="comment"># DB_CONN: credentials (system/sys:oracle)</span></span><br><span class="line">      - ORACLE_ALLOW_REMOTE=true</span><br><span class="line">      - ORACLE_DISABLE_ASYNCH_IO=true</span><br><span class="line">      - ORACLE_ENABLE_XDB=true</span><br><span class="line">      - DBCA_TOTAL_MEMORY=<span class="number">1024</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">1521</span>:<span class="number">1521</span></span><br><span class="line">      - <span class="number">1522</span>:<span class="number">8080</span> <span class="comment"># for apex</span></span><br></pre></td></tr></table></figure>
<p>由于 Oracle 数据库一个用户对应一个 Schema，要创建一个数据库，我们就得先创建对应的用户，创建用户又分为以下几个步骤：</p>
<ul>
<li>
<p>使用 system 账号（DBA 角色）创建用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&quot;username&quot;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&quot;password&quot;</span> <span class="keyword">DEFAULT</span> <span class="keyword">TABLESPACE</span> <span class="string">&quot;USERS&quot;</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLESPACE</span> <span class="string">&quot;TEMP&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分配空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&quot;spc&quot;</span> <span class="keyword">QUOTA</span> <span class="keyword">UNLIMITED</span> <span class="keyword">ON</span> <span class="string">&quot;SYSTEM&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为用户授予基本的权限，比如创建序列、创建表、建立连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span>, <span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span>, <span class="keyword">CREATE</span> <span class="keyword">SESSION</span>, <span class="keyword">CREATE</span> <span class="keyword">SYNONYM</span>, <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>, <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="keyword">TO</span> <span class="string">&quot;username&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>Liqubibase</code>，会有下面的警告：</p>
<blockquote>
<p>Liquibase needs to access the DBA_RECYCLEBIN table so we can automatically handle the case where<br />
constraints are deleted and restored. Since Oracle doesn’t properly restore the original table names<br />
referenced in the constraint, we use the information from the DBA_RECYCLEBIN to automatically correct this<br />
issue.</p>
</blockquote>
<p>需要使用 <code>sys</code> 账号以 <code>SYSDBA</code> 角色登陆，如下面的 Oracle SQL Developer，然后执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> SYS.DBA_RECYCLEBIN <span class="keyword">TO</span> “username”;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="../../images/jpa/oracle-login-sysdba.png" alt="image-20210319212801827" /></p>
<blockquote>
<p>对于正式环境的 Oracle 使用，请从 Oracle <a target="_blank" rel="noopener" href="https://container-registry.oracle.com/pls/apex/f?p=113:4:878081924406:::4:P4_REPOSITORY,AI_REPOSITORY,AI_REPOSITORY_NAME,P4_REPOSITORY_NAME,P4_EULA_ID,P4_BUSINESS_AREA_ID:9,9,Oracle%20Database%20Enterprise%20Edition,Oracle%20Database%20Enterprise%20Edition,31,0&amp;cs=301x0l2wtU24LAdobHQkwjesse7qnXICCKfQxvSwcCdgJi-R14Qvs-B9OtkSzPWfnOLTDLu3bfEsfLjsLmBYqNw">官方镜像注册中心</a>获取，强烈建议使用 19c 长期支持版本（直到 2027 年）。</p>
<p>可以在以下位置找到 Oracle 数据库 19c（EE，SE2，单实例和 RAC）Docker 镜像：<a target="_blank" rel="noopener" href="https://container-registry.oracle.com">https://container-registry.oracle.com</a></p>
<p>可以在以下位置找到 Oracle 数据库 19c Docker 构建文件：<a target="_blank" rel="noopener" href="https://github.com/oracle/docker-images/tree/master/OracleDatabase">https://github.com/oracle/docker-images/tree/master/OracleDatabase</a></p>
</blockquote>
</li>
<li>
<p><strong>Mssql</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  mssql:</span><br><span class="line">    image: mcr.microsoft.com/mssql/server:<span class="number">2017</span>-latest-ubuntu</span><br><span class="line">    <span class="comment"># volumes are not supported on macOS</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ./mssql/data/:/var/opt/mssql/data/</span><br><span class="line">    environment:</span><br><span class="line">      - ACCEPT_EULA=Y</span><br><span class="line">      - MSSQL_PID=Express</span><br><span class="line">      - SA_PASSWORD=yourStrong(!)Password</span><br><span class="line">      - MSSQL_DATABASE=mssql</span><br><span class="line">      - MSSQL_SLEEP=<span class="number">60</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">1433</span>:<span class="number">1433</span></span><br><span class="line">    command: /bin/bash -c <span class="string">&#x27;/opt/mssql/bin/sqlservr &amp; echo &quot;wait $$MSSQL_SLEEP sec for DB to start &quot;; sleep $$MSSQL_SLEEP; /opt/mssql-tools/bin/sqlcmd -U sa -P $$SA_PASSWORD -d tempdb -q &quot;EXIT(CREATE DATABASE $$MSSQL_DATABASE)&quot;; wait;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="依赖引入"><a class="markdownIt-Anchor" href="#依赖引入"></a> 依赖引入</h2>
<p>这里我们以 Gradle 为例，对于不同的 profile 选择不同的依赖，由于项目使用 jhipster BOM，这里没有指明版本。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">project</span>.hasProperty(<span class="string">&quot;oracle&quot;</span>)) &#123;</span><br><span class="line">    implementation <span class="string">&quot;com.oracle.database.jdbc:ojdbc8&quot;</span></span><br><span class="line">    liquibaseRuntime <span class="string">&quot;com.oracle.database.jdbc:ojdbc8&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">project</span>.hasProperty(<span class="string">&quot;mssql&quot;</span>)) &#123;</span><br><span class="line">    implementation <span class="string">&quot;com.microsoft.sqlserver:mssql-jdbc&quot;</span></span><br><span class="line">    liquibaseRuntime  <span class="string">&quot;com.microsoft.sqlserver:mssql-jdbc&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    implementation <span class="string">&quot;mysql:mysql-connector-java&quot;</span></span><br><span class="line">    liquibaseRuntime <span class="string">&quot;mysql:mysql-connector-java&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开发环境配置文件"><a class="markdownIt-Anchor" href="#开发环境配置文件"></a> 开发环境配置文件</h2>
<p>数据库需要的库及用户名和密码都有了，对于 SpringBoot 项目可以建立不同环境的 profile 文件，这里仅说明核心的配置信息：</p>
<ul>
<li>
<p><strong>Mysql</strong></p>
<p><em><code>application-mysql.yml</code></em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">     <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">     <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/spc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">     <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">     <span class="attr">properties:</span></span><br><span class="line">       <span class="attr">hibernate.id.new_generator_mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Oralce</strong></p>
<p><em><code>application-oracle.yml</code></em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:oracle:thin:@192.168.1.194:1521:xe</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">       <span class="attr">hibernate.id.new_generator_mappings:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Mssql</strong></p>
<p><em><code>application-mssql.yml</code></em></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:sqlserver://192.168.1.194:1433;database=spc</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">SA</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourStrong(!)Password</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">       <span class="attr">hibernate.id.new_generator_mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一个核心的配置项 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators-auto"><code>hibernate.id.new_generator_mappings</code></a>，该属性在 5.0 之后的 hibernate 中默认为 <code>true</code>，为 <code>true</code> 时如果主键生成策略为 <code>AUTO</code>，则将处理为<strong>基于序列</strong>的 <code>SequenceStyleGenerator</code>，如果数据库支持序列，将使用序列，否则使用基于单表（<code>TABLE</code>）维护的主键生成器。这里我们为 <strong>Oracle</strong> 使用设置为 <code>true</code>。</p>
<p>为 <code>false</code> 时将回退到数据库方言中原生的主键策略，具体由 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/dialect/Dialect.html#getNativeIdentifierGeneratorStrategy--">Dialect#getNativeIdentifierGeneratorStrategy</a> 返回值决定（<code>identity</code> 或 <code>sequence</code>）。由于 <code>mysql</code>、<code>mssql</code> 本身支持自增主键，这里我们使用数据库原生的自增主键策略。</p>
<h2 id="实体配置"><a class="markdownIt-Anchor" href="#实体配置"></a> 实体配置</h2>
<p>实体没有太多配置，只需要设置主键的策略为 <code>AUTO</code> 就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>
<p><em>下方配置可选</em></p>
<hr />
<p>由于 Oracle 使用序列作为主键生成策略，hibernate 将会在我们新增实体时获取下一个序列号，序列的名称默认为：<code>hibernate_sequence</code>。</p>
<p>我们也可以为每个表指定一个序列，或者为每个表其指定表名 + 可选后缀的序列名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.AUTO, generator = &quot;sequence-generator&quot;)</span></span><br><span class="line"><span class="meta">@GenericGenerator(</span></span><br><span class="line"><span class="meta">	name = &quot;sequence-generator&quot;,</span></span><br><span class="line"><span class="meta">  strategy = &quot;org.hibernate.id.enhanced.SequenceStyleGenerator&quot;,</span></span><br><span class="line"><span class="meta">  parameters = &#123;</span></span><br><span class="line"><span class="meta">    @Parameter(name = SEQUENCE_PARAM, value = &quot;user_sequence&quot;),  // 使用固定的序列名</span></span><br><span class="line"><span class="meta">    @Parameter(name = CONFIG_PREFER_SEQUENCE_PER_ENTITY, value = &quot;true&quot;), // 每个表一个序列，基于表名+可选后缀的形式</span></span><br><span class="line"><span class="meta">    @Parameter(name = CONFIG_SEQUENCE_PER_ENTITY_SUFFIX, value = &quot;sequence&quot;), // 可选后缀</span></span><br><span class="line"><span class="meta">    @Parameter(name = INITIAL_PARAM, value = &quot;4&quot;),</span></span><br><span class="line"><span class="meta">    @Parameter(name = INCREMENT_PARAM, value = &quot;1&quot;)</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br></pre></td></tr></table></figure>
<h2 id="liquibase-或脚本配置"><a class="markdownIt-Anchor" href="#liquibase-或脚本配置"></a> Liquibase 或脚本配置</h2>
<h3 id="初始化-oracle-序列"><a class="markdownIt-Anchor" href="#初始化-oracle-序列"></a> 初始化 Oracle 序列</h3>
<p>由于我们没有使用 hibernate 的自动建表，所以需要手动创建相应的序列，以默认的 <code>hibernate_sequence</code> 为例，对于 Liquibase 需要，增加如下 ChangeSet：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">&quot;00000000000000&quot;</span> <span class="attr">author</span>=<span class="string">&quot;Zeral&quot;</span> <span class="attr">dbms</span>=<span class="string">&quot;oracle&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">createSequence</span> <span class="attr">sequenceName</span>=<span class="string">&quot;hibernate_sequence&quot;</span> <span class="attr">minValue</span>=<span class="string">&quot;1&quot;</span> <span class="attr">startValue</span>=<span class="string">&quot;20&quot;</span> <span class="attr">incrementBy</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbms 指这条变更集针对的数据库为 oracle。</p>
<blockquote>
<p>如果加载了带有主键的数据，请注意序列的起始值为数据中主键最大的下一个数字。</p>
</blockquote>
<h3 id="mssql-加载带有主键的数据"><a class="markdownIt-Anchor" href="#mssql-加载带有主键的数据"></a> Mssql 加载带有主键的数据</h3>
<p>由于 Mssql 表默认不允许带有主键的数据进行新增，要加载带有主键的数据，Liquibase 可以做如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">&quot;20191118183100&quot;</span> <span class="attr">author</span>=<span class="string">&quot;Zeral&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">dbms</span>=<span class="string">&quot;mssql&quot;</span>&gt;</span></span><br><span class="line">        SET IDENTITY_INSERT base_factor ON;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loadData</span> <span class="attr">encoding</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">file</span>=<span class="string">&quot;config/liquibase/base_factor.csv&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">tableName</span>=<span class="string">&quot;base_factor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;is_auto_report_necessary&quot;</span> <span class="attr">type</span>=<span class="string">&quot;boolean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loadData</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">dbms</span>=<span class="string">&quot;mssql&quot;</span>&gt;</span></span><br><span class="line">        SET IDENTITY_INSERT base_factor OFF;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>及使用 <code>SET IDENTITY_INSERT 表名 ON/OFF;</code> 包裹加载数据脚本，并设置 <code>dbms</code> 仅对 <code>mssql</code> 作用。</p>
<h3 id="数据库字段类型选择"><a class="markdownIt-Anchor" href="#数据库字段类型选择"></a> 数据库字段类型选择</h3>
<p>在用 Liquibase 创建表字段时，选择合适的类型，不要使用特定于数据库的数据类型。</p>
<p><strong>Data types mapping in Liquibase 3.6.x</strong></p>
<table>
<thead>
<tr>
<th><strong>Liquibase data type</strong></th>
<th><strong>SQL Server data type</strong></th>
<th><strong>Oracle data type</strong></th>
<th><strong>MySQL</strong></th>
<th><strong>PostgreSQL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>bigint</td>
<td>bigint</td>
<td>number(38,0)</td>
<td>bigint</td>
<td>bigint/bigserial</td>
</tr>
<tr>
<td>blob</td>
<td>varbinary(max)</td>
<td>blob</td>
<td>blob</td>
<td>oid</td>
</tr>
<tr>
<td>boolean</td>
<td>bit</td>
<td>number(1)</td>
<td>bit</td>
<td>bit</td>
</tr>
<tr>
<td>char</td>
<td>char</td>
<td>char</td>
<td>char</td>
<td>character</td>
</tr>
<tr>
<td>clob</td>
<td>nvarchar(max)</td>
<td>clob</td>
<td>longtext</td>
<td>text</td>
</tr>
<tr>
<td>currency</td>
<td>money</td>
<td>number(15,2)</td>
<td>decimal</td>
<td>decimal</td>
</tr>
<tr>
<td>datetime</td>
<td>datetime</td>
<td>timestamp</td>
<td>timestamp</td>
<td>timestamp</td>
</tr>
<tr>
<td>date</td>
<td>date</td>
<td>date</td>
<td>date</td>
<td>date</td>
</tr>
<tr>
<td>decimal</td>
<td>decimal</td>
<td>decimal</td>
<td>decimal</td>
<td>decimal</td>
</tr>
<tr>
<td>double</td>
<td>float</td>
<td>float(24)</td>
<td>double</td>
<td>double precision</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
<td>integer</td>
<td>int</td>
<td>integer/serial</td>
</tr>
<tr>
<td>mediumint</td>
<td>int</td>
<td>mediumint</td>
<td>mediumint</td>
<td>mediumint</td>
</tr>
<tr>
<td>nchar</td>
<td>nchar</td>
<td>nchar</td>
<td>nchar</td>
<td>nchar</td>
</tr>
<tr>
<td>nvarchar</td>
<td>nvarchar</td>
<td>nvarchar2</td>
<td>nvarchar</td>
<td>varchar</td>
</tr>
<tr>
<td>number</td>
<td>numeric</td>
<td>number</td>
<td>numeric</td>
<td>numeric</td>
</tr>
<tr>
<td>smallint</td>
<td>smallint</td>
<td>number(5)</td>
<td>smallint</td>
<td>smallint/smallserial</td>
</tr>
<tr>
<td>time</td>
<td>time</td>
<td>date</td>
<td>time</td>
<td>time</td>
</tr>
<tr>
<td>timestamp</td>
<td>datetime</td>
<td>timestamp</td>
<td>timestamp</td>
<td>timestamp</td>
</tr>
<tr>
<td>tinyint</td>
<td>tinyint</td>
<td>number(3)</td>
<td>tinyint</td>
<td>smallint</td>
</tr>
<tr>
<td>uuid</td>
<td>uniqueidentifier</td>
<td>raw(16)</td>
<td>char(36)</td>
<td>uuid</td>
</tr>
<tr>
<td>varchar</td>
<td>varchar</td>
<td>varchar2</td>
<td>varchar</td>
<td>varchar/character (varying)</td>
</tr>
</tbody>
</table>
<h2 id="其它注意"><a class="markdownIt-Anchor" href="#其它注意"></a> 其它注意</h2>
<h3 id="原生语句"><a class="markdownIt-Anchor" href="#原生语句"></a> 原生语句</h3>
<ul>
<li>
<p>尽量避免使用原生语句，如果必须使用原生语句，请保证语法相对简单，能适配不同数据库。</p>
</li>
<li>
<p>很多时候为了安全性等，登录用户和当前 schema 并不是一定保持一致，所以执行语句时必须显式指明当前操作的 schema 下的表，可以通过在要执行语句中所有表名前加上 <code>&#123;h-domain&#125;</code> 即可，详情查看<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#sql-global-catalog-schema">官方使用指南相关链接</a>，例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &#123;h-<span class="keyword">domain</span>&#125;person <span class="keyword">where</span> age(hired_on) &lt; <span class="string">&#x27;30 days&#x27;</span>；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="oracle-长度限制"><a class="markdownIt-Anchor" href="#oracle-长度限制"></a> Oracle 长度限制</h3>
<p>对于 Oracle 版本 19c, 18c and 12cR2：</p>
<ul>
<li>实体名称不能超过 124 个字符，这是由于 Oracle 对对象名称的限制为 128 个字符，并且我们保留 4 个字符来为生成的表生成主键序列。</li>
<li>实体<u>字段</u>名称不能超过 128 个字符。</li>
<li>建立关系时，外键名称不能超过 128 个字符，因此，如果它们太长，将被截断。</li>
<li>在进行多对多关系时，联接表名称将遵循 JPA规范（格式为 “firstTable_secondTable”）：如果长度超过 128 个字符，则将其截断。</li>
<li>数据库索引名称不能超过 128 个字符。</li>
</ul>
<p>对于 Oracle 版本 11g，12cR1：</p>
<ul>
<li>实体名称不能超过 26 个字符，这是由于 Oracle 对对象名称的限制为 30 个字符，并且我们保留 4 个字符来为生成的表生成主键序列。</li>
<li>实体字段名称不能超过 30 个字符。</li>
<li>建立关系时，外键名称不能超过 30 个字符，因此，如果它们太长，则会被截断。</li>
<li>在进行多对多关系时，联接表名称将遵循 JPA 规范（格式为 “firstTable_secondTable”）：如果长度超过 30 个字符，则将其截断。</li>
</ul>
<h3 id="关键字使用注意"><a class="markdownIt-Anchor" href="#关键字使用注意"></a> 关键字使用注意</h3>
<p>在为实体或字段起名时，避免使用到相关数据库的关键字和保留关键字，可以通过加限制前缀来避免。下方罗列可能和你使用版本有差异。</p>
<p>Mysql 相关关键字链接：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">https://dev.mysql.com/doc/refman/8.0/en/keywords.html</a></p>
<p>Oracle 相关关键字链接：<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/B19306_01/em.102/b40103/app_oracle_reserved_words.htm">https://docs.oracle.com/cd/B19306_01/em.102/b40103/app_oracle_reserved_words.htm</a></p>
<p>Mssql 相关关键字链接：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sql/odbc/reference/appendixes/reserved-keywords?view=sql-server-ver15">https://docs.microsoft.com/en-us/sql/odbc/reference/appendixes/reserved-keywords?view=sql-server-ver15</a></p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>Hibernate</tag>
        <tag>Oracle</tag>
        <tag>Mssql</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Starter 简介</title>
    <url>/spring/Spring-Boot-Starter-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p>Spring Boot Starters 是一系列为我们提供方便的依赖项描述符，通过在应用中加入这些依赖项描述符，我们就可以很方便的集齐所有需要的依赖和相关技术，不用再为解决依赖问题而浪费时间。比如你想使用 Spring 和 JPA 访问数据，在你的依赖管理文件中加入 <code>spring-boot-starter-data-jpa</code> 就好了，<code>starter</code> 就如它的名字一样 —— 快速启动。</p>
<p>官方的依赖一般遵循 <code>spring-boot-starter-*</code> 模式，<code>*</code> 为一种特定的技术或程序。详细的清单列表见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter">链接</a>。</p>
<span id="more"></span>
<h1 id="开发自己的-starter"><a class="markdownIt-Anchor" href="#开发自己的-starter"></a> 开发自己的 Starter</h1>
<p>一个典型的 Spring Boot Starter 包含用于自动配置和自定义特定技术的基础架构的代码，为了使其易于扩展，可以将专用命名空间中的许多配置密钥公开给环境。最后，提供了一个 “starter” 依赖项，以帮助用户尽可能轻松地入门。</p>
<p>这里我们就以 “acme” 这个自定义启动器为例：</p>
<p>具体而言，自定义启动器可以包含以下内容：</p>
<ul>
<li>包含 “acme” 的自动配置代码的 <code>autoconfigure</code> 模块。</li>
<li><code>starter</code> 模块，它提供对 <code>autoconfigure</code> 模块的依赖以及 “acme” 和通常有用的任何其他依赖。简而言之，starter 应提供开始使用该库所需的一切。</li>
</ul>
<p>完全没有必要将这两个模块分开。如果 “acme” 具有多种风格，选项或可选功能，则最好将自动配置分开，因为您可以清楚地表示某些功能是可选的。此外，您还可以制作一个启动器，以提供有关那些可选依赖项的意见。同时，其他人只能依靠自动配置模块并以不同的意见来制作自己的启动器。</p>
<p>完整的项目见这两个 Demo： <a target="_blank" rel="noopener" href="https://github.com/snicoll/spring-boot-master-auto-configuration">Demo1</a>、<a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/spring-boot-modules/spring-boot-custom-starter">Demo2</a>。</p>
<h2 id="命名"><a class="markdownIt-Anchor" href="#命名"></a> 命名</h2>
<p>我们应该确保为启动器提供适当的名称空间。不要使用以 spring-boot 起始的 Maven groupId 命名，因为这是官方标准命名，将来，可能会为您自动配置的内容提供官方支持。</p>
<p>经验而言，你可以使用自己的模块加 spring-boot-starter 来命名。例如，假设您要为 “acme” 创建启动程序，并命名自动配置模块 <code>acme-spring-boot-autoconfigure</code> 和启动器 <code>acme-spring-boot-starter</code>。如果您只有一个将两者结合的模块，请将其命名为 <code>acme-spring-boot-starter</code>。</p>
<h2 id="配置属性"><a class="markdownIt-Anchor" href="#配置属性"></a> 配置属性</h2>
<p>如果你的 starter 提供了配置，请为其使用唯一的名称空间。特别是，不要将配置键包含在 Spring Boot 使用的名称空间中（例如 <code>server</code>，<code>management</code>，<code>spring</code> 等）。</p>
<p>确保为键字段提供 javadoc 文档说明，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether to check the location of acme resources.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> checkLocation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Timeout for establishing a connection to the acme server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Duration loginTimeout = Duration.ofSeconds(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters &amp; setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动配置autoconnfigure模块"><a class="markdownIt-Anchor" href="#自动配置autoconnfigure模块"></a> 自动配置（autoconnfigure）模块</h2>
<p>自动配置模块包含开始使用该库所需的所有内容。它还可能包含配置属性键定义（例如 <code>@ConfigurationProperties</code>）和可用于进一步自定义组件初始化方式的任何回调接口。</p>
<p>一般会在启动器的依赖文件中包含自动配置模块及其相关使用的特定的库。</p>
<h3 id="自动配置-bean-如何工作"><a class="markdownIt-Anchor" href="#自动配置-bean-如何工作"></a> 自动配置 bean 如何工作</h3>
<p>在后台，自动配置是通过标准 <code>@Configuration</code> 类实现的。其他 <code>@Conditional</code> 注解用于约束何时应应用自动配置。通常，自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解。这样可以确保仅当找到相关的类并且没有声明自己的 <code>@Configuration</code> 时，才应用自动配置。</p>
<p>您可以浏览 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.4.4/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a> 的源代码以查看 Spring 提供的 <code>@Configuration</code> 类（请参阅 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.4.4/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a> 文件）。</p>
<h4 id="定位自动配置候选人"><a class="markdownIt-Anchor" href="#定位自动配置候选人"></a> 定位自动配置候选人</h4>
<p>这是一种 <code>SPI</code>（Service Provider Interface-服务提供接口）机制。spring.factories 和原生 Java SPI 的 service 服务文件提供机制类似。</p>
<p>Spring Boot 检查发布的 jar 中是否存在 <code>META-INF/spring.factories</code> 文件。该文件应在 <code>EnableAutoConfiguration</code> 键下列出您的自动配置类，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动配置只能以这种方式加载。确保在特定的程序包空间中定义它们，并且决不要将它们作为组件扫描的目标。此外，自动配置类不应启用组件扫描以查找其他组件。应使用特定的 <code>@Import</code>s 代替。</p>
</blockquote>
<p>如果需要按特定顺序应用配置，则可以使用 <code>@AutoConfigureAfter</code> 或 <code>@AutoConfigureBefore</code> 注解。如果要排序某些彼此之间不具有直接了解的自动配置，则也可以使用 <code>@AutoConfigureOrder</code>。该注解与常规 <code>@Order</code> 注解具有相同的语义，但为自动配置类提供了专用的顺序。</p>
<p>与标准 <code>@Configuration</code> 类一样，自动配置类的应用顺序仅会影响其 bean 的***定义***顺序。随后创建这些 bean 的顺序不受影响，而是由每个  bean 的依赖关系以及任何 <code>@DependsOn</code> 关系确定。</p>
<h4 id="condition-注解"><a class="markdownIt-Anchor" href="#condition-注解"></a> Condition 注解</h4>
<p>一般在自动配置类中会包含一个或多个 <code>@Conditional</code> 注解。<code>@ConditionalOnMissingBean</code> 注解最为常见，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
<p><img src="../../images/spring/spring-boot/ConfigurationClassRegistry.svg" alt="ConfigurationClassRegistry" /></p>
<p>从上图的时序图我们可以看到 <code>@Conditional</code> 注解是在 <code>ConditionEvaluator</code> 的 <code>shouldSkip</code> 中调用，只有满足条件的类才会被加载并注入，其它的 Condition 注解都是基于该注解的。</p>
<p>Spring Boot 包含许多 <code>@Conditional</code> 注解，你可以通过在自己的代码的 <code>@Configuration</code> 类或单个 <code>@Bean</code> 方法中使用这些注解。这些注解包括：</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-class-conditions">Class Conditions</a></p>
<p>通过 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解，可以根据是否存在特定类来包含 <code>@Configuration</code> 类。由于注解元数据是通过使用 <a target="_blank" rel="noopener" href="https://asm.ow2.io/">ASM</a> 进行解析的，因此即使该类可能实际上没有出现在正在运行的应用程序类路径上，您也可以使用 value 属性来引用真实的类。如果您更喜欢通过使用 String 值来指定类名称，则也可以使用 name 属性，这里需使用完全限定名称。</p>
<blockquote>
<p>具体是 <code>MetadataReader</code> 的实现类 <code>SimpleMetadataReader</code> 使用 ASM 的 <code>ClassReader</code> 调用 <code>AnnotationMetadataReadingVisitor</code> 来获取注解元数据的。</p>
</blockquote>
<p>这种机制不适用于 @Bean 方法，后者通常将返回类型作为条件的目标：在方法的条件适用之前，JVM 将加载该类和可能处理的方法引用，如果该类不存在，则该引用将失败。</p>
<p>要处理这种情况，可以使用单独的 @Configuration 类隔离条件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// Some conditions</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Auto-configured beans</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(EmbeddedAcmeService.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EmbeddedAcmeService <span class="title">embeddedAcmeService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-bean-conditions">Bean Conditions</a></p>
<p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据是否存在特定 bean 来包含 bean。你可以使用 <code>value</code> 属性按类型指定 bean 或使用名称按名称指定 bean。<code>search</code> 属性使你可以限制在搜索 bean 时应考虑的 ApplicationContext 层次结构。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-property-conditions">Property Conditions</a></p>
<p><code>@ConditionalOnProperty</code> 注解允许基于 Spring Environment 属性包含配置。使用 <code>prefix</code> 和 <code>name</code> 属性指定应检查的属性。默认情况下，匹配存在且不等于 false 的任何属性。您也可以使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性来创建更高级的检查。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-resource-conditions">Resource Conditions</a></p>
<p><code>@ConditionalOnResource</code> 注解仅在存在特定资源时才包括配置。可以使用通常的 Spring 约定来指定资源，如以下示例所示：<code>file:/home/user/test.dat</code>。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-web-application-conditions">Web Application Conditions</a></p>
<p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为 “Web 应用程序” 来包含配置。</p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spel-conditions">SpEL Expression Conditions</a></p>
<p><code>@ConditionalOnExpression</code> 注解允许基于 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.3.5/reference/html/core.html#expressions">SpEL 表达式</a>的结果包括配置。</p>
</li>
</ul>
<h2 id="starter-模块"><a class="markdownIt-Anchor" href="#starter-模块"></a> Starter 模块</h2>
<p>Starter 其实是一个空 jar 包。其唯一目的是<strong>提供必要的依赖关系</strong>以使用库，我们需要的只是仓库中管理依赖的 pom 文件或 build.gradle 文件。</p>
<p>你唯一需要做的就是创建依赖管理文件，并包含你的自动配置模块及改 Starter 特定的依赖。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot Starter</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL utf8 和 utf8mb4 的区别</title>
    <url>/persistence/db/MySQL-utf8-vs-utf8mb4/</url>
    <content><![CDATA[<h1 id="字符集-校对规则和-unicode"><a class="markdownIt-Anchor" href="#字符集-校对规则和-unicode"></a> 字符集、校对规则和 Unicode</h1>
<p><strong>字符集</strong> (<code>Character Sets</code>) 是指一种从二进制编码到某类字符符号的映射，可以参考如何使用一个字节来表示英文字母。</p>
<p><strong>“校对”</strong> (<code>Collations</code>) 是指一组用于某个字符集的排序规则。</p>
<p>MySQL 服务器有默认的字符集和校对规则，每个数据库也有自己的默认值，每个表也有自己的默认值。这是一个逐层继承的默认设置，最终最靠底层的默认设置将影响你创建的对象。这些默认值，至上而下地告诉 MySQL 应该使用什么字符集来存储某个列。</p>
<p>MySQL 8.0 默认服务端字符集和校对规则分别为 <code>utf8mb4</code> 和 <code>utf8mb4_0900_ai_ci</code>；</p>
<p>MySQL 5.6/5.7 默认服务端字符集和校对规则分别为 <code>latin1</code> 和 <code>latin1_swedish_ci</code>。</p>
<a id="more"></a>
<p>使用命令 <code>SHOW CHARACTERSET</code> 和 <code>SHOW COLLATION</code> 来查看 MySQL 支持的字符集和校对规则。</p>
<p>可通过查询环境变量查看当前版本信息：<code>SHOW VARIABLES Like '%character_set%';</code></p>
<p>更多介绍查看<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/charset.html">官方文档</a>。</p>
<h2 id="unicode-支持"><a class="markdownIt-Anchor" href="#unicode-支持"></a> Unicode 支持</h2>
<p>Unicode 标准包括来自基本多文种平面 (BMP) 的字符和位于 BMP 之外的补充字符。本节介绍 MySQL 中对 Unicode 的支持。有关 Unicode 标准本身的信息，请访问 <a target="_blank" rel="noopener" href="http://www.unicode.org/">Unicode 联盟网站</a>。</p>
<p>BMP 字符具有以下特征：</p>
<ul>
<li>它们的码点值 (code point values) 在 0 到 65535 之间 (U+0000 和 U+FFFF)。</li>
<li>它们可以使用 8 位，16 位或 24 位（1 到 3 个字节）以可变长度编码进行编码。</li>
<li>它们可以使用 16 位（2 字节）以固定长度编码进行编码。</li>
<li>它们足以应付主要语言中的几乎所有字符。</li>
</ul>
<p>补充字符位于 BMP 之外：</p>
<ul>
<li>它们的码点值在 U+10000 和 U+10FFFF 之间，主要是一些 emoji 表情。</li>
<li>Unicode 对补充字符的支持要求字符集的范围超出了 BMP 字符，因此比 BMP 字符占用更多的空间（每个字符最多 4 个字节）。</li>
</ul>
<p>根据 RFC 3629 实现了用于对 Unicode 数据进行编码的 UTF-8（具有 8 位单位的 Unicode 转换格式）方法，该方法描述了从一到四个字节的编码序列。 UTF-8 的思想是使用不同长度的字节序列对各种 Unicode 字符进行编码：</p>
<ul>
<li>基本的拉丁字母，数字和标点符号使用一个字节。</li>
<li>大多数欧洲和中东脚本字母均以 2 字节的顺序排列：扩展的拉丁字母（带有波浪号，长音符号，重音和其他重音符号），西里尔字母，希腊语，亚美尼亚语，希伯来语，阿拉伯语，叙利亚语等。</li>
<li>韩文，中文和日文表意文字使用 3 字节或 4 字节序列。</li>
</ul>
<p>MySQL 支持以下 Unicode 字符集：</p>
<ul>
<li>utf8mb4: Unicode 字符集的 UTF-8 编码，每个字符使用一到四个字节。</li>
<li>utf8mb3: Unicode 字符集的 UTF-8 编码，每个字符使用一到三个字节。</li>
<li>utf8: utf8mb3 的别名。</li>
<li>…</li>
</ul>
<blockquote>
<p>在 8.0 之后 utf8mb3 字符集已被弃用，可能在将来的 MySQL 版本中将被删除。请改用 utf8mb4。尽管 utf8 当前是 utf8mb3 的别名，但在某些时候 utf8 有望成为对 utf8mb4 的引用。为避免对 utf8 的含义含糊不清，请考虑为字符集引用而不是 utf8 显式指定 utf8mb4。</p>
</blockquote>
<p><strong>Table Unicode 字符集的一般特征</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">字符集</th>
<th style="text-align:left">支持的字符</th>
<th style="text-align:left">单个字符需要的存储空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>utf8mb3</code>, <code>utf8</code></td>
<td style="text-align:left">BMP only</td>
<td style="text-align:left">1, 2, or 3 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>ucs2</code></td>
<td style="text-align:left">BMP only</td>
<td style="text-align:left">2 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf8mb4</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">1, 2, 3, or 4 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf16</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">2 or 4 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf16le</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">2 or 4 bytes</td>
</tr>
<tr>
<td style="text-align:left"><code>utf32</code></td>
<td style="text-align:left">BMP and supplementary</td>
<td style="text-align:left">4 bytes</td>
</tr>
</tbody>
</table>
<h2 id="校对规则命名约定"><a class="markdownIt-Anchor" href="#校对规则命名约定"></a> 校对规则命名约定</h2>
<p>MySQL 校对规则名称遵循以下约定：</p>
<ul>
<li>
<p>校对规则名称以与其关联的字符集的名称开头，通常后跟一个或多个后缀，以表示其他校对特征。例如，<code>utf8mb4_general_ci</code> 和 <code>latin1_swedish_ci</code> 分别是 <code>utf8mb4</code> 和 <code>latin1</code> 字符集的校对规则。二进制字符集具有单个排序规则，也称为 <code>binary</code>，没有后缀。</p>
</li>
<li>
<p>特定于语言的校对规则包括语言环境代码或语言名称。例如，<code>utf8mb4_tr_0900_ai_ci</code> 和 <code>utf8mb4_hu_0900_ai_ci</code> 使用土耳其语和匈牙利语规则对 <code>utf8mb4</code> 字符集的字符进行排序。 相对应的 <code>utf8mb4_turkish_ci</code> 和 <code>utf8mb4_hungarian_ci</code> ，只是基于 <code>Unicode</code> 排序算法的较新版本。</p>
</li>
<li>
<p>排序规则后缀指示排序规则是否区分大小写，区分重音还是假名敏感（或其某种组合）还是二进制。下表显示了用于表示这些特征的后缀。</p>
<p><strong>Table 排序规则后缀含义</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">后缀</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>_ai</code></td>
<td style="text-align:left">Accent-insensitive (重音不敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_as</code></td>
<td style="text-align:left">Accent-sensitive (重音敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_ci</code></td>
<td style="text-align:left">Case-insensitive (大小写不敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_cs</code></td>
<td style="text-align:left">Case-sensitive (大小写敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_ks</code></td>
<td style="text-align:left">Kana-sensitive (假名敏感)</td>
</tr>
<tr>
<td style="text-align:left"><code>_bin</code></td>
<td style="text-align:left">Binary</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Unicode 字符集的排序规则名称可以包括版本号，以指示排序规则所基于的 Unicode 排序规则算法 (UCA) 的版本。在名称中没有版本号的基于 UCA 的排序规则使用版本 4.0.0 UCA 作为其配重键。例如：</p>
<ul>
<li>utf8mb4_0900_ai_ci 基于 UCA 9.0.0 配重键 (<a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt">http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt</a>)。</li>
<li>utf8mb4_unicode_520_ci 基于 UCA 5.2.0 配重键 (<a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt">http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt</a>)。</li>
<li>utf8mb4_unicode_ci（未命名版本）基于 UCA 4.0.0 配重键 (<a target="_blank" rel="noopener" href="http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt">http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt</a>)。</li>
</ul>
</li>
<li>
<p>对于 Unicode 字符集，<code>xxx_general_mysql500_ci</code> 排序规则保留原始 <code>xxx_general_ci</code> 排序规则在 5.1.24 之前的顺序，并允许对在 MySQL 5.1.24 之前创建的表进行升级 (Bug #27877)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Character Sets</tag>
        <tag>Collations</tag>
        <tag>Unicode</tag>
        <tag>BMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 中的 lambda 表达式如何工作？</title>
    <url>/java/jvm/Java-%E4%B8%AD%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>lambda 表达式在 Java 代码和 JVM 内部是什么样的？显然，它是某种类型的值，而 Java 只允许两种类型的值：原始类型和对象引用。lambda 显然不是原始类型，因此 Lambda 表达式必须是某种返回对象引用的表达式。</p>
<p>让我们看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; System.out.println(HELLO);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>熟悉内部类的程序员可能会猜测 lambda 实际上只是 <code>Runnable</code> 匿名内部类的语法糖。但是，编译以上类将生成一个文件：<code>LambdaExample.class</code>。该类中并没有其他类文件。</p>
<span id="more"></span>
<p>这意味着 lambda 不是内部类。相反，它们必须是其他某种机制。实际上，通过 <code>javap -c -p</code> 反编译字节码揭示了两件事。</p>
<p>首先是以下事实：lambda 主体已被编译为私有的静态方法，该方法出现在主类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">9</span>                  <span class="comment">// String Hello World!</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>关于字节码的第二件事要注意的是 main 方法的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span> <span class="keyword">throws</span> java.lang.Exception</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: invokedynamic #<span class="number">2</span>,  <span class="number">0</span>              <span class="comment">// InvokeDynamic #0:run:()Ljava/lang/Runnable;</span></span><br><span class="line">       <span class="number">5</span>: astore_1</span><br><span class="line">       <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// class java/lang/Thread</span></span><br><span class="line">       <span class="number">9</span>: dup</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      <span class="number">11</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span></span><br><span class="line">      <span class="number">14</span>: astore_2</span><br><span class="line">      <span class="number">15</span>: aload_2</span><br><span class="line">      <span class="number">16</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/lang/Thread.start:()V</span></span><br><span class="line">      <span class="number">19</span>: aload_2</span><br><span class="line">      <span class="number">20</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/Thread.join:()V</span></span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>请注意，字节码以 <code>invokedynamic</code> 调用开始。此操作码已添加到版本 7 的 Java 中（这是有史以来唯一添加到 JVM 字节码的操作码）。我在“<a target="_blank" rel="noopener" href="https://blogs.oracle.com/javamagazine/real-world-bytecode-handling-with-asm?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991">使用 ASM 的操作字节码</a>”和“<a target="_blank" rel="noopener" href="https://www.oracle.com/a/ocom/docs/corporate/java-magazine-nov-dec-2017.pdf#page=67?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991">了解使用 invokedynamic 进行 Java 方法调用</a>”中讨论了方法调用，您可以将其作为本文的附带内容阅读。</p>
<p>理解此代码中的 <code>invokedynamic</code> 调用的最直接方法是将其视为对某种特殊形式的 factory 方法的调用。方法调用返回实现 <code>Runnable</code> 的某种类型的实例。确切的类型没有在字节码中指定，从根本上来说也没什么关系。</p>
<p>实际类型在编译时不存在，将在运行时按需创建。为了更好地说明这一点，我将讨论三种结合使用以实现该效果的机制：<strong>调用站点(call sites)</strong>，<strong>方法句柄(method handles)<strong>和</strong>引导程序(bootstrapping)</strong>。</p>
<h2 id="call-sites"><a class="markdownIt-Anchor" href="#call-sites"></a> Call sites</h2>
<p>字节码中方法调用指令发生的位置称为调用站点。</p>
<p>调用站点持有一个 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html"><code>MethodHandle</code></a> 变量，作为它的调用目标，链接到调用站点的 <code>invokedynamic</code> 调用将会全部委托给 <code>MethodHandle</code>。调用站点可能和多个 <code>invokedynamic</code> 关联，也可能是“自由浮动”的，没有任何关联。无论哪种情况，它都可以通过<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html#:~:text=handle%20called%20its-,dynamic%20invoker,-.">动态调用</a>产生的关联方法句柄来调用。</p>
<p>传统上，Java 字节码具有四个处理不同方法调用情况的操作码：</p>
<ul>
<li><strong>(invokestatic)</strong> 静态方法，用于调用类方法</li>
<li><strong>(invokevirtual)</strong> “常规”调用，用于调用对象的实例方法（可能涉及方法重写的虚拟调用）</li>
<li><strong>(invokeinterface)</strong> 接口查找，用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li><strong>(invokespecial)</strong> “特殊”调用，用于调用一些需要特殊处理的实例方法（对于不需要重写解析的情况，例如超类调用和私有方法）。</li>
</ul>
<p><strong>(invokedynamic)</strong> 相比于之前的四条指令，他们的分派逻辑都是固化在 JVM 内部，而 invokedynamic 则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断，从而达到动态语言的支持。</p>
<p>在这里，<code>invokedynamic</code> 调用站点在 Java 堆中表示为 <code>CallSite</code> 对象。这并不奇怪：自 Java 1.1 开始，Java 就使用了反射 API 做类似的事情，其中包含诸如 <code>Method</code> 之类的类型，Java 在运行时具有许多动态行为，因此 Java 现在正在对调用站点以及其他运行时类型信息进行建模的想法应该就不足为奇了。</p>
<p>每个 <code>invokedynamic</code> 指令的出现被称为<em>动态调用站点（dynamic call site）</em>，动态调用站点最开始是未链接的状态，在这种状态下，调用站点没有要调用的目标方法。在 JVM 可以执行动态调用站点（<code>invokedynamic</code> 指令）之前，必须首先链接调用站点。链接是通过调用 <code>bootstrap</code> 方法来完成的，该方法获得调用站点的静态信息内容，并且必须生成一个提供调用站点行为的方法句柄（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html"><code>method handle</code></a>）。</p>
<p>当执行到 <code>invokedynamic</code> 指令时，JVM 会找到相应的调用站点对象（或者，如果以前从未执行过此调用站点，它将创建一个新对象）。</p>
<p>调用站点对象是必要的间接级别，允许关联的调用目标（即方法句柄）随时间变化。</p>
<p><code>CallSite</code>（抽象类）有三个可用的子类：<code>ConstantCallSite</code>，<code>MutableCallSite</code> 和 <code>VolatileCallSite</code>。基类仅具有包访问权限构造函数，而三个子类型具有公共构造函数。这意味着 <code>CallSite</code> 不能由用户代码直接子类化，但是可以子类化子类。例如，<code>JRuby</code> 语言使用 <code>invokedynamic</code> 作为其实现的一部分，并继承了 <code>MutableCallSite</code> 子类。</p>
<p><strong>注意</strong>：某些 <code>invokedynamic</code> 调用站点实际上只是延迟计算，并且目标对象的方法在第一次执行后就不会改变。这是 <code>ConstantCallSite</code> 的非常常见的用例，其中包括 lambda 表达式。</p>
<p>这意味着在程序的整个生命周期中，非常量调用站点可以改变不同的方法句柄作为其目标 <code>setTarget(MethodHandle newTarget)</code>，新目标必须与前一个目标具有相同的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html#type--">类型（MethodType）</a>。</p>
<h2 id="method-handles"><a class="markdownIt-Anchor" href="#method-handles"></a> Method handles</h2>
<p>反射是一种用于执行运行时技巧的强大技术，但它具有许多设计缺陷。反射的一个关键问题是性能，尤其是因为即时调用（JIT）编译器难以内联反射调用。</p>
<p>这很不好，因为内联在几种方面对 JIT 编译非常重要，其中最重要的一点是因为内联通常是首次应用优化，并且为其他技术打开了大门（例如转义分析和无效代码消除）。</p>
<p>第二个问题是，每次遇到 <code>Method.invoke()</code> 的调用站点时，都会链接反射调用。例如，这意味着执行安全访问检查。这是非常浪费的，因为在第一次调用时检查通常会成功还是失败，并且如果成功，它将在程序的整个生命周期中继续这样做。然而，反射却又一次又一次地链接调用。因此，反射通过重新链接和浪费 CPU 时间而导致许多不必要的成本。</p>
<p>为了解决这些问题（以及其他问题），Java 7 引入了一个新的 API，即 <code>java.lang.invoke</code>，由于它引入的主类的名称，通常将其称为<em>方法句柄 (method handles)</em>。</p>
<p>方法句柄（MH）是 Java 版本的类型安全的函数指针。类似于 Java 反射中的 Method 对象。MH 具有实际上与反射执行底层方法相同的 <code>invoke()</code> 方法。</p>
<p>一方面，MH 实际上只是一种更有效的反射机制，它更接近本质。反射 API 中由对象表示的任何内容都可以转换为等效的 MH。例如，可以使用 <code>Lookup.unreflect(Method m)</code> 将反射方法对象转换为 MH。创建的 MH 通常是访问基础方法的更有效方法。</p>
<p>可以通过 <code>MethodHandles</code> 类中的静态辅助方法以多种方式来修改 MH，例如通过组合和方法参数的部分绑定（柯理化），它还提供了一个静态的查询工厂类用于构建方法句柄。</p>
<p>通常，方法链接需要类型描述符的精确匹配。但是，MH 上 的 <code>invoke()</code> 方法具有特殊的多态签名，无论调用的方法的签名如何，都允许进行链接。</p>
<p>在运行时，<code>invoke()</code> 调用站点上的签名应该看起来和你正在直接调用引用的方法一样，这避免了反射调用通常会发生的类型转换和自动装箱成本。</p>
<p>由于 Java 是一种静态类型的语言，因此出现了一个问题，即当使用这种动态的机制时，可以保留多少类型安全性。MH API 通过使用一种称为 <code>MethodType</code> 的类型来解决此问题，该类型是方法采用的参数的不可变表示：<strong>方法的签名</strong>。</p>
<p>MH 的内部实现在 Java 8 的生命周期内进行了更改。新的实现称为 lambda 形式，<strong>它提供了显着的性能提升，现在 MH 在许多用例中都比反射更好。</strong></p>
<h2 id="bootstrapping"><a class="markdownIt-Anchor" href="#bootstrapping"></a> Bootstrapping</h2>
<p>字节码指令流中第一次遇到每个特定的 <code>invokedynamic</code> 调用站点时，JVM 不知道它针对的是哪种方法。实际上，没有与该指令关联的调用站点对象。</p>
<p>调用站点需要被*引导（bootstrapped）*来完成链接，并且 JVM 通过运行引导方法 bootstrap method（BSM）生成并返回调用站点对象来实现此目的。</p>
<p>每个 <code>invokedynamic</code> 调用站点都有与其关联的 BSM，该 BSM 存储在类文件的单独区域中。这些方法允许用户代码在运行时以编程方式确定链接。</p>
<p>链接首先解析引导方法的常量池条目，并解析动态调用站点的类型描述符的 MethodType 对象。此解析过程可能会触发类加载。因此，如果类加载失败，它可能会引发错误。链接不会触发类初始化。</p>
<p>反编译 <code>invokedynamic</code> 调用（例如我在 Runnable 的原始示例中的调用）表明它具有以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: invokedynamic #2,  0</span><br></pre></td></tr></table></figure>
<p>在类文件的常量池中，请注意，条目 <code>#2</code> 是类型 <code>CONSTANT_InvokeDynamic</code> 的常量。常量池的相关部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#2 = InvokeDynamic      #0:#31</span><br><span class="line">   ...</span><br><span class="line">  #31 = NameAndType        #46:#47        // run:()Ljava/lang/Runnable;</span><br><span class="line">  #46 = Utf8               run</span><br><span class="line">  #47 = Utf8               ()Ljava/lang/Runnable;</span><br></pre></td></tr></table></figure>
<p>常数中存在 0 是一个提示。常量池条目从 1 开始编号，因此 0 会提醒您实际的 BSM 位于类文件的另一部分。</p>
<p>对于 lambda，<code>NameAndType</code> 条目采用特殊形式。名称是任意的，但是类型签名包含一些有用的信息。</p>
<p>返回类型对应于 <code>invokedynamic</code> 工厂的返回类型。它是 lambda 表达式的目标类型。同样，参数列表由 lambda 捕获的元素类型组成。对于无状态 lambda，返回类型将始终为空。只有 Java 闭包才会有参数存在。</p>
<p>BSM 至少需要接受三个参数并返回 <code>CallSite</code>。标准参数是以下类型：</p>
<ul>
<li><code>MethodHandles.Lookup</code>：发生调用站点的类上的查找对象</li>
<li><code>String</code>: <code>NameAndType</code> 中提到的名称</li>
<li><code>MethodType</code>：<code>NameAndType</code> 中的已解析类型描述符</li>
</ul>
<p>除了这几个参数，后面的参数是 BSM 所需的任何其他参数。这些在文档中称为附加静态参数。</p>
<p>BSM 的一般情况允许一种非常灵活的机制，非 Java 语言实现者可以使用这种机制。但是，Java 语言没有提供用于生成任意 <code>invokedynamic</code> 调用站点的语言级别的构造。</p>
<p>对于 lambda 表达式，BSM 采用一种特殊形式，为了充分理解该机制的工作原理，我将对其进行更仔细的研究。</p>
<h2 id="解码-lambda-的-bootstrap-方法"><a class="markdownIt-Anchor" href="#解码-lambda-的-bootstrap-方法"></a> 解码 lambda 的 bootstrap 方法</h2>
<p>对 <code>javap</code> 使用 <code>-v</code> 参数可查看引导程序方法。这是必需的，因为引导程序方法位于类文件的特殊部分中，并且将引用返回到主常量池中。对于这个简单的 <code>Runnable</code> 示例，它有一个引导程序方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BootstrapMethods:</span><br><span class="line">  0: #28 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:</span><br><span class="line">        (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;</span><br><span class="line">         Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;</span><br><span class="line">         Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #29 ()V</span><br><span class="line">      #30 REF_invokeStatic LambdaExample.lambda$main$0:()V</span><br><span class="line">      #29 ()V</span><br></pre></td></tr></table></figure>
<p>有点难以理解，所以让我们对其进行解码。</p>
<p>此调用站点的引导方法是常量池中的条目 <code>#28</code>。这是 <code>MethodHandle</code> 类型的条目（一种常量池类型，已在 Java 7 中添加到标准中）。现在，将其与字符串函数示例的情况进行比较：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: #27 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:</span><br><span class="line">        (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;</span><br><span class="line">         Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;</span><br><span class="line">         Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;</span><br><span class="line">    Method arguments:</span><br><span class="line">      #28 (Ljava/lang/Object;)Ljava/lang/Object;</span><br><span class="line">      #29 REF_invokeStatic StringFunction.lambda$static$0:(Ljava/lang/String;)Ljava/lang/Integer;</span><br><span class="line">      #30 (Ljava/lang/String;)Ljava/lang/Integer;</span><br></pre></td></tr></table></figure>
<p>将用作 BSM 的方法句柄与静态方法 <code>LambdaMetafactory.metafactory(...)</code> 相同。</p>
<p>更改的部分是方法参数。这些是 lambda 表达式的附加静态参数，其中有三个。它们代表了 lambda 的签名以及 lambda 实际最终调用目标的方法句柄：lambda 主体。第三个静态参数是签名的擦除形式。</p>
<p>让我们将代码跟随到 <code>java.lang.invoke</code> 中，看看平台如何使用 <em>metafactories</em> 动态地处理实际上为 lambda 表达式实现目标类型的类。</p>
<h2 id="the-lambda-metafactories"><a class="markdownIt-Anchor" href="#the-lambda-metafactories"></a> The lambda metafactories</h2>
<p>BSM 对此静态方法进行调用，该方法最终<strong>返回调用站点对象</strong>。当执行 <code>invokedynamic</code> 指令时，调用站点（Call Site）中包含的方法句柄（Method Handle）将返回一个实现 lambda 目标类型的类的实例。</p>
<p>BSM -&gt; metafactory -&gt; CallSite -&gt; MethodHandle</p>
<p>metafactory 方法的源代码相对简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">metafactory</span><span class="params">(MethodHandles.Lookup caller,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       String invokedName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       MethodType invokedType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       MethodType samMethodType,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       MethodHandle implMethod,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       MethodType instantiatedMethodType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> LambdaConversionException </span>&#123;</span><br><span class="line">        AbstractValidatingLambdaMetafactory mf;</span><br><span class="line">        mf = <span class="keyword">new</span> InnerClassLambdaMetafactory(caller, invokedType,</span><br><span class="line">                                             invokedName, samMethodType,</span><br><span class="line">                                             implMethod, instantiatedMethodType,</span><br><span class="line">                                             <span class="keyword">false</span>, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);</span><br><span class="line">        mf.validateMetafactoryArgs();</span><br><span class="line">        <span class="keyword">return</span> mf.buildCallSite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找对象对应于 <code>invokedynamic</code> 指令所在的上下文。在这种情况下，就是定义 lambda 的同一个类，因此查找上下文将具有访问 lambda 主体编译成的私有方法的正确权限。</p>
<p>调用的名称和类型由 VM 提供，并且是实现的详细信息。最后三个参数是 BSM 的其他静态参数。</p>
<p>在当前的实现中，元工厂将代码委派给使用 <a target="_blank" rel="noopener" href="https://asm.ow2.io/?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991">ASM 字节码库</a>的内部拷贝的代码，以编织实现目标类型的内部类。</p>
<p>如果 lambda 没有从其封闭范围中捕获任何参数，则结果对象是无状态的，因此该实现可通过预先计算单个实例来进行优化 - 有效地将 lambda 的实现类设为单例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> Function&lt;String, Integer&gt; <span class="function"><span class="title">makeFn</span></span>() &#123;</span></span><br><span class="line">   ...&gt;   return s -&gt; s.length();</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  created method makeFn()</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> var f1 = makeFn();</span></span><br><span class="line">f1 ==&gt; $Lambda$27/0x0000000800b8f440@533ddba</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> var f2 = makeFn();</span></span><br><span class="line">f2 ==&gt; $Lambda$27/0x0000000800b8f440@533ddba</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> var f3 = makeFn();</span></span><br><span class="line">f3 ==&gt; $Lambda$27/0x0000000800b8f440@533ddba</span><br></pre></td></tr></table></figure>
<p>这是文档强烈劝阻 Java 程序员不要依赖任何形式的 lambda 身份语义的原因之一。</p>
<h2 id="结束"><a class="markdownIt-Anchor" href="#结束"></a> 结束</h2>
<p>本文探讨了 JVM 如何实现对 lambda 表达式的支持的详细细节。这是您将要遇到的更复杂的平台功能之一，因为它深入到语言实现者的领域。</p>
<p>一路上，我讨论了 <code>invokedynamic</code> 和方法处理 API。这是现代 JVM 平台的主要部分的两项关键技术。这两种机制都在整个生态系统中得到了越来越多的使用。例如，在 Java 9 及更高版本中，<code>invokedynamic</code> 已用于实现新形式的字符串连接。</p>
<p>了解这些功能可以使您深入了解 Java 应用程序所依赖的平台和现代框架的最深层运作。</p>
<blockquote>
<p><em><a target="_blank" rel="noopener" href="https://blogs.oracle.com/javamagazine/behind-the-scenes-how-do-lambda-expressions-really-work-in-java?source=:em:nw:mt:::RC_WWMK200429P00043:NSL400105991&amp;elq_mid=178066&amp;sh=01220926150119261320312809260905&amp;cmid=WWMK200429P00043C0012">原文链接</a></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>lambda</tag>
        <tag>invokedynamic</tag>
        <tag>CallSite</tag>
        <tag>MethodHandle</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 快速入门</title>
    <url>/persistence/Mybatis-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<p><code>MyBatis</code> 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects）为数据库中的记录。</p>
<p><code>MyBatis</code> 作为一款持久层框架，它趋向于以数据库为中心，因此主要的关注点会落在 SQL 定义、结果映射上，相对来说比较轻量，也更容易入手，对于 SQL 优化也比较容易，但也正是由于偏重 SQL，将会和使用的数据库强关联。</p>
<h1 id="对比-orm-框架"><a class="markdownIt-Anchor" href="#对比-orm-框架"></a> 对比 ORM 框架</h1>
<p>同时使用面向对象的软件和关系数据库既麻烦又费时。由于对象和关系数据库中的数据表示方式之间存在<strong>范式不匹配</strong>，因此开发成本要高得多。</p>
<p>相比 <code>ORM</code> 框架，<code>ORM</code> 框架更多的将关注点放在面向对象的域模型和业务逻辑层，<code>ORM</code> 框架一般会遵循 <code>JPA</code> 标准，比如最常见的实现 <code>Hibernate</code>。</p>
<p><code>ORM</code> 框架的主要目的之一是降低与特定数据库的耦合性，它抽象了数据库系统，因此在不同数据库切换、移植时会更加容易，抽象的代价是与之而来的复杂性的增加，但也提供了更多丰富的功能特性：数据变更追踪、审计、一/二级缓存、并发版本控制、数据懒加载、级联操作，以及丰富的查询方式：<code>SQL</code>、<code>HQL</code>、<code>JPQL</code>、<code>Criteria API</code>、<code>Query DSL</code> 等；</p>
<span id="more"></span>
<h1 id="xml-or-annotation"><a class="markdownIt-Anchor" href="#xml-or-annotation"></a> XML or Annotation</h1>
<p>在使用 MyBatis 开发应用时，最大一部分工作是在和 <a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html"><code>Mapper（映射器）</code></a>打交道，Mapper 中主要又分为两部分：</p>
<ul>
<li>sql 语句定义（select、insert、update、delete、sql）</li>
<li>结果集映射 resultMap</li>
</ul>
<p>而这两部分既可以通过 XML 也可以通过注解来定义，同样是为代码运行提供元数据，使用哪种更好呢？</p>
<p>每种方法都有其优点和缺点，通常，由开发人员决定哪种策略更适合他们。由于它们的定义方式，注解在其声明时提供了大量上下文，从而导致更短更简洁的配置。但是，XML 擅长在不触及源代码或重新编译它们的情况下连接组件。一些开发人员更喜欢将配置靠近源，而另一些开发人员则认为注解类不再是 POJO，而且配置变得分散且难以控制。</p>
<p><strong>MyBatis 的 XML 提供了全量的功能，注解受限于灵活性不能覆盖所有方面，比如嵌套结果映射等，但是能基本的满足开发使用。</strong></p>
<blockquote>
<p>个人建议：优先考虑使用 XML。</p>
</blockquote>
<h1 id="动态-sql"><a class="markdownIt-Anchor" href="#动态-sql"></a> 动态 SQL</h1>
<p>动态 SQL 定义又分为<strong>编译时定义</strong>和<strong>运行时定义</strong>。</p>
<h2 id="编译时动态-sql-定义"><a class="markdownIt-Anchor" href="#编译时动态-sql-定义"></a> 编译时动态 SQL 定义</h2>
<p><strong>编译时定义</strong>通常是使用 XML 或注解提供元数据的方式提前定义好，对于 XML 通常提供以下标签：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#if"><code>if</code></a>  -  条件拼接</li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#chooseWhenOtherwise"><code>choose (when, otherwise)</code></a>  -  多条件选择，类似 switch</li>
<li><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#trimWhereSet"><code>trim (where, set)</code></a>  -  动态 where 条件适配</li>
<li><code>foreach</code> - 集合遍历</li>
</ul>
<p>要在注解中使用动态元素，可以通过 <code>script</code> 标签来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update(&#123;&quot;&lt;script&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;update Author&quot;,</span></span><br><span class="line"><span class="meta">  &quot;  &lt;set&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;    &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;  &lt;/set&gt;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;where id=#&#123;id&#125;&quot;,</span></span><br><span class="line"><span class="meta">  &quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="运行时动态-sql-定义"><a class="markdownIt-Anchor" href="#运行时动态-sql-定义"></a> 运行时动态 SQL 定义</h2>
<p>虽然通过 XML 直接注入 SQL 片段参数也能实现运行时动态定义 SQL，但 MyBatis 提供了更加安全且灵活的定义方式：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-dynamic-sql/docs/introduction.html">MyBatis Dynamic SQL</a>。</p>
<p>该库通过实现类似于 SQL 的 DSL(domain-specific language) - 领域特定语言来工作，该 DSL 创建一个包含完整 SQL 语句和该语句所需的任何参数的对象。MyBatis 可以将 SQL 语句对象直接用作映射器方法的参数。</p>
<p>该库内置了很多易用的<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-dynamic-sql/docs/conditions.html">条件方法</a>，结合 Java8 的 <code>Predicate</code>、<code>Supplier</code> 等函数，可以实现复杂的条件拼接。</p>
<p><strong>作为一个 SQL 构建器，它并没有实现所有 SQL 的语法，比如查询的 WITH、HAVING、部分子查询写法等。</strong></p>
<h1 id="对象关系映射"><a class="markdownIt-Anchor" href="#对象关系映射"></a> 对象关系映射</h1>
<p>对于普通的查询都能通过映射 POJO 对象或 Map 或基础类型来完成，对于存在对象关系的映射：</p>
<h2 id="一对一"><a class="markdownIt-Anchor" href="#一对一"></a> 一对一</h2>
<p>在 XML 中可通过 <code>association</code> 标签加载关联，在注解中使用 <code>result</code> 的 <code>one</code> 属性，加载方式分为两种：</p>
<ul>
<li>
<p>嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询博客 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 查询博客的作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAuthor&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在查询完 blog 后，会通过 association 标签中定义的 column 找到结果集中的该字段结果，并使用该字段结果去调用 selectAuthor 中定义的语句，并将结果返回给 Blog 对象中 author 对象。</p>
<p>在注解中通过 result 的 one 属性定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(id=&quot;blogResult&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;blog_title&quot;, property=&quot;title&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;author_id&quot;, property=&quot;author&quot;, one=@One(select = &quot;selectAuthor&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。</p>
<p>比如对该查询结果进行映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询博客及博客作者 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogDetails&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       A.id as author_id,</span><br><span class="line">       A.username as author_username,</span><br><span class="line">       A.password as author_password,</span><br><span class="line">       A.email as author_email,</span><br><span class="line">       A.bio as author_bio,</span><br><span class="line">       A.favourite_section as author_favourite_section</span><br><span class="line">  from Blog B</span><br><span class="line">       left outer join Author A on B.author_id = A.id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>映射关联查询中的 Blog 对象中的一对一 Author ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Author&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_id&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_username&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_password&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_email&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;bio&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_bio&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;favouriteSection&quot;</span> <span class="attr">column</span>=<span class="string">&quot;author_favourite_section&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@one 注解 API 不支持嵌套结果映射。这是由于 Java 注解中的限制，不允许循环引用。</strong></p>
<blockquote>
<p>对于关联表和主表字段名相同的，必须使用不同别名，否则在返回结果集时会映射出错。</p>
<p>可以使用 <code>columnPrefix</code> 指定关联表字段的统一前缀。</p>
</blockquote>
</li>
</ul>
<h2 id="一对多"><a class="markdownIt-Anchor" href="#一对多"></a> 一对多</h2>
<p>一对多在 XML 中使用 <code>collection</code> 标签，在注解中使用 result 的 many 标签加载关联，同样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合：</p>
<ul>
<li>
<p>嵌套 Select 查询：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;blogResult&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">select</span>=<span class="string">&quot;selectPostsForBlog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 查询博客 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;blogResult&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 查询博客下的所有文章 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostsForBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST WHERE BLOG_ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于使用注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Results(id=&quot;blogResult&quot;, value = &#123;</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;blog_title&quot;, property=&quot;title&quot;),</span></span><br><span class="line"><span class="meta">    @Result(column=&quot;id&quot;, property=&quot;posts&quot;, many=@Many(select = &quot;selectPostsForBlog&quot;))</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>javaType</code> 是指集合的类型，一般可以推断出，不用写，<code>ofType</code> 是指集合元素的类型。</p>
</li>
<li>
<p>嵌套结果映射：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询博客及下面的所有文章 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogDetails&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">       B.id as blog_id,</span><br><span class="line">       B.title as blog_title,</span><br><span class="line">       B.author_id as blog_author_id,</span><br><span class="line">       P.id as post_id,</span><br><span class="line">       P.blog_id as post_blog_id,</span><br><span class="line">       P.author_id as post_author_id,</span><br><span class="line">       P.created_on as post_created_on,</span><br><span class="line">       P.section as post_section,</span><br><span class="line">       P.subject as post_subject,</span><br><span class="line">       P.draft as draft,</span><br><span class="line">       P.body as post_body,</span><br><span class="line">  from Blog B</span><br><span class="line">       inner join Post p on B.id = P.blog_id</span><br><span class="line">  where B.id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以使用下面的结果映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Very Complex Result Map --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;detailedBlogResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">&quot;blog_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span> <span class="attr">column</span>=<span class="string">&quot;blog_title&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">column</span>=<span class="string">&quot;post_subject&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>@many 注解 API 不支持嵌套结果映射。这是由于 Java 注解中的限制，不允许循环引用。</strong></p>
</li>
</ul>
<h1 id="使用注意"><a class="markdownIt-Anchor" href="#使用注意"></a> 使用注意</h1>
<ul>
<li>XML 符号转义</li>
</ul>
<p>在 XML 中配置查询 sql 时，对于部分符号需要特殊转义</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>转义符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td><code>&amp;lt;</code></td>
<td>小于号</td>
</tr>
<tr>
<td>&lt;=</td>
<td><code>&amp;lt;=</code></td>
<td>小于等于号</td>
</tr>
<tr>
<td>&gt;</td>
<td><code>&amp;gt;</code></td>
<td>大于号</td>
</tr>
<tr>
<td>&gt;=</td>
<td><code>&amp;gt;=</code></td>
<td>大于等于号</td>
</tr>
<tr>
<td>&amp;</td>
<td><code>&amp;amp;</code></td>
<td>和</td>
</tr>
<tr>
<td>’</td>
<td><code>&amp;apos;</code></td>
<td>单引号</td>
</tr>
<tr>
<td>&quot;</td>
<td><code>&amp;quot;</code></td>
<td>双引号</td>
</tr>
</tbody>
</table>
<p>或者可以将包含特殊符号的语句用 <code>CDATA</code> 包裹起来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">  sql statement </span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure>
<h1 id="核心处理流程"><a class="markdownIt-Anchor" href="#核心处理流程"></a> 核心处理流程</h1>
<h2 id="构建-sqlsessionfactory"><a class="markdownIt-Anchor" href="#构建-sqlsessionfactory"></a> 构建 SqlSessionFactory</h2>
<p>每个基于 MyBatis 的应用都是以一个 <code>SqlSessionFactory</code> 的实例为核心的。SqlSessionFactory 的实例可以通过 <code>SqlSessionFactoryBuilder</code> 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 <code>Configuration</code> 实例来构建出 SqlSessionFactory 实例。</p>
<p>在 <code>MyBatis-Spring</code> 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。</p>
<h2 id="从-sqlsessionfactory-中获取-sqlsession"><a class="markdownIt-Anchor" href="#从-sqlsessionfactory-中获取-sqlsession"></a> 从 SqlSessionFactory 中获取 SqlSession</h2>
<p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 <code>SqlSession</code> 的实例，通过 SqlSessionFactory 的 <code>openSession</code> 方法。</p>
<p><strong>SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</strong></p>
<h2 id="使用-mapper-定义语句和结果映射"><a class="markdownIt-Anchor" href="#使用-mapper-定义语句和结果映射"></a> 使用 Mapper 定义语句和结果映射</h2>
<p>映射器主要定义了语句和结果映射。</p>
<p>通过映射器接口，我们可以与 XML 配置形成分离，使用和指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），使我们的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<p>Mybatis 本身可以通过配置文件定义 Mapper 的位置来帮助程序定位和查找映射器。</p>
<p>在 <code>Mybatis-Spring</code> 中，最简单的方法是委托给 Spring 帮我们扫描注册 Bean，具体在下一节中详细介绍。</p>
<p>扫描到的 Mapper，语句，结果映射（ResultMap）等都会放到 <code>Configuration</code> 类中，在后面的执行中我们将会从这里查找。</p>
<h2 id="执行语句和结果映射"><a class="markdownIt-Anchor" href="#执行语句和结果映射"></a> 执行语句和结果映射</h2>
<p>通过 Mapper 的定义我们拿到了要执行的语句，也知道了结果要如何映射。在我们调用 Mapper 的接口时，会反射调用 <code>MapperProxy</code> 代理类，该代理类又委托给 <code>MapperMethod</code> 代理类，最终方法代理类将使用 <code>SqlSession</code> 实例去执行，SqlSession 使用从 <code>Configuration</code> 类拿到的语句，交给 <code>Executor</code> 执行器去执行查询，如果定义了 <code>ResultHandler</code> 则使用该处理器处理结果，否则将使用从 <code>Configuration</code> 中找到的 <code>ResultMap</code> 来处理映射，ResultMap 对不同的字段类型使用 <code>TypeHandlerRegistry</code> 查找已注册的合适的 <code>TypeHandler</code> 进行处理。</p>
<h1 id="spring-mybatis-mapper-注册机制"><a class="markdownIt-Anchor" href="#spring-mybatis-mapper-注册机制"></a> Spring Mybatis Mapper 注册机制</h1>
<p><strong>Mybatis</strong> 结合 <strong>Spring</strong> 将 <strong>Mapper</strong> 注册到 <strong>Spring IoC</strong> 的机制是这样的：</p>
<p><img src="../../images/jpa/mybatis/640.png" alt="640" /></p>
<p>其实里面涉及到 <strong>Spring</strong> 和 <strong>Mybatis</strong> 的知识点还是比较多的，但是我们只要梳理出来流程就比较容易理解和掌握。</p>
<h2 id="importbeandefinitionregistrar"><a class="markdownIt-Anchor" href="#importbeandefinitionregistrar"></a> ImportBeanDefinitionRegistrar</h2>
<p><code>ImportBeanDefinitionRegistrar</code> 是一个非常重要的接口，凡是要把第三方整合到 <strong>Spring</strong> 的开发者都应该掌握这个接口。这接口用来动态的注册某一些具有相同特征的一批类到 <strong>Spring IoC</strong>，借助于<code>@Import</code>注解“附着在”自定义的注解上，就像 <strong>Mybatis-Spring</strong> 的用法一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(MapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@Repeatable(MapperScans.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MapperScan &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将该注解附着到标记有<code>@Configuration</code>或者具有相同功能的配置类上，Spring 会在处理配置类时处理我们的 <code>Import</code> 注解。</p>
<p><code>MapperScannerRegistrar</code> 实现了该接口，该接口只定义了一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据导入的 <span class="doctag">@Configuration</span> 类上给定的注解元数据，根据需要注册 Bean 的定义。</span></span><br><span class="line"><span class="comment"> * 请注意，由于与 <span class="doctag">@Configuration</span> 类处理相关的生命周期限制，可能无法在此处注册 BeanDefinitionRegistryPostProcessor 类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> importingClassMetadata 导入类注解的元数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> registry 当前的 bean 定义注册表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中参数 <code>importingClassMetadata</code> 包含了 <code>@Import</code> 所依附的配置类上的所有注解。这意味着我们可以拿到对应注解的元信息并作为我们动态导入的判断依据，上面就是从 <code>@MapperScan</code> 获取了 <strong>Mapper</strong> 所在的包以及其它信息。</p>
<p>在拿到 <code>MapperScan</code> 注解的元数据后，我们为 <code>MapperScannerConfigurer</code> 提供了配置信息，该配置类又实现了 <code>BeanDefinitionRegistryPostProcessor</code> ，其继承于 <code>BeanDefinitionRegistry</code>。</p>
<p><code>BeanDefinitionRegistry</code> 就是用来注册 <strong>Spring Bean</strong> 的。那么到底是如何注册的呢？这就该下一个主角登场了。</p>
<h2 id="beandefinitionregistrypostprocessor"><a class="markdownIt-Anchor" href="#beandefinitionregistrypostprocessor"></a> BeanDefinitionRegistryPostProcessor</h2>
<p><code>BeanDefinitionRegistryPostProcessor</code> 是 <code>BeanFactoryPostProcessor</code> 的子接口。</p>
<p><code>BeanFactoryPostProcessor</code> 的作用是在 <strong>Spring Bean</strong> 的定义信息已经加载但还没有实例化的时候执行 <code>postProcessBeanFactory()</code> 来处理一些额外的逻辑，比如对 Bean 配置元数据进行操作。也就是说，Spring IoC 容器允许 <code>BeanFactoryPostProcessor</code> 读取配置元数据，并有可能在容器实例化除 <code>BeanFactoryPostProcessor</code> 实例之外的任何 bean之前更改它。</p>
<p>而 <code>BeanDefinitionRegistryPostProcessor</code> 的作用是在 <code>BeanFactoryPostProcessor</code> 增加了一个前置处理，当一个 <strong>Bean</strong> 实现了该接口后，始化前先执行该接口的 <code>postProcessBeanDefinitionRegistry()</code> 方法，然后再执行其父类的方法 <code>postProcessBeanFactory()</code>。这样就把一个 <strong>Spring Bean</strong> 的初始化周期更加细化，让我们在各个阶段有定制它的可能。</p>
<p><code>MapperScannerRegistrar</code> 并没有在该后置处理中注册 Bean，它将注册动作委托给 <code>ClassPathMapperScanner</code> 去扫描注册。</p>
<h2 id="classpathbeandefinitionscanner"><a class="markdownIt-Anchor" href="#classpathbeandefinitionscanner"></a> ClassPathBeanDefinitionScanner</h2>
<p>从名字上来看这个类就是在类路径下扫描 <strong>Bean</strong> 定义并将符合条件的批量通过 <code>BeanDefinitionRegistry</code> 注册到 <strong>Spring IoC</strong>。</p>
<p>它提供了可配置的过滤器来检出需要被注入 <strong>Spring IoC</strong> 的 <strong>Bean</strong>，默认的过滤器包括用 Spring 的 <code>@Component</code>、<code>@Repository</code>、 <code>@Service</code>、<code>@Controller</code> 注释的类 。还支持 Java EE 6 的 <code>javax.annotation.ManagedBean</code> 和 JSR-330 的 <code>javax.inject.Named</code> 注解，如果这些注解可用。当然你可以通过 <code>addIncludeFilter</code> 来新增被包含的 <strong>Bean</strong>，或者 <code>addExcludeFilter</code> 来排除一些 Bean。然后只需要调用其 <code>scan</code> 方法对特定的包进行扫描注入。</p>
<p>Mybatis 的 <code>ClassPathMapperScanner</code> 继承于 Spring 的 <code>ClassPathBeanDefinitionScanner</code> ，它为 Mapper 提供了 Mybatis 需要的参数变量，比如：<code>SqlSessionFactory</code> 以及 封装了 <code>SqlSession</code> 后线程安全的 <code>SqlSessionTemplate</code>，<code>SqlSessionTemplate</code> 还提供与 Spring 事物管理一起工作的能力。</p>
<p>在扫描到特定包下的 Mapper 对象时，会选择用实现 <code>FactoryBean</code> 接口的 <code>MapperFactoryBean</code> 作为该 Mapper 的工厂类，工厂类对其 Mapper 的获取最终委托给 Mybatis 的 <code>Configuration</code> 类来获取，Configuration 内部维护了已找到的 Mapper、结果映射配置等，Configuration 通过使用 <code>MapperProxyFactory</code> 实例化一个该 Mapper 的 <code>MapperProxy</code> 代理类，最终在我们调用 Mapper 接口时，会通过实现了 InvokeHandler 的代理类的 Invoke 去真正执行逻辑，流程如下图：</p>
<p><img src="../../images/jpa/mybatis/mybatis-mapper-proxy.svg" alt="mybatis-mapper-proxy" /></p>
]]></content>
      <categories>
        <category>Persistence</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Explain 执行计划解释</title>
    <url>/persistence/db/MySQL-Explain/</url>
    <content><![CDATA[<h2 id="explain-简介"><a class="markdownIt-Anchor" href="#explain-简介"></a> EXPLAIN 简介</h2>
<p><code>EXPLAIN</code> 语句提供有关 MySQL 如何执行语句的信息，MySQL 解释了它将如何处理该语句，包括有关如何连接表以及以何种顺序连接表的信息。EXPLAIN 可以与 SELECT，DELETE，INSERT，REPLACE 和 UPDATE 语句一起使用。</p>
<p>在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">EXPLAIN</a> 的帮助下，您可以看到应该在表中添加索引的位置，以便通过使用索引查找行来使语句更快地执行。您还可以使用 EXPLAIN 检查优化器是否以最佳顺序连接表。</p>
<blockquote>
<p>EXPLAIN 也可用于获取有关表中各列的信息。 EXPLAIN <em><strong>tbl_name</strong></em> 与 DESCRIBE <em><strong>tbl_name</strong></em> 和 SHOW COLUMNS FROM <em><strong>tbl_name</strong></em> 相同。</p>
</blockquote>
<span id="more"></span>
<p>以下示例中的表使用 MySQL <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/sakila/en/sakila-installation.html">Sakila 示例数据库</a>。</p>
<p>EXPLAIN 的输出总是有相同的列。可变的是行数及内容。下表汇总这些列及它的简介，在接下来的小节中，我们将展示在 EXPLAIN 结果中每一列的意义。记住，输出中的行以 MySQL 实际执行的查询部分的顺序出现，而这个顺序不总是与其在原始 SQL 中的相一致。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Column</th>
<th style="text-align:left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id"><code>id</code></a></td>
<td style="text-align:left"><code>SELECT</code> 编号</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type"><code>select_type</code></a></td>
<td style="text-align:left"><code>SELECT</code> 类型</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table"><code>table</code></a></td>
<td style="text-align:left">该行的表名</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions"><code>partitions</code></a></td>
<td style="text-align:left">匹配的分区</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type"><code>type</code></a></td>
<td style="text-align:left">关联类型</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td>
<td style="text-align:left">可能用到的索引</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key"><code>key</code></a></td>
<td style="text-align:left">实际用到的索引</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len"><code>key_len</code></a></td>
<td style="text-align:left">实际用到索引的键长度</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref"><code>ref</code></a></td>
<td style="text-align:left">与索引进行比较的列名</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows"><code>rows</code></a></td>
<td style="text-align:left">估算要检查的行数</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered"><code>filtered</code></a></td>
<td style="text-align:left">按表条件过滤的行百分比</td>
</tr>
<tr>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra"><code>Extra</code></a></td>
<td style="text-align:left">附加信息</td>
</tr>
</tbody>
</table>
<h2 id="id-列"><a class="markdownIt-Anchor" href="#id-列"></a> id 列</h2>
<p>这一列总是包含一个编号，标识 SELECT 所属的行。如果在语句当中没有子査询或联合，那么只会有唯一的 SELECT，于是每一行在这个列中都将显示一个 1。否则，内层的 SELECT 语句一般会顺序编号，对应于其在原始语句中的位置。<br />
MYSQL 将 SELECT 査询分为简单和复杂类型，复杂类型可分成三大类：简单子査询、所谓的派生表(在 FROM 子句中的子査询)，以及 UNION 查询。下面是一个简单的子査询：</p>
<blockquote>
<p>id 的值代表 SELECT 在原 SQL 中的顺序，id 的顺序代表执行计划的顺序。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT (SELECT 1 FROM sakila.actor LIMIT 1) FROM sakila.film;</span></span><br><span class="line">+----+-------------+....</span><br><span class="line">| id | select_type |....</span><br><span class="line">+----+-------------+....</span><br><span class="line">|  1 | PRIMARY     |....</span><br><span class="line">|  2 | SUBQUERY    |....</span><br><span class="line">+----+-------------+....</span><br></pre></td></tr></table></figure>
<p>FROM 子句中的子査询和联合增加了 id 列的复杂性。下面是一个 FROM 子句中的基本子査询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT film_id FROM (SELECT film_id from sakila.film LIMIT 10) as der;</span></span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">| id | select_type | table      |...</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; |...</span><br><span class="line">|  2 | DERIVED     | film       |...</span><br><span class="line">+----+-------------+------------+...</span><br></pre></td></tr></table></figure>
<p>如你所知，这个查询执行时有一个匿名临时表。 MySQL 内部通过别名（der）在外层查询中引用这个临时表，在更复杂的査询中可以看到 ref 列。</p>
<p>最后，下面是一个 UNION 查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT 1 UNION SELECT 1;</span></span><br><span class="line">+------+--------------+------------+...</span><br><span class="line">|  id  | select_type  | table      |...</span><br><span class="line">+------+--------------+------------+...</span><br><span class="line">|  1   | PRIMARY      | NULL       |...</span><br><span class="line">|  2   | UNION        | NULL       |...</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; |...</span><br><span class="line">+------+--------------+------------+...</span><br></pre></td></tr></table></figure>
<p>注意 UNION 结果输出中的额外行。 UNION 结果总是放在一个匿名临时表中，之后 MySQL 将结果读取到临时表外。临时表并不在原 SQL 中出现，因此它的 id 列是 NULL。与之前的例子相比（演示子査询的那个 FROM 子句中），从这个査询产生的临时表在结果中出现在最后一行，而不是第一行。</p>
<p>上面只是简单语句，但这三类语句的混合则会使输出变得非常复杂，后面我们会看到。</p>
<h2 id="select_type-列"><a class="markdownIt-Anchor" href="#select_type-列"></a> select_type 列</h2>
<p>这一列显示了对应行是简单还是复杂 SELECT（如果是后者，那么是三种复杂类型中的哪一种)。 可能的值如下：</p>
<h3 id="simple"><a class="markdownIt-Anchor" href="#simple"></a> <code>SIMPLE</code></h3>
<p>SIMPLE 值意味着查询不包括子査询和  UNION。</p>
<h3 id="primary"><a class="markdownIt-Anchor" href="#primary"></a> <code>PRIMARY</code></h3>
<p>如果査询有任何复杂的子部分，则最外层部分标记为 PRIMARY，其他部分标记如下。</p>
<h3 id="subquery"><a class="markdownIt-Anchor" href="#subquery"></a> <code>SUBQUERY</code></h3>
<p>包含在 SELECT 列表中的子査询中的 SELECT (换句话说，不在 FROM 子句中)标记为 SUBOUERY。</p>
<h3 id="derived"><a class="markdownIt-Anchor" href="#derived"></a> <code>DERIVED</code></h3>
<p>DERIVED 值用来表示包含在 FROM 子句的子査询中的 SELECT，MySQL 会递归执行并将结果放到一个临时表中。服务器内部称其“派生表”，因为该临时表是从子査询中派生来的。</p>
<h3 id="union"><a class="markdownIt-Anchor" href="#union"></a> <code>UNION</code></h3>
<p>在 UNION 中的第二个和随后的 SELECT 被标记为 UNION。</p>
<blockquote>
<p>UNION 和 UNION DISTINCT 同义，会删除重复行。UNION ALL 不会删除重复行。</p>
</blockquote>
<h3 id="union-result"><a class="markdownIt-Anchor" href="#union-result"></a> <code>UNION RESULT</code></h3>
<p>用来从 UNION 的匿名临时表检索结果的 SELECT 被标记为 UNION RESULT。</p>
<h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3>
<p>除了这些值，SUBQUERY 和 UNI0N 还可以被标记为 <code>DEPENDENT</code> 和 <code>UNCACHEABLE</code>。 DEPENDENT 意味着 SELECT 依赖于外层査询中发现的数据，UNCACHEABLE 意味着 SELECT 中的某些特性阻止结果被缓存于ー个 Item cache 中。（ Item cache 未被文档记载，它与査询缓存不是一回事，尽管它可以被一些相同类型的构件否定，例如 RAND() 函数。)</p>
<h2 id="table-列"><a class="markdownIt-Anchor" href="#table-列"></a> table 列</h2>
<p>这一列显示了对应行正在访问哪个表。在通常情况下，它相当明了：它就是那个表，或是该表的别名(如果 SQL 中定义了别名)。</p>
<p>可以在这一列中从上往下观察 MySQL 的关联优化器为査询选择的关联顺序。例如，可以看到在下面的査询中 MySQL 选择的关联顺序不同于语句中所指定的顺序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT film.film_id</span></span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor USING (actor_id);</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">| id | select_type | table      |...</span><br><span class="line">+----+-------------+------------+...</span><br><span class="line">|  1 | SIMPLE      | actor      |...</span><br><span class="line">|  1 | SIMPLE      | film_actor |...</span><br><span class="line">|  1 | SIMPLE      | film       |...</span><br><span class="line">+----+-------------+------------+...</span><br></pre></td></tr></table></figure>
<p>MySQL 的査询执行计划总是左侧深度优先树。如果把这个计划放倒，就能按顺序读出叶子节点，它们直接对应于 EXPLAIN 中的行。之前的査询计划看起来如图所示。</p>
<p><img src="../../../images/db/explain-left-deep.jpg" alt="left-deep" /></p>
<blockquote>
<p>在 SELECT 后加入指示 <code>STRAIGHT_JOIN</code> 会要求 Mysql 按指定顺序进行连接，但是这也会丧失自动优化的好处。</p>
</blockquote>
<h3 id="派生表和联合"><a class="markdownIt-Anchor" href="#派生表和联合"></a> 派生表和联合</h3>
<p>当 FROM 子句中有子査询或有 UNION 时，table 列会变得复杂得多。在这些场景下，确实没有一个“表”可以参考到，因为  MySQL 创建的匿名临时表仅在査询执行过程中存在。<br />
当在 FROM 子句中有子査询时，table 列是&lt;derived<em>N</em>&gt;的形式，其中 N 是子査询的 id。这总是“向前引用”一换言之，N 指向 EXPLAIN 输出中后面的一行。<br />
当有 UNION 时，UNION RESULT 的 table 列包含一个参与 UNION 的 id 列表。这总是“向后引用”，因为 UNION RESULT 出现在 UION 中所有参与行之后。如果在列表中有超过 20 个 id， table 列可能被截断以防止太长，此时不可能看到所有的值。幸运的是，仍然可以推测包括哪些行，因为你可以看到第一行的 id。在这一行和 UNION RESULT 之间出现的一切都会以某种方式被包含。</p>
<p>下面是一个无意义的査询，我们这里把它用作某种复杂 SELECT 类型的紧凑示例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1   EXPLAIN</span><br><span class="line">2   SELECT actor_id,</span><br><span class="line">3          (SELECT 1 FROM sakila.film_actor WHERE film_actor.actor_id =</span><br><span class="line">4                                                 der_1.actor_id LIMIT 1)</span><br><span class="line">5   FROM (</span><br><span class="line">6       SELECT actor_id</span><br><span class="line">7       FROM sakila.actor LIMIT 5</span><br><span class="line">8   ) AS der_1</span><br><span class="line">9   UNION</span><br><span class="line">10  SELECT film_id,</span><br><span class="line">11         (SELECT @var1 FROM sakila.rental LIMIT 1)</span><br><span class="line">12  FROM (</span><br><span class="line">13      SELECT film_id,</span><br><span class="line">14             (SELECT 1 FROM sakila.store LIMIT 1)</span><br><span class="line">15      FROM sakila.film LIMIT 5</span><br><span class="line">16  ) AS der_2;</span><br></pre></td></tr></table></figure>
<p>下面是 EXPLAIN 的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+------+----------------------+------------+...</span><br><span class="line">| id   | select_type          | table      |...</span><br><span class="line">+------+----------------------+------------+...</span><br><span class="line">|  1   | PRIMARY              | &lt;derived3&gt; |...</span><br><span class="line">|  3   | DERIVED              | actor      |...</span><br><span class="line">|  2   | DEPENDENT SUBQUERY   | film_actor |...</span><br><span class="line">|  4   | UNION                | &lt;derived6&gt; |...</span><br><span class="line">|  6   | DERIVED              | film       |...</span><br><span class="line">|  7   | SUBQUERY             | store      |...</span><br><span class="line">|  5   | UNCACHEABLE SUBQUERY | rental     |...</span><br><span class="line">| NULL | UNION RESULT         | &lt;union1,4&gt; |...</span><br><span class="line">+------+----------------------+------------+...</span><br></pre></td></tr></table></figure>
<h2 id="type-列"><a class="markdownIt-Anchor" href="#type-列"></a> type 列</h2>
<p>MySQL 用户手册上说这一列显示了“关联类型”，但我们认为更准确的说法是访问类型一一换言之就是 MySQL 决定如何查找表中的行。下面是最重要的访问方法，依次从最优到最差。</p>
<h3 id="null"><a class="markdownIt-Anchor" href="#null"></a> <code>NULL</code></h3>
<p>这种访问方式意味着 MySQL 能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。例如，从一个索引列里选取最小值可以通过单独查找索引来完成，不需要在执行时访问表。</p>
<h3 id="const-system"><a class="markdownIt-Anchor" href="#const-system"></a> <code>const, system</code></h3>
<p>当 MySQL 能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型。举例来说，如果你通过将某一行的主键放入 WHERE 子句里的方式来选取此行的主键，MySQL 就能把这个查询转换为一个常量。然后就可以高效地将表从联接执行中移除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT * FROM sakila.film WHERE film_id = 1;</span>     </span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br><span class="line">| id | select_type | table | partitions | type  |...</span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br><span class="line">|  1 | SIMPLE      | film  | NULL       | const |...</span><br><span class="line">+----+-------------+-------+------------+-------+...</span><br></pre></td></tr></table></figure>
<p><code>system</code>是 const 的特例，<strong>对应于系统表的数据过滤</strong>。</p>
<h3 id="eq_ref"><a class="markdownIt-Anchor" href="#eq_ref"></a> <code>eq_ref</code></h3>
<p>使用这种索引査找，MySQL 知道最多只返回一条符合条件的记录。这种访问方法可以在 MySQL 使用<strong>主键或者唯一性索引</strong>査找时看到，它会将它们与某个参考值做比较。MySQL 对于这类访问类型的优化做得非常好，因为它知道无须估计匹配行的范围或在找到匹配行后再继续査找。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN</span></span><br><span class="line">    -&gt; SELECT film.film_id</span><br><span class="line">    -&gt; FROM sakila.film</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor USING (actor_id);</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br><span class="line">| id | select_type | table      | partitions | type   |...</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br><span class="line">|  1 | SIMPLE      | actor      | NULL       | index  |...</span><br><span class="line">|  1 | SIMPLE      | film_actor | NULL       | ref    |...</span><br><span class="line">|  1 | SIMPLE      | film       | NULL       | eq_ref |...</span><br><span class="line">+----+-------------+------------+------------+--------+...</span><br></pre></td></tr></table></figure>
<h3 id="ref"><a class="markdownIt-Anchor" href="#ref"></a> <code>ref</code></h3>
<p>这是一种索引访问(有时也叫做索引査找)，它返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，它是査找和扫描的混合体。此类索引访问只有当使用<strong>非唯一性索引或者唯一性索引的非唯一性前缀时</strong>オ会发生。把它叫做 ref 是因为索引要跟某个参考值相比较。这个参考值或者是一个常数，或者是来自多表査询前一个表里的结果值。</p>
<p>可以用于使用 = 或 &lt;=&gt; 运算符进行比较的索引列。</p>
<h3 id="ref_or_null"><a class="markdownIt-Anchor" href="#ref_or_null"></a> <code>ref_or_null</code></h3>
<p>这种连接类型类似于 ref，但是 MySQL 会额外搜索包含 NULL 值的行。此联接类型优化最常用于解析子查询。在以下示例中，MySQL 可以使用 ref_or_null 连接来处理 ref_table：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="operator">=</span> expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="range"><a class="markdownIt-Anchor" href="#range"></a> <code>range</code></h3>
<p>范围扫描就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这比全索引扫描好一些，因为它用不着遍历全部索引。显而易见的范围扫描是带有 <code>BETWEEN</code> 或在 WHERE 子句里带有比较运算法（&lt;&gt;, &lt;=&gt;, &gt;, &gt;=, &lt;, &lt;=）的查询。当 MySQL 使用索引去査找一系列值时，例如 <code>IN()</code> 和 <code>OR</code> 列表，也会显示为范围扫描。<br />
然而，这两者其实是相当不同的访问类型，在性能上有重要的差异。</p>
<p>输出行中的 key 列表示使用了哪个索引。key_len 包含使用的最长的键部分。此类型的 ref 列为 NULL。</p>
<h3 id="index"><a class="markdownIt-Anchor" href="#index"></a> <code>index</code></h3>
<p>这个跟全表扫描一样，只是 MySQL 扫描表时按索引次序进行而不是行。它的主要优点是避免了排序；最大的缺点是要承担按索引次序读取整个表的开销。这通常意味着若是按随机次序访问行，开销将会非常大。<br />
如果在 Extra 列中看到 “Using index”，说明 MySQL 正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行。它比按索引次序全表扫描的开销要少很多。</p>
<h3 id="all"><a class="markdownIt-Anchor" href="#all"></a> <code>ALL</code></h3>
<p>这就是人们所称的全表扫描，通常意味着 MySQL 必须扫描整张表，从头到尾，去找到需要的行。(这里也有个例外，例如在査询里使用了 LIMIT，或者在 Extra 列中显示 “Using distinct/not exists”。)</p>
<h2 id="possible_keys-列"><a class="markdownIt-Anchor" href="#possible_keys-列"></a> possible_keys 列</h2>
<p>这一列显示了査询<strong>可以使用哪些索引</strong>，这是基于査询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早期创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。</p>
<h2 id="key-列"><a class="markdownIt-Anchor" href="#key-列"></a> key 列</h2>
<p>这一列显示了 MySQL <strong>决定采用哪个索引</strong>来优化对该表的访问。如果该索引没有出现在 possible_keys 列中，那么 MySQL 选用它是出于另外的原因一例如，它可能选择了个覆盖索引，哪怕没有 WHERE 子句。<br />
换句话说，possible keys 揭示了哪一个索引能有助于高效地行査找，而 key 显示的是优化采用哪一个索引可以最小化査询成本。下面就是一个例子。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor \G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: idx_fk_film_id</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5462</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure>
<h2 id="key_len-列"><a class="markdownIt-Anchor" href="#key_len-列"></a> <code>key_len</code> 列</h2>
<p>该列显示了 MySQL 在索引里使用的字节数。如果 MySQL 正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列。要记住，MySQL5.5 及之前版本只能使用索引的最左前缀。举例来说，sakila.film_actor 的主键是两个 SMALLINT 列，并且每个 SMALLINT 列是两字节，那么索引中的每项是 4 字节。以下就是一个査询的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT actor_id, film_id FROM sakila.film_actor WHERE actor_id=4;</span></span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br><span class="line">| id | select_type | table      | possible_keys          | key     | key_len |...</span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br><span class="line">|  1 | SIMPLE      | film_actor | PRIMARY,idx_fk_film_id | PRIMARY | 2       |...</span><br><span class="line">+----+-------------+------------+------------------------+---------+---------+...</span><br></pre></td></tr></table></figure>
<p>基于结果中的 key_len 列，可以推断出査询使用唯一的首列一 actor_id 列，来执行索引査找。当我们计算列的使用情况时，务必把字符列中的字符集也考虑进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> CREATE TABLE t</span></span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt;     a char(3) NOT NULL,</span><br><span class="line">    -&gt;     b int(11) NOT NULL,</span><br><span class="line">    -&gt;     c char(1) NOT NULL,</span><br><span class="line">    -&gt;     PRIMARY KEY (a, b, c)</span><br><span class="line">    -&gt; ) ENGINE = MYISAM</span><br><span class="line">    -&gt;   DEFAULT CHARSET = utf8;</span><br><span class="line">    </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> INSERT INTO t(a, b, c)</span></span><br><span class="line">    -&gt; SELECT DISTINCT LEFT(TABLE_SCHEMA, 3), ORD(TABLE_NAME), LEFT(COLUMN_NAME, 1)</span><br><span class="line">    -&gt; FROM INFORMATION_SCHEMA.COLUMNS;</span><br><span class="line">    </span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT a FROM t WHERE a = <span class="string">&#x27;sak&#x27;</span> AND b = 112;</span></span><br><span class="line">...+------+---------------+---------+---------+...</span><br><span class="line">...| type | possible_keys | key     | key_len |...</span><br><span class="line">...+------+---------------+---------+---------+...</span><br><span class="line">...| ref  | PRIMARY       | PRIMARY | 13      |...</span><br><span class="line">...+------+---------------+---------+---------+...</span><br></pre></td></tr></table></figure>
<p>这个査询中平均长度为 13 字节，即为 a 列和 b 列的总长度。a 列是 3 个字符，utf8 下每一个最多为 3 字节，而 b 列是一个 4 字节整型。则 key_len = 3*3 + 4；</p>
<p>key_len 列显示了在索引字段中可能的最大长度，而不是表中数据使用的实际字节数。<br />
在前面例子中 MySQL 总是显示 13 字节，即使 a 列恰巧只包含一个字符长度。换言之，key_len 通过査找表的定义而被计算出，而不是表中的数据。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>长度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串</td>
<td>char(n)：n 字节长度；varchar(n)：2 字节存储字符串长度</td>
<td>如果是 utf-8，则 n 字节变为 3n</td>
</tr>
<tr>
<td>数值类型</td>
<td>tinyint：1 字节；smallint：2 字节；int：4 字节；bigint：8 字节</td>
<td></td>
</tr>
<tr>
<td>时间类型</td>
<td>date：3 字节；timestamp：4 字节；datetime：8 字节</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="ref-列"><a class="markdownIt-Anchor" href="#ref-列"></a> ref 列</h2>
<p>ref 列显示将哪些列或常量与 key 列中的列出的索引进行比较，以从表中选择行。下面是一个展示关联条件和别名组合的例子。注意，ref 列反映了在査询文本中 film 表是如何以 f 为别名的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN</span></span><br><span class="line">    -&gt; SELECT STRAIGHT_JOIN f.film_id</span><br><span class="line">    -&gt; FROM sakila.film AS f</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor AS fa</span><br><span class="line">    -&gt;              ON f.film_id = fa.film_id AND fa.actor_id = 1</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor AS a USING (actor_id);</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br><span class="line">...| table |...| key                | key_len | ref                    |...</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br><span class="line">...| f     |...| idx_fk_language_id | 1       | NULL                   |...</span><br><span class="line">...| fa    |...| PRIMARY            | 4       | const,sakila.f.film_id |...</span><br><span class="line">...| a     |...| PRIMARY            | 2       | const                  |...</span><br><span class="line">...+-------+...+--------------------+---------+------------------------+...</span><br></pre></td></tr></table></figure>
<h2 id="rows-列"><a class="markdownIt-Anchor" href="#rows-列"></a> rows 列</h2>
<p>rows 列表示 MySQL 认为执行查询必须检查的行数。这个数字是内嵌循环关联计划里的循环数目。也就是说它不是 MySQL 认为它最终要从表里读取出来的行数，而是 MySQL 为了找到符合査询的每一点上标谁的那些行而必须读取的行的平均数。（这个标准包括 SQL 里给定的条件，以及来自联接次序上前一个表的当前列。）</p>
<p>根据表的统计信息和索引的选用情况，这个估算可能很不精确。在有些版本里,它也反映不出 LIMIT 子句。举例来说，下面这个査询不会真的检査1000 行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain select * from sakila.film <span class="built_in">limit</span> 1\G</span></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film</span><br><span class="line">            ...</span><br><span class="line">         rows: 1000</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure>
<p>通过把所有 rows 列的值相乘，可以粗略地估算出整个査询会检査的行数。例如，以下这个査询大约会检査 5400 行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN</span></span><br><span class="line">    -&gt; SELECT f.film_id</span><br><span class="line">    -&gt; FROM sakila.film AS f</span><br><span class="line">    -&gt;          INNER JOIN sakila.film_actor AS fa USING (film_id)</span><br><span class="line">    -&gt;          INNER JOIN sakila.actor AS a USING (actor_id);</span><br><span class="line">...+------+...</span><br><span class="line">...| rows |...</span><br><span class="line">...+------+...</span><br><span class="line">...|  200 |...</span><br><span class="line">...|   27 |...</span><br><span class="line">...|    1 |...</span><br><span class="line">...+------+...</span><br></pre></td></tr></table></figure>
<p>要记住这个数字是 MySQL 认为它要检査的行数，而不是结果集里的行数。同时也要认识到有很多优化手段，例如关联缓冲区和缓存，无法影响到行数的显示。MySQL 可能不必真的读所有它估计到的行，它也不知道任何关于操作系统或硬件缓存的信息。</p>
<h2 id="partitions-filtered-列"><a class="markdownIt-Anchor" href="#partitions-filtered-列"></a> partitions、filtered 列</h2>
<p>partitions 表示所匹配的分区；</p>
<p>filtered 显示的是针对表里符合某个条件（WHERE 子句或联接条件）的记录数的百分比所做的一个悲观估算。最大值为100，这表示未对行进行过滤。值从 100 减小表示过滤量增加。rows 显示要检查的行的估计数，rows × filtered 显示与接下来的表连接的行数。例如，如果 rows 为1000，filtered 为 50.00（50％），则与下表连接的行数为1000×50％ = 500。</p>
<h2 id="extra-列"><a class="markdownIt-Anchor" href="#extra-列"></a> Extra 列</h2>
<p>这一列包含的是不适合在其他列显示的额外信息。 MySQL 用户手册里记录了大多数可以在这里出现的值。</p>
<p>常见的最重要的值如下：</p>
<h3 id="using-index"><a class="markdownIt-Anchor" href="#using-index"></a> ”<em>Using index</em>“</h3>
<p>此值表示 MySQL 将使用覆盖索引，以避免访问表。不要把覆盖索引和 index 访问类型弄混了。</p>
<p>表示查询的列被索引覆盖，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表。</p>
<h3 id="using-where"><a class="markdownIt-Anchor" href="#using-where"></a> “<em>Using where</em>”</h3>
<p>这意味着 MySQL 服务器将在存储擎检索行后再进行过滤。许多 WHERE 条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带 WHERE 子句的査询都会显示 “Using where”。有时 “Using where” 的出现就是个暗示：査询可受益于不同的索引。</p>
<p>WHERE 子句用于限制要与下一个表匹配或发送给客户端的行。除非您特别打算从表中获取或检查<strong>所有行</strong>，否则，如果 Extra 值不是 Using where 并且表联接类型为 ALL 或 index，则查询中可能出现了问题。</p>
<h3 id="using-temporary"><a class="markdownIt-Anchor" href="#using-temporary"></a> “<em>Using temporary</em>”</h3>
<p>为了完成查询，MySQL 需要创建一个临时表来保存结果。如果查询包含以不同方式列出列的 <code>GROUP_BY</code> 和 <code>ORDER BY</code> 子句，通常会发生这种情况。</p>
<h3 id="using-filesort"><a class="markdownIt-Anchor" href="#using-filesort"></a> “<em>Using filesort</em>”</h3>
<p>这意味着 MySQL 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。 如果读取到的行数据于 sort_buffer_size 系统变量相比小，则在内存排序，相反内存不够或超过该变量，那么 MySQL 会先将数据分块，对每个独立的块使用 “快速排序” 进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。 EXPLAIN 不会告诉你 MySQL 将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。</p>
<h3 id="using-join-buffer"><a class="markdownIt-Anchor" href="#using-join-buffer"></a> “<em>Using join buffer</em>”</h3>
<p>Using join buffer 表示使用连接缓冲区的行提取匹配行。</p>
<p>内部细分可能包含：块级联循环算法（Block Nested-Loop），批量键访问算法（Batched Key Access），hash join。</p>
<h3 id="impossible-where"><a class="markdownIt-Anchor" href="#impossible-where"></a> “<em>Impossible where</em>”</h3>
<p>WHERE 子句始终为 false，无法选择任何行。</p>
<h3 id="select-tables-optimized-away"><a class="markdownIt-Anchor" href="#select-tables-optimized-away"></a> “<em>Select tables optimized away</em>”</h3>
<p>表示 SELECT 语句没有遍历表或者索引就返回数据了。</p>
<p>比如在优化阶段可以确定要读取的行（通过读取索引行），则在查询阶段无需读取任何表。如下面的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> EXPLAIN SELECT MIN(film_id) FROM sakila.film;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 调优指南</title>
    <url>/java/jvm/JVM-%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>从桌面上的小 applet 到大型服务器上的 Web 服务，各种各样的应用程序都使用 Java。为了支持这种多样化的部署场景，Java HotSpot VM 提供了多个垃圾收集器，每个垃圾收集器旨在满足不同的需求。Java 根据运行应用程序的计算机的类别选择最合适的垃圾收集器。但是，此选择可能并非对每个应用程序都是最佳的。具有严格性能目标或其他要求的用户，开发人员和管理员可能需要明确选择垃圾回收器并调整某些参数以实现所需的性能水平。本文档提供了有助于完成这些任务的信息。</p>
<p>首先，在串行，stop-the-world 收集器的上下文中描述了垃圾收集器的一般功能和基本的调整选项。然后介绍了其他收集器的特定功能以及选择收集器时要考虑的因素。</p>
<span id="more"></span>
<h1 id="什么是垃圾收集器"><a class="markdownIt-Anchor" href="#什么是垃圾收集器"></a> 什么是垃圾收集器？</h1>
<p>垃圾收集器（GC）自动管理应用程序的动态内存分配请求。</p>
<p>垃圾收集器通过以下操作执行自动动态内存管理：</p>
<ul>
<li>从操作系统分配内存并将其还给操作系统。</li>
<li>根据请求将内存分发给应用程序。</li>
<li>确定应用程序仍在使用该内存的哪些部分。</li>
<li>回收未使用的内存，以供应用程序重新使用。</li>
</ul>
<p>Java HotSpot 垃圾收集器采用了各种技术来提高这些操作的效率：</p>
<ul>
<li>将分代清理与老化结合使用，可以将精力集中在堆中最有可能包含大量可回收内存区域的区域上。</li>
<li>使用多个线程积极地使操作并行化，或者在后台与应用程序并发执行一些长时间运行的操作。</li>
<li>尝试通过压缩活动对象来恢复较大的连续可用内存。</li>
</ul>
<h1 id="为什么选择垃圾收集器很重要"><a class="markdownIt-Anchor" href="#为什么选择垃圾收集器很重要"></a> 为什么选择垃圾收集器很重要？</h1>
<p>垃圾收集器的目的是使应用程序开发人员从手动动态内存管理中解放出来。开发人员摆脱了将分配与释放分配相匹配的要求，并密切注意分配的动态内存的生命周期。这完全消除了一些与内存管理有关的错误操作，但付出了一些额外的运行时开销。 Java HotSpot VM 提供了一系列垃圾回收算法供您选择。</p>
<p>什么时候选择垃圾收集器很重要？对于某些应用程序，答案永远是不重要。也就是说，在存在垃圾收集的情况下，应用程序可以很好地执行，并具有适度的收集频率和持续暂停时间。但是，对于大型应用程序却不是这种情况，特别是那些具有大量数据（数 GB），许多线程和高事务处理率的应用程序。</p>
<p>阿姆达尔（Amdahl）定律（给定问题中的可并行加速部分受到问题的可顺序部分的限制）意味着大多数工作负载无法完美并行化。某些部分始终是顺序的，不能从并行性中受益。在 Java 平台中，当前有四种受支持的垃圾收集替代方案，除了其中一种（串行 GC），并行化工作以提高性能。尽可能减少垃圾收集的开销非常重要。</p>
<h1 id="人机工程学"><a class="markdownIt-Anchor" href="#人机工程学"></a> 人机工程学</h1>
<p>人机工程学是 Java 虚拟机（JVM）和垃圾收集启发法（例如基于行为的启发法）提高应用程序性能的过程。</p>
<p>JVM 作为垃圾收集器，堆大小和运行时编译器提供了依赖于平台的默认选择。这些选择可满足不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调整可动态优化堆的大小，以满足应用程序的指定行为。</p>
<p>本节描述了这些默认选择和基于行为的调整。在使用后续各节中介绍的更详细的控件之前，请使用这些默认值。</p>
<h2 id="垃圾收集器堆和运行时编译器的默认选择"><a class="markdownIt-Anchor" href="#垃圾收集器堆和运行时编译器的默认选择"></a> 垃圾收集器，堆和运行时编译器的默认选择</h2>
<p>这些是垃圾收集器，堆大小和运行时编译器的默认选择：</p>
<h3 id="java-8"><a class="markdownIt-Anchor" href="#java-8"></a> Java 8</h3>
<p>具有以下属性的机器被认为是服务器类型机器：</p>
<ul>
<li>2 个或更多物理处理器</li>
<li>2 GB 或更多的物理内存</li>
</ul>
<p>在服务器级计算机上，默认情况下选择以下内容：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html">吞吐量垃圾收集器</a>（并行垃圾收集器 - Parallel Collector）</li>
<li>初始堆大小为 1/64 的物理内存，最大为 1 GB</li>
<li>最大堆大小为物理内存的 1/4，最大为 1 GB</li>
<li>服务器运行时编译器</li>
</ul>
<h3 id="java-11"><a class="markdownIt-Anchor" href="#java-11"></a> Java 11</h3>
<ul>
<li>Garbage-First (G1) 收集器</li>
<li>GC 线程的最大数量受堆大小和可用 CPU 资源的限制</li>
<li>初始堆大小为物理内存的 1/64</li>
<li>最大堆大小为物理内存的 1/4</li>
<li>分层编译器，同时使用 C1 和 C2</li>
</ul>
<blockquote>
<p><strong>C1 compiler</strong></p>
<p>快速，轻度优化的字节码编译器。执行一些值编号，内联和类分析。使用简单的面向 CFG 的 SSA “high” IR，面向机器的 “low” IR，线性扫描寄存器分配以及模板样式的代码生成器。</p>
<p><strong>C2 compiler</strong></p>
<p>高度优化的字节码编译器，也称为 “opto”。使用 “sea of nodes” SSA “ideal” IR，它降低为同类机器特定的 IR。具有图形着色寄存器分配器；为所有机器状态上色，包括局部，全局和参数寄存器以及堆栈。</p>
</blockquote>
<h3 id="查看当前运行-jvm-收集器"><a class="markdownIt-Anchor" href="#查看当前运行-jvm-收集器"></a> 查看当前运行 JVM 收集器</h3>
<ul>
<li>
<p>Java &lt;= 8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -heap &lt;pid&gt; | grep GC</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Java &gt; 9</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jhsdb jmap --heap --pid &lt;pid&gt; | grep GC</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基于行为的调整"><a class="markdownIt-Anchor" href="#基于行为的调整"></a> 基于行为的调整</h2>
<p>可以将 Java HotSpot VM 垃圾收集器配置为优先满足以下两个目标之一：<strong>最大暂停时间</strong>和<strong>应用程序吞吐量</strong>。如果达到了首选目标，则收集器将尝试使其他目标最大化。自然地，这些目标并不总是能够满足的：应用程序需要最小的堆来容纳至少所有实时数据，而其他配置可能会阻止达到某些或所有期望的目标。</p>
<p>下面的配置适用于吞吐量并行收集器和 G1 收集器。</p>
<h3 id="最大暂停时间目标"><a class="markdownIt-Anchor" href="#最大暂停时间目标"></a> 最大暂停时间目标</h3>
<p>暂停时间是垃圾收集器停止应用程序并恢复不再使用的空间的持续时间。最大暂停时间目标的目的是限制这些暂停中的最长时间。</p>
<p>垃圾回收器会保持平均的停顿时间和该平均值的方差。平均值是从执行开始时获取的，但会对其进行加权，以使最近的暂停次数变得更多。如果平均时间加上暂停时间的方差大于最大暂停时间目标，则垃圾收集器认为未达到目标。</p>
<p>最大暂停时间目标是通过命令行选项 <code>-XX:MaxGCPauseMillis=&lt;nnn&gt;</code>  指定的。这被解释为向垃圾收集器的提示，要求暂停时间为 &lt;<em>nnn</em>&gt; 毫秒或更短。垃圾收集器会调整 Java 堆大小和与垃圾收集相关的其他参数，以使垃圾收集的暂停时间短于 &lt;<em>nnn</em>&gt; 毫秒。最大暂停时间目标的默认值因收集器而异。<strong>这些调整可能导致垃圾回收更加频繁地发生，从而降低了应用程序的整体吞吐量</strong>。</p>
<h3 id="吞吐量目标"><a class="markdownIt-Anchor" href="#吞吐量目标"></a> 吞吐量目标</h3>
<p>吞吐量目标是根据收集垃圾所花费的时间来衡量的，而在垃圾收集之外所花费的时间就是应用时间。</p>
<p>该目标由命令行选项 <code>-XX:GCTimeRatio=&lt;nnn&gt;</code> 指定。垃圾收集时间与应用程序时间的比率为 1/(1 + <em><nnn></em>)。例如，<code>-XX:GCTimeRatio=19</code> 设置目标垃圾收集的时间占总时间的 1/20 或 5％。</p>
<p>垃圾收集所花费的时间是所有垃圾收集引起的暂停的总时间。<strong>如果未达到吞吐量目标，那么垃圾收集器可能采取的一种措施是增加堆的大小，以便在两次收集暂停之间花费在应用程序中的时间可以更长。</strong></p>
<h3 id="占用空间"><a class="markdownIt-Anchor" href="#占用空间"></a> 占用空间</h3>
<p>如果已满足吞吐量和最大暂停时间目标，则垃圾收集器会减小堆的大小，直到无法满足其中一个目标（始终是吞吐量目标）。可以分别使用 <code>-Xms=&lt;nnn&gt;</code> 和 <code>-Xmx=&lt;mmm&gt;</code> 分别设置垃圾收集器可以使用的最小和最大堆大小。</p>
<h2 id="调整策略"><a class="markdownIt-Anchor" href="#调整策略"></a> 调整策略</h2>
<p>堆增大或缩小到支持所选吞吐量目标的大小。了解有关堆调整策略的信息，例如选择最大堆大小和选择最大暂停时间目标。</p>
<p>除非您知道需要的堆大于默认的最大堆大小，否则不要为堆选择最大值。选择足以满足您的应用程序的吞吐量目标。</p>
<p>应用程序行为的更改可能导致堆增大或缩小。例如，如果应用程序开始以更高的速率分配，则堆会增长以保持相同的吞吐量。</p>
<p>如果堆增长到最大大小，并且无法满足吞吐量目标，则最大堆大小对于吞吐量目标而言太小。将最大堆大小设置为接近平台上总物理内存的值，再次执行该应用程序。如果仍然没有达到吞吐量目标，那么对于平台上的可用内存来说，应用程序时间目标就太高了。</p>
<p>如果可以满足吞吐量目标，但是暂停时间太长，则选择最大暂停时间目标。选择最大暂停时间目标可能意味着您的吞吐量目标将无法实现，因此请选择对应用程序可接受的折衷值。</p>
<p>当垃圾收集器试图满足竞争目标时，堆的大小通常会发生波动。即使应用程序已达到稳定状态，也是如此。达到吞吐量目标（可能需要更大的堆）的压力与以获得最大的暂停时间和最小的占用空间（这两者都可能需要一个小堆）的目标相互竞争。</p>
<h1 id="垃圾收集器实现"><a class="markdownIt-Anchor" href="#垃圾收集器实现"></a> 垃圾收集器实现</h1>
<p>Java 平台的优势之一在于，它使开发人员免受内存分配和垃圾回收的复杂性的困扰。</p>
<p>但是，当垃圾收集是主要瓶颈时，了解实现的某些方面很有用。垃圾收集器对应用程序使用对象的方式进行了假设，并且这些反映在可调整的参数中，可以调整这些参数以提高性能而不会牺牲抽象的能力。</p>
<h3 id="分代垃圾收集器"><a class="markdownIt-Anchor" href="#分代垃圾收集器"></a> 分代垃圾收集器</h3>
<p>当无法从正在运行的程序中任何其他活动对象的任何引用中访问该对象时，该对象被视为垃圾，并且 VM 可以重用其内存。</p>
<p>一种理论上最直接的垃圾回收算法，每次运行时都会遍历每个可到达的对象。任何剩余的对象都被视为垃圾。这种方法花费的时间与活动对象的数量成正比，这对于维护大量活动数据的大型应用程序是不允许的。</p>
<p>Java HotSpot VM 包含许多不同的垃圾收集算法，这些算法均使用称为分代收集的技术。天真的垃圾收集每次都会检查堆中的每个活动对象，而分代收集则利用大多数应用程序的一些经验观察到的属性，以最大程度地减少回收未使用的（垃圾）对象所需的工作。这些观察到的特性中最重要的是<em>弱分代假设（weak generational hypothesis）</em>，该假设指出大多数物体只能存活很短的时间。</p>
<p>下图中的蓝色区域是对象生命周期的典型分布。 x 轴显示以分配的字节为单位的对象生存期。 y 轴上的字节数是具有相应生存期的对象中的总字节数。左侧的尖峰表示分配后可以回收的对象（换句话说，已“死亡”）。例如，迭代器对象通常仅在单个循环期间才处于活动状态。</p>
<p><img src="../../../images/java/jvm/jsgct_dt_003_alc_vs_srvng.png" alt="Typical Distribution for Lifetimes of Objects" /></p>
<p>有些对象的寿命更长，因此分布向右延伸。例如，通常在初始化时分配一些对象，这些对象一直存在直到 VM 退出。在这两个极端之间是在某些中间计算期间仍处于活动状态的对象，在此处被视为初始峰值右侧的区域。一些应用程序的外观分布非常不同，但是令人惊讶的是，大量应用程序具有这种总体形状。通过关注大多数对象“早逝”这一事实，可以进行有效的收集。</p>
<h3 id="分代"><a class="markdownIt-Anchor" href="#分代"></a> 分代</h3>
<p>为了针对这种情况进行优化，内存是分代管理的（存储着不同年龄对象的内存池）。当一分代填满时，垃圾收集会发生在每一代中。</p>
<p>绝大多数对象分配在专用于年轻对象（<em>新生代</em>）的池中，并且大多数对象都死在那里。当新生代填满时，将导致***次要收集（Minor GC）***  ，其中仅收集新生代，不会回收其他代的垃圾。首先，这种收集的费用与所收集的存活对象的数量成正比；新生代中死亡对象的收集非常快。通常，在每个 Minor GC 期间，来自新生代的幸存对象中有一部分会转移到老年代。最终，因为老年代填满并必须被收集，从而导致一个  ***主要收集（Major GC）***，整个堆都会被收集。Major GC 的持续时间通常比 Minor GC 的持续时间长得多，因为涉及的对象数量很多。下图显示了串行垃圾收集器中各代的默认排列：</p>
<p><img src="../../../images/java/jvm/jsgct_dt_001_armgnt_gn_new.png" alt="Default Arrangement of Generations in the Serial Collector" /></p>
<p>启动时，Java HotSpot VM 会在地址空间中保留整个 Java 堆，但除非需要，否则不会为其分配任何物理内存。覆盖 Java 堆的整个地址空间被逻辑分为新生代和老年代。</p>
<p>新生代由 <code>伊甸园（eden）</code> 和两个 <code>幸存者（survivor）</code> 空间组成。大多数对象最初是在 eden 中分配的。在垃圾收集期间，一个 survivor 空间可能随时被清空用作 eden 和其他 survivor 空间中活动对象的目的地，而另一个幸存者空间则用作垃圾收集者的目的地；垃圾回收后，eden 和源 survivor 空间被清空。在下一次垃圾收集中，将交换两个幸存者空间。最近填充满的一个空间中的活动对象是将要复制到的另一个幸存者的来源。以这种方式在幸存者空间之间复制对象，直到它们被复制了一定次数或空间不足为止，这些对象将被复制到老年代中，此过程也称为<em>老化｜晋升（aging</em>）。</p>
<h3 id="性能考量"><a class="markdownIt-Anchor" href="#性能考量"></a> 性能考量</h3>
<p>垃圾收集的主要衡量指标是吞吐量和延迟。</p>
<ul>
<li>
<p>吞吐量是长时间内未花费在垃圾回收上的总时间的百分比。吞吐量包括分配所花费的时间（但是通常不需要调整分配速度）。</p>
</li>
<li>
<p>延迟是应用程序的响应能力。垃圾回收暂停会影响应用程序的响应速度。</p>
</li>
</ul>
<p>用户对垃圾回收有不同的要求。例如，有些人认为 Web 服务器的正确度量标准是吞吐量，因为垃圾回收期间的暂停可能是可以容忍的，或者可能被网络延迟所掩盖。但是，在交互式图形程序中，即使短暂的暂停也会对用户体验产生负面影响。</p>
<p>一些用户对其他注意事项敏感。占用空间是进程的工作集，以页和缓存行计算而来。在物理内存有限或有许多进程的系统上，占用空间可能决定可伸缩性。*即时性（Promptness）*是指对象死掉到内存可用之间的时间，这是分布式系统（包括远程方法调用（RMI））的重要考虑因素。</p>
<p>通常，为特定分代选择大小是这些考虑之间的权衡。例如，一个非常大的新生代可以使吞吐量最大化，但是这样做会占用空间，及时性和暂停时间。也可以通过使用少量的新生代来最小化新生代停顿，但会降低吞吐量。一个分代的大小不会影响另一分代的收集频率和暂停时间。</p>
<p>没有选择分代大小的绝对的正确方法。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾收集器的选择并非总是最佳选择，并且可能会被命令行选项所替代。请参阅影响垃圾收集性能的因素。</p>
<h3 id="吞吐量和空间占用测量"><a class="markdownIt-Anchor" href="#吞吐量和空间占用测量"></a> 吞吐量和空间占用测量</h3>
<p>吞吐量和占用空间最好使用特定于应用程序的指标来衡量。</p>
<p>通过检查虚拟机本身的诊断输出，很容易估计由于垃圾收集而引起的暂停。</p>
<p>命令行选项 <code>-verbose:gc</code> 在每次收集中输出有关堆和垃圾回收的信息。这是一个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M-&gt;57M(307M) (15,646s, 15,651s) 5,048ms</span><br><span class="line">[16,162s][info ][gc] GC(37) Pause Young (G1 Evacuation Pause) 238M-&gt;57M(307M) (16,146s, 16,162s) 16,565ms</span><br><span class="line">[16,367s][info ][gc] GC(38) Pause Full (System.gc()) 69M-&gt;31M(104M) (16,202s, 16,367s) 164,581ms</span><br></pre></td></tr></table></figure>
<p>输出显示了两个新生代的收集，然后是由应用程序调用 System.gc() 启动的完整收集。这些行以一个时间戳开始，该时间戳指示从应用程序启动开始的时间。接下来是有关此行的日志级别（info）和标签（gc）的信息。其后是 GC 标识号。在这种情况下，存在三个 GC，其编号分别为 36、37 和 38。然后记录 GC 的类型和说明 GC 的原因。此后，将记录有关内存消耗的一些信息。该日志使用格式 “GC 之前使用情况”-&gt;“ GC 之后使用情况”（“堆总大小”）。</p>
<p>在示例的第一行中，239M-&gt;57M(307M)，这意味着在 GC 之前该区域使用了 239 MB，GC 清除了大部分内存，但仍有 57 MB 存活。堆总大小为 307 MB。请注意，在此示例中，完整的 GC 将堆从 307 MB 减小到 104 MB。在内存使用情况信息之后，将记录 GC 的开始和结束时间以及持续时间（结束-开始）。</p>
<p><code>-verbose:gc</code> 命令是 <code>-Xlog:gc</code> 的别名。 -Xlog 是用于 HotSpot JVM 的常规日志记录配置选项。这是一个基于标签的系统，其中 gc 是标签之一。要获取有关 GC 正在执行的操作的更多信息，您可以配置日志记录以打印具有 gc 标记和任何其他标记的任何消息。命令行选项是 <code>-Xlog:gc*</code>。</p>
<p>这是一个用 <code>-Xlog:gc*</code> 记录的 G1 新生代收集的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[10.178s][info][gc,start ] GC(36) Pause Young (G1 Evacuation Pause) </span><br><span class="line">[10.178s][info][gc,task ] GC(36) Using 28 workers of 28 for evacuation </span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Pre Evacuate Collection Set: 0.0ms</span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Evacuate Collection Set: 6.9ms </span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Post Evacuate Collection Set: 5.9ms </span><br><span class="line">[10.191s][info][gc,phases ] GC(36) Other: 0.2ms </span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Eden regions: 286-&gt;0(276) </span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Survivor regions: 15-&gt;26(38)</span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Old regions: 88-&gt;88 </span><br><span class="line">[10.191s][info][gc,heap ] GC(36) Humongous regions: 3-&gt;1 </span><br><span class="line">[10.191s][info][gc,metaspace ] GC(36) Metaspace: 8152K-&gt;8152K(1056768K)</span><br><span class="line">[10.191s][info][gc ] GC(36) Pause Young (G1 Evacuation Pause) 391M-&gt;114M(508M) 13.075ms </span><br><span class="line">[10.191s][info][gc,cpu ] GC(36) User=0.20s Sys=0.00s Real=0.01s</span><br></pre></td></tr></table></figure>
<h1 id="影响垃圾收集性能的因素"><a class="markdownIt-Anchor" href="#影响垃圾收集性能的因素"></a> 影响垃圾收集性能的因素</h1>
<h2 id="总堆大小"><a class="markdownIt-Anchor" href="#总堆大小"></a> 总堆大小</h2>
<p>影响垃圾收集性能的最重要因素是总可用内存。由于收集是在分代填满时发生的，因此吞吐量与可用内存量成反比。</p>
<blockquote>
<p>以下有关堆的增长和收缩，堆布局和默认值的讨论以串行收集器为例。尽管其他收集器使用类似的机制，但此处介绍的详细信息可能不适用于其他收集器。有关其他收集器的类似信息，请参阅相应主题。</p>
</blockquote>
<h3 id="影响分代大小的堆选项"><a class="markdownIt-Anchor" href="#影响分代大小的堆选项"></a> 影响分代大小的堆选项</h3>
<p>许多选项会影响分代大小。下图说明了堆中已提交空间和虚拟空间之间的区别。在虚拟机初始化时，将保留堆的整个空间。可以使用 <code>-Xmx</code> 选项指定保留空间的大小。如果 <code>-Xms</code> 参数的值小于 <code>-Xmx</code> 参数的值，则并非所有保留的空间都会立即提交给虚拟机。在此图中，未使用的空间标记为 “virtual”。堆的不同部分，即老年代和新生代，可以根据需要增长到虚拟空间的极限。</p>
<p>一些参数是堆的一部分与另一部分的比率。例如，参数 <code>–XX:NewRatio</code> 表示老年代与新生代的相对大小。</p>
<p><img src="../../../images/java/jvm/jsgct_dt_006_prm_gn_sz_new.png" alt="Heap Options" /></p>
<h3 id="堆大小的默认选项值"><a class="markdownIt-Anchor" href="#堆大小的默认选项值"></a> 堆大小的默认选项值</h3>
<p>默认情况下，虚拟机会在每次收集增加或缩小堆，以尝试将每次收集中活动对象的可用空间比例保持在特定范围内。</p>
<p>该目标范围由 <code>-XX:MinHeapFreeRatio=</code>&lt;<em>minimum</em>&gt; 和 <code>-XX:MaxHeapFreeRatio</code>=&lt;<em>maximum</em>&gt; 选项设置为百分比，总大小的下限为 <code>–Xms&lt;min&gt;</code>，上限为 <code>–Xmx&lt;max&gt;</code> 。下表中显示了 64 位 Solaris 操作系统（SPARC 平台版本）的默认选项。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Option</th>
<th style="text-align:left">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:MinHeapFreeRatio</code></td>
<td style="text-align:left">40</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:MaxHeapFreeRatio</code></td>
<td style="text-align:left">70</td>
</tr>
<tr>
<td style="text-align:left"><code>-Xms</code></td>
<td style="text-align:left">6656 KB</td>
</tr>
<tr>
<td style="text-align:left"><code>-Xmx</code></td>
<td style="text-align:left">calculated</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其他参数和选项可能会影响这些默认值。要验证默认值，请使用 <code>-XX:+PrintFlagsFinal</code> 选项。</p>
</blockquote>
<p>使用这些选项，如果某代中的可用空间百分比降到 40％ 以下，则该代将扩展以维持 40％ 的可用空间，直到该代最大允许的大小。同样，如果可用空间超过 70％，则分代会收缩，因此只有 70％ 的空间可用，这取决于分代的最小大小。</p>
<p>如表所述，默认的最大堆大小是由 JVM 计算的值。 Java SE 中为 Parallel 收集器使用的计算方式现在已用于所有垃圾收集器。计算的一部分因素是 64 位平台的最大堆大小的上限。请参见<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/parallel-collector1.html#GUID-74BE3BC9-C7ED-4AF8-A202-793255C864C4">并行收集器默认堆大小</a>。客户端 JVM 的计算与此类似，这导致最大堆大小小于服务器 JVM。</p>
<p>以下是有关服务器应用程序堆大小的一般准则：</p>
<ul>
<li>除非您在暂停方面遇到问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常太小。</li>
<li>将 <code>-Xms</code> 和 <code>-Xmx</code> 设置为相同的值可以提高可预测性，因为消除了虚拟机最重要的确定大小的决策。但是，如果选择不当，虚拟机将无法补偿。</li>
<li>通常，随着处理器数量的增加，内存也会增加，因为分配可以并行进行。</li>
</ul>
<h2 id="新生代"><a class="markdownIt-Anchor" href="#新生代"></a> 新生代</h2>
<p>在总可用内存之后，影响垃圾收集性能的第二大影响因素是专用于新生代的堆的比例。</p>
<p>**新生代越大，Minor-次要 收集的次数就越少。**但是，对于有限的堆大小，较大的新生代意味着较小的老年代，<strong>这将增加 Major-主要 收集的频率</strong>。最佳选择取决于应用程序分配的对象的生命周期分布。</p>
<h3 id="新生代大小选项"><a class="markdownIt-Anchor" href="#新生代大小选项"></a> 新生代大小选项</h3>
<p>通常，新生代的大小受 <code>-XX:NewRatio</code> 该选项控制。</p>
<p>比如，设置 <code>-XX:NewRatio=3</code> 表示新生代与老年代之间的比率为 1:3。换句话说，伊甸园-eden 空间和 幸存者-survivor 空间的总大小将是堆总大小的四分之一。</p>
<p>选项 <code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code> 从下方和上方限制了新生代的大小。将这些值设置为相同的值可以修复新生代，就像将 <code>-Xms</code> 和 <code>-Xmx</code> 设置为相同的值可以修复总堆大小一样。与 <code>-XX:NewRatio</code> 允许的整数倍相比，这对于以更精细的粒度调整新生代很有用。</p>
<h3 id="幸存者-survivor-空间大小"><a class="markdownIt-Anchor" href="#幸存者-survivor-空间大小"></a> 幸存者-Survivor 空间大小</h3>
<p>您可以使用选项 <code>-XX:SurvivorRatio</code> 来调整幸存者空间的大小，但这通常对性能并不重要。</p>
<p>例如，<code>-XX:SurvivorRatio=6</code> 将伊甸园和幸存空间之间的比率设置为 6:1。换句话说，每个幸存者空间将是伊甸园大小的六分之一，因此是新生代的八分之一（而不是七分之一，因为有两个幸存者空间）。</p>
<p>如果幸存者空间太小，那么收集时复制将直接溢出到老年代中。如果幸存者空间太大，那么它们将毫无用处。在每次垃圾回收时，虚拟机都会选择一个阈值数，该阈值是对象在变旧之前可以复制的次数。选择该阈值可使幸存者半满。您可以使用日志配置 <code>-Xlog:gc,age</code> 可用于显示此阈值和新生代对象的寿命。</p>
<p><strong>64 位 Solaris 幸存者空间大小的默认选项值</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Option</th>
<th style="text-align:left">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:NewRatio</code></td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:NewSize</code></td>
<td style="text-align:left">1310 MB</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:MaxNewSize</code></td>
<td style="text-align:left">not limited</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:SurvivorRatio</code></td>
<td style="text-align:left">8</td>
</tr>
</tbody>
</table>
<p>从总堆的最大大小和 <code>-XX:NewRatio</code> 参数的值计算出新生代的最大大小。</p>
<p><code>-XX:MaxNewSize</code> 参数的 “not limited” 默认值意味着，除非在命令行上指定了 <code>-XX:MaxNewSize</code> 的值，否则计算所得值不受 <code>-XX:MaxNewSize</code> 的限制。</p>
<p>以下是服务器应用程序的一般准则：</p>
<ul>
<li>首先确定您可以负担得起的虚拟机的最大堆大小。然后，针对新生代绘制性能指标，以找到最佳设置。
<ul>
<li>请注意，最大堆大小应始终小于计算机上安装的内存量，以避免过多的页面错误和崩溃。</li>
</ul>
</li>
<li>如果总堆大小是固定的，则增加新生代大小需求减少老年代大小。保留足够大的老年代以容纳应用程序在任何给定时间使用的所有存活对象，以及一定数量的空闲空间（10％ 到 20％ 或更多）。</li>
<li>遵循先前对老年代的约束：
<ul>
<li>为新生代留出充裕的内存。</li>
<li>随着处理器数量的增加，可以增加新生代的大小，因为分配动作可以并行化。</li>
</ul>
</li>
</ul>
<h1 id="可用的收集器"><a class="markdownIt-Anchor" href="#可用的收集器"></a> 可用的收集器</h1>
<p>到目前为止，讨论的都是串行收集器。 Java HotSpot VM 包括三种不同类型的收集器，每种收集器具有不同的性能特征。</p>
<h2 id="串行收集器"><a class="markdownIt-Anchor" href="#串行收集器"></a> 串行收集器</h2>
<p>串行收集器使用单个线程来执行所有垃圾收集工作，这使之相对高效，因为线程之间没有通信开销。</p>
<p>它最适合单处理器计算机，因为它不能利用多处理器硬件，尽管它在多处理器上对于数据量较小（最大约 100 MB）的应用程序很有用。默认情况下，在某些硬件和操作系统配置上选择了串行收集器，或者可以通过选项 <code>-XX:+UseSerialGC</code> 显式启用串行收集器。</p>
<h2 id="并行收集器"><a class="markdownIt-Anchor" href="#并行收集器"></a> 并行收集器</h2>
<p>并行收集器也称为吞吐量收集器，它是类似于串行收集器的分代收集器。串行收集器和并行收集器之间的主要区别是并行收集器具有多个线程，这些线程用于加速垃圾收集。</p>
<p>并行收集器旨在用于具有在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。您可以使用 <code>-XX:+UseParallelGC</code> 选项启用它。</p>
<p>并行压缩是使并行收集器能够并行执行 Major-主要 收集的功能。如果没有并行压缩，则使用单个线程执行 Major 收集，这会大大限制可伸缩性。如果已指定选项 <code>-XX:+UseParallelGC</code>，则默认情况下启用并行压缩。您可以使用 <code>-XX:-UseParallelOldGC</code> 选项禁用并行压缩。</p>
<h2 id="最主要的大部分并发收集器"><a class="markdownIt-Anchor" href="#最主要的大部分并发收集器"></a> 最主要的大部分并发收集器</h2>
<p>并发标记清除（CMS）收集器和 Garbage-First（G1）垃圾收集器是两个最主要的大部分并发收集器。通常，并发收集器会与应用程序同时执行一些昂贵的工作。</p>
<ul>
<li>
<p>G1 垃圾收集器：<strong>此服务器形式的收集器用于具有大量内存的多处理器计算机。它极有可能满足垃圾收集暂停时间目标，同时实现高吞吐量。</strong></p>
<p>G1 在某些硬件和操作系统配置上默认为选中，或者可以使用 <code>-XX:+UseG1GC</code> 明确启用。</p>
</li>
<li>
<p>CMS 收集器：<strong>此收集器适用于那些希望更短的垃圾收集暂停时间并能够与垃圾收集共享处理器资源的应用程序。</strong></p>
<p>使用选项 <code>-XX:+UseConcMarkSweepGC</code> 启用 CMS 收集器。</p>
</li>
</ul>
<p><strong>从 JDK 9 开始不推荐使用 CMS 收集器。</strong></p>
<h3 id="z-垃圾收集器"><a class="markdownIt-Anchor" href="#z-垃圾收集器"></a> Z 垃圾收集器</h3>
<p>Z 垃圾收集器（ZGC）是可伸缩的低延迟垃圾收集器。 ZGC 同时执行所有昂贵的工作，而不会停止执行应用程序线程。</p>
<p>ZGC <strong>适用于需要低延迟（少于 10 毫秒的暂停）和/或使用非常大的堆（数 TB）的应用程序</strong>。您可以通过使用 <code>-XX:+UseZGC</code> 选项来启用。</p>
<p><strong>从 JDK 11 开始，ZGC 可以作为实验功能使用。</strong></p>
<h2 id="选择收集器"><a class="markdownIt-Anchor" href="#选择收集器"></a> 选择收集器</h2>
<p>除非您的应用程序有非常严格的暂停时间要求，否则请先运行您的应用程序并允许 VM 选择收集器。</p>
<p>如有必要，请调整堆大小以提高性能。如果性能仍然不能满足您的目标，请使用以下准则作为选择收集器的开始：</p>
<ul>
<li>
<p>如果应用程序的数据集较小（最大约 100 MB），则选择带有选项 <code>-XX:+UseSerialGC</code> 的串行收集器。</p>
</li>
<li>
<p>如果应用程序将在单个处理器上运行并且没有暂停时间要求，则选择带有选项 <code>-XX:+UseSerialGC</code> 的串行收集器。</p>
</li>
<li>
<p>如果（a）应用程序性能峰值是第一优先级，并且（b）没有暂停时间要求或一秒钟或更长时间的暂停是可接受的，则让 VM 选择收集器或使用 <code>-XX:+UseParallelGC</code> 选择并行收集器。</p>
</li>
<li>
<p>如果响应时间比总体吞吐量更重要，并且垃圾收集暂停时间必须短于大约一秒钟，则选择带有 <code>-XX:+UseG1GC</code> 或 <code>-XX:+UseConcMarkSweepGC</code> 的并发收集器。</p>
</li>
<li>
<p>如果响应时间是高优先级，和/或您使用的堆非常大，请使用 <code>-XX:UseZGC</code> 选择完全并发的收集器。</p>
</li>
</ul>
<p>这些准则只是选择收集器的开始，因为性能<strong>取决于堆的大小，应用程序维护的实时数据量以及可用处理器的数量和速度</strong>。</p>
<p>如果推荐的收集器没有达到所需的性能，则首先尝试调整堆和分代大小以满足所需的目标。如果性能仍然不足，请尝试使用其他收集器：<strong>使用并发收集器可以减少暂停时间，并可以使用并行收集器来提高多处理器硬件上的总体吞吐量</strong>。</p>
<h1 id="garbage-first-垃圾收集器"><a class="markdownIt-Anchor" href="#garbage-first-垃圾收集器"></a> Garbage-First 垃圾收集器</h1>
<h2 id="g1-收集器简介"><a class="markdownIt-Anchor" href="#g1-收集器简介"></a> G1 收集器简介</h2>
<p>Garbage-First（G1）垃圾收集器的目标是具有大量内存的多处理器计算机。它试图以极高的可能性满足垃圾收集暂停时间的目标，同时在几乎不需要配置的情况下实现高吞吐量。G1 的目标是使用当前目标应用程序和环境在延迟和吞吐量之间达到最佳平衡，其特点包括：</p>
<ul>
<li>堆大小最大为 10 GB 或更大，其中超过 50％ 的 Java 堆被存活数据占用。</li>
<li>对象分配和晋升的速率可能会随时间而显著变化。</li>
<li>堆中有大量碎片。</li>
<li>可预测的暂停时间目标目标不超过几百毫秒，避免了长时间的垃圾收集暂停。</li>
</ul>
<p>G1 替代了并发标记清除（CMS）收集器。它也是 Java 11 默认的收集器。</p>
<p>G1 收集器可实现高性能，并尝试通过以下各节中描述的几种方式满足暂停时间目标。</p>
<h2 id="启用-g1"><a class="markdownIt-Anchor" href="#启用-g1"></a> 启用 G1</h2>
<p>Garbage-First 垃圾收集器是 Java 11 默认的收集器，因此通常不必执行任何其他操作。您可以通过在命令行上提供 <code>-XX:+UseG1GC</code> 来显式启用它。</p>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<p>G1是分代，增量，并行，大部分并发的，stop-the-world 的并且 evacuating（撤离） 的垃圾收集器，它在每次 stop-the-world 暂停中监视暂停时间为目标。与其他收集器类似，G1 将堆分成（虚拟的）新生代和老年代。空间回收工作主要集中在最有效的新生代，而老年代则偶尔进行空间回收。</p>
<p>某些操作总是在 stop-the-world 的暂停中执行，以提高吞吐量。在应用程序停止时会花费更多时间在其他操作（例如整个堆的全局标记之类的操作）但是与应用程序并行并发执行的。为了使 stop-the-world 停顿的时间足够短来做空间回收，G1 分步并行执行。G1 通过跟踪有关先前应用程序的行为和垃圾收集暂停的信息来建立可关联性模型，从而实现可预测性。它使用此信息来确定暂停中要完成的工作。例如，G1 首先回收最高效区域中的空间（也就是大部分被垃圾填充的区域）。</p>
<p>G1 主要通过撤离（evacuating）来回收空间：将在选定存储区域中收集的活动对象复制到新的存储区域，并在此过程中对其进行压缩。evacuating 完成后，活动对象先前占用的空间将重新用于应用程序分配。</p>
<p>G1 收集器不是实时收集器。它会尝试在更长的时间内以较高的概率达到设定的暂停时间目标，但对于给定的暂停时间却并非总是绝对有把握。</p>
<h3 id="堆布局"><a class="markdownIt-Anchor" href="#堆布局"></a> 堆布局</h3>
<p>G1 将堆划分为一组大小相等的堆区域，每个堆区域都有一个连续的虚拟内存范围，如图所示。区域是内存分配和回收的单位。在任何给定时间，这些区域中的每个区域都可以为空（浅灰色），或分配给特定的年龄段（新生或老年）。随着内存请求的到来，内存管理器将释放可用区域。内存管理器将它们分配给一个分代，然后将它们作为可分配自身的可用空间返回给应用程序。</p>
<p><img src="../../../images/java/jvm/jsgct_dt_004_grbg_frst_hp.png" alt="G1 Garbage Collector Heap Layout" /></p>
<p>新生代包含 伊甸园-eden 区域（红色）和 幸存者-survivor 区域（红色带有“ S”）。这些区域提供的功能与其他收集器中相应的连续空间相同，不同的是，在 G1 中，这些区域通常以不连续的模式布置在内存中。浅蓝色区域构成了老年代。对于跨越多个区域的对象，老年代区域可能是巨大的（浅蓝色，带有“ H”）。</p>
<p>应用程序总是分配给新生代，即伊甸园区域，但庞大对象将直接分配为老年代。</p>
<p>G1 垃圾收集暂停时可以回收整个新生代中的空间，并且可以在任何收集暂停时回收任何其他老年代区域。在暂停期间，G1 将对象从该次收集批次中复制到堆中的一个或多个不同区域。对象的目标区域取决于该对象的源区域：整个新生代都被复制到幸存者或老年代区域中，并通过老化将对象从老年代区域复制到其他不同的老年代区域。</p>
<h3 id="垃圾回收周期"><a class="markdownIt-Anchor" href="#垃圾回收周期"></a> 垃圾回收周期</h3>
<p>在较高级别上，G1 收集器在两个阶段之间交替。Young-only 阶段包含垃圾回收，这些垃圾回收逐渐将老年代中的对象填充到当前可用的内存中。在空间回收（Space Reclamation）阶段，G1 除了处理新生代外，还逐步回收老年代的空间。然后，循环以仅年轻阶段重新开始。</p>
<p>下图给出了有关此循环的概述，并举例说明了可能发生的垃圾收集暂停的顺序：</p>
<p><img src="../../../images/java/jvm/jsgct_dt_001_grbgcltncyl.png" alt="Garbage Collection Cycle Overview" /></p>
<p>以下列表详细描述了 G1 垃圾回收周期的各个阶段，它们的暂停以及各阶段之间的过渡：</p>
<ol>
<li>仅新生代（Young-only）阶段：这个阶段从一些普通的新生代收集开始，这些收集将对象晋升到老年代。当新生代的占用率达到某个阈值（初始堆占用阈值）时，Young-only 阶段和空间回收阶段之间的过渡开始。此时，G1 开始并发收集新生代，而不是普通收集。</li>
</ol>
<ul>
<li>并发开始：这种类型的收集除了执行“正常”收集新生代外，还会启动标记过程。并发标记确定了在下一个空间回收阶段中要保留的老年代区域中所有当前可到达的（活动）对象。尽管收集标记尚未完全完成，但可能会出现正常的新生代收集。标记结束时有两个特殊的 stop-the-world 暂停：“标记-Remark” 和 “清除-Cleanup”。</li>
<li>Remark：此<strong>暂停</strong>将最终完成标记本身，执行全局引用处理和类卸载，回收完全为空的区域并清理内部数据结构。在“标记-Remark”和“清除-Cleanup”之间，G1 计算信息以便以后能够同时回收选定的老年代区域中的可用空间，这些信息将在清除暂停中最终确定。</li>
<li>Cleanup：此<strong>暂停</strong>确定是否将实际进行空间回收阶段。如果随后进行空间回收阶段，则 Young-only 阶段将以单个预混合（Prepare Mixed）新生代收集结束。</li>
</ul>
<ol start="2">
<li>空间回收阶段：此阶段包括多个混合收集，这些收集除了新生代区域外，还 evacuating-撤离 了老年代区域中的活动对象。当 G1 确定撤离更多老年代区域不会产生值得努力的足够自由空间时，空间回收阶段结束。</li>
</ol>
<p>在进行空间回收之后，收集周期会从另一个 Young-only 阶段开始重新启动。作为备份，如果应用程序在收集活动信息时内存不足，则 G1 会像其他收集器一样执行 in-place stop-the-world 的全堆压缩（Full GC）。</p>
<h2 id="g1-内部"><a class="markdownIt-Anchor" href="#g1-内部"></a> G1 内部</h2>
<p>本节描述了垃圾优先（G1）垃圾收集器的一些重要细节。</p>
<h3 id="确定初始堆占用率"><a class="markdownIt-Anchor" href="#确定初始堆占用率"></a> 确定初始堆占用率</h3>
<p><em>初始堆占用率</em>（<em>Initiating Heap Occupancy Percent</em> - IHOP）定义为老年代大小的百分比，它是触发初始标记收集的阈值。</p>
<p>默认情况下，G1 通过观察<strong>标记所需的时间</strong>以及<strong>标记周期内老年代分配的内存量</strong>来自动确定最佳的 IHOP。此功能称为自适应 IHOP。如果启用此功能，就会将 <code>-XX:InitiatingHeapOccupancyPercent</code> 选项初始值确定为当前老年代大小的百分比，直到没有足够的观测值可以很好地预测初始堆占用阈值。使用选项 <code>-XX:-G1UseAdaptiveIHOP</code> 关闭 G1 的这种行为。在这种情况下，<code>-XX:InitiatingHeapOccupancyPercent</code> 的值将会确定此阈值。</p>
<p>在内部，当老年代占用率为当前最大的老年代大小减去 <code>-XX:G1HeapReservePercent</code> 作为额外的缓冲区值时，自适应 IHOP 尝试设置初始堆占用率，以便开始空间回收阶段的第一个混合垃圾收集。</p>
<h3 id="标记"><a class="markdownIt-Anchor" href="#标记"></a> 标记</h3>
<p>G1 标记使用称为<em>开始时快照</em>（<em>Snapshot-At-The-Beginning</em> - SATB）的算法。当初始标记暂停时，它会为堆创建虚拟快照，此时在标记开始时所有处于活动状态的对象都被认为在其余标记时间也处于活动状态。这意味着出于空间回收的目的（在某些情况下例外），在标记过程中变成死（不可到达）的对象仍被认为是活动的。与其他收集器相比，这可能导致错误地保留了一些额外的内存。但是，这也潜在的使 SATB 在 Remark 暂停期间提供了更好的延迟。在该标记过程中过于保守地认为存活的对象将在下一次标记期间回收。有关标记问题的更多信息，请参见 G1 垃圾收集器优化主题。</p>
<h3 id="堆非常紧张时的行为"><a class="markdownIt-Anchor" href="#堆非常紧张时的行为"></a> 堆非常紧张时的行为</h3>
<p>当应用程序了保留大量内存导致撤离（evacuation）无法找到足够的空间复制到该空间时，就会发生撤离失败。撤离失败意味着 G1 通过将所有已移动的对象保留在新位置，并且不复制任何尚未移动的对象，仅调整对象之间的引用的方式来尝试完成当前的垃圾收集，撤离失败可能会产生一些额外的开销，但通常应与其他新生代收集一样快。在撤离失败的垃圾收集之后，G1 将正常恢复应用程序，而无需采取任何其他措施。G1 假定撤离失败发生在垃圾收集即将结束时； 也就是说，大多数对象已被移动，并且剩余空间足以继续运行应用程序，直到标记完成并开始空间回收。</p>
<p>如果这种假设不成立，那么 G1 最终将安排一个完全 GC。这种类型的收集执行整个堆的  in-place 压缩。这可能很慢。</p>
<p>有关在内存不足之前发出分配失败或完整GC的问题的更多信息，请参见 G1 垃圾收集器优化。</p>
<h3 id="大型对象"><a class="markdownIt-Anchor" href="#大型对象"></a> 大型对象</h3>
<p>大型对象是大于或等于一半区域大小的对象。除非使用 <code>-XX:G1HeapRegionSize</code> 选项进行设置，否则当前区域的大小将按照 G1 GC 的<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector.html#GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016">人机工程学默认值</a>中的说明按人机工程学确定。</p>
<p>这些大型对象有时会以特殊方式处理：</p>
<ul>
<li>在老年代中，每个大型对象都被分配为一系列连续的区域。对象本身的起点始终按该顺序位于第一个区域的起点。最后一个区域中的所有剩余空间都将浪费，直到回收整个对象时才会进行分配。</li>
<li>通常，大型对象只能在 清理-Cleanup 暂停期间的标记结束时回收，或者如果变得无法访问，则可以在完整 GC 期间回收。但是，对于大型对象有特殊的规定，用于原始类型的数组，例如 bool，各种整数和浮点值，如果在任何类型的垃圾回收暂停中许多对象都未引用大型对象，则 G1 机会尝试回收大型对象。默认情况下启用此行为，但是您可以使用选项 <code>-XX:G1EagerReclaimHumongousObjects</code> 禁用它。</li>
<li>分配大型对象可能会导致垃圾回收暂停提前发生。 G1 会在每次大型对象分配时检查“初始堆占用”阈值，如果当前占用量超过该阈值，则可能会立即强制执行初始标记新生代收集。</li>
<li>大型永远不会移动，即使在 Full GC 期间也不会移动。这可能会导致 Full GC 提前到来，或者由于区域空间因大量浪费的空间碎片而导致意外内存不足情况。</li>
</ul>
<h3 id="young-only-阶段分代大小确定"><a class="markdownIt-Anchor" href="#young-only-阶段分代大小确定"></a> Young-Only 阶段分代大小确定</h3>
<p><strong>在仅新生代阶段，要收集的区域批次（收集批次）仅由新生代区域组成。</strong> G1 总是在正常的新生代收集结束时为下一个阶段确定新生代大小。这样，G1 可以通过使用 <code>-XX:MaxGCPauseTimeMillis</code> 和 <code>-XX:PauseTimeIntervalMillis</code> 基于对实际暂停时间的长期观察来达成暂停时间目标。它考虑了撤离规模相似的新生代需要多长时间。这包括诸如在收集过程中必须复制多少个对象以及这些对象之间关联的信息。</p>
<p>如果没有其他限制，则 G1 在 <code>-XX:G1NewSizePercent</code> 和 <code>-XX:G1MaxNewSizePercent</code> 确定满足暂停时间的值之间自适应地调整新生代大小。有关如何解决长时间停顿的更多信息，请参见 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">G1 垃圾收集器优化</a>。</p>
<h3 id="空间回收阶段分代大小确定"><a class="markdownIt-Anchor" href="#空间回收阶段分代大小确定"></a> 空间回收阶段分代大小确定</h3>
<p>在空间回收阶段，G1 尝试在单个垃圾收集暂停中最大化老年代中回收的空间量。它会将新生代的大小设置为允许的最小值（通常由 <code>-XX:G1NewSizePercent</code> 确定），并将任何老年区域添加到回收空间，直到 G1 确定添加更多区域将超过暂停时间目标为止。在特定的垃圾收集暂停中，G1 按照回收效率的顺序添加老年代区域，回收效率高的优先，然后用剩余可用时间来获取最终的收集批次。</p>
<p>每次垃圾收集所能使用的老年代区域的数量受到要收集的潜在候选老年代区域（收集批次候选区域）的数量除以 <code>-XX:G1MixedGCCountTarget</code> 确定的空间回收阶段的长度的限制。<em>收集批次候选区域</em>是该阶段开始时占用率低于 -<code>XX:G1MixedGCLiveThresholdPercent</code> 的所有老年代区域。</p>
<p>当可在收集批次候选区域中回收的剩余空间量小于 <code>-XX:G1HeapWastePercent</code> 设置的百分比时，该阶段结束。</p>
<p>有关 G1 将使用多少个老年代区域以及如何避免长时间的混合收集暂停的更多信息，请参见 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector-tuning.html#GUID-90E30ACA-8040-432E-B3A0-1E0440AB556A">G1 的垃圾收集器优化。</a></p>
<h2 id="g1-gc-的人机工程学默认值"><a class="markdownIt-Anchor" href="#g1-gc-的人机工程学默认值"></a> G1 GC 的人机工程学默认值</h2>
<p>本主题概述了特定于 G1 的最重要参数及其默认值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项和默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-XX:MaxGCPauseMillis=200</code></td>
<td style="text-align:left">最大暂停时间的目标。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:GCPauseTimeInterval</code>=<em><ergo></em></td>
<td style="text-align:left">最大暂停时间间隔的目标。默认情况下，G1 不设置任何目标，允许 G1 在极端情况下连续执行垃圾收集。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:ParallelGCThreads</code>=<em><ergo></em></td>
<td style="text-align:left">垃圾回收暂停期间用于并行工作的最大线程数。这是通过以下方式从运行 VM 的计算机的可用线程数得出的：如果该进程可用的 CPU 线程数小于或等于 8，则使用该数量。否则，将线程数的八分之五增加到最终线程数。<br />在每次暂停开始时，使用的最大线程数进一步受最大总堆大小的限制：对于配置了每个线程能使用的最大堆内存 <code>-XX:HeapSizePerGCThread</code>，达到内存要求时 G1 不会使用多个线程。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:ConcGCThreads</code>=<em><ergo></em></td>
<td style="text-align:left">用于并发工作的最大线程数。默认情况下，此值为 <code>-XX:ParallelGCThreads</code> 除以 4。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:+G1UseAdaptiveIHOP</code><br /><code>-XX:InitiatingHeapOccupancyPercent=45</code></td>
<td style="text-align:left">用于控制初始堆占用率的默认值，以及指示自适应 IHOP 为启用，并且对于前几个收集周期，G1 将使用老年代占用率的 45％ 作为标记开始阈值。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1HeapRegionSize=&lt;ergo&gt;</code></td>
<td style="text-align:left">基于初始堆大小和最大堆大小确定的堆区域大小。因此，该堆包含大约 2048 个堆区域。堆区域的大小可以从 1 到 32 MB 不等，并且必须为 2 的幂。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1NewSizePercent=5</code><br /><code>-XX:G1MaxNewSizePercent=60</code></td>
<td style="text-align:left">总体上，新生代的大小在这两个值之间变化，以当前使用的 Java 堆的百分比表示。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1HeapWastePercent=5</code></td>
<td style="text-align:left">集合中允许的候选未回收空间百分比。如果收集批次候选中的可用空间低于该比值，则 G1 停止空间回收阶段。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1MixedGCCountTarget=8</code></td>
<td style="text-align:left">预期空间回收阶段收集的次数。</td>
</tr>
<tr>
<td style="text-align:left"><code>-XX:G1MixedGCLiveThresholdPercent=85</code></td>
<td style="text-align:left">在此空间回收阶段，高于该老年代存活对象占比时将不会被收集。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：<ergo> 表示实际值是根据环境和人机工程学确定的。</p>
</blockquote>
<h2 id="与其他收集器的比较"><a class="markdownIt-Anchor" href="#与其他收集器的比较"></a> 与其他收集器的比较</h2>
<p>这是 G1 与其他收集器之间主要区别的摘要：</p>
<ul>
<li>并行 GC 只能从整体上压缩和回收老年代中的空间。 G1 将这项工作逐步分配到多个较短的收集中。这大大缩短了暂停时间也潜在的提高了吞吐量。</li>
<li>与 CMS 相似，G1 并发执行部分老年代空间回收。但是，CMS 无法对老年代的堆进行碎片整理，最终会遇到较长的 Full GC。</li>
<li>G1 可能表现出比其他收集器更高的开销，由于其并发性而影响吞吐量。</li>
</ul>
<p>由于其工作方式，G1 具有一些独特的机制来提高垃圾收集效率：</p>
<ul>
<li>G1 可以在任何收集过程中回收一些老年代的完全空的，较大的区域。这样可以避免许多其他不必要的垃圾收集，而无需付出很多努力即可释放大量空间。</li>
<li>G1 可以选择尝试并发的对 Java 堆上的重复字符串进行重复数据删除。</li>
</ul>
<p>始终启用从老年代中回收空的大型对象的功能。您可以使用选项 <code>-XX:-G1EagerReclaimHumongousObjects</code> 禁用此功能。默认情况下，字符串重复数据删除功能处于禁用状态。您可以使用选项 <code>-XX:+G1EnableStringDeduplication</code> 启用它。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>G1</tag>
        <tag>CMG</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/java/Java-NIO/</url>
    <content><![CDATA[<p>从 1.4 版本开始，Java 提供了另一套 I/O 系统，称为 NIO(New I/O 的缩写)。NIO 支持面向缓冲区的、基于通道的 I/O 操作。随着 JDK7 的发布，Java 对 NIO 系统进行了极大扩展，增强了对文件处理和文件系统特性的支持。缘于 NIO 文件类提供的功能，NIO 预期会成为文件处理中越来越重要的部分。</p>
<p>NIO 包含下面几个核心的组件：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>还有基于文件的几个核心组件：</p>
<ul>
<li>Path</li>
<li>FileSystem</li>
</ul>
<p>下面我们就以核心组件展开来说。</p>
<span id="more"></span>
<h1 id="通道和缓冲区channels-and-buffers"><a class="markdownIt-Anchor" href="#通道和缓冲区channels-and-buffers"></a> 通道和缓冲区（Channels and Buffers）</h1>
<p>标准的 I/O 编程接口是面向字节流和字符流的。而 NIO 是面向通道和缓冲区的，数据总是从通道中读到 buffer 缓冲区内，或者从 buffer 写入到通道中。</p>
<p><img src="../../images/java/nio/overview-channels-buffers.png" alt="http://tutorials.jenkov.com/images/java-nio/overview-channels-buffers.png" /></p>
<h2 id="channel"><a class="markdownIt-Anchor" href="#channel"></a> Channel</h2>
<p>I/O 操作的纽带。<br />
通道表示与实体的开放连接，例如硬件设备、文件、网络套接字或能够执行一个或多个不同 I/O 操作（例如读取或写入）的程序组件。<br />
通道要么打开要么关闭。 通道在创建时打开，一旦关闭，它便保持关闭状态。</p>
<p>有很多的 Channel 类型。下面列举了主要的几种：</p>
<ul>
<li>FileChannel - 用于读取、写入、映射和操作文件的通道。</li>
<li>DatagramChannel - 可以通过 Selector 复用的面向报文的套接字通道。</li>
<li>SocketChannel - 可以通过 Selector 复用的面向流的连接套接字通道。</li>
<li>ServerSocketChannel - 可以通过 Selector 复用的面向流的侦听套接字通道。</li>
</ul>
<p>Java NIO Channel 通道和流非常相似，主要有以下几点区别：</p>
<ul>
<li>通道即可以读也可以写，流一般来说是单向的（只能读或者写）。</li>
<li>通道可以异步读写。</li>
<li>通道总是基于缓冲区 Buffer 来读写。</li>
</ul>
<p>在 Java NIO 中如果一个 Channel 是 FileChannel 类型的，那么他可以直接把数据传输到另一个 Channel。逐个特性得益于 FileChannel 包含的 <code>transferTo</code> 和 <code>transferFrom</code> 两个方法。</p>
<ul>
<li>
<p><code>FileChannel.transferFrom</code> 方法把数据从通道源传输到 FileChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"> </span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"> </span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br></pre></td></tr></table></figure>
<p>transferFrom 的参数 position 和 count 表示目标文件的写入位置和最多写入的数据量。如果通道源的数据小于 count 那么就传实际有的数据量。<br />
另外，有些 SocketChannel 的实现在传输时只会传输哪些处于就绪状态的数据，即使 SocketChannel 后续会有更多可用数据。因此，这个传输过程可能不会传输整个的数据。</p>
</li>
<li>
<p><code>FileChannel.transferTo</code> 方法把 FileChannel 数据传输到另一个 channel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;fromFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"> </span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;toFile.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"> </span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure>
<p>这段代码和之前介绍 transferFrom 时的代码非常相似，区别只在于调用方法的是哪个 FileChannel.</p>
<p>SocketChannel 的问题也存在与 transferTo 的实现可能只在发送的 buffer 填充满后才发送，并结束。</p>
</li>
</ul>
<h3 id="scattergather-io"><a class="markdownIt-Anchor" href="#scattergather-io"></a> Scatter/Gather IO</h3>
<p>Java NIO 发布时内置了对分散（Scatter）/ 聚集（Gather）IO 的支持。Scatter / Gather 是通过单个通道向多个 Buffer 读写数据的两个概念。</p>
<p>Scattering Read 指的是从通道读取的操作能把数据写入多个 Buffer，也就是 Scatter 代表了数据从一个 Channel 到多个 Buffer 的过程。</p>
<p>Scatter / Gather 在有些场景下会非常有用，比如需要处理多份分开传输的数据。举例来说，假设一个消息包含了 Header 和 Body，我们可能会把 Header 和 Body 保存在不同独立 Buffer 中，这种分开处理 Header 与 Body 的做法会使开发更简明。</p>
<p>Java 提供了 java.nio.channels.ScatteringByteChannel 接口，以支持 Scattering 和 java.nio.channels.GatheringByteChannel 接口来支持 Gathering。</p>
<h4 id="scattering-read"><a class="markdownIt-Anchor" href="#scattering-read"></a> Scattering Read</h4>
<p>“Scattering Read” 是把数据从单个 Channel 写入到多个 Buffer，下面是示意图：</p>
<p><img src="../../images/java/nio/scatter.png" alt="scatter.png" /></p>
<p>用代码来表示的话如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ByteBuffer </span>header = <span class="keyword">ByteBuffer.allocate(128);</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">ByteBuffer </span><span class="keyword">body </span>  = <span class="keyword">ByteBuffer.allocate(1024);</span></span><br><span class="line"><span class="keyword"></span> </span><br><span class="line"><span class="keyword">ByteBuffer[] </span><span class="keyword">bufferArray </span>= &#123; header, <span class="keyword">body </span>&#125;;</span><br><span class="line"> </span><br><span class="line">channel.read(<span class="keyword">bufferArray);</span></span><br></pre></td></tr></table></figure>
<p>观察代码可以发现，我们把多个 buffer 写在了一个数组中，然后把数组传递给 channel.read() 方法。read() 方法内部会负责把数据按顺序写进传入的 buffer 数组内。一个 buffer 写满后，接着写到下一个 buffer 中。</p>
<p>实际上，Scattering Read 内部必须写满一个 buffer 后才会向后移动到下一个 buffer，因此这并不适合消息大小会动态改变的部分，也就是说，如果你有一个 header 和 body，并且 header 有一个固定的大小（比如 128 字节），这种情形下可以正常工作。</p>
<h4 id="gathering-write"><a class="markdownIt-Anchor" href="#gathering-write"></a> Gathering Write</h4>
<p>“Gathering Write” 把多个 Buffer 的数据写入到同一个 Channel 中，下面是示意图：</p>
<p><img src="../../images/java/nio/gather.png" alt="gather.png" /></p>
<p>用代码表示的话如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// write data into buffers</span></span><br><span class="line"> </span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"> </span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>
<h2 id="buffer"><a class="markdownIt-Anchor" href="#buffer"></a> Buffer</h2>
<p>缓冲区是特定原始类型数据的容器，本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。</p>
<p>下面是核心的 Buffer 实现类的列表：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些 Buffer 涵盖了可以通过 I/O 操作的基础类型：byte，short，int，long，float，double 以及 characters。NIO 实际上还包含一种 MappedBytesBuffer，一般用于和内存映射的文件。</p>
<h3 id="容量位置上限"><a class="markdownIt-Anchor" href="#容量位置上限"></a> 容量，位置，上限</h3>
<p>一个Buffer有三个属性是必须掌握的，分别是：</p>
<ul>
<li>capacity - 容量</li>
<li>position - 位置</li>
<li>limit - 限制</li>
</ul>
<p>position 和 limit 的具体含义取决于当前 buffer 的模式。capacity 在两种模式下都表示容量。</p>
<p>下面有张示例图，描诉了不同模式下 position 和 limit 的含义：</p>
<p><img src="../../images/java/nio/buffers-modes.png" alt="buffers-modes.png" /></p>
<h4 id="容量capacity"><a class="markdownIt-Anchor" href="#容量capacity"></a> 容量（Capacity）</h4>
<p>作为一块内存，buffer 有一个固定的大小，叫做 capacity 容量。也就是最多只能写入容量值得字节，整形等数据。一旦 buffer 写满了就需要清空已读数据以便下次继续写入新的数据。</p>
<h4 id="位置position"><a class="markdownIt-Anchor" href="#位置position"></a> 位置（Position）</h4>
<p>当写入数据到 Buffer 的时候需要中一个确定的位置开始，默认初始化时这个位置 position 为 0，一旦写入了数据比如一个字节，整形数据，那么 position 的值就会指向数据之后的一个单元，position 最大可以到 capacity。</p>
<p>当从 Buffer 读取数据时，也需要从一个确定的位置开始。buffer 从写入模式变为读取模式时，position 会归零，每次读取后，position 向后移动。</p>
<h4 id="上限limit"><a class="markdownIt-Anchor" href="#上限limit"></a> 上限（Limit）</h4>
<p>在写模式，limit 的含义是我们所能写入的最大数据量。它等同于 buffer 的容量。</p>
<p>一旦切换到读模式，limit 则代表我们所能读取的最大数据量，他的值等同于写模式下 position 的位置。</p>
<p>数据读取的上限时 buffer 中已有的数据，也就是 limit 的位置（原 position 所指的位置）。</p>
<h3 id="标记和重置"><a class="markdownIt-Anchor" href="#标记和重置"></a> 标记和重置</h3>
<p>缓冲区的标记是在调用 <code>reset</code> 方法时将其位置重置到的索引。 标记并不总是被定义，但当它被定义时，它永远不会是负数，也永远不会大于位置。 如果定义了标记，则在将位置或限制调整为小于标记的值时将丢弃该标记。 如果未定义标记，则调用 reset 方法会导致抛出 <code>InvalidMarkException</code> 。</p>
<h3 id="不变量"><a class="markdownIt-Anchor" href="#不变量"></a> 不变量</h3>
<p>以下不变量适用于标记、位置、限制和容量值：<br />
<strong>0 &lt;= 标记 &lt;= 位置 &lt;= 限制 &lt;= 容量</strong><br />
新创建的缓冲区始终具有零位置和未定义的标记。 初始限制可能为零，也可能是某个其他值，具体取决于缓冲区的类型及其构造方式。 新分配的缓冲区的每个元素都初始化为零。</p>
<h3 id="清除翻转和倒带"><a class="markdownIt-Anchor" href="#清除翻转和倒带"></a> 清除，翻转和倒带</h3>
<p>利用 Buffer 读写数据，通常遵循四个步骤：</p>
<ul>
<li>把数据写入 Buffer；</li>
<li>调用 <code>buffer.flip()</code>；</li>
<li>从 Buffer 中读取数据；</li>
<li>调用 <code>buffer.clear()</code> 或者 <code>buffer.compact()</code></li>
</ul>
<p>当写入数据到 buffer 中时，buffer 会记录已经写入的数据大小。当需要读数据时，通过 <code>flip()</code> 方法把 buffer 从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。</p>
<p>当读取完数据后，需要清空 buffer，以满足后续写入操作。清空 buffer 有两种方式：调用 <code>clear()</code> 或 <code>compact()</code> 方法。<code>clear</code> 会清空整个 buffer，<code>compact</code> 则只清空已读取的数据，未被读取的数据会被移动到 buffer 的开始位置，写入位置则近跟着未读数据之后。</p>
<p>如果想重复读取已写入的数据，可以使用 <code>rewind()</code> 将 position 置为 0。</p>
<h1 id="选择器selectors"><a class="markdownIt-Anchor" href="#选择器selectors"></a> 选择器（Selectors）</h1>
<p><code>SelectableChannel</code> 对象的多路复用器。</p>
<p>选择器允许单线程操作多个通道。如果你的程序中有大量的链接，同时每个链接的 I/O 带宽不高的话，这个特性将会非常有帮助。比如聊天服务器。 下面是一个单线程中 Selector 维护 3 个 Channel 的示意图：</p>
<p><img src="../../images/java/nio/overview-selectors.png" alt="http://tutorials.jenkov.com/images/java-nio/overview-selectors.png" /></p>
<p>要使用 Selector 的话，我们必须把 Channel 注册到 Selector 上，然后就可以调用 Selector 的 <code>select()</code> 方法。这个方法会进入阻塞，直到有一个 Channel 的状态符合条件。当方法返回时，线程就可以处理事件，比如：连接事件，数据到达事件等。</p>
<h2 id="创建-selector"><a class="markdownIt-Anchor" href="#创建-selector"></a> 创建 Selector</h2>
<p>创建一个Selector可以通过Selector.open()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h2 id="注册-channel-到-selector-上"><a class="markdownIt-Anchor" href="#注册-channel-到-selector-上"></a> 注册 Channel 到 Selector 上</h2>
<p>为了通过 Selector 来使用 Channel，我们必须先把 Channel 注册到 Selector 上，这个操作可以使用 SelectableChannel.register() 完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>Channel 必须处于非阻塞模式才能与 Selector 一起使用。这意味着您不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 无法切换到非阻塞模式。不过，套接字通道可以正常工作。</p>
<p>注意 register() 方法的第二个参数。这是一个“关注集合（interest set）”，代表我们关注的 Channel 状态，有四种基础类型可供监听 。</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>一个 channel 触发了一个事件也可视作该事件处于就绪状态。因此当 channel 与 server 连接成功后，那么就是“连接就绪”状态。server socket channel 接收请求连接时处于“可连接就绪”状态。channel 有数据可读时处于“读就绪”状态。channel 可以进行数据写入时处于“写就绪”状态。</p>
<p>这四个事件由四个 SelectionKey 常量表示：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果您对多个事件感兴趣，可以使用 OR 将常量放在一起，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;    </span><br></pre></td></tr></table></figure>
<h2 id="selectionkey"><a class="markdownIt-Anchor" href="#selectionkey"></a> SelectionKey</h2>
<p>正如您在上一节中看到的，当您使用 Selector 注册 Channel 时， register() 方法返回一个 <code>SelectionKey</code> 对象。这个 <code>SelectionKey</code> 对象包含一些有趣的属性：</p>
<ul>
<li>关注集合 The interest set</li>
<li>就绪集合 The ready set</li>
<li>The Channel</li>
<li>The Selector</li>
<li>附加对象 An attached object (optional)</li>
</ul>
<p>这 5 个属性都代表什么含义呢？下面会一一介绍。</p>
<h3 id="interest-set"><a class="markdownIt-Anchor" href="#interest-set"></a> Interest Set</h3>
<p>这个“关注集合”实际上就是我们希望处理的事件的集合，它的值就是注册时传入的参数，我们可以用按为与运算把每个事件取出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = interestSet &amp; SelectionKey.OP_ACCEPT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<h3 id="ready-set"><a class="markdownIt-Anchor" href="#ready-set"></a> Ready Set</h3>
<p>&quot;就绪集合&quot;中的值是当前 channel 处于就绪的值，一般来说在调用了 select 方法后都会需要用到就绪状态，select 会在后面介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure>
<p>从“就绪集合”中取值的操作类似于“关注集合”的操作，当然还有更简单的方法，SelectionKey 提供了一系列返回值为 boolean 的的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure>
<h3 id="channel-selector"><a class="markdownIt-Anchor" href="#channel-selector"></a> Channel + Selector</h3>
<p>从 SelectionKey 操作 Channel 和 Selector 非常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure>
<h3 id="attaching-objects"><a class="markdownIt-Anchor" href="#attaching-objects"></a> Attaching Objects</h3>
<p>我们可以给一个 SelectionKey 附加一个 Object，这样做一方面可以方便我们识别某个特定的 channel，同时也增加了 channel 相关的附加信息。例如，可以把用于 channel 的 buffer 附加到 SelectionKey 上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line"> </span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure>
<p>附加对象的操作也可以在 register 的时候就执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure>
<h2 id="从-selector-中选择-channel"><a class="markdownIt-Anchor" href="#从-selector-中选择-channel"></a> 从 Selector 中选择 Channel</h2>
<p>一旦我们向 Selector 注册了一个或多个 channel 后，就可以调用 <code>select</code> 来获取 channel。<code>select</code> 方法会返回所有处于<strong>就绪状态</strong>的 channel。 select 方法具体如下：</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select() 方法在返回 channel 之前处于阻塞状态。 select(long timeout) 和 select 做的事一样，不过他的阻塞有一个超时限制。</p>
<p>selectNow() 不会阻塞，根据当前状态立刻返回合适的 channel。</p>
<p>select() 方法的返回值是一个 int 整形，代表有多少 channel 处于就绪了。也就是自上一次 select 后有多少 channel 进入就绪。举例来说，假设第一次调用 select 时正好有一个 channel 就绪，那么返回值是 1，并且没有 对这个 channel 做任何处理，接着再次调用 select，此时恰好又有一个新的 channel 就绪，那么返回值还是 1，现在我们一共有两个 channel 处于就绪，但是在每次调用 select 时只有一个 channel 是就绪的。</p>
<h3 id="selectedkeys"><a class="markdownIt-Anchor" href="#selectedkeys"></a> selectedKeys()</h3>
<p>在调用 select 并返回了有 channel 就绪之后，可以通过选中的 key 集合来获取 channel，这个操作通过调用 selectedKeys() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure>
<p>还记得在 register 时的操作吧，我们 register 后的返回值就是 SelectionKey 实例，也就是我们现在通过 selectedKeys() 方法所返回的 SelectionKey。</p>
<p>可以通过如下方法遍历这些 SelectionKey：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selected<span class="constructor">Keys()</span>;</span><br><span class="line"> </span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator<span class="literal">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(keyIterator.has<span class="constructor">Next()</span>) &#123;</span><br><span class="line"> </span><br><span class="line">    SelectionKey key = keyIterator.next<span class="literal">()</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(key.is<span class="constructor">Acceptable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.is<span class="constructor">Connectable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.is<span class="constructor">Readable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.is<span class="constructor">Writable()</span>) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    keyIterator.remove<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述循环会迭代 key 集合，针对每个 key 我们单独判断他是处于何种就绪状态。</p>
<p>注意 keyIterater.remove() 方法的调用，Selector 本身并不会移除 SelectionKey 对象，这个操作需要我们手动执行。当下次 channel 处于就绪时，Selector 任然会把这些 key 再次加入进来。</p>
<p>SelectionKey.channel 返回的 channel 实例需要强转为我们实际使用的具体的 channel 类型，例如 ServerSocketChannel 或 SocketChannel.</p>
<h2 id="wakeup"><a class="markdownIt-Anchor" href="#wakeup"></a> wakeUp()</h2>
<p>由于调用 select 而被阻塞的线程，可以通过调用 Selector.wakeup() 来唤醒即便此时已然没有 channel 处于就绪状态。具体操作是，使用另一个线程调用该 Selector 的 Selector.wakeup()，被阻塞与 select 方法的线程就会立刻返回。</p>
<p>如果另一个线程调用了 wakeup()，而 select() 中当前没有线程被阻塞，那么下一个调用 select() 的线程将立即“唤醒”。</p>
<h2 id="close"><a class="markdownIt-Anchor" href="#close"></a> close()</h2>
<p>当操作 Selector 完毕后，需要调用 close 方法。close 的调用会关闭 Selector 并使相关的 SelectionKey 都无效。channel 本身并未关闭。</p>
<p>由于 Selector 实现了 Closable，所以可以使用 try-with-resources 来在方法退出时自动关闭。</p>
<h2 id="完整的-selector-案例"><a class="markdownIt-Anchor" href="#完整的-selector-案例"></a> 完整的 Selector 案例</h2>
<p>这有一个完整的案例，首先打开一个 Selector，然后注册 channel，并持续监视选择器以了解四个事件（接受、连接、读取、写入）的“准备情况”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"> </span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"> </span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"> </span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"> </span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="管道pipe"><a class="markdownIt-Anchor" href="#管道pipe"></a> 管道（Pipe）</h1>
<p>一个 Java NIO 的管道是两个线程间单向传输数据的连接。一个管道（Pipe）有一个 Source Channel 源管道和一个 Sink Channel 下游管道。我们把数据写到 Sink Channel 中，这些数据可以同过 Source Channel 再读取出来。</p>
<p>下面是一个管道的示意图：</p>
<p><img src="../../images/java/nio/pipe-internals.png" alt="http://tutorials.jenkov.com/images/java-nio/pipe-internals.png" /></p>
<h1 id="路径path"><a class="markdownIt-Anchor" href="#路径path"></a> 路径（Path）</h1>
<p>Path 在 Java 7 新增。相关接口位于 <code>java.nio.file</code> 包下。</p>
<p>一个 Path 实例代表一个文件系统内的路径。Path 可以指向文件也可以指向目录。可以是相对路径也可以是绝对路径。绝对路径包含了从根目录到该文件（目录）的完整路径。相对路径是从一个路径（基准路径）指向另一个目录或文件的路径。完整路径实际上等同于相对路径加上基准路径。</p>
<h1 id="文件系统filesystem"><a class="markdownIt-Anchor" href="#文件系统filesystem"></a> 文件系统（FileSystem）</h1>
<p>您可以通过打包在 java.nio.file 中的 <code>FileSystem</code> 和 <code>FileSystems</code> 类轻松访问文件系统。 事实上，可以通过 SPI 服务提供商的形式注册 <code>FileSystemProvider</code>，使用 <code>FileSystems</code> 定义的 <code>newFileSystem()</code> 方法，甚至可以获得一个新的文件系统。<br />
<code>FileStore</code> 类封装了文件存储系统。</p>
<h2 id="files"><a class="markdownIt-Anchor" href="#files"></a> Files</h2>
<p>Java NIO 中的 Files 类（java.nio.file.Files）提供了多种操作文件系统中文件、目录等文件相关类型的静态方法，在大多数情况下，此处定义的方法将委派给关联的文件系统提供程序以执行文件操作。</p>
<p>例如，它具有允许您打开或创建具有指定路径的文件的方法。 也可以获取有关路径下文件的信息，例如它是可执行的，隐藏还是只读，或者获取文件的属性，比如最后修改时间等。或者判断该路径文件是否符号链接（软链接），创建软链接，获取软链接的目标等。</p>
<p>Files 还提供让您复制或移动文件的方法，以及遍历文件夹树的 <code>walk</code> 和 <code>walkFileTree</code> 方法，walkFileTree 支持使用 <code>FileVisitor</code> 的精确遍历文件和文件夹。</p>
<p>Files 还包括这四种方法：<code>list()</code>，<code>walk()</code>，<code>lines()</code>，以及 <code>find()</code>，都返回 <code>Stream</code> 对象。 这些方法有助于将 NIO 与 Stream API 集成。从 JDK 11 开始，Files 还包括方法 <code>readString()</code> 和 <code>writeString()</code>，其返回包含文件中的字符串或写入<code>CharSequence</code>（例如 String）到文件。</p>
<h2 id="监视服务watchservice"><a class="markdownIt-Anchor" href="#监视服务watchservice"></a> 监视服务（WatchService）</h2>
<p>监视已注册对象的变化和事件。</p>
<p>例如，文件管理器可以使用监视服务来监视目录的更改，以便在创建或删除文件时更新文件列表的显示。</p>
<p>从文件系统监视事件的实现旨在直接映射到可用的本地文件事件通知工具，或者在本地工具不可用时使用原始机制，例如轮询。</p>
<h1 id="asynchronous-io"><a class="markdownIt-Anchor" href="#asynchronous-io"></a> Asynchronous I/O</h1>
<p>NIO 提供多路复用 I/O，以便于创建高度可扩展的服务器。 客户端代码注册套接字通道到 <code>Selector</code> 以便通道准备开始 I/O 时通知它。</p>
<p>NIO 也提供异步 I/O，允许客户端代码启动 I/O 操作，然后在操作完成时通知客户端。 类似于多路复用 I/O，异步 I/O 也通常用于促进创建高度可扩展的服务器。</p>
<p><code>java.nio.channels.AsynchronousChannel</code> 接口描述了异步通道，它支持异步 I/O 操作（读取，写入等）。</p>
<p>一种形式是调用方法然后立即返回 <code>Future</code>，它代表异步计算的结果，我们可以通过 <code>isDone</code> 来判断是否完成，<code>get</code> 等待完成并获取结果，或者调用 <code>cancel</code> 指示取消此任务执行。</p>
<p>另一种是在异步完成或失败时，调用我们传入的 <code>CompletionHandler</code> 的 <code>completed</code> 或 <code>failed</code> 回掉方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 代理 入门</title>
    <url>/java/Java-%E4%BB%A3%E7%90%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="什么是代理"><a class="markdownIt-Anchor" href="#什么是代理"></a> 什么是代理</h2>
<p>代理是一种设计模式。当我们想要添加或修改现有类的某些功能时，我们创建并使用代理对象。通常，代理对象具有与原始代理对象相同的方法，并且在 Java 代理类中通常扩展原始类。代理的主要目的是控制对目标对象的访问，而不是增强目标对象的功能。</p>
<p>这样，代理类可以通过方便的方式实现许多功能：</p>
<ul>
<li>方法开始和结束时日志</li>
<li>访问控制，过滤恶意请求</li>
<li>本地执行远程服务</li>
<li>缓存请求结果</li>
<li>对参数执行额外检查</li>
<li>模拟原始类的行为</li>
<li>实现对昂贵资源的懒加载</li>
<li>智能引用，可在没有客户端使用某个重量级对象时立即销毁该对象</li>
<li>etc…</li>
</ul>
<p>在实际应用中，代理类不直接实现功能。遵循单一责任原则，代理类仅执行代理，并且实际行为在处理程序中实现。</p>
<p>与静态代理相比，动态代理需要在运行时进行 Java 反射的字节码生成。使用动态方法，无需创建代理类，这可以带来更多便利。</p>
<span id="more"></span>
<h2 id="静态代理类"><a class="markdownIt-Anchor" href="#静态代理类"></a> 静态代理类</h2>
<p>由程序创建或特定工具自动生成源代码，在程序运行前，代理类的.class文件就已经存在。</p>
<p>通过将目标类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的。</p>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ul>
<li>冗余。定义的静态代理类非常特定于一个实现，这意味着对于每个实现，代理都需要明确定义，这是重复的工作。</li>
<li>受限。单个代理类无法实现对多个不同类的方法调用的代理。</li>
<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>
</ul>
<h2 id="动态代理类"><a class="markdownIt-Anchor" href="#动态代理类"></a> 动态代理类</h2>
<p>动态代理类（下面简称为代理类）是一个在运行时实现指定接口列表的类，这样就可以通过其中一个接口实例类上的方法调用编码并通过统一接口分配给另一个对象。因此，动态代理类可用于为接口列表创建类型安全的代理对象，而无需预生成代理类，例如使用编译时工具。动态代理类的实例上的方法调用被分派到实例的调用处理程序中的单个方法 - <code>invoke</code>。</p>
<p>动态代理类对于需要在呈现接口 API 的对象上提供类型安全反射调度调用的应用程序或库非常有用。例如应用程序可以使用动态代理类来创建实现多个任意事件侦听器接口的对象，通过扩展 <code>java.util.EventListener</code> 的接口，以统一的方式处理不同类型的各种事件，例如将所有此类事件记录到文件中。</p>
<h3 id="动态代理类-api"><a class="markdownIt-Anchor" href="#动态代理类-api"></a> 动态代理类 API</h3>
<p>动态代理类（下面简称为代理类）是一个实现在运行时创建指定的接口列表的类的<strong>类（Class）</strong>。</p>
<p>代理接口就是由代理类实现的接口。</p>
<p>代理实例是代理类的实例。</p>
<h4 id="创建代理类"><a class="markdownIt-Anchor" href="#创建代理类"></a> 创建代理类</h4>
<p>使用类 <code>java.lang.reflect.Proxy</code> 的静态方法来创建代理类及其实例。</p>
<p>在给定类加载器和接口数组的情况下，<code>Proxy.getProxyClass</code> 方法返回代理类的 java.lang.Class 对象。代理类将在指定的类加载器中定义，并将实现所有提供的接口。如果已经在类加载器中定义了相同的接口排列的代理类，将返回现有的代理类；否则，将动态生成这些接口的代理类，并在类加载器中定义。</p>
<p>可以传递给 <code>Proxy.getProxyClass</code> 的参数有几个限制：</p>
<ul>
<li><code>interfaces</code> 数组中的所有 <code>Class</code> 对象都必须表示接口，而不是类或基本类型。</li>
<li><code>interfaces</code> 数组中的任何两个元素都不能引用相同的 <code>Class</code> 对象。</li>
<li>所有接口类型必须通过指定的类加载器按名称可见。换句话说，对于类加载器 cl 和每个接口 i，以下表达式必须为 true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(i.getName(), <span class="keyword">false</span>, cl) == i</span><br></pre></td></tr></table></figure>
<ul>
<li>所有非公共接口必须位于同一个包中；否则，代理类无法实现所有接口，无论它在哪个包中定义。</li>
<li>对于具有相同签名的指定接口的任何成员方法集：
<ul>
<li>如果任何方法的返回类型是基本类型或 void，则所有方法必须具有相同的返回类型。</li>
<li>否则，其中一个方法必须具有可分配给其余方法的所有返回类型的返回类型。</li>
</ul>
</li>
<li>生成的代理类不得超过虚拟机对类强加的任何限制。例如，VM 可以将类可以实现的接口数量限制为 65535；在这种情况下，<code>interfaces</code> 数组的大小不得超过 65535。</li>
</ul>
<p>如果违反任何这些限制，<code>Proxy.getProxyClass</code> 将抛出 <code>IllegalArgumentException</code>。如果接口数组参数或其任何元素为空，则将抛出 <code>NullPointerException</code>。</p>
<p>请注意，指定代理接口的顺序很重要：对具有相同接口组合但顺序不同的代理类的两个请求将导致两个不同的代理类。代理类通过其代理接口的顺序来区分，以便在两个或更多代理接口共享具有相同名称和参数签名的方法的情况下提供确定性方法调用编码;</p>
<p>因此，每次使用相同的类加载器和接口列表调用 <code>Proxy.getProxyClass</code> 时，不需要生成新的代理类，动态代理类 API 的实现应保留生成的代理类的缓存，缓存的键由其相应的加载器和接口列表定义。实现缓存时应注意不要引用类加载器，接口和代理类，以防止类加载器及其所有类在适当时被垃圾收集。</p>
<h5 id="代理类属性"><a class="markdownIt-Anchor" href="#代理类属性"></a> 代理类属性</h5>
<p>代理类具有以下属性：</p>
<ul>
<li>代理类是公共的，最终的，而不是抽象的。</li>
<li>代理类的非限定名称是未指定的。但是，以字符串 <code>“$Proxy”</code> 开头的类名空间是为代理类保留的。</li>
<li>代理类 extend <code>java.lang.reflect.Proxy</code>。</li>
<li>代理类以相同的顺序实现其创建时指定的接口。</li>
<li>由于代理类实现了在创建时指定的所有接口，因此在其 Class 对象上调用 <code>getInterfaces</code> 将返回一个包含相同接口列表的数组（按照创建时指定的顺序）。在其 Class 对象上调用 <code>getMethods</code> 将返回包含这些接口中所有方法的 <code>Method</code> 对象数组，并且调用 <code>getMethod</code> 将按预期在代理接口中查找方法。</li>
<li>如果 <code>Proxy.isProxyClass</code> 方法传递了一个代理类 -（由 <code>Proxy.getProxyClass</code> 返回的类或 <code>Proxy.newProxyInstance</code> 返回的对象的类），则返回 true，否则返回 false。</li>
<li>代理类的 <code>java.security.ProtectionDomain</code> 与引导类加载器加载的系统类相同，例如 java.lang.Object，因为代理类的代码是由受信任的系统代码生成的。通常会授予此保护域 <code>java.security.AllPermission</code>。</li>
</ul>
<h4 id="创建代理实例"><a class="markdownIt-Anchor" href="#创建代理实例"></a> 创建代理实例</h4>
<p>每个代理类都有一个公共构造函数，它接受一个参数，即 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/InvocationHandler.html"><code>InvocationHandler</code></a> 接口的实现。</p>
<p>每个代理实例都有一个关联的 <code>InvocationHandler</code> 对象，该对象就是通过构造方法传递进来的。不必非要使用反射 API 来访问公共构造函数，也可以通过调用 <code>Proxy.newProxyInstance</code> 方法创建代理实例。 <code>Proxy.newProxyInstance</code> 因与 <code>Proxy.getProxyClass</code> 相同的原因抛出 <code>IllegalArgumentException</code>（比如接口数量不能超过 65535）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(...);</span><br><span class="line"><span class="comment">// 创建代理类</span></span><br><span class="line">Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);</span><br><span class="line"><span class="comment">// 使用代理类创建代理实例</span></span><br><span class="line">Foo proxy = (Foo) proxyClass.getConstructor(InvocationHandler.class).newInstance(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用静态方法直接创建代理实例</span></span><br><span class="line">Foo proxy = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Foo.class&#125;, handler);</span><br></pre></td></tr></table></figure>
<h5 id="代理实例属性"><a class="markdownIt-Anchor" href="#代理实例属性"></a> 代理实例属性</h5>
<p>代理实例有以下属性：</p>
<ul>
<li>给定代理实例 proxy 和其代理类 Foo 实现的接口之一，以下表达式将返回 true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">proxy <span class="keyword">instanceof</span> Foo</span><br></pre></td></tr></table></figure>
<p>并且以下转换操作将成功（而不是抛出 ClassCastException）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(Foo) proxy</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>静态 <code>Proxy.getInvocationHandler</code> 方法传递代理实例并返回与之关联的 <code>InvocationHandler</code>。如果传递给 <code>Proxy.getInvocationHandler</code> 的对象不是代理实例，则将抛出 <code>IllegalArgumentException</code>。</p>
</li>
<li>
<p>代理实例上的接口方法调用将被编码并调度到 <code>InvocationHandler</code> 的调用方法，如下所述。</p>
<p>代理实例本身将作为 <code>invoke</code> 的第一个参数传递，它是 Object 类型。</p>
<p>传递给 <code>invoke</code> 的第二个参数是 <code>java.lang.reflect.Method</code> 实例，该实例对应于在代理实例上调用的接口方法。<code>Method</code> 对象的声明类将是声明方法的接口，它可以是代理接口继承方法的代理接口的超接口。</p>
<p>传递给 <code>invoke</code> 的第三个参数是一个对象数组，其中包含在代理实例上的方法调用中传递的参数的值。原始类型的参数包装在适当的原始包装类的实例中，例如 <code>java.lang.Integer</code> 或 <code>java.lang.Boolean</code>。 <strong><code>invoke</code> 方法的实现可以自由修改此数组的内容。</strong></p>
<p><code>invoke</code> 方法返回的值将成为代理实例上方法调用的返回值。如果接口方法的声明返回值是基本类型，则 invoke 返回的值必须是相应原始包装类的实例；否则，它必须是可分配给声明的返回类型的类型。如果 <code>invoke</code> 返回的值为 <code>null</code>，并且接口方法的返回类型为原始类型，则代理实例上的方法调用将抛出 <code>NullPointerException</code>。如果 <code>invoke</code> 返回的值与上面描述的方法声明的返回类型不兼容，则代理实例将抛出 <code>ClassCastException</code>。</p>
<p>如果 <code>invoke</code> 方法抛出异常，它也将在代理实例上的方法调用中抛出。异常的类型必须可分配给在接口方法的签名中声明的任何异常类型，或者分配给未经检查的异常类型 <code>java.lang.RuntimeException</code> 或 <code>java.lang.Error</code>。如果通过调用抛出已检查的异常，该异常不能分配给接口方法的 <code>throws</code> 子句中声明的任何异常类型，在代理实例上的方法调用时将抛出 <code>UndeclaredThrowableException</code>，该异常由 <code>invoke</code> 方法抛出的异常来构造。</p>
</li>
<li>
<p>在代理实例上的 <code>java.lang.Object</code> 中声明的 <code>hashCode</code>，<code>equals</code> 或 <code>toString</code> 方法的调用将被编码并调度到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法，其方式与编码和分派接口方法调用的方式相同，如上所述。 传递给 <code>invoke</code> 的 <code>Method</code> 对象的声明类将是 <code>java.lang.Object</code>。 从 <code>java.lang.Object</code> 继承的代理实例的其他公共方法不会被代理类覆盖，因此这些方法的调用行为就像它们对 java.lang.Object 的实例所做的一样。</p>
</li>
</ul>
<h3 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h3>
<p>由于 <code>java.lang.reflect.Proxy</code> 实现了 <code>java.io.Serializable</code>，因此可以序列化代理实例。</p>
<h3 id="在多个代理接口中重复的方法"><a class="markdownIt-Anchor" href="#在多个代理接口中重复的方法"></a> 在多个代理接口中重复的方法</h3>
<p>当两个或多个代理接口包含具有相同名称和参数签名的方法时，代理类接口的顺序就变得很重要。</p>
<p>当在代理实例上调用重复方法时，包含代理类接口列表中的方法（直接或通过超接口继承）的<strong>最前面接口中方法的 Method 对象</strong>将传递给调用处理程序的 <code>invoke</code> 方法。</p>
<h3 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> Examples</h3>
<h4 id="example-1"><a class="markdownIt-Anchor" href="#example-1"></a> Example 1</h4>
<p>下面是一个简单的示例，它在实现任意接口列表的对象上的方法调用之前和之后打印出一条消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">bar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> BazException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooImpl</span> <span class="keyword">implements</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">bar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> BazException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugProxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.newProxyInstance(</span><br><span class="line">            obj.getClass().getClassLoader(),</span><br><span class="line">            obj.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> DebugProxy(obj));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DebugProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before method &quot;</span> + m.getName());</span><br><span class="line">            result = m.invoke(obj, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;unexpected invocation exception: &quot;</span> +</span><br><span class="line">                                       e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;after method &quot;</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要为 <code>Foo</code> 接口的实现构造 <code>DebugProxy</code> 并调用其方法之一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = (Foo) DebugProxy.newInstance(<span class="keyword">new</span> FooImpl());</span><br><span class="line">foo.bar(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> Example 2</h4>
<p>下面是一个实用程序调用处理程序类的示例，它为从 <code>java.lang.Object</code> 继承的方法提供默认代理行为，并根据被调用方法的接口实现对不同对象的某些代理方法调用的委派：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delegator</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preloaded Method objects for the methods in java.lang.Object</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashCodeMethod = Object.class.getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">            equalsMethod =</span><br><span class="line">                Object.class.getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> Class[] &#123; Object.class &#125;);</span><br><span class="line">            toStringMethod = Object.class.getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class[] interfaces;</span><br><span class="line">    <span class="keyword">private</span> Object[] delegates;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Delegator</span><span class="params">(Class[] interfaces, Object[] delegates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interfaces = (Class[]) interfaces.clone();</span><br><span class="line">        <span class="keyword">this</span>.delegates = (Object[]) delegates.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class declaringClass = m.getDeclaringClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (declaringClass == Object.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.equals(hashCodeMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxyHashCode(proxy);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.equals(equalsMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxyEquals(proxy, args[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m.equals(toStringMethod)) &#123;</span><br><span class="line">                <span class="keyword">return</span> proxyToString(proxy);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                    <span class="string">&quot;unexpected Object method dispatched: &quot;</span> + m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (declaringClass.isAssignableFrom(interfaces[i])) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> m.invoke(delegates[i], args);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.getTargetException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> invokeNotDelegated(proxy, m, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">invokeNotDelegated</span><span class="params">(Object proxy, Method m,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">&quot;unexpected method dispatched: &quot;</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">proxyHashCode</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(System.identityHashCode(proxy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Boolean <span class="title">proxyEquals</span><span class="params">(Object proxy, Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (proxy == other ? Boolean.TRUE : Boolean.FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">proxyToString</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxy.getClass().getName() + <span class="string">&#x27;@&#x27;</span> +</span><br><span class="line">            Integer.toHexString(proxy.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Delegator</code> 的子类可以覆盖 <code>invokeNotDelegated</code> 以实现代理方法调用的行为，而不是直接委托给其他对象，并且可以覆盖 <code>proxyHashCode</code>、<code>proxyEquals</code> 和 <code>proxyToString</code> 来覆盖代理从 java.lang.Object 继承的方法的默认行为。</p>
<p>构造实现 <code>Foo</code> 接口的 <code>Delegator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class[] proxyInterfaces = <span class="keyword">new</span> Class[] &#123; Foo.class &#125;;</span><br><span class="line">Foo foo = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), proxyInterfaces, </span><br><span class="line">                                       <span class="keyword">new</span> Delegator(proxyInterfaces, <span class="keyword">new</span> Object[] &#123; <span class="keyword">new</span> FooImpl() &#125;));</span><br></pre></td></tr></table></figure>
<p>请注意，上面给出的 <code>Delegator</code> 类的实现旨在说明用途而不是优化。</p>
<blockquote>
<p>由于 <code>InvocationHandler</code> 是一个函数接口，因此可以使用 <code>lambda</code> 表达式内联定义处理程序。</p>
</blockquote>
<h4 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> Example 3</h4>
<p>将代理模式和工厂模式结合起来，可以无感的创建基于代理的实例。很多框架都是这样提供的实例，比如 Spring 的 Bean、MyBatis 的 Mapper、Hibernate 的关联集合、Spring Data JPA 的 Repository 等。</p>
<ul>
<li>工厂方法用于抽象或隐藏对象创建的逻辑。</li>
<li>代理类用于正确代理并委托所有方法给实现，为需要代理的类提供统一抽象处理，或者为代理类不同生命周期阶段提供钩子（Hook）。</li>
</ul>
<p>比如 MyBatis 的 Mapper 的实例化，通过 Mapper 接口类来实例化 Mapper。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="cglib-代理"><a class="markdownIt-Anchor" href="#cglib-代理"></a> CGLIB 代理</h2>
<p><code>JDK 动态代理</code>通常用于动态创建代理。JDK 动态代理很容易使用，但 JDK 动态代理方法要求目标对象实现一个或多个接口。对象不一定实现接口，对象集合不一定共享相同的接口。面对这样的需求，JDK 动态代理无法提供答案。</p>
<p><code>CGLIB</code> 是一个功能强大的高性能代码生成库。它在基于代理的面向方面编程（<code>AOP</code>）框架（如 <code>Spring AOP</code> 和 <code>dynaop</code>）中广泛使用，以提供方法拦截。<code>Hibernate</code> 使用 <code>CGLIB</code> 为持久化类生成代理。<code>EasyMock</code> 和 <code>jMock</code> 是使用模拟对象测试 <code>Java</code> 代码的库。它们都使用 <code>CGLIB</code> 库为没有接口的类创建模拟对象。</p>
<p>在幕后，CGLIB 库使用 <code>ASM</code>，一个小但快速的字节码操作框架，来转换现有的字节码并生成新的类。除了 <code>CGLIB</code> 库之外，脚本语言（如 <code>Groovy</code> 和 <code>BeanShell</code>）也使用 <code>ASM</code> 生成 <code>Java</code> 字节码。 <code>ASM</code> 使用类似 <code>SAX</code> 解析器的机制来实现高性能。不鼓励直接使用 <code>ASM</code>，因为它需要熟悉 <code>JVM</code>，包括类文件格式和指令集。</p>
<p><img src="../../images/java/cglib.PNG" alt="CGLIB and ASM" /></p>
<blockquote>
<p>请注意，某些框架（如 <code>Spring AOP</code> 和 <code>Hibernate</code>）通常同时使用 <code>CGLIB</code> 库和 <code>JDK 动态代理</code>来满足其需求。<code>Hibernate</code> 使用 JDK 动态代理为 <code>WebShere</code> 应用程序服务器实现事务管理器适配器；默认情况下，<code>Spring AOP</code> 使用 <strong>JDK 动态代理</strong>来代理接口，除非您强制使用 CGLIB 代理。</p>
</blockquote>
<h3 id="cglib-代理-api"><a class="markdownIt-Anchor" href="#cglib-代理-api"></a> CGLIB 代理 API</h3>
<p><code>CGLIB</code> 库代码库很小，但由于缺少文档，很难学习。<code>CGLIB</code> 库的版本组织如下：</p>
<ul>
<li>
<p><code>net.sf.cglib.core</code></p>
<p>低级字节码操作类；他们中的大多数都与 <code>ASM</code> 有关。</p>
</li>
<li>
<p><code>net.sf.cglib.transform</code></p>
<p>运行时或构建时的类文件转换的类</p>
</li>
<li>
<p><code>net.sf.cglib.proxy</code></p>
<p>代理创建和方法拦截的类</p>
</li>
<li>
<p><code>net.sf.cglib.reflect</code></p>
<p>用于更快反射的类和 <code>C#</code> 样式的委托</p>
</li>
<li>
<p><code>net.sf.cglib.util</code></p>
<p>集合排序工具类</p>
</li>
<li>
<p><code>net.sf.cglib.beans</code></p>
<p><code>JavaBean</code> 相关工具类</p>
</li>
</ul>
<p>要动态创建代理，大多数情况下，您只需要使用代理包中的一些 API。</p>
<p>如前一节所述，<code>CGLIB</code> 库是 <code>ASM</code> 之上的高级层。它对代理不实现接口的类非常有用。本质上，它动态生成一个子类来覆盖代理类的非 final 方法，并连接回调用户定义的拦截器的钩子。它比 JDK 动态代理方法更快。</p>
<p><img src="../../images/java/cblig-2.PNG" alt="CGLIB APIs commonly used for proxying classes" /></p>
<p>通常用于代理具体类的 CGLIB 库 API 如上图所示。<code>net.sf.cglib.proxy.Callback</code> 接口是一个标记接口。 <code>net.sf.cglib.proxy.Enhancer</code> 类使用的所有回调接口都扩展了此接口。</p>
<p><code>net.sf.cglib.proxy.MethodInterceptor</code> 是最常用的回调类型。它在 AOP 术语中启用 ”around advice“（围绕建议） - 也就是说，您可以在调用 “super” 方法之前和之后调用自定义代码。此外，您可以在调用 super 方法之前修改参数，或者根本不调用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, java.lang.reflect.Method method,</span></span></span><br><span class="line"><span class="params"><span class="function">        Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>
<p>当 <code>net.sf.cglib.proxy.MethodInterceptor</code> 是代理的所有方法的回调时，代理上的方法调用将在调用原始对象上的方法之前路由到此方法。如下图所示。第一个参数是代理对象。第二个和第三个参数分别是截获的方法和方法参数。可以使用 <code>java.lang.reflect.Method</code> 对象或使用 <code>net.sf.cglib.proxy.MethodProxy</code> 对象通过常规反射调用原始方法。<code>net.sf.cglib.proxy.MethodProxy</code> 通常是首选，因为它更快。在此方法中，可以在调用原始方法之前或之后注入自定义代码。</p>
<p><img src="../../images/java/cglib-3.PNG" alt="CGLIB MethodInterceptor" /></p>
<p><code>net.sf.cglib.proxy.MethodInterceptor</code> 满足任何拦截需求，但在某些情况下可能有点过分。为了简化和性能，提供了开箱即用的其他专用回调类型。举些例子，</p>
<ul>
<li>
<p><code>net.sf.cglib.proxy.FixedValue</code></p>
<p>出于性能原因，强制特定方法返回固定值很有用。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.NoOp</code></p>
<p>它将方法调用直接委托给超类中的默认实现。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.LazyLoader</code></p>
<p>当真实对象需要延迟加载时，它很有用。加载实际对象后，它将用于代理实例的每个未来方法调用。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.Dispatcher</code></p>
<p>它与 <code>net.sf.cglib.proxy.LazyLoader</code> 具有相同的签名，但在调用代理方法时始终会调用 <code>loadObject</code> 方法。</p>
</li>
<li>
<p><code>net.sf.cglib.proxy.ProxyRefDispatcher</code></p>
<p>它与 <code>Dispatcher</code> 相同，但它允许将代理对象作为 <code>loadObject</code> 方法的参数传入。</p>
</li>
</ul>
<p>回调通常用于代理类中的所有方法，如上图所示，但您可以使用 <code>net.sf.cglib.proxy.CallbackFilter</code> 有选择地对方法应用回调。JDK 动态代理中没有这种细粒度控制功能，其中 <code>java.lang.reflect.InvocationHandler</code> 的 <code>invoke</code> 方法适用于代理对象的所有方法。</p>
<p>除了代理类之外，CGLIB 还可以通过提供 <code>java.lang.reflect.Proxy</code> 的替代代码 <code>net.sf.cglib.proxy.Proxy</code> 来代理接口，以支持 JDK 1.3 之前的 Java 代理。由于很少使用此替换代理功能，因此此处不涉及相关代理 API。</p>
<p>代理包还提供对 <code>net.sf.cglib.proxy.Mixin</code> 的支持。基本上，它允许将多个对象组合成一个更大的对象。代理上的方法调用委托给底层对象。</p>
<p>让我们看看如何使用 CGLIB 代理 API 创建代理。</p>
<h4 id="创建代理类-2"><a class="markdownIt-Anchor" href="#创建代理类-2"></a> 创建代理类</h4>
<p>CGLIB 代理的核心是 <code>net.sf.cglib.proxy.Enhancer</code> 类。要创建 CGLIB 代理，至少需要一个类。让我们先使用内置的 NoOp 回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用NoOp回调创建代理。目标类必须有一个默认的零参数构造函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass 代理的超类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 目标类实例的新代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Class targetClass)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(targetClass);</span><br><span class="line">    enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值是目标类实例的代理。在此示例中，为 <code>net.sf.cglib.proxy.Enhancer</code> 类配置了单个 <code>net.sf.cglib.proxy.Callback</code>。可以看出，创建一个简单的代理是相当简单的。而不是创建 <code>net.sf.cglib.proxy.Enhancer</code> 的新实例，您可以简单地使用 <code>net.sf.cglib.proxy.Enhancer</code> 类中的静态帮助器方法来创建代理。但是最好使用上例中显示的方法，因为它允许您配置 <code>net.sf.cglib.proxy.Enhancer</code> 实例以精确控制生成的代理。</p>
<p>请注意，目标类作为生成的代理的超类传入。与 JDK 动态代理不同，您无法在代理创建期间传递目标对象。目标对象必须由 CGLIB 库创建。在此示例中，默认的零参数构造函数用于创建目标实例。如果您希望 CGLIB 使用一些参数创建实例，<code>net.sf.cglib.proxy.Enhancer.create(Class[]，Object[])</code> 应当使用该方法替代 <code>net.sf.cglib.proxy.Enhancer.create()</code>。第一个参数指定参数类型和第二个指定参数值。原始类型在参数中应该使用包装类型。</p>
<h4 id="使用-methodinterceptor"><a class="markdownIt-Anchor" href="#使用-methodinterceptor"></a> 使用 MethodInterceptor</h4>
<p>要使代理更有用，可以使用自定义 <code>net.sf.cglib.proxy.MethodInterceptor</code> 替换 net.sf.cglib.proxy.NoOp 回调。代理上的所有方法调用都被调度到 <code>net.sf.cglib.proxy.MethodInterceptor</code> 的单个 <code>intercept</code> 方法。然后，<code>intercept</code> 方法将调用委托给底层对象。</p>
<p>假设您要对目标对象的所有方法调用应用授权检查。如果授权失败，将抛出运行时异常 <code>AuthorizationException</code>。 <code>Authorization.java</code> 接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用于说明目的的简单授权服务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthorizationService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法调用的授权检查。如果检查失败将抛出 AuthorizationException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">authorize</span><span class="params">(Method method)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>net.sf.cglib.proxy.MethodInterceptor</code> 的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> com.lizjason.cglibproxy.AuthorizationService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的 MethodInterceptor 实现，对代理方法调用应用授权检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AuthorizationService authorizationService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的 AuthorizationServic 创建 AuthorizationInterceptor </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationInterceptor</span> <span class="params">(AuthorizationService authorizationService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorizationService = authorizationService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截代理方法调用以注入授权检查。通过 MethodProxy 调用原始方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 拦截方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法传参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 用于调用原始方法的代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 可抛出任何异常；如果抛出异常，将不会调用 super 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与代理方法的签名兼容的任何值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object object, Method method, Object[] args, MethodProxy methodProxy )</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (authorizationService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//may throw an AuthorizationException if authorization failed</span></span><br><span class="line">            authorizationService.authorize(method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(object, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>intercept</code> 方法中，首先检查授权。如果授权通过，则 <code>intercept</code> 方法将调用目标对象上的原始方法。出于性能原因，使用 <code>CGLIB</code> <code>net.sf.cglib.proxy.MethodProxy</code> 对象而不是使用 <code>java.lang.reflect.Method</code> 对象进行常规反射来调用原始方法。</p>
<h4 id="使用-callbackfilter"><a class="markdownIt-Anchor" href="#使用-callbackfilter"></a> 使用 CallbackFilter</h4>
<p><code>net.sf.cglib.proxy.CallbackFilter</code> 允许您在方法级别设置回调。假设您有一个 <code>PersistenceServiceImpl</code> 类，它有两个方法：<code>save</code> 和 <code>load</code>。 <code>save</code> 方法需要授权检查，但 <code>load</code> 方法不需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lizjason.cglibproxy.PersistenceService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersistenceService 接口的简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersistenceService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">long</span> id, String data)</span> </span>&#123;</span><br><span class="line">        System.out.println(data + <span class="string">&quot; has been saved successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Jason Zhicheng Li&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>PersistenceServiceImpl</code> 类实现了 <code>PersistenceService</code> 接口，但这不是使用 <code>CGLIB</code> 生成代理所必需的。 <code>PersistenceServiceImpl</code> 的 <code>net.sf.cglib.proxy.CallbackFilter</code> 实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersistenceServiceImpl 的 CallbackFilter 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistenceServiceCallbackFilter</span> <span class="keyword">implements</span> <span class="title">CallbackFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save 方法的回调索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAVE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load 方法的回调索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOAD = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定要用于所调用方法的回调。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@method</span> 被调用的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此方法的回调数组中的回调索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;save&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SAVE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于其他方法，包括 load方法，使用第二个回调</span></span><br><span class="line">        <span class="keyword">return</span> LOAD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>accept</code> 方法将代理方法映射到回调。返回值是特定方法的回调数组中的索引。以下是 <code>PersistenceServiceImpl</code> 类的代理创建实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(PersistenceServiceImpl.class);</span><br><span class="line"></span><br><span class="line">CallbackFilter callbackFilter = <span class="keyword">new</span> PersistenceServiceCallbackFilter();</span><br><span class="line">enhancer.setCallbackFilter(callbackFilter);</span><br><span class="line"></span><br><span class="line">AuthorizationService authorizationService = ...</span><br><span class="line">Callback saveCallback = <span class="keyword">new</span> AuthorizationInterceptor(authorizationService);</span><br><span class="line">Callback loadCallback = NoOp.INSTANCE;</span><br><span class="line">Callback[] callbacks = <span class="keyword">new</span> Callback[]&#123;saveCallback, loadCallback &#125;;</span><br><span class="line">enhancer.setCallbacks(callbacks);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> (PersistenceServiceImpl)enhancer.create();</span><br></pre></td></tr></table></figure>
<p>在此示例中，<code>AuthorizationInterceptor</code> 实例应用于 <code>save</code> 方法，<code>NoOp.INSTANCE</code> 应用于 <code>load</code> 方法。可选的，您可以通过 <code>net.sf.cglib.proxy.Enhancer.setInterfaces(Class [])</code> 方法指定代理对象要实现的接口。</p>
<p>除了设置 <code>net.sf.cglib.proxy.Enhancer</code> 的回调数组外，还可以通过 <code>net.sf.cglib.proxy.Enhancer.setCallbackTypes(Class [])</code> 方法指定回调类型数组。如果在代理创建期间没有实际回调实例数组，则回调类型很有用。与回调类似，您需要使用 <code>net.sf.cglib.proxy.CallbackFilter</code> 为每个方法指定回调类型索引。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>**<code>JDK 动态代理</code>**允许我们在运行时动态的创建代理类。但必须要求代理对象实现一个或多个接口。它大量使用反射进行操作，使用原生 Java 代码。</p>
<p><strong><code>CGLIB</code></strong> 是一个功能强大的高性能代码生成库。它是 JDK 动态代理的补充，除了实现接口之外，还允许代理扩展具体的基类。底层，它使用 ASM 字节码操作框架。实质上，CGLIB 动态生成一个子类来覆盖代理类的非 final 方法。它比使用 Java 反射的 JDK 动态代理方法更快。</p>
<p><strong>CGLIB 不能代理 final 类或任何 final 方法。</strong></p>
<p>对于一般情况，您使用 JDK 动态代理方法来创建代理。 当接口不可用或性能问题时，CGLIB 是一个很好的选择。</p>
<blockquote>
<p><em>原文链接：<a target="_blank" rel="noopener" href="http://jnb.ociweb.com/jnb/jnbNov2005.html">使用 CGLIB 库动态创建代理</a></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
        <tag>CGLIB</tag>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Cache 入门</title>
    <url>/java/Java-%E7%BC%93%E5%AD%98%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="什么是缓存"><a class="markdownIt-Anchor" href="#什么是缓存"></a> 什么是缓存</h2>
<p>术语缓存在计算机中无处不在。在应用程序设计的上下文中，它经常被用来描述应用程序开发人员利用单独的内存或低延迟的数据结构。缓存，用于临时存储或缓存信息的副本或引用，应用程序可能会在稍后的某个时间点重复使用，从而减轻重新访问或重新创建它的成本。</p>
<p>在 JCache 的上下文中，术语缓存描述了 Java 的技术开发人员使用缓存提供程序临时缓存 Java 对象。</p>
<h2 id="什么时候引入缓存"><a class="markdownIt-Anchor" href="#什么时候引入缓存"></a> 什么时候引入缓存</h2>
<p>引入缓存会提高系统复杂度，因为你要考虑缓存的失效、更新、一致性等问题。</p>
<p>冒着上述种种风险，仍能说服你引入缓存的理由，总结起来无外乎以下两种：</p>
<ul>
<li>为缓解 CPU 压力而做缓存：譬如把方法运行结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用，这可以节省 CPU 算力，顺带提升响应性能。</li>
<li>为缓解 I/O 压力而做缓存：譬如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩部件（如缓存中间件）的访问，顺带提升响应性能。</li>
</ul>
<p>请注意，缓存虽然是典型以空间换时间来提升性能的手段，但它的出发点是缓解 CPU 和 I/O 资源在峰值流量下的压力，“顺带”而非“专门”地提升响应性能。这里的言外之意是如果可以通过增强 CPU、I/O 本身的性能（譬如扩展服务器的数量）来满足需要的话，那升级硬件往往是更好的解决方案，即使需要一些额外的投入成本，也通常要优于引入缓存后可能带来的风险。</p>
<h2 id="缓存设计模式"><a class="markdownIt-Anchor" href="#缓存设计模式"></a> 缓存设计模式</h2>
<h3 id="cache-aside"><a class="markdownIt-Anchor" href="#cache-aside"></a> Cache Aside</h3>
<p>其中最简单、成本最低的 Cache Aside 模式是指：</p>
<ul>
<li>读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。</li>
<li>写数据时，先写数据源，然后失效（而不是更新）掉缓存。</li>
</ul>
<p>读数据方面一般没什么出错的余地，但是写数据时，就有必要专门强调两点：一是先后顺序是先数据源后缓存。试想一下，如果采用先失效缓存后写数据源的顺序，那一定存在一段时间缓存已经删除完毕，但数据源还未修改完成，此时新的查询请求到来，缓存未能命中，就会直接流到真实数据源中。这样请求读到的数据依然是旧数据，随后又重新回填到缓存中。当数据源的修改完成后，结果就成了数据在数据源中是新的，在缓存中是老的，两者就会有不一致的情况。另一点是应当失效缓存，而不是去尝试更新缓存，这很容易理解，如果去更新缓存，更新过程中数据源又被其他请求再次修改的话，缓存又要面临处理多次赋值的复杂时序问题。所以直接失效缓存，等下次用到该数据时自动回填，期间无论数据源中的值被改了多少次都不会造成任何影响。</p>
<p>Cache Aside 模式依然是不能保证在一致性上绝对不出问题的，否则就无须设计出 <a target="_blank" rel="noopener" href="http://icyfenix.cn/distribution/consensus/paxos.html">Paxos</a> 这样复杂的共识算法了。典型的出错场景是如果某个数据是从未被缓存过，请求会直接流到真实数据源中，如果数据源中的写操作发生在查询请求之后，结果回填到缓存之前，也会出现缓存中回填的内容与数据库的实际数据不一致的情况。但这种情况的概率是很低的，Cache Aside 模式仍然是以低成本更新缓存，并且获得相对可靠结果的解决方案。</p>
<h3 id="readwrite-through"><a class="markdownIt-Anchor" href="#readwrite-through"></a> Read/Write Through</h3>
<p>Write Through 将数据同时写入高速缓存和相应的主内存位置。缓存的数据允许按需快速检索，而主存储器中的相同数据可确保在发生崩溃，电源故障或其他系统中断时不会丢失任何内容。</p>
<p>尽管直写可以最大程度地减少数据丢失的风险，但是每个写操作必须执行两次，并且这种冗余需要时间。活动的应用程序必须等待，直到将每个数据块都写入主内存和高速缓存中，然后才能开始下一个操作。因此，“数据保险”是以牺牲系统速度为代价的。</p>
<p>直写是无法容忍数据丢失的应用程序（例如银行和医疗设备控制）中首选的数据存储方法。</p>
<h3 id="write-behind-caching"><a class="markdownIt-Anchor" href="#write-behind-caching"></a> Write Behind Caching</h3>
<p>回写在每次发生更改时，数据都会先写入高速缓存，但仅在指定的时间间隔或特定条件下，数据才会写入主存储中的相应位置。</p>
<h2 id="jsr107-jcache"><a class="markdownIt-Anchor" href="#jsr107-jcache"></a> JSR107 (JCache)</h2>
<p>JCache 是 Java 的缓存 API。它由 JSR107 定义。它定义了供开发人员使用的标准 Java 缓存 API 和供实现者使用的标准 SPI（“服务提供者接口”）。</p>
<p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit">标准定义文档</a></p>
<span id="more"></span>
<h3 id="jcache-核心概念"><a class="markdownIt-Anchor" href="#jcache-核心概念"></a> JCache 核心概念</h3>
<p>Java 的缓存 API 定义了五个核心接口：<code>CachingProvider</code>，<code>CacheManager</code>，<code>Cache</code>，<code>Entry</code>  和 <code>ExpiryPolicy</code>。</p>
<p><em><strong><code>CachingProvider</code></strong></em></p>
<p>定义了建立，配置，获取，管理和控制零个或多个 <code>CacheManager</code> 的机制。应用程序可以在运行期间访问和使用零个或多个 <code>CacheProvider</code>。</p>
<p><em><strong><code>CacheManager</code></strong></em><br />
定义在上下文中了建立，配置，获取，管理和控制零个或多个唯一命名的缓存的机制。 <code>CacheManager</code> 被单个 <code>CachingProvider</code> 拥有。</p>
<p><em><strong><code>Cache</code></strong></em><br />
是一个像 Map 一样的数据结构，它允许基于 Key 的临时储存。缓存被单个 <code>CacheManager</code> 拥有。</p>
<p><em><strong><code>Entry</code></strong></em><br />
是被 <code>Cache</code> 存储的单个 key-value 对，JCache 允许我们定义按值或按引用来存储条目。</p>
<p><em><strong><code>ExpiryPolicy</code></strong></em></p>
<p>每一个被 Cache 存储的 entry 都定义了存活时间，被称作过期持续时间。**缓存过期时间是可以动态设置的，在执行某些缓存操作后，缓存条目将在设置的时间后过期。**一旦这个过期时间到达，该条目就被认为是过期了。一旦过期，就会从缓存中驱逐出去，不能再访问，更新和删除条目。</p>
<ul>
<li>getExpiryForCreation() - 创建条目时的持续时间</li>
<li>getExpiryForAccess() - 条目被访问时的新持续时间</li>
<li>getExpiryForUpdate() - 条目被更新时的新持续时间</li>
</ul>
<p>另外，getExpiryForUpdate() 和 getExpiryForAccess() 也可能返回 null，这表示缓存实现应保留创建时这些操作的条目的有效期限不变。</p>
<h3 id="按值存储和按引用存储"><a class="markdownIt-Anchor" href="#按值存储和按引用存储"></a> 按值存储和按引用存储</h3>
<p>条目（Entry）由每个缓存使用两种机制之一存储。</p>
<p><em><strong>默认的机制，称为值存储。</strong></em></p>
<p>指示实现使副本应用程序在将它们储存在 Cache 中之前提供键和值，之后在访问缓存时再返回新的条目副本。复制条目的目的是存储在缓存和从缓存中再次返回时应用程序继续变异键和值的状态，不会对缓存持有的条目造成副作用。</p>
<p>一个简单的方法实现可用于制作键和值的副本是 Java 序列化。</p>
<p><em><strong>替代和可选机制，称为引用存储。</strong></em></p>
<p>指示 Cache 实现简单地存储和返回对应用程序提供的键和值的引用，而不是按照按值存储方法的要求制作副本。如果应用程序稍后使用引用存储语义来改变提供给缓存的键或值，则突变的副作用对于从缓存访问条目的人来说是可见的，而应用程序不必更新缓存。</p>
<p>对于在 Java 堆上实现的缓存，引用存储是最快的存储技术。</p>
<h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h3>
<p>除了定义核心接口， JCache 还为我们定义了：</p>
<ul>
<li>
<p>缓存无效时的读写集成定义</p>
<p>JCache 定义基本的配置，具体服务提供商可以提供相应的实现，以便：</p>
<p>配置 <code>isReadThrough</code> 为 <code>true</code> 时，当请求的值不在高速缓存中时，配置的 <code>cacheLoaderFactory</code> 提供从 <code>CacheLoader</code> 读取值的功能（通过高速缓存读取）<br />
配置 <code>isWriteThrough</code> 为 <code>true</code> 时，当从缓存中创建/更新/删除值时，配置的 <code>cacheWriterFactory</code> 提供将值写入 <code>CacheWriter</code> （通过缓存写入）</p>
</li>
<li>
<p>缓存条目监听器接口</p>
<p>我们可以注册条目不同事件的监听器在运行期或配置阶段，通过 <code>CacheEntryListenerConfiguration</code> 注册 <code>CacheEntryListener</code>。</p>
</li>
<li>
<p>缓存注解，为用户提供与缓存交互的类的方法拦截器处理，类定义在 <code>javax.cache.annotation</code> 包中</p>
<ul>
<li>@CacheDefaults - 类级别注解，定义类中使用的所有缓存相关注解的默认属性值，如缓存名称、缓存处理器、key 生成器</li>
<li>@CacheResult - 方法级别注解，标记方法使用参数生成的键缓存自身返回的结果。</li>
<li>@CachePut</li>
<li>@CacheRemove</li>
<li>@CacheRemoveAll</li>
</ul>
</li>
<li>
<p>监控管理</p>
<p><code>javax.cache.management</code> 包提供了用于缓存管理和统计的 <code>MXBean</code> 接口</p>
<p>默认情况下，管理和统计信息均处于禁用状态。 要在配置时将其打开，可以在 <code>MutableConfiguration</code> 上使用以下方法：</p>
<ul>
<li>setManagementEnabled(boolean enabled) 启用管理</li>
<li>setStatisticsEnabled(boolean enabled)  启用统计</li>
</ul>
</li>
</ul>
<h2 id="从-jcache-到-ehcache"><a class="markdownIt-Anchor" href="#从-jcache-到-ehcache"></a> 从 JCache 到 EhCache</h2>
<p>使用 JCache 可以完成大部分的缓存操作，但是如果需要使用到 EhCache 的特性，则必须使用提供给程序的特定 API。</p>
<p>EhCache 的主要特性如下：</p>
<ul>
<li>**快速，简单。**EhCache 的线程机制是为大型高并发系统设计的，使用 EhCache 也不需要特别复杂的配置，很容易部署上线和运行。</li>
<li>**多种缓存策略。**提供 LRU、LFU 和 FIFO 缓存策略。支持基于 Cache 和 Element 的过期策略。</li>
<li>**缓存数据有两级。**内存和磁盘，因此无需担心容量问题。EhCache 为大数据存储做过优化。在大内存情况下，所有进程可以支持数百 GB 的吞吐，在单台虚拟机上可以支持多缓存管理器，还可以通过 Terracotta 服务器矩阵伸缩到数百个节点。</li>
<li>**缓存数据会在虚拟机重启的过程中写入磁盘。**EhCache 是第一个引入缓存持久化存储到开源 Java 缓存框架，缓存的数据可以在机器重启后从磁盘上重新获得，可以根据需要使用 cache.flush 方法将缓存刷到磁盘上面。</li>
<li><strong>可以通过 RMI、JMS、JGroups、可插入 API 等方式进行分布式缓存。</strong></li>
<li><strong>具有缓存和缓存管理器的侦听接口。</strong></li>
<li><strong>提供 Hibernate、Mysql 等框架的缓存实现。</strong></li>
</ul>
<p>下图是 EhCache 的架构图：</p>
<p><img src="../../images/cache/layered_architecture.png" alt="Image result for ehcache architecture diagram" /></p>
<h3 id="使用-ehcache-作为-jcache-供应商"><a class="markdownIt-Anchor" href="#使用-ehcache-作为-jcache-供应商"></a> 使用 EhCache 作为 JCache 供应商</h3>
<p>JCache 作为标准有很多的实现，我们这里主要以 EhCache 来展开学习，要想使用 EhCache 作为 JCache 的供应商很简单，我们只要将 EhCache 的 jar 包和 JCache 放在一起便可以使用。</p>
<p>通过 JCache 的接口，我们便可以操控缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CachingProvider provider = Caching.getCachingProvider();  </span><br><span class="line">CacheManager cacheManager = provider.getCacheManager();   </span><br><span class="line">MutableConfiguration&lt;Long, String&gt; configuration =</span><br><span class="line">    <span class="keyword">new</span> MutableConfiguration&lt;Long, String&gt;()  </span><br><span class="line">        .setTypes(Long.class, String.class)   </span><br><span class="line">        .setStoreByValue(<span class="keyword">false</span>)   </span><br><span class="line">        .setExpiryPolicyFactory(CreatedExpiryPolicy.factoryOf(Duration.ONE_MINUTE));  </span><br><span class="line">Cache&lt;Long, String&gt; cache = cacheManager.createCache(<span class="string">&quot;jCache&quot;</span>, configuration); </span><br><span class="line">cache.put(<span class="number">1L</span>, <span class="string">&quot;one&quot;</span>); </span><br><span class="line">String value = cache.get(<span class="number">1L</span>); </span><br></pre></td></tr></table></figure>
<p>JCache 会从应用程序的类路径中检索默认的 <code>CachingProvider</code> 实现。但这必须保证类路径上只有一个 JCache 实现，否则必须指定具体的供应商名称，可以使用设置系统变量 <code>javax.cache.spi.CachingProvider</code> 或通过调用 <code>Caching.getCachingProvider(String)</code> 静态方法指定完整的类名称。</p>
<p>上述代码中，我们获取到缓存的供应器，并从中得到一个默认的 <code>CacheManager</code> 实例，使用不可用的配置类设置了键和值的类型，条目的存储类型，以及过期方案来生成一个名称为 JCache 的缓存对象，并向缓存中添加了一组数据，并使用键获取值。</p>
<p>JCache 提供了一组最小配置，非常适合内存缓存。但是 EhCache 在拓扑和功能方面提供了更强大的实现。</p>
<h3 id="从-jcache-配置访问基础-ehcache-配置"><a class="markdownIt-Anchor" href="#从-jcache-配置访问基础-ehcache-配置"></a> 从 JCache 配置访问基础 Ehcache 配置</h3>
<p>当以使用 JCache 创建了配置时，你任然可以访问底层的 EhCache <code>CacheRuntimeConfiguration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MutableConfiguration&lt;Long, String&gt; configuration = <span class="keyword">new</span> MutableConfiguration&lt;&gt;();</span><br><span class="line">configuration.setTypes(Long.class, String.class);</span><br><span class="line">Cache&lt;Long, String&gt; cache = cacheManager.createCache(<span class="string">&quot;someCache&quot;</span>, configuration); </span><br><span class="line"></span><br><span class="line">CompleteConfiguration&lt;Long, String&gt; completeConfiguration = cache.getConfiguration(CompleteConfiguration.class); </span><br><span class="line"></span><br><span class="line">Eh107Configuration&lt;Long, String&gt; eh107Configuration = cache.getConfiguration(Eh107Configuration.class); </span><br><span class="line"></span><br><span class="line">CacheRuntimeConfiguration&lt;Long, String&gt; runtimeConfiguration = eh107Configuration.unwrap(CacheRuntimeConfiguration.class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们还可以使用 Ehcache CacheConfiguration 创建 JCache 缓存。</p>
<p>EhCache 不总是同意 JCache 的默认行为。两者在默认值上存在一定的差异。</p>
</blockquote>
<h3 id="使用编程的方式配置-ehcache"><a class="markdownIt-Anchor" href="#使用编程的方式配置-ehcache"></a> 使用编程的方式配置 EhCache</h3>
<p>我们可以使用编程配置或 XML 来配置 EhCache，个人比较喜欢以编程的形式配置大多数不是很容易变动的配置，通过使用提供流畅 API 的构建器我们可以很容易完成配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder() </span><br><span class="line">    .withCache(<span class="string">&quot;preConfigured&quot;</span>,</span><br><span class="line">        CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class, ResourcePoolsBuilder.heap(<span class="number">10</span>))) </span><br><span class="line">    .build(); </span><br><span class="line">cacheManager.init(); </span><br><span class="line"></span><br><span class="line">Cache&lt;Long, String&gt; preConfigured =</span><br><span class="line">    cacheManager.getCache(<span class="string">&quot;preConfigured&quot;</span>, Long.class, String.class); </span><br><span class="line"></span><br><span class="line">Cache&lt;Long, String&gt; myCache = cacheManager.createCache(<span class="string">&quot;myCache&quot;</span>, </span><br><span class="line">    CacheConfigurationBuilder.newCacheConfigurationBuilder(Long.class, String.class, ResourcePoolsBuilder.heap(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">myCache.put(<span class="number">1L</span>, <span class="string">&quot;da one!&quot;</span>); </span><br><span class="line">String value = myCache.get(<span class="number">1L</span>); </span><br><span class="line"></span><br><span class="line">cacheManager.removeCache(<span class="string">&quot;preConfigured&quot;</span>); </span><br><span class="line"></span><br><span class="line">cacheManager.close(); </span><br></pre></td></tr></table></figure>
<p>这里的配置很清晰明了，具体配置我们可以查看配置参数查看。</p>
<h3 id="ehcache-存储层"><a class="markdownIt-Anchor" href="#ehcache-存储层"></a> EhCache 存储层</h3>
<p>我们可以配置 Ehcache 以使用各种数据存储区域。当缓存配置为使用多个存储区域时，这些区域将按层排列和管理。它们按层次结构组织，最低层（更远）称为权限层，其他层则是缓存层的一部分（更近，也称为近缓存）。缓存层本身可以由多个存储区域组成。最热门的数据保存在缓存层中，这通常不如权限级别那么丰富但速度更快。所有数据都保存在权限层中，这更慢但更丰富。</p>
<p>Ehcache 支持的数据存储包括：</p>
<p><em><strong>堆内存储</strong></em></p>
<p>利用 Java 的堆内 RAM 内存来存储缓存条目。此层使用与 Java 应用程序相同的堆内存，所有这些都必须由 JVM 垃圾收集器扫描。JVM 使用的堆空间越多，应用程序性能就越会受到垃圾收集暂停的影响。这个存储非常快，但通常是您最有限的存储资源。</p>
<p><em><strong>堆外存储</strong></em></p>
<p>大小受限于可用的 RAM 内存。不受 Java 垃圾收集（GC）的限制。速度非常快，但比堆内存储慢，因为数据必须在存储和重新访问时移入和移出 JVM 堆，移入移出对象可能涉及到对象的序列化和反序列化。</p>
<p><em><strong>磁盘存储</strong></em></p>
<p>利用磁盘（文件系统）来存储缓存条目。这种类型的存储资源通常非常丰富，但比基于 RAM 的存储要慢得多。对于使用磁盘存储的所有应用程序，建议使用快速专用磁盘来优化吞吐量。</p>
<p><em><strong>集群存储</strong></em></p>
<p>此数据存储是远程服务器上的缓存。远程服务器可以可选地提供具有高可用性的故障转移服务器。由于集群存储会因网络延迟以及建立客户端/服务器一致性等因素而导致性能下降，这个层本质上比本地堆外存储慢。</p>
<p><img src="../../images/cache/EhcacheTerminology.png" alt="EhcacheTerminology" /></p>
<h3 id="用户管理的缓存"><a class="markdownIt-Anchor" href="#用户管理的缓存"></a> 用户管理的缓存</h3>
<p>用户管理的缓存为我们提供了一种直接配置缓存的简单方法，而无需设置或使用 CacheManager 的复杂性。是否使用 <code>UserManagedCache</code> 而不是 CacheManager 的选择通常取决于我们是否需要 CacheManager 的所有内置功能。如果缓存要求相对简单，并且不需要 CacheManager 的全部功能，则可以考虑使用 UserManagedCache。</p>
<p>使用 UserManagedCache 的典型方案有：方法本地缓存，线程本地缓存或缓存生命周期短于应用程序生命周期的任何其他位置。</p>
<p><a target="_blank" rel="noopener" href="http://www.ehcache.org/documentation/3.5/usermanaged.html">使用介绍</a></p>
<h2 id="hibernate-缓存"><a class="markdownIt-Anchor" href="#hibernate-缓存"></a> Hibernate 缓存</h2>
<p>数据库抽象层（如ORM（对象 - 关系映射）框架）的一个优点是它们能够透明地缓存从底层存储中检索的数据。这有助于消除频繁访问数据的数据库访问成本。</p>
<p>在运行时，Hibernate 处理将数据移入和移出二级缓存以响应 Session 执行的操作，该操作充当持久数据的事务级缓存。<strong>一旦实体被管理，该对象就会被添加到当前持久化上下文（EntityManager 或 Session）的内部缓存中。持久化上下文也称为第一级缓存，默认情况下已启用。</strong></p>
<p>但由于 Hibernate 会话（session）绑定到当前正在运行的逻辑事务，所以一旦事务结束，该会话也将被销毁，会话中持有的上下文也会消失。</p>
<p>适当的缓存解决方案必须跨越多个 Hibernate 会话，这就是 Hibernate 也支持附加的二级缓存的原因。 **二级缓存是绑定到 SessionFactory 域的生命周期，意味着它由使用相同会话工厂创建的所有会话共享，仅在关闭 SessionFactory 时（通常是在应用程序关闭时）才销毁。**二级缓存主要基于实体，也支持可选的查询缓存解决方案。</p>
<blockquote>
<p>Hibernate 缓存不了解其他应用程序对持久性存储所做的更改。比如 EhCache 管理的缓存。要解决此限制，可以在二级缓存区域级别配置 TTL（生存时间）保留策略，以便底层缓存条目定期到期。</p>
</blockquote>
<h3 id="配置二级缓存"><a class="markdownIt-Anchor" href="#配置二级缓存"></a> 配置二级缓存</h3>
<p>Hibernate 可以与各种缓存提供程序集成，以便在特定会话的上下文 (session) 之外缓存数据。要配置启用二级缓存，则需提供 <code>RegionFactory</code> 的实现类。</p>
<h4 id="regionfactory"><a class="markdownIt-Anchor" href="#regionfactory"></a> RegionFactory</h4>
<p><code>RegionFactory</code> 是 <code>Region</code> 的工厂类，Region 不代表缓存中的特定概念，它只是定义一些具有共同特征的基本合同，而与打算在该区域内存储的数据类型无关。更具体的子类型是 DomainDataRegion（存储实体，集合和自然 ID 数据）和 DirectAccessRegion（存储查询结果和时间戳数据）。</p>
<p><code>org.hibernate.cache.spi.RegionFactory</code> 定义了 Hibernate 与可插拔缓存提供程序之间的集成。Hibernate 二级缓存设计为让我们感觉不到所使用的实际缓存，SPI（服务提供者接口）为缓存实现者定义了接口，Hibernate 只需要提供 org.hibernate.cache.spi.RegionFactory 接口的实现，该接口封装了特定于实际缓存提供者的所有细节。基本上，它充当 Hibernate 和缓存提供者之间的桥梁。Hibernate 内置支持 Java 缓存标准 <code>JCache</code> 以及两个流行的缓存库：<code>Ehcache</code> 和 <code>Infinispan</code>。</p>
<h4 id="缓存配置属性"><a class="markdownIt-Anchor" href="#缓存配置属性"></a> 缓存配置属性</h4>
<p>除了提供程序特定的配置之外，集成的 Hibernate 端还有许多配置选项可控制各种缓存行为：</p>
<p><em><strong><code>hibernate.cache.use_second_level_cache</code></strong></em></p>
<p>整体启用或禁用二级缓存。默认情况下，如果当前配置的 RegionFactory 不是 <code>NoCachingRegionFactory</code>，则将启用第二级缓存。否则，将禁用二级缓存。</p>
<p><em><strong><code>hibernate.cache.use_query_cache</code></strong></em></p>
<p>启用或禁用查询结果的二级缓存。默认值为 false。</p>
<p><em><strong><code>hibernate.cache.query_cache_factory</code></strong></em></p>
<p>查询结果缓存由特殊的规则处理，该规则定义了数据的实效策略。默认实现是不失效，适合用于对数据要求松散的应用。或者我们可以指定自己的规则。自定义的规则只需要实现  <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/cache/spi/QueryCacheFactory.html"><code>QueryCacheFactory</code></a> 接口。hibernate 默认内置的是 <code>StandardQueryCacheFactory</code>。</p>
<p><em><strong><code>hibernate.cache.auto_evict_collection_cache</code></strong></em></p>
<p>当关联仅从拥有方改变时，启用或禁用双向关联的集合缓存条目的自动驱逐。默认情况下禁用该选项，因为它会跟踪关联状态并对性能产生影响。但是，如果您的应用程序不管理高速缓存集合端的双向关联的双方，则替代方法是在该集合缓存中保留陈旧数据。</p>
<blockquote>
<p>使用陈旧数据时很可能会出现数据不一致的情况，比如实体存在于缓存中但不存在于数据库中，在做级联删除时，会报 <code>EntityNotFoundException</code> 异常，可以在级联删除的集合上配置 <code>@NotFound(action = NotFoundAction.IGNORE)</code> 忽略该异常或者启用该选项。</p>
</blockquote>
<p><em><strong><code>hibernate.cache.use_reference_entries</code></strong></em></p>
<p>允许将实体引用直接存储到二级缓存中，以用于只读或不可变实体。使用引用存储缓存的好处是我们不用显式的维护缓存，缓存更新时直接反映给调用者。缺点是该缓存只可用于只读状态，否则对象逸出，会很难控制。</p>
<p><em><strong><code>hibernate.cache.default_cache_concurrency_strategy</code></strong></em></p>
<p>在 hibernate 二级缓存中，可以对所有区域进行不同的配置，包括在访问特定区域时要使用的并发策略。此设置允许定义要使用的默认策略。有效值包括：</p>
<ul>
<li>read-only</li>
<li>read-write</li>
<li>nonstrict-read-write</li>
<li>transactional</li>
</ul>
<p><em><strong><code>hibernate.cache.keys_factory</code></strong></em></p>
<p>当将条目 (entries) 作为键值对存储到二级缓存中时，标识符可以包装为元组 &lt;实体类型，租户，标识符&gt; 以确保唯一性，以防第二级缓存将所有实体存储在单个空间中。这些元组然后用作高速缓存中的键。当前，仅当 <code>Infinispan</code> 配置为第二级缓存实现时才支持此属性。有效值为：</p>
<ul>
<li>default（将标识符包装在元组中）</li>
<li>simple（使用标识符作为键，无需任何包装）</li>
<li>实现 <code>org.hibernate.cache.spi.CacheKeysFactory</code> 的完全限定的类名</li>
</ul>
<p><em><strong><code>hibernate.cache.use_structured_entries</code></strong></em></p>
<p>如果为 <code>true</code>，则强制 Hibernate 以更人性化的格式将数据存储在二级缓存中。如果希望能够直接在缓存中“浏览”数据，则可能会很有用，但确实会对性能产生影响。</p>
<h3 id="配置二级缓存映射"><a class="markdownIt-Anchor" href="#配置二级缓存映射"></a> 配置二级缓存映射</h3>
<p>可以通过 JPA 注解或 XML 描述符或使用特定于 Hibernate 的映射文件来配置缓存映射。默认情况下，实体不是二级缓存的一部分，我们可以通过配置 <code>javax.persistence.sharedCache.mode</code> 来映射缓存。该配置有四个选项：</p>
<p><em><strong><code>ENABLE_SELECTIVE</code></strong></em></p>
<p>默认也是推荐的选项。除非明确标记为可缓存（使用 <code>@Cacheable</code> 注解），否则不会缓存实体。</p>
<p><em><strong><code>DISABLE_SELECTIVE</code></strong></em></p>
<p>除非明确标记为不可缓存 <code>@Cachable</code> 注解 value 设置为 false，否则实体将被缓存。</p>
<p><em><strong><code>ALL</code></strong></em></p>
<p>即使标记为不可缓存，实体也始终被缓存。</p>
<p><em><strong><code>NONE</code></strong></em></p>
<p>即使标记为可缓存，也不会缓存任何实体。此选项可以完全禁用二级缓存。</p>
<p>默认情况下使用的缓存并发策略可以通过以下方式全局设置 <code>hibernate.cache.default_cache_concurrency_strategy</code> 来配置属性，配置选项如下：</p>
<p><em>read-only</em></p>
<p>如果您的应用程序需要读取但不修改持久化类的实例，则只读缓存是最佳选择。应用程序仍然可以删除实体，这些更改应该反映在二级缓存中，以便缓存不提供过时的实体。实现可以基于实体的不变性来使用性能优化。</p>
<p><em>read-write</em></p>
<p>如果应用程序需要更新数据，则读写缓存可能是合适的。此策略提供对单个实体的一致访问，但不提供可序列化的事务隔离级别；实现可以基于实体的不变性来使用性能优化。</p>
<p><em>nonstrict-read-write</em></p>
<p>与读写策略类似，但在并发访问实体时可能偶尔会出现过时读取。如果应用程序很少同时更新相同的数据并且不需要严格的事务隔离，则可以选择此策略。实现可以使用利用宽松一致性保证的性能优化。</p>
<p><em>transactional</em></p>
<p>提供可序列化的事务隔离级别。</p>
<blockquote>
<p>建议不要使用全局设置，而是基于每个实体、方法或集合字段上定义缓存并发策略。为此，请使用 <code>@ org.hibernate.annotations.Cache</code> 注解。</p>
</blockquote>
<p>该注解有三个属性：</p>
<p><em>usage</em></p>
<p>定义 <code>CacheConcurrencyStrategy</code>。</p>
<p><em>region</em></p>
<p>定义存储条目的缓存区域。对于每个实体类，Hibernate 将使用单独的缓存区域来存储该类的实例状态。区域名称是完全限定的类名。</p>
<p><em>include</em></p>
<p>是否（lazy）延迟加载属性应包含在二级缓存中。默认值是所有延迟属性都可缓存。另一个可能的值是非延迟，因此延迟属性不可缓存。</p>
<h3 id="实体继承和二级缓存映射"><a class="markdownIt-Anchor" href="#实体继承和二级缓存映射"></a> 实体继承和二级缓存映射</h3>
<p>传统上，当使用实体继承时，Hibernate 要求实体层次结构完全缓存或根本不缓存。因此，如果要缓存属于给定实体层次结构的子类，则 JPA <code>@Cacheable</code> 和特定于 Hibernate 的 <code>@Cache</code> 注解必须仅在根实体级别声明。</p>
<blockquote>
<p>Cacheable 注解的值由子类继承；可以通过在子类上指定 Cacheable 来覆盖它。从 Hibernate ORM 5.3 开始，您现在可以在子类级别覆盖基类 @Cacheable 或 @Cache 定义。但是，Hibernate 缓存并发策略（例如，只读，非严格读写，读写，事务）仍然在根实体级别定义，并且不能被覆盖。</p>
</blockquote>
<h3 id="管理缓存数据"><a class="markdownIt-Anchor" href="#管理缓存数据"></a> 管理缓存数据</h3>
<p>传统上，Hibernate 定义了 <code>CacheMode</code> 枚举来描述与缓存数据交互的方式。 JPA 通过存储（<code>CacheStoreMode</code>）和检索（<code>CacheRetrieveMode</code>）分割缓存模式。两者的关系如下表：</p>
<table>
<thead>
<tr>
<th>Hibernate</th>
<th>JPA</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CacheMode.NORMAL</td>
<td><code>CacheStoreMode.USE</code> 和 <code>CacheRetrieveMode.USE</code></td>
<td>默认。from/into 缓存读取/写入数据</td>
</tr>
<tr>
<td>CacheMode.REFRESH</td>
<td><code>CacheStoreMode.REFRESH</code> 和 <code>CacheRetrieveMode.BYPASS</code></td>
<td>不从缓存中读取，而是在从数据库加载时写入缓存</td>
</tr>
<tr>
<td>CacheMode.PUT</td>
<td><code>CacheStoreMode.USE</code> 和 <code>CacheRetrieveMode.BYPASS</code></td>
<td>不从缓存中读取，而是在从数据库读取时写入缓存</td>
</tr>
<tr>
<td>CacheMode.GET</td>
<td><code>CacheStoreMode.BYPASS</code> 和 <code>CacheRetrieveMode.USE</code></td>
<td>从缓存中读取，但不写入缓存</td>
</tr>
<tr>
<td>CacheMode.IGNORE</td>
<td><code>CacheStoreMode.BYPASS</code> 和 <code>CacheRetrieveMode.BYPASS</code></td>
<td>不从缓存读取/写入数据</td>
</tr>
</tbody>
</table>
<p>设置缓存模式可以在直接加载实体或执行查询时完成。</p>
<ul>
<li>使用 JPA 自定义缓存模式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; hints = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">hints.put( <span class="string">&quot;javax.persistence.cache.retrieveMode&quot;</span> , CacheRetrieveMode.USE );</span><br><span class="line">hints.put( <span class="string">&quot;javax.persistence.cache.storeMode&quot;</span> , CacheStoreMode.REFRESH );</span><br><span class="line">Person person = entityManager.find( Person.class, <span class="number">1L</span> , hints);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Hibernate 自定义缓存模式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setCacheMode( CacheMode.REFRESH );</span><br><span class="line">Person person = session.get( Person.class, <span class="number">1L</span> );</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 Spring Data JPA 自定义缓存模式（1.10 版本之后）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@QueryHints(value = &#123;</span></span><br><span class="line"><span class="meta">    @QueryHint(name = &quot;javax.persistence.cache.retrieveMode&quot;, value = &quot;USE&quot;),</span></span><br><span class="line"><span class="meta">    @QueryHint(name = &quot;javax.persistence.cache.storeMode&quot;, value = &quot;REFRESH&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function">Optional&lt;Person&gt; <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>查询缓存，集合缓存，和缓存统计以后再来补充。</p>
<h2 id="spring-boot-使用-ehcache"><a class="markdownIt-Anchor" href="#spring-boot-使用-ehcache"></a> Spring Boot 使用 EhCache</h2>
<p>个人使用 Gradle 管理项目依赖，以下所述依赖皆是以基于Groovy 的特定于域的语言（DSL）定义。</p>
<h3 id="仅使用缓存"><a class="markdownIt-Anchor" href="#仅使用缓存"></a> 仅使用缓存</h3>
<p>Spring Boot 使用缓存非常简单，我们只需要导入所需要的包即可开箱即用，如果我们仅仅想使用缓存，则直接引入：<code>org.springframework.boot:spring-boot-starter-cache</code> starter 便可使用。</p>
<p>在配置类或启动类上加入  <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/EnableCaching.html"><code>@EnableCaching</code></a> 注解，该注解会触发一个后处理器（post processor）去检测每个 Spring Bean 上是否存在公共方法的缓存注解。如果找到这样的注解，则自动创建代理以拦截方法调用并相应地处理缓存行为。</p>
<p>此后处理器管理的注解是 <code>Cacheable</code>，<code>CachePut</code> 和 <code>CacheEvict</code>。Spring Boot 会自动配置合适的 <code>CacheManager</code> 作为相关缓存的提供程序。如果只引入了该包，则默认只会使用 Spring 上下文 <strong><code>ConcurrentHashMap</code></strong> 结构来存储缓存，这完全符合 JCache 的标准。</p>
<p>如果当前上下文中存在 JSR-107 API，即 <code>javax.cache:cache-api</code> 该 jar 包，将额外的为 JSR-107 API 注解的 bean 创建代理，这些注解是 <code>@CacheResult</code>，<code>@CachePut</code>，<code>@CacheRemove</code> 和 <code>@CacheRemoveAll</code>。</p>
<h3 id="使用-jcache-来构建-hibernate-二级缓存"><a class="markdownIt-Anchor" href="#使用-jcache-来构建-hibernate-二级缓存"></a> 使用 JCache 来构建 Hibernate 二级缓存</h3>
<p>要使用 JCache 的内置集成，您需要将 <code>hibernate-jcache</code> 模块 <code>org.hibernate:hibernate-jcache</code> jar 集成进去。此外，还需要添加 JCache 实现。</p>
<p><code>hibernate-jcache</code> 模块定义了以下区域工厂：<code>JCacheRegionFactory</code>。</p>
<p>要使用该 <code>JCacheRegionFactory</code>，只需配置该属性为：<code>hibernate.cache.region.factory_class: org.hibernate.cache.jcache.JCacheRegionFactory</code>。</p>
<p>JCache 要求共享相同 URI 和类加载器的 CacheManagers 在 JVM 中是唯一的。如果未指定其他属性，JCacheRegionFactory 将加载默认的 JCache 提供程序并创建默认的 CacheManager。同样的，将使用默认的 <code>javax.cache.configuration.MutableConfiguration</code> 创建缓存。</p>
<p>为了控制使用哪个提供程序为 CacheManager 和 Caches 指定配置，您可以使用以下两个属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;hibernate.javax.cache.provider&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;org.ehcache.jsr107.EhcacheCachingProvider&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;hibernate.javax.cache.uri&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;file:/path/to/ehcache.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-ehcache-20-构建-hibernate-二级缓存"><a class="markdownIt-Anchor" href="#使用-ehcache-20-构建-hibernate-二级缓存"></a> 使用 EhCache 2.0 构建 Hibernate 二级缓存</h3>
<p>使用 Ehcache 的内置集成要求我们引入 <code>org.hibernate:hibernate-ehcahe</code> jar 作为依赖。</p>
<p>同样的我们需要配置 RegionFactory 为：<code>hibernate.cache.region.factory_class: org.hibernate.cache.ehcache.EhCacheRegionFactory</code> 。</p>
<p>强制 Hibernate 使用单个 Ehcache CacheManager：<code>hibernate.cache.region.factory_class: org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory</code> 。</p>
<h3 id="使用-ehcache-30-构建-hibernate-二级缓存"><a class="markdownIt-Anchor" href="#使用-ehcache-30-构建-hibernate-二级缓存"></a> 使用 EhCache 3.0 构建 Hibernate 二级缓存</h3>
<p>使用 EhCache 3.0 时，hibernate 并没有默认的模块支持。但是我们可以通过 JCache 来指定具体的实现完成。</p>
<p>我们同时引入 <code>org.ehcache:ehcache</code> 和 <code>org.hibernate:hibernate-jcache</code>，这里我们并没有指明具体版本，因为我们使用 spring boot starter 管理的版本，具体可以查看自己 spring boot starter 的版本和依赖版本。</p>
<p>我们可以指定服务提供者 <code>hibernate.javax.cache.provider</code> 来完成配置。但是 <code>JCacheRegionFactory</code> 会使用默认的 <code>MutableConfiguration</code> 来创建 Cache，如果我们需要使用 EhCache 的配置来定义缓存，我们需要自己定义 RegionFactory 并以此作为 RegionFactory 配置。</p>
<p>为了防止 JCacheRegionFactory 自动创建缓存，我们可以按如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoDefaultJCacheRegionFactory</span> <span class="keyword">extends</span> <span class="title">JCacheRegionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCEPTION_MESSAGE = <span class="string">&quot;All Hibernate caches should be created upfront. &quot;</span> +</span><br><span class="line">        <span class="string">&quot;Please update CacheConfiguration.java to add&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Cache&lt;Object, Object&gt; <span class="title">createCache</span><span class="params">(String regionName, Properties properties, CacheDataDescription</span></span></span><br><span class="line"><span class="params"><span class="function">        metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(EXCEPTION_MESSAGE + <span class="string">&quot; &quot;</span> + regionName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后指定二级缓存 CacheManager 的创建方法，并使用当前的 CalssLoader，修复了 Spring Boot 2.0.3 中引入的 Spring 类加载器问题。 这允许对 ehcache 使用相同的类加载器，包括 Spring Cache 抽象和 Hibernate  2nd 级缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanClassLoaderAwareJCacheRegionFactory</span> <span class="keyword">extends</span> <span class="title">NoDefaultJCacheRegionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> CacheManager <span class="title">getCacheManager</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(classLoader, <span class="string">&quot;Please set Spring&#x27;s classloader in the setBeanClassLoader &quot;</span> +</span><br><span class="line">            <span class="string">&quot;method before using this class in Hibernate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CachingProvider cachingProvider = getCachingProvider(properties);</span><br><span class="line">        String cacheManagerUri = getProp(properties, CONFIG_URI);</span><br><span class="line"></span><br><span class="line">        URI uri = getUri(cachingProvider, cacheManagerUri);</span><br><span class="line">        CacheManager cacheManager = cachingProvider.getCacheManager(uri, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To prevent some class loader memory leak this might cause</span></span><br><span class="line">        setBeanClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> URI <span class="title">getUri</span><span class="params">(CachingProvider cachingProvider, String cacheManagerUri)</span> </span>&#123;</span><br><span class="line">        URI uri;</span><br><span class="line">        <span class="keyword">if</span> (cacheManagerUri != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                uri = <span class="keyword">new</span> URI(cacheManagerUri);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">&quot;Couldn&#x27;t create URI from &quot;</span> + cacheManagerUri, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri = cachingProvider.getDefaultURI();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method must be called from a Spring Bean to get the classloader.</span></span><br><span class="line"><span class="comment">     * For example: BeanClassLoaderAwareJCacheRegionFactory.setBeanClassLoader(this.getClass().getClassLoader());</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader The Spring classloader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        BeanClassLoaderAwareJCacheRegionFactory.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以使用 EhCache 的配置来创建缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> javax.cache.configuration.Configuration&lt;Object, Object&gt; jcacheConfiguration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheConfiguration</span><span class="params">(ApplicationProperties applicationProperties)</span> </span>&#123;</span><br><span class="line">        BeanClassLoaderAwareJCacheRegionFactory.setBeanClassLoader(<span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        ApplicationProperties.Cache.Ehcache ehcache =</span><br><span class="line">            applicationProperties.getCache().getEhcache();</span><br><span class="line"></span><br><span class="line">        CacheEventListenerConfigurationBuilder cacheEventListenerConfiguration = CacheEventListenerConfigurationBuilder</span><br><span class="line">            .newEventListenerConfiguration(<span class="keyword">new</span> CacheListener(applicationProperties), EventType.CREATED, EventType.UPDATED, EventType.EVICTED, EventType.EXPIRED, EventType.REMOVED)</span><br><span class="line">            .unordered().asynchronous();</span><br><span class="line"></span><br><span class="line">        jcacheConfiguration = Eh107Configuration.fromEhcacheCacheConfiguration(</span><br><span class="line">            CacheConfigurationBuilder.newCacheConfigurationBuilder(Object.class, Object.class,</span><br><span class="line">                ResourcePoolsBuilder.heap(ehcache.getMaxEntries()))</span><br><span class="line">                .add(<span class="keyword">new</span> Jsr107CacheConfiguration(ConfigurationElementState.ENABLED, ConfigurationElementState.ENABLED))</span><br><span class="line">                .add(cacheEventListenerConfiguration)</span><br><span class="line">                .withExpiry(ExpiryPolicyBuilder.timeToLiveExpiration(Duration.ofSeconds(ehcache.getTimeToLiveSeconds())))</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JCacheManagerCustomizer <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cm -&gt; &#123;</span><br><span class="line">         cm.createCache(com.zeral.domain.User.class.getName(), jcacheConfiguration);</span><br><span class="line">         cm.createCache(com.auo.spc.domain.User.class.getName() + <span class="string">&quot;.authorities&quot;</span>, jcacheConfiguration);</span><br><span class="line">         <span class="comment">// application-needle-ehcache-add-entry</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用了堆内存储，并指定了每个域最大缓存条目数，指定了缓存键和值的类型，以及过期策略，并开启了监控，配置了缓存监听器。</p>
<p>这里我们并没有使用 Hibernate 的 <code>@Cacheable</code> 来显示指明需要缓存哪里实体或集合，而是手动的通过调用 cacheManager 创建了基于 Ehcache 配置的缓存，<code>JCacheManagerCustomizer</code> 回掉函数允许我们在 Spring Boot 根据当前环境服务提供者 JCacheRegionFactory 创建缓存管理器时做一些额外的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">jCacheCacheManager</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   CacheManager jCacheCacheManager = createCacheManager();</span><br><span class="line">   List&lt;String&gt; cacheNames = <span class="keyword">this</span>.cacheProperties.getCacheNames();</span><br><span class="line">   <span class="keyword">if</span> (!CollectionUtils.isEmpty(cacheNames)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String cacheName : cacheNames) &#123;</span><br><span class="line">         jCacheCacheManager.createCache(cacheName, getDefaultCacheConfiguration());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   customize(jCacheCacheManager);</span><br><span class="line">   <span class="keyword">return</span> jCacheCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hibernate-二级缓存如何工作"><a class="markdownIt-Anchor" href="#hibernate-二级缓存如何工作"></a> Hibernate 二级缓存如何工作</h2>
<p>每当要加载实体时，都会触发 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/event/spi/LoadEvent.html">LoadEevent</a>，并且 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/event/internal/DefaultLoadEventListener.html">DefaultLoadEventListener</a> 对其进行如下处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object entity = loadFromSessionCache( event,</span><br><span class="line">    keyToLoad, options );</span><br><span class="line"><span class="keyword">if</span> ( entity == REMOVED_ENTITY_MARKER ) &#123;</span><br><span class="line">    LOG.debug(<span class="string">&quot;Load request found matching entity</span></span><br><span class="line"><span class="string">        in context, but it is scheduled for removal;</span></span><br><span class="line"><span class="string">        returning null&quot;</span> );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( entity == INCONSISTENT_RTN_CLASS_MARKER ) &#123;</span><br><span class="line">    LOG.debug(<span class="string">&quot;Load request found matching entity</span></span><br><span class="line"><span class="string">        in context, but the matched entity was of</span></span><br><span class="line"><span class="string">        an inconsistent return type;</span></span><br><span class="line"><span class="string">        returning null&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( entity != <span class="keyword">null</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( traceEnabled ) &#123;</span><br><span class="line">        LOG.tracev(<span class="string">&quot;Resolved object in &quot;</span></span><br><span class="line">            + <span class="string">&quot;session cache: &#123;0&#125;&quot;</span>,</span><br><span class="line">            MessageHelper.infoString( persister,</span><br><span class="line">                event.getEntityId(),</span><br><span class="line">                event.getSession().getFactory() )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">entity = loadFromSecondLevelCache( event,</span><br><span class="line">    persister, options );</span><br><span class="line"><span class="keyword">if</span> ( entity != <span class="keyword">null</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( traceEnabled ) &#123;</span><br><span class="line">        LOG.tracev(<span class="string">&quot;Resolved object in &quot;</span></span><br><span class="line">            + <span class="string">&quot;second-level cache: &#123;0&#125;&quot;</span>,</span><br><span class="line">            MessageHelper.infoString( persister,</span><br><span class="line">                event.getEntityId(),</span><br><span class="line">                event.getSession().getFactory() )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( traceEnabled ) &#123;</span><br><span class="line">        LOG.tracev(<span class="string">&quot;Object not resolved in &quot;</span></span><br><span class="line">            + <span class="string">&quot;any cache: &#123;0&#125;&quot;</span>,</span><br><span class="line">            MessageHelper.infoString( persister,</span><br><span class="line">                event.getEntityId(),</span><br><span class="line">                event.getSession().getFactory() )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    entity = loadFromDatasource( event, persister,</span><br><span class="line">        keyToLoad, options );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 <code>doLoad</code> 方法协调加载给定实体的工作。首先，尝试从会话级缓存中加载实体。如果在此处找不到，再尝试从二级缓存加载。最后，尝试直接从数据源加载它。</p>
<h3 id="二级缓存内部"><a class="markdownIt-Anchor" href="#二级缓存内部"></a> 二级缓存内部</h3>
<p>实体被作为 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/cache/spi/entry/CacheEntry.html"><em>CacheEntry</em></a> 存储，实体 <em>水合 (hydrated)</em><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 状态用于创建缓存条目值。</p>
<h4 id="水合"><a class="markdownIt-Anchor" href="#水合"></a> 水合</h4>
<p>在 Hibernate 中，<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/persister/entity/Loadable.html#hydrate">水合作用</a> 是将 <em>JDBC ResultSet</em> 转换为由原始值组成的数组的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] values = persister.hydrate(</span><br><span class="line">    rs, id, object,</span><br><span class="line">    rootPersister, cols, eagerPropertyFetch, session</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>水合状态以 EntityEntry 对象的形式保存在当前运行的持久化上下文中，该对象封装了加载时的实体快照。然后通过以下方式使用水合状态：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://vladmihalcea.com/the-anatomy-of-hibernate-dirty-checking/">默认脏检查机制</a>，它将当前实体数据与加载时的快照比较</li>
<li>二级缓存，其缓存项是根据加载时实体快照构建的</li>
</ul>
<p>反向操作称为<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/persister/entity/AbstractEntityPersister.html#dehydrate">脱水</a>，它将实体状态复制到 <em>INSERT</em> 或 <em>UPDATE</em> 语句中。</p>
<h4 id="二级缓存键"><a class="markdownIt-Anchor" href="#二级缓存键"></a> 二级缓存键</h4>
<p>键 <a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/4.3/javadocs/org/hibernate/cache/spi/CacheKey.html">CacheKey</a> 在之前介绍过，默认会将标识符封装在元组中构建。</p>
<h4 id="二级缓存值元素"><a class="markdownIt-Anchor" href="#二级缓存值元素"></a> 二级缓存值元素</h4>
<p>二级缓存值元素使用拆解的水合状态构建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> CacheEntry entry = persister.buildCacheEntry(entity, hydratedState, version, session);</span><br></pre></td></tr></table></figure>
<p>水合状态在存储到 CacheEntry 中之前先进行分解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.disassembledState = TypeHelper.disassemble(</span><br><span class="line">    state, </span><br><span class="line">    persister.getPropertyTypes(),</span><br><span class="line">    persister.isLazyPropertiesCacheable() ? <span class="keyword">null</span> : persister.getPropertyLaziness(),</span><br><span class="line">    session,</span><br><span class="line">    owner</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下来会根据配置来选择是否结构化存储值，其中：</p>
<ul>
<li>不存储 id（主键）它作为缓存键的一部分存储</li>
<li>瞬态（Transient）属性不存储</li>
<li>集合不存储</li>
<li>非关联属性值以其原始格式存储</li>
<li>ToOne 关联仅存储 id（外键）</li>
</ul>
<p>我们必须明确指出集合（OneToMany 或 ManyToMany 关联）是可缓存的，否则就不会缓存。</p>
<p>实际上，Hibernate 将集合存储在单独的缓存区域中，每个集合一个。区域名称是完全限定的类名称加上集合属性的名称。如上诉代码手动添加的用户角色关联缓存。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>二级缓存是关系数据缓存，因此它以规范化形式存储数据，并且每个实体更新仅影响一个缓存条目。由于在二级缓存条目中未实现实体关联，因此无法读取整个实体图（entity graph）。</p>
<p>聚合的实体图以使写入操作复杂化为代价，但为读取操作提供了更好的性能。如果未对缓存的数据进行规范化并将其散布在各种聚合模型中，则实体更新将不得不修改多个缓存项，从而影响写入操作的性能。</p>
<p>由于它反映了基础关系数据，因此二级缓存提供了各种并发策略机制，因此我们可以平衡读取性能和保证一致性。</p>
<hr class="footnotes-sep" />
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>水合，最初是一个术语，表示从 DB 中填充实例化但为空的值-对象/模型。在给某物补水时，例如干无花果，该物质的本质在那里，但缺乏饱满感。这就是“水合”对象时发生的事情。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>Cache</tag>
        <tag>EhCache</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Agent</title>
    <url>/java/Java-Agent/</url>
    <content><![CDATA[<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html">Java Instrumentation API</a>，提供允许 Java 编程语言代理人（agent）检测（instrument）在 JVM 上运行的程序的服务。</p>
<p>检测（Instrumennt）设计的目的是将字节码添加到方法中，收集工具使用的数据。出于这个目的，因为更改纯粹是附加的，因此这些工具不会修改应用程序状态或行为。此类良性工具的示例包括监控代理、分析器、覆盖分析器和事件记录器。</p>
<p>由于这种检测机制提供了修改现有已编译 Java 类的字节码或添加字节码的能力，所以我们也可以动态修改运行的程序代码。</p>
<span id="more"></span>
<blockquote>
<p>注意：开发人员/管理员负责验证他们部署的 Java 代理的内容和结构的可信度，因为它们能够任意转换来自其他 JAR 文件的字节码。由于这是在包含字节码的 Jars 被验证为可信之后发生的，因此 Java 代理的可信度将确定整个程序的可信度。</p>
</blockquote>
<p>agent 代理，以下文章中的所述代理都是指 agent。</p>
<h1 id="启动-java-agent"><a class="markdownIt-Anchor" href="#启动-java-agent"></a> 启动 Java Agent</h1>
<p>代理人（agent）通常部署为 JAR 文件。 JAR 文件清单（MANIFEST.MF）中的属性指定将加载以启动代理的代理类。可以通过多种方式启动代理：</p>
<ul>
<li>对于支持命令行接口的实现，可以通过在命令行上指定一个选项来启动代理。</li>
<li>也支持在 VM 启动一段时间后启动代理的机制的实现。例如，实现可以提供一种机制，允许工具附加到正在运行的应用程序，并初始化加载工具代理到正在运行的应用程序中。</li>
<li>代理也可以与应用程序一起打包在一个可执行的 JAR 文件中。</li>
</ul>
<p>下面描述了 <strong>Java 11</strong> 中这些启动代理的方式：</p>
<h2 id="通过命令行接口启动代理"><a class="markdownIt-Anchor" href="#通过命令行接口启动代理"></a> 通过命令行接口启动代理</h2>
<p>如果实现提供了从命令行接口启动代理的方法，则可以通过向命令行添加以下选项来启动代理，这种实现一般称为<strong>静态加载</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-javaagent:&lt;jarpath&gt;[=&lt;options&gt;]</span><br></pre></td></tr></table></figure>
<p>其中 <jarpath> 是代理 JAR 文件的路径，<options> 是代理选项。</p>
<p>代理 JAR 文件的清单必须在其主清单中包含属性 <code>Premain-Class</code>。该属性的值是代理类的名称。代理类必须实现一个与主应用程序入口点原则相似的 <code>public static premain</code> 方法。在 Java 虚拟机 (JVM) 初始化之后，将调用 <code>premain</code> 方法，然后才是真正的应用程序 <code>main</code> 方法。 <code>premain</code> 方法必须返回才能继续启动。</p>
<p><code>premain</code> 方法具有两个可能的签名之一。 JVM 首先尝试在代理类上调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br></pre></td></tr></table></figure>
<p>如果代理类未实现此方法，则 JVM 将尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span></span><br></pre></td></tr></table></figure>
<p>代理类可能还有一个 <code>agentmain</code> 方法，用于在 VM 启动后启动代理时使用（见下文）。当使用命令行选项启动代理时，不会调用 <code>agentmain</code> 方法。</p>
<p>每个代理都通过 <code>agentArgs</code> 参数传递其代理选项。代理选项作为单个字符串传递，任何额外的解析都应该由代理本身执行。</p>
<p>如果无法启动代理（例如，无法加载代理类，或者代理类没有合适的 <code>premain</code> 方法），<strong>JVM 将中止</strong>。如果 <code>premain</code> 方法抛出未捕获的异常，JVM 将中止。</p>
<p><code>-javaagent</code> 选项可以在同一命令行上多次使用，从而启动多个代理。<code>premain</code> 方法将按照代理在命令行上指定的顺序调用。多个代理可能使用相同的 <jarpath>。</p>
<p>代理 <code>premain</code> 方法可以做什么没有建模限制。应用程序 <code>main</code> 可以做的任何事情，包括创建线程，在 <code>premain</code> 中都是合法的。</p>
<h2 id="在-vm-启动后启动代理"><a class="markdownIt-Anchor" href="#在-vm-启动后启动代理"></a> 在 VM 启动后启动代理</h2>
<p>实现也可以提供一种机制来在 VM 启动后的某个时间启动代理，一般称为<strong>动态加载</strong>。关于如何启动的细节是特定于实现的，但通常应用程序已经启动并且它的 <code>main</code> 方法已经被调用。</p>
<p>我们可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/jdk.attach/module-summary.html">Java Attach API</a> 来将代理附加到应用程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VirtualMachine jvm = VirtualMachine.attach(jvmPid);</span><br><span class="line">jvm.loadAgent(agentFile.getAbsolutePath());</span><br><span class="line">jvm.detach();</span><br></pre></td></tr></table></figure>
<p>如果实现支持在 VM 启动后启动代理，则以下适用：</p>
<ul>
<li>代理 JAR 的清单必须在其清单中包含属性 <code>Agent-Class</code>。该属性的值是代理类的名称。</li>
<li>代理类必须实现 <code>public static agentmain</code> 方法。</li>
</ul>
<p>agentmain 方法具有两种可能的签名之一。 JVM 首先尝试在代理类上调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br></pre></td></tr></table></figure>
<p>如果代理类未实现此方法，则 JVM 将尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs)</span></span></span><br></pre></td></tr></table></figure>
<p>当使用命令行选项启动代理时，代理类也可能有一个 <code>premain</code> 方法。在 VM 启动后启动代理时，不会调用 <code>premain</code> 方法。</p>
<p>代理通过 <code>agentArgs</code> 参数传递其代理选项。代理选项作为单个字符串传递，任何额外的解析都应该由代理本身执行。</p>
<p><code>agentmain</code> 方法应该执行启动代理所需的任何必要初始化。启动完成后，该方法应返回。如果无法启动代理（例如，因为无法加载代理类，或者因为代理类没有符合的 <code>agentmain</code> 方法），<strong>JVM 不会中止</strong>。如果 <code>agentmain</code> 方法抛出未捕获的异常，它将被忽略（但可能会被 JVM 记录以进行故障排除）。</p>
<h2 id="在可执行-jar-文件中包含代理"><a class="markdownIt-Anchor" href="#在可执行-jar-文件中包含代理"></a> 在可执行 JAR 文件中包含代理</h2>
<p>JAR 文件规范定义了打包为可执行 JAR 文件的独立应用程序的清单属性。</p>
<p>如果实现支持将应用程序作为可执行 JAR 启动的机制，则主清单可能包含 <code>Launcher-Agent-Class</code> 属性，以指定要在调用应用程序主方法之前启动的代理的类名。 Java 虚拟机尝试在代理类上调用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span></span><br></pre></td></tr></table></figure>
<p>如果代理类未实现此方法，则 JVM 将尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs)</span></span></span><br></pre></td></tr></table></figure>
<p><code>agentmain</code> 方法应该执行启动代理和返回所需的任何必要初始化。如果无法启动代理，例如无法加载代理类，代理类没有定义符合规范的 <code>agentmain</code> 方法，或者 <code>agentmain</code> 方法抛出未捕获的异常或错误，<strong>JVM 将中止</strong>。</p>
<h2 id="加载代理类和代理类可用的模块类"><a class="markdownIt-Anchor" href="#加载代理类和代理类可用的模块类"></a> 加载代理类和代理类可用的模块/类</h2>
<blockquote>
<p>这里的模块是指 Java 11 的模块化系统的模块。</p>
</blockquote>
<p>从代理 JAR 文件加载的类由<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#getSystemClassLoader()">系统类加载器</a>加载，并且是系统类加载器的<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#getUnnamedModule()">未命名模块</a>的成员。系统类加载器通常也定义包含应用程序 <code>main</code> 方法的类。</p>
<p>代理类可见的类是系统类加载器可见的类，至少包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html#boot()">引导层</a>模块导出的包中的类。引导层是否包含所有平台模块将取决于初始模块或应用程序的启动方式。</li>
<li>可以由系统类加载器（通常是类路径）定义为未命名模块成员的类。</li>
<li>代理安排由引导类加载器定义的任何类，作为其未命名模块的成员。</li>
</ul>
<p>如果代理类需要链接到不在引导层中的平台（或其他）模块中的类，那么应用程序可能需要在启动确保这些模块在引导层中。例如，在 JDK 实现中，<code>--add-modules</code> 命令行选项可用于将模块添加到要在启动时解析的根模块集中。</p>
<p>支持安排由引导类加载器加载的代理类（通过 <code>appendToBootstrapClassLoaderSearch</code> 或下面指定的 <code>Boot-Class-Path</code> 属性），必须只链接到定义到引导类加载器的类。不能保证所有平台类都可以由引导类加载器定义。</p>
<p>如果配置了自定义系统类加载器（通过 <code>getSystemClassLoader</code> 方法中指定的系统属性 <code>java.system.class.loader</code>），则它必须定义 <code>appendToSystemClassLoaderSearch</code> 中指定的 <code>appendToClassPathForInstrumentation</code> 方法。 换句话说，自定义系统类加载器必须支持将代理 JAR 文件添加到系统类加载器搜索的机制。</p>
<h2 id="清单属性manifest-attributes"><a class="markdownIt-Anchor" href="#清单属性manifest-attributes"></a> 清单属性(Manifest Attributes)</h2>
<p>为代理 JAR 文件定义了以下清单属性：</p>
<ul>
<li>
<p><code>Premain-Class</code></p>
<p>在 JVM 启动时指定代理时，此属性指定代理类。也就是说，包含 <code>premain</code> 方法的类。在 JVM 启动时指定代理时，此属性是必需的。如果该属性不存在，JVM 将中止。注意：这是一个类名，而不是文件名或路径。</p>
</li>
<li>
<p><code>Agent-Class</code></p>
<p>如果实现支持在 VM 启动后某个时间启动代理的机制，则该属性指定代理类。即包含 <code>agentmain</code> 方法的类。如果此属性不存在，代理将不会启动。注意：这是一个类名，而不是文件名或路径。</p>
</li>
<li>
<p><code>Launcher-Agent-Class</code></p>
<p>如果实现支持将应用程序作为可执行 JAR 启动的机制，则主清单可能包含此属性，以指定要在调用应用程序主方法之前启动的代理的类名。</p>
</li>
<li>
<p><code>Boot-Class-Path</code></p>
<p>引导类加载器要搜索的路径列表。路径代表目录或库（在许多平台上通常称为 JAR 或 zip 库）。在定位类的平台特定机制失败后，引导类加载器会搜索这些路径。按照列出的顺序搜索路径。列表中的路径由一个或多个空格分隔。路径采用分层 URI 的路径组件的语法。如果路径以斜杠字符 (’/’) 开头，则该路径是绝对路径，否则它是相对路径。根据代理 JAR 文件的绝对路径解析相对路径。格式错误和不存在的路径将被忽略。在 VM 启动后某个时间启动代理时，不代表 JAR 文件的路径将被忽略。该属性是可选的。</p>
</li>
<li>
<p><code>Can-Redefine-Classes</code></p>
<p>布尔值（true 或 false，大小写无关）。是否能够重新定义此代理所需的类。 true 以外的值被认为是 false。该属性是可选的，默认为 false。</p>
</li>
<li>
<p><code>Can-Retransform-Classes</code></p>
<p>布尔值（true 或 false，大小写无关）。是否能够重新转换此代理所需的类。 true 以外的值被认为是 false。该属性是可选的，默认为 false。</p>
</li>
<li>
<p><code>Can-Set-Native-Method-Prefix</code></p>
<p>布尔值（true 或 false，大小写无关）。是否能够设置此代理所需的本机方法前缀。 true 以外的值被认为是 false。该属性是可选的，默认为 false。</p>
</li>
</ul>
<p>代理 JAR 文件可能在清单中同时具有 <code>Premain-Class</code> 和 <code>Agent-Class</code> 属性。当使用 <code>-javaagent</code> 选项在命令行上启动代理时，<code>Premain-Class</code> 属性指定代理类的名称，而 <code>Agent-Class</code> 属性将被忽略。同样，如果代理在 VM 启动后的某个时间启动，则 <code>Agent-Class</code> 属性指定代理类的名称（忽略 <code>Premain-Class</code> 属性的值）。</p>
<h1 id="修改代码"><a class="markdownIt-Anchor" href="#修改代码"></a> 修改代码</h1>
<p>要修改已有类的代码，我们主要是通过传入的 <code>Instrumentation</code> 实例注册 <code>ClassFileTransformer</code> 转换器来实现。在转换器实现内我们通过类名和类加载器共同来判断是否是我们需要修改的类，然后去修改字节码，可以使用一些类库轻松实现字节码的修改。如果我们注册的是具有重新转换能力的转换器，则可以使用 <code>retransformClasses</code> 立即修改转换类，否则会在类定义、加载或重新定义时调用。</p>
<blockquote>
<p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<p>也就是说要比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p>
<p>这里所指的“相等”，包括代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象的所属关系判定等情况。</p>
</blockquote>
<h2 id="instrumentation"><a class="markdownIt-Anchor" href="#instrumentation"></a> Instrumentation</h2>
<p>在上面列出的方法签名的参数中，不管是静态加载的 <code>premain</code> 还是动态加载的 <code>agentmain</code>，都传递了一个 <code>Instrumentation</code> 实例给我们。一旦我们的代理获得了 <code>Instrumentation</code> 实例，就可以随时调用该实例上的方法。</p>
<p>该实例主要包含以下方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer)">addTransformer</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a> transformer)</td>
<td>注册提供的转换器。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer,boolean)">addTransformer</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a> transformer, boolean canRetransform)</td>
<td>注册提供的转换器，当 canRetransform 为 true 时，代表该转换器具有重新转换能力。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#removeTransformer(java.lang.instrument.ClassFileTransformer)">removeTransformer</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html">ClassFileTransformer</a> transformer)</td>
<td>取消注册提供的转换器。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getAllLoadedClasses()">getAllLoadedClasses</a></strong>()</td>
<td>返回 JVM 当前加载的所有类的数组。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)">getInitiatedClasses</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html">ClassLoader</a> loader)</td>
<td>返回 loader 启动加载器所有类的数组。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isModifiableClass(java.lang.Class)">isModifiableClass</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html">Class</a>&lt;?&gt; theClass)</td>
<td>测试一个类是否可以通过 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformation</a> 或 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefinition</a> 来修改。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isRetransformClassesSupported()">isRetransformClassesSupported</a></strong>()</td>
<td>返回当前 JVM 配置是否支持类的重新转换。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#retransformClasses(java.lang.Class...)">retransformClasses</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Class.html">Class</a>&lt;?&gt;… classes)</td>
<td>重新转换提供的类集合。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()">isRedefineClassesSupported</a></strong>()</td>
<td>返回当前 JVM 配置是否支持重新定义类。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition...)">redefineClasses</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassDefinition.html">ClassDefinition</a>… definitions)</td>
<td>使用给定的类文件重新定义提供的类集合。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#isModifiableModule(java.lang.Module)">isModifiableModule</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Module.html">Module</a> module)</td>
<td>测试是否可以使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)">redefineModule</a> 修改模块。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#redefineModule(java.lang.Module,java.util.Set,java.util.Map,java.util.Map,java.util.Set,java.util.Map)"><strong>redefineModule</strong></a>(…)</td>
<td>重新定义模块以扩展它读取的模块集、它导出或打开的包集或其使用或提供的服务。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#getObjectSize(java.lang.Object)">getObjectSize</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html">Object</a> objectToSize)</td>
<td>返回指定对象消耗的存储量的特定于实现的近似值。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)">appendToBootstrapClassLoaderSearch</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/jar/JarFile.html">JarFile</a> jarfile)</td>
<td>指定一个 JAR 文件，其中包含要由引导程序类加载器定义的检测类。</td>
</tr>
<tr>
<td><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/Instrumentation.html#appendToSystemClassLoaderSearch(java.util.jar.JarFile)">appendToSystemClassLoaderSearch</a></strong>(<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/jar/JarFile.html">JarFile</a> jarfile)</td>
<td>指定一个 JAR 文件，其中包含要由系统类加载器定义的检测类。</td>
</tr>
</tbody>
</table>
<h2 id="classfiletransformer"><a class="markdownIt-Anchor" href="#classfiletransformer"></a> ClassFileTransformer</h2>
<p>如果我们要转换一个类，则可以通过注册一个自定义的 <code>ClassFileTransformer</code> 来实现，Java 虚拟机会在***加载***、***重新定义***或***重新转换类***时调用该实例的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.instrument/java/lang/instrument/ClassFileTransformer.html#transform(java.lang.Module,java.lang.ClassLoader,java.lang.String,java.lang.Class,java.security.ProtectionDomain,byte%5B%5D)"><code>transform</code></a> 方法。转换器是在 Java 虚拟机***定义类之前***被调用。</p>
<p><code>ClassFileTransformer</code> 可以实现为具有重新转换能力的转换器，通过在注册时将 <code>canRetransform</code> 参数传入为 <code>true</code> 告诉注册器自己有重新转换的能力。</p>
<p>一旦使用 <code>addTransformer</code> 注册了转换器，将在每个新的类定义时和每个类重新定义时调用转换器。在每个类重新转换时，也将调用具有重新转换能力的转换器。对新类定义的请求是使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ClassLoader.html#defineClass(byte%5B%5D,int,int)"><code>ClassLoader.defineClass</code></a> 或其原生等效方法进行的。类重新定义的请求是使用  <code>Instrumentation.redefineClasses</code> 或其原生等效方法进行的。类重新转换的请求是使用 <code>Instrumentation.retransformClasses</code> 或其原生等效方法进行的。在处理请求期间，<strong>转换器是在类的文件字节被验证和应用之前调用</strong>。当有多个转换器时，转换操作是通过转换器调用链组成的。也就是说，一次调用返回的字节数组成为下一次调用的输入（通过 <code>classfileBuffer</code> 参数）。</p>
<p>转换器将按以下顺序生效：</p>
<ul>
<li>没有再转换能力的转换器</li>
<li>没有再转换能力的原生转换器</li>
<li>有再转换能力的转换器</li>
<li>有再转换能力的原生转换器</li>
</ul>
<p>对于再转换，不调用没有再转换能力的转换器，而是重用前一次转换的结果。其他情况，该转换方式始终被调用。在这些所有分组中，转换器都是按照注册的顺序被调用。本机转换器由 Java 虚拟机工具接口（<code>JVMTI</code>）中的 <code>ClassFileLoadHook</code> 事件提供）。</p>
<p>传给第一个转换器的输入（<code>classfileBuffer</code> 参数）是：</p>
<ul>
<li>对于新的类定义，传递其 <code>ClassLoader.defineClass</code> 的字节</li>
<li>对于类重新定义，是 <code>Instrumentation.redefineClasses</code> 时传入的参数 <code>ClassDefinition</code> 实例的 <code>getDefinitionClassFile()</code> 返回结果</li>
<li>对于类重新转换，传递的是新类定义的字节。或者，如果是重新定义，则是最后一次重新定义的字节。</li>
</ul>
<p>如果实现方法确定不需要转换，则应返回 <code>null</code>。否则，它应该创建一个新的 byte[] 数组，将输入的 <code>classfileBuffer</code> 连同所有所需的转换复制到其中，并返回新数组。不得修改输入的 <code>classfileBuffer</code>。</p>
<p>在重新转换和重新定义的情况下，转换器必须支持重新定义语义：如果转换器在初始定义期间更改的类后来被重新转换或重新定义，则转换器必须确保第二个类输出类文件是第一个输出类文件的合法重新定义。</p>
<p>如果转换器抛出异常（它没有捕获），后续转换器仍将被调用，并且仍将尝试加载、重新定义或重新转换。因此，抛出异常与返回 null 具有相同的效果。为了防止在转换器代码中生成未经检查的异常时出现意外行为，转换器可以捕获 <code>Throwable</code>。如果转换器认为 <code>classFileBuffer</code> 不代表有效格式化的类文件，它应该抛出一个 <code>IllegalClassFormatException</code>；虽然这与返回 null 具有相同的效果。它有助于记录或调试格式损坏。</p>
<h2 id="字节码操作库"><a class="markdownIt-Anchor" href="#字节码操作库"></a> 字节码操作库</h2>
<p>字节码的操作库有的偏重性能，有的偏重更友好的 API 操作，下面介绍几种常见的字节码操作库：</p>
<h3 id="byte-buddy"><a class="markdownIt-Anchor" href="#byte-buddy"></a> <a target="_blank" rel="noopener" href="http://bytebuddy.net/">Byte Buddy</a></h3>
<p>Byte Buddy 是一个代码生成和操作库，用于在 Java 应用程序运行时创建和修改 Java 类，无需编译器的帮助。</p>
<p>Byte Buddy 是一个相当新的库，但提供了 CGLIB 或 Javassist 提供的任何功能等等。Byte Buddy 可以完全定制到字节码级别，并带有一个富有表现力的领域特定语言（DSL），在操作字节码时，它可能是最安全、最合理的选择，而且代码可读性很高。</p>
<p>Byte Buddy 也提供了一个方便的 API 来定义 Java 代理（agent），比如下面这个统计代码时间的 Demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerAgent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String arguments, </span></span></span><br><span class="line"><span class="params"><span class="function">                             Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> AgentBuilder.Default()</span><br><span class="line">      .type(ElementMatchers.nameEndsWith(<span class="string">&quot;Timed&quot;</span>))</span><br><span class="line">      .transform((builder, type, classLoader, <span class="keyword">module</span>) -&gt; </span><br><span class="line">          builder.method(ElementMatchers.any())</span><br><span class="line">                 .intercept(MethodDelegation.to(TimingInterceptor.class))</span><br><span class="line">      ).installOn(instrumentation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RuntimeType</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">intercept</span><span class="params">(<span class="meta">@Origin</span> Method method, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@SuperCall</span> Callable&lt;?&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> callable.call();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(method + <span class="string">&quot; took &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="javassist"><a class="markdownIt-Anchor" href="#javassist"></a> <a target="_blank" rel="noopener" href="http://jboss-javassist.github.io/javassist/">Javassist</a></h3>
<p>它是 Java 中用于编辑字节码的类库；它使 Java 程序能够在运行时定义一个新类，并在 JVM 加载类文件时修改它。与其他类似的字节码编辑器不同，Javassist 提供了两个级别的 API：源代码级和字节码级。如果用户使用源代码级 API，他们可以在不了解 Java 字节码规范的情况下编辑类文件。</p>
<h3 id="cglib"><a class="markdownIt-Anchor" href="#cglib"></a> <a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a></h3>
<p>CGLIB 速度非常快，这是它仍然存在的主要原因之一。</p>
<p>一般来说，允许在运行时重写类的库必须避免在重写相应的类之前加载任何类型。 因此，它们不能使用 Java 反射 API 来加载反射中使用的任何类型，所以他们必须通过 IO（这是一个性能破坏者）读取类文件。 这使得 Javassist 或 Proxetta 比 Cglib 慢得多，CGLIB 只是通过反射 API 读取方法并覆盖它们。</p>
<h3 id="asm"><a class="markdownIt-Anchor" href="#asm"></a> <a target="_blank" rel="noopener" href="http://asm.ow2.org/">ASM</a></h3>
<p>CGLIB、Byte Buddy 和几乎所有其他库都建立在 ASM 之上，ASM 本身在非常低的级别上操作字节码。这对大多数人来说是个障碍，因为您必须了解字节码和一点点 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/specs/">JVMS</a> 才能正确使用它。</p>
<p>但是掌握 ASM 无疑是非常有趣的。 但是请注意，虽然有一个很棒的 <a target="_blank" rel="noopener" href="http://download.forge.objectweb.org/asm/asm4-guide.pdf">ASM 4 指南</a>，但在 API 的某些部分中，javadoc 文档可能非常简洁，ASM 正在改进它的文档。</p>
<p>它紧跟 JVM 版本以支持新功能。</p>
<h1 id="java-agent-和-jvm-native-agent"><a class="markdownIt-Anchor" href="#java-agent-和-jvm-native-agent"></a> Java Agent 和 JVM Native Agent</h1>
<p>虽然两者都以几乎相同的方式加载到 <code>JVM</code> 中（使用特殊的 <code>JVM</code> 启动参数），但它们的构建方式几乎完全不同。</p>
<p>native agent 一般使用 <code>-agentlib</code> 或 <code>-agentpath</code> 命令行参数指定，Java agent 静态加载是通过 <code>-javaagent</code> 指定。</p>
<p>Java Agent 底层也是通过 JVMTI 接口来驱动的。</p>
<h2 id="native-agents"><a class="markdownIt-Anchor" href="#native-agents"></a> Native Agents</h2>
<p>Native 代理是完全不同的野兽。如果您认为 Java 代理可以让您做很酷的事情，那么请抓紧时间，因为本地代理在完全不同的层面上运行。本机代理不是用 Java 编写的，而是主要用 C++ 编写的，并且不受普通 Java 代码运行的规则和限制的约束。不仅如此，它们还提供了一组极其强大的功能，称为 JVM 工具接口 (JVMTI)。</p>
<h3 id="它能做什么"><a class="markdownIt-Anchor" href="#它能做什么"></a> 它能做什么</h3>
<p>jvmti.h 公开的这组 API 使 JVM 动态加载的 C++ 库能够获得对 JVM 实时工作的极高级别的可见性。这跨越了广泛的领域，包括 GC、locking、代码操作、同步、线程管理、编译调试等等。JVMTI 旨在使 JVM 尽可能透明，同时仍保持设计灵活性，以允许 JVM 供应商提供不同的底层实现。这组 API 非常广泛，包含数百个关于 JVM 的回调和函数。您可以使用这些来做 Java 代理无法做的非常强大的事情，例如编写自己的调试器，或者构建低级、实时错误分析工具，比如 JRebel 和 JProfiler 等。</p>
<p>JRebel 通过 JVMTI 构建一种在运行时提供类的平滑热交换而无需重新启动 JVM 的技术。</p>
<p>JProfiler 通过 JVMTI 修改目标框架的代码以注入收集性能指标的新代码。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Instrumentation</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分布式锁</title>
    <url>/middleware/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="用锁来做什么"><a class="markdownIt-Anchor" href="#用锁来做什么"></a> 用锁来做什么？</h1>
<p>在计算机科学中，锁是多线程环境中防止不同线程对同一资源进行操作的机制。锁的目的是确保在可能尝试执行同一工作的多个节点中，只有一个节点实际执行此操作（至少一次只有一个）。这项工作可能是将一些数据写入共享存储系统、执行一些计算、调用一些外部 API 等。概括而言，您可能需要在分布式应用程序中锁定的原因有两个：<strong>为了效率</strong>或<strong>为了正确性</strong>。为了区分这些情况，您可以询问如果锁定失败会发生什么：</p>
<ul>
<li><strong>效率 - Efficiency</strong>：获取锁可以避免你不必要地做同样的工作两次（例如一些昂贵的计算）。</li>
<li><strong>正确性 - Correctness</strong>：使用锁可以防止并发进程相互干扰并破坏系统状态。如果锁失败，两个节点同时处理同一份数据，结果是文件损坏，数据丢失，永久性不一致、错误的执行结果或其他一些严重问题。</li>
</ul>
<p>两者都是需要锁的有效情况，但您需要非常清楚您正在处理的是两者中的哪一个。</p>
<h1 id="安全性和活跃性保证"><a class="markdownIt-Anchor" href="#安全性和活跃性保证"></a> 安全性和活跃性保证</h1>
<p>我们将仅使用三个属性对我们的设计进行建模，从我们的角度来看，这是以有效方式使用分布式锁所需的最低保证。</p>
<ol>
<li><strong>安全特性</strong>：互斥。在任何给定时刻，只有一个客户端可以持有锁。</li>
<li>活跃性属性 A：无死锁。最终总是有可能获得锁，即使锁定资源的客户端崩溃或被分区。</li>
<li>活跃性属性 B：容错。只要大多数 Redis 节点都已启动，客户端就可以获取和释放锁。</li>
</ol>
<span id="more"></span>
<h1 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h1>
<p>分布式锁在许多环境中是非常有用的原语，在这些环境中，不同的进程必须以互斥的方式使用共享资源。操作系统或我们的软件一般会使用锁管理器来组织和顺序化去访问资源。<strong>分布式锁管理器 (distributed lock manager - DLM</strong>) 运行在集群中的每台机器上，并具有集群范围相同副本的锁数据库。通过这种方式，DLM 为分布在多台机器上的集群中的软件应用程序提供了一种同步对共享资源的访问的方法。</p>
<h2 id="为什么基于故障转移的实现是不够的"><a class="markdownIt-Anchor" href="#为什么基于故障转移的实现是不够的"></a> 为什么基于故障转移的实现是不够的</h2>
<p>为了了解我们想要改进的地方，让我们分析大多数基于 Redis 的分布式锁库的当前状态。</p>
<p>使用 Redis 锁定资源的最简单方法是在实例中创建 key。创建的 key 通常是有限的生存时间的，使用 Redis 过期功能，以便最终将其释放（我们列表中的属性 2）。</p>
<p>从表面上看，这很有效，但有一个问题：这是我们架构中的单点故障。如果 Redis master 宕机了怎么办？好吧，让我们添加一个 slave！如果 master 不可用，则使用它。不幸的是，这是不可行的。这样做我们无法实现互斥的安全属性，<strong>因为 Redis 复制是异步的</strong>。</p>
<p>这个模型有一个明显的竞争条件：</p>
<ol>
<li>客户端 A 获取 master 的锁</li>
<li>写入 key 到 slave 之前，master 崩溃了</li>
<li>slave 提升为 master</li>
<li>客户端 B 获取对 A 已经持有锁的同一资源的锁。<strong>违背安全性！</strong></li>
</ol>
<p>有时，在特殊情况下（例如在故障期间），多个客户端可以同时持有锁是完全没问题的。如果允许这种情况，您可以使用基于复制的解决方案。否则，我们建议实施本文档中描述的解决方案。</p>
<h1 id="基于单实例的正确实现"><a class="markdownIt-Anchor" href="#基于单实例的正确实现"></a> 基于单实例的正确实现</h1>
<p>在尝试克服上述单实例崩溃的限制之前，让我们检查一下如何在这个简单的情况下正确地做到这一点，因为在不经常出现竞争条件的应用程序中，这实际上是一个可行的解决方案，并且因为锁定单个实例是我们将用于此处描述的分布式算法的基础。</p>
<p>要获取锁，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>
<p>该命令仅在 key 不存在（NX 选项）时设置，过期时间为 30000 毫秒（PX 选项）。将 key 设置为值 “myrandomvalue”。该值在所有客户端和所有锁定请求中必须是唯一的。</p>
<p>随机值用于以安全的方式释放锁，该脚本告诉 Redis：仅当 key 存在并且存储在 key 中的值正是我期望的值时才删除它。这是通过以下 Lua 脚本完成的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这对于避免删除由另一个客户端创建的锁很重要。例如，客户端可能获取锁，在某些操作中被阻塞超过锁有效时间（key 将到期的时间），然后删除其他客户端已经获取的锁。仅使用 DEL 是不安全的，因为客户端可能会删除另一个客户端的锁。使用上面的脚本，每个锁都用一个随机字符串“签名”，因此只有当它仍然是试图删除它的客户端设置的锁时，才会删除它。</p>
<p>这个随机字符串应该是什么？我假设它是来自 /dev/urandom 的 20 个字节，但是你可以找到更便捷的方法来使它对你的任务足够唯一。例如，一个安全的选择是用 /dev/urandom 为 RC4 做种子，并从中生成一个伪随机流。一个更简单的解决方案是使用 unix 时间微秒，将它与客户端 ID 连接，它不是那么安全，但可能适合大多数环境中的任务。</p>
<p>我们用作 key *存活时间（time to live - TTL）*的时间，称为“锁有效时间”。它既是自动释放时间，也是客户端在另一个客户端能够再次获取锁之前执行操作所需的时间，也就是该客户端对该 key 的租期，在技术上不违反互斥保证的情况下，互斥保证只限于从获取锁那一刻起的给定时间窗口。</p>
<p>所以现在我们有一个很好的方法来获取和释放锁。我们推理由单个始终可用的实例组成的非分布式系统是安全的。让我们将这个概念扩展到没有这种保证的分布式系统。</p>
<h1 id="redlock-算法"><a class="markdownIt-Anchor" href="#redlock-算法"></a> Redlock 算法</h1>
<p>在算法的分布式版本中，我们假设我们有 N 个 Redis master 节点。这些节点是完全独立的，所以我们不使用复制或任何其他隐式协调系统。我们已经描述了如何在单个实例中安全地获取和释放锁。我们理所当然地认为算法会在单个实例中使用这种方法来获取和释放锁。</p>
<p>为了获取锁，客户端执行以下操作：</p>
<ol>
<li>客户端以毫秒为单位获取当前时间。</li>
<li>它尝试顺序获取所有 N 个实例中的锁，并在所有实例中使用相同的 key 和随机值。在第 2 步中，当在每个实例中设置锁时，客户端使用一个比总锁自动释放时间更小的超时时间来获取锁。例如，如果自动释放时间为 10 秒，则超时时间可能在 ~ 5-50 毫秒范围内。这可以防止客户端长时间处于阻塞状态，试图与已关闭的 Redis 节点通信：如果实例不可用，我们应该尽快尝试与下一个实例通信。</li>
<li>客户端通过从当前时间中减去步骤 1 中获得的时间戳来计算获取锁所用的时间。当且仅当客户端能够在大多数实例（至少 3 个）中获取锁，并且获取锁所用的总时间小于锁有效时间，则认为该锁已获取。</li>
<li>如果获得了锁，则其有效时间被视为初始有效时间减去经过的时间，如步骤 3 中计算的那样。</li>
<li>如果客户端由于某种原因获取锁失败（或者它无法锁定 N/2+1 个实例或有效时间为负），它将尝试解锁所有实例（即使是它认为没有锁定的实例）能够锁定）。</li>
</ol>
<h2 id="算法是异步的吗"><a class="markdownIt-Anchor" href="#算法是异步的吗"></a> 算法是异步的吗？</h2>
<p>该算法依赖于这样的假设：虽然进程之间没有同步时钟，但每个进程中的本地时间仍然以大致相同的速率流动，与锁的自动释放时间相比误差很小。这个假设与现实世界的计算机非常相似：每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来实现很小的时钟漂移。</p>
<p>此时我们需要更好地指定我们的互斥规则：<strong>只有持有锁的客户端会在锁的有效期内（如步骤 3 中获得的）内终止其工作，我们才能保证互斥</strong>，减去一些时间（只需几毫秒以补偿进程之间的时钟漂移）。</p>
<p>有关需要绑定*时钟漂移（clock drift）*的类似系统的更多信息，这篇论文是一个有趣的参考：<a target="_blank" rel="noopener" href="http://dl.acm.org/citation.cfm?id=74870">Leases：一种用于分布式文件缓存一致性的高效容错机制。</a></p>
<p>如果在锁的有效期内未停止其工作，如下图：</p>
<p><img src="../../images/middleware/redis/exceed-ttl.png" alt="image-20200804204605476" /></p>
<p>客户端 1 在获得锁之后发生了很长时间的 GC pause，在此期间，它获得的锁租约过期了，而客户端 2 重新获得了该锁。当客户端 1 从 GC pause 中恢复过来的时候，它不知道自己持有的锁已经过期了，它依然向共享资源发起了写数据请求，而这时锁实际上被客户端 2 持有，因此两个客户端的写请求就有可能冲突（锁的互斥作用失效了）。</p>
<p>那怎么解决这个问题呢？<a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">Martin</a> 给出了一种方法，称为 fencing token。fencing token 是一个单调递增的数字，当客户端成功获取锁的时候它随同锁一起返回给客户端。而客户端访问共享资源的时候带着这个 fencing token，这样提供共享资源的服务就能根据它进行检查，拒绝掉延迟到来的访问请求（避免了冲突）。如下图：</p>
<p><img src="../../images/middleware/redis/fencing-token.png" alt="image-20200804204717901" /></p>
<p>在上图中，客户端 1 先获取到的锁，因此有一个较小的 fencing token，等于 33，而客户端 2 后获取到的锁，有一个较大的 fencing token，等于 34。客户端 1 从 GC pause 中恢复过来之后，依然是向存储服务发送访问请求，但是带了 fencing token = 33。存储服务发现它之前已经处理过 34 的请求，所以会拒绝掉这次 33 的请求。这样就避免了冲突。</p>
<blockquote>
<p>但这种处理又将锁的排他安全性转移给了资源服务，如果资源服务本身就可以保证排他访问，为什么需要分布式锁？</p>
</blockquote>
<h2 id="失败时重试"><a class="markdownIt-Anchor" href="#失败时重试"></a> 失败时重试</h2>
<p>当客户端无法获取锁时，它应该在随机延迟后重试，以尝试使多个客户端同时尝试获取同一资源的锁（这可能会导致没有人获胜的脑裂情况）。此外，客户端尝试在大多数 Redis 实例中获取锁的速度越快，出现脑裂情况的窗口就越小（以及需要重试），<strong>所以理想情况下，客户端应该尝试使用多路复用将 SET 命令同时发送到 N 个实例。</strong></p>
<p>值得强调的是，对于未能获取大部分锁的客户端，尽快释放（部分）获取的锁是多么重要，这样就不需要等待 key 到期才能再次获取锁（但是，如果发生网络分区并且客户端不再能够与 Redis 实例通信，则在等待 key 到期时需要容忍可用性损失）。</p>
<h2 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h2>
<p>释放锁很简单，只涉及在所有实例中释放锁，无论客户端是否相信它能够成功锁定给定的实例。</p>
<p>如果一个分布式锁占用资源时间过长，导致其他客户端无法在有效时间内获取同一资源，则可以使用 Redis 的发布订阅功能，去主动告知其他需要资源的客户端。</p>
<p><img src="../../images/middleware/redis/redis-lock-pub-sub.png" alt="Pub Sub Lock" /></p>
<h2 id="安全性参数"><a class="markdownIt-Anchor" href="#安全性参数"></a> 安全性参数</h2>
<p>算法安全吗？我们可以尝试了解在不同场景中会发生什么。</p>
<p>首先让我们假设客户端能够在大多数情况下获取锁。所有实例都将包含一个具有相同生存时间的 key。但是，key 是在不同的时间设置的，因此 key 也会在不同的时间到期。但是如果第一个 key 最差在时间 T1（我们在联系第一台服务器之前采样的时间）设置，而最后一个 key 最差在时间 T2（我们从最后一个服务器获得回复的时间）设置，我们确信集合中第一个要过期的 key 至少会存在 MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT。所有其他 key 将在稍后到期，因此我们确信至少这次 key 将同时设置。</p>
<p>在设置了大多数 key 的时间内，另一个客户端将无法获取锁，因为如果 N/2+1 个 key 已经存在，则 N/2+1 次 SET NX 操作将无法成功。因此，如果获取了锁，则不可能同时重新获取它（违反互斥属性）。</p>
<p>但是，我们还希望确保多个客户端同时尝试获取锁不能同时成功。</p>
<p>如果客户端使用接近或大于锁定最大有效时间（我们用于 SET 的 TTL）的时间锁定大多数实例，它将认为锁定无效并解锁实例，所以我们只需要考虑客户端能够在小于有效时间的时间内锁定大多数实例的情况。在这种情况下，对于上面已经陈述的参数，对于  MIN_VALIDITY，没有客户端应该能够重新获取锁。因此，只有当锁定多数的时间大于 TTL 时间时，多个客户端才能同时锁定 N/2+1 个实例（“时间”为第 2 步的结束），从而使锁定无效。</p>
<h2 id="活跃性参数"><a class="markdownIt-Anchor" href="#活跃性参数"></a> 活跃性参数</h2>
<p>系统活跃性基于三个主要特征：</p>
<ol>
<li>锁的自动释放（因为 key 过期）：最终 key 可以再次被锁定。</li>
<li>事实上，客户端通常会在没有获得锁时合作移除锁，或者当获得锁并且工作终止时合作移除锁，这使得我们可能不必等待 key 到期来重新获取锁锁。</li>
<li>事实上，当客户端需要重试锁时，它等待的时间比获取大多数锁所需的时间要长，以便在资源争用期间从概率上使脑裂情况不太可能发生。</li>
</ol>
<p>然而，我们在网络分区上容忍了与 <a target="_blank" rel="noopener" href="https://redis.io/commands/ttl">TTL</a> 时间相等的可用性损失，所以如果有连续的分区，我们需要无限期地容忍这个损失。每次客户端获取锁并在能够删除锁之前被分区时都会发生这种情况。</p>
<p>基本上，如果有无限连续的网络分区，系统可能会在无限长的时间内变得不可用。</p>
<h2 id="性能-崩溃恢复和-fsync"><a class="markdownIt-Anchor" href="#性能-崩溃恢复和-fsync"></a> 性能、崩溃恢复和 fsync</h2>
<p>许多使用 Redis 作为锁服务器的用户在获取和释放锁的延迟方面以及每秒可能执行的获取/释放操作数量方面都需要高性能。为了满足这个需求，与 N 个 Redis 服务器对话以减少延迟的策略肯定是多路复用（即把 socket 置于非阻塞模式，发送所有命令，然后读取所有命令，假设客户端和每个实例之间的 RTT 相似）。</p>
<p>然而，如果我们想要针对崩溃恢复系统模型，还有另一个关于持久性的考虑。</p>
<p>假设一共有 5 个 Redis 节点：A, B, C, D, E。设想发生了如下的事件序列：</p>
<ol>
<li>客户端 1 成功锁住了 A, B, C，<strong>获取锁</strong>成功（但 D 和 E 没有锁住）。</li>
<li>节点 C 崩溃重启了，但客户端 1 在 C 上加的锁没有持久化下来，丢失了。</li>
<li>节点 C 重启后，客户端 2 锁住了 C, D, E，<strong>获取锁</strong>成功。</li>
</ol>
<p>这样，客户端 1 和客户端 2 同时获得了锁（针对同一资源），违反了锁的排他性的安全属性。</p>
<p>如果我们启用 AOF 持久化，情况会有所改善。例如，我们可以通过发送 SHUTDOWN 并重新启动它来升级服务器。因为 Redis 过期是在语义上实现的，所以当服务器关闭时，实际上时间仍然在流逝，所以我们所有的要求都很好。然而，一切都很好，只要它是干净的关机。停电了怎么办？如果 Redis 配置为默认情况下每秒在磁盘上进行 fsync，则可能在重新启动后丢失我们的 key 。理论上，如果我们想在面对任何类型的实例重启时保证锁的安全，我们需要在持久化设置中启用 <code>fsync=always</code>。这样会破坏性能，将会和传统上用于以安全方式实现分布式锁的 CP 系统相同级别。</p>
<p>然而，事情总比乍一看的样子要好。基本上，只要实例在崩溃后重新启动，<strong>它不再参与任何当前活动的锁</strong>，就可以保留算法安全性。这样当实例重新启动时，当前活动的一组锁都是通过锁定实例而不是重新加入系统的实例获得的。</p>
<p>为了保证这一点，我们只需要确保一个实例，在崩溃后，至少在比我们使用的最大 TTL 多一点的时间内不可用，即实例崩溃时存在的所有锁的 key 所需的时间，即实例崩溃，失效并自动释放时存在的所有锁的 key 所需的时间。</p>
<p><strong>使用延迟重启</strong>，即使没有任何可用的 Redis 持久性，基本上也可以实现安全性，但是请注意，这可能会转化为可用性损失。例如，如果大多数实例崩溃，系统将在 TTL 中全局不可用（这里全局意味着在此期间根本没有资源可锁定）。</p>
<h2 id="使算法更可靠扩展锁"><a class="markdownIt-Anchor" href="#使算法更可靠扩展锁"></a> 使算法更可靠：扩展锁</h2>
<p>如果客户端执行的工作由小步骤组成，则可以默认使用较小的锁有效时间，并扩展实现锁扩展机制的算法。基本上客户端，如果在计算的中间，当锁有效性接近低值时，如果 key 存在并且它的值仍然是获取锁时客户端分配的随机值，可以通过向所有扩展 key 的实例的 Lua 脚本发送一个 Lua 脚本来扩展锁。 如果客户端能够将锁扩展到大多数实例，并且在有效时间内（基本上使用的算法与获取锁时使用的算法非常相似），客户端应该只考虑重新获取锁。 然而，这在技术上不会改变算法，因此应该限制锁重新获取尝试的最大次数，否则会违反活跃性属性之一。</p>
<p>在单实例时使用监视器也可以达成该目的，在多实例下实现会更加复杂。</p>
<p>比如使用守护线程或其他形式去观察并自动续约，例如 Redisson 的 watchdog。</p>
<p><img src="../../images/middleware/redis/redis-lock-monitor.png" alt="Monitor Lock" /></p>
<h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">Redisson</a> 作为 Java 版本的 Redis 客户端，底层使用 Netty 这种高性能无阻塞的 IO 框架，为我们提供了很多 Redis 数据结构的 Java 版本，还有很多分布式锁、分布式对象，分布式服务等，以及提供了异步、响应式的请求方式。</p>
<p><img src="../../images/middleware/redis/redisson.png" alt="img" /></p>
<p>它也支持 Redis 的多种部署方式：复制、集群、哨兵、主从、单例模式。</p>
<h2 id="单实例下的有效锁"><a class="markdownIt-Anchor" href="#单实例下的有效锁"></a> 单实例下的有效锁</h2>
<p><code>Redisson</code> 中基于单实例的正确实现锁有很多，他们都实现了 RLock 接口，该接口继承与 Java 的 Lock 接口，实现该接口的类也都实现了可重入性。最基本的实现有：</p>
<ul>
<li><code>RedissonLock</code>：Java Lock 的分布式实现，实现可重入锁。如果客户端断开连接，锁定将自动解除。实现非公平锁定，因此不保证获取顺序。</li>
<li><code>RedissonFairLock</code>：和上述锁相同，但实现了公平性，以保证线程的获取顺序。</li>
</ul>
<h3 id="redissonlock"><a class="markdownIt-Anchor" href="#redissonlock"></a> RedissonLock</h3>
<p>接下来我们就来看下 <code>RedissonLock</code> 是如何实现锁的，他的 UML 类继承图如下：</p>
<p><img src="../../images/middleware/redis/redisson-lock.png" alt="RedissonLock" /></p>
<p>这里需要有几点认知：</p>
<ul>
<li><code>RedissonLock</code> 实现了 <code>java.util.concurrent.locks.Lock</code> 接口中除了 <code>newCondition()</code> 方法外的所有方法，也就是可以基本无缝适配 <code>Lock</code> 接口，对于习惯 <code>Lock</code> 接口的 <code>API</code> 的使用者来说是一个福音</li>
<li><code>RedissonLock</code> 基本所有同步 <code>API</code> 都依赖于异步 <code>API</code> 的实现，也就是 <code>RLock</code> 的实现依赖于 <code>RLockAsync</code> 的实现，底层依赖的是 <code>Netty</code> 的 <code>io.netty.util.concurrent.Promise</code>，具体见 <code>RedissonPromise</code>，如果用过 <code>JUC</code> 中的 <code>Future</code> 的开发者应该比较熟悉 <code>Future#get()</code>，这里的做法类似</li>
<li>右边的几个父类的简单功能描述如下：
<ul>
<li><code>RObjectAsync</code>：所有 <code>Redisson</code> 对象的基础接口，提供一些内存测量、对象拷贝、移动等的异步方法</li>
<li><code>RObject</code>：<code>RObjectAsync</code> 的同步版本</li>
<li><code>RExpirableAsync</code>：提供对象 <code>TTL</code> 相关的异步方法</li>
<li><code>RExpirable</code>：<code>RExpirableAsync</code> 的同步版本</li>
<li><code>RedissonObject</code>：直接实现类 <code>RObject</code> 接口中的方法</li>
<li><code>RedissonExpirable</code>：主要是实现了 <code>RExpirable</code> 接口中的方法</li>
</ul>
</li>
</ul>
<p>下面我们就来看下如何使用该 Lock，一般我们使用 Java 的 Lock 典型用法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"> <span class="keyword">if</span> (lock.tryLock(<span class="number">5L</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 操作保护资源</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 执行锁获取失败的可选操作</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 RedissonLock 中我们同样可以这样使用，但是就像我们之前陈述的，我们需要为锁定义有效时间（TTL），让我们看下代码中是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该类实现了 Lock 的 tryLock 接口，</span></span><br><span class="line"><span class="comment">// 调用自身的 tryLock，第二个参数为锁的有效时间，这里传入 -1  </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tryLock(waitTime, -<span class="number">1</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> time = unit.toMillis(waitTime);</span><br><span class="line">  <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">  <span class="comment">// 尝试获取锁，为 null 代表锁操作成功，可能是初次获取成功，或者重入获取成功，将会在后面的 lua 脚本说明</span></span><br><span class="line">  <span class="comment">// 否则返回锁的有效时间</span></span><br><span class="line">  Long ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果尝试获取锁的经过时间大于允许等待的时间，则获取锁失败</span></span><br><span class="line">  time -= System.currentTimeMillis() - current;</span><br><span class="line">  <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    acquireFailed(waitTime, unit, threadId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新获取当前时间</span></span><br><span class="line">  current = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// 使用 redis 的发布订阅 pub/sub 功能来等待该锁的释放通知，这里的 threadId 并没有什么意义</span></span><br><span class="line">  RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);</span><br><span class="line">  <span class="comment">// 订阅时间超过允许等待的时间，取消订阅，获取锁失败</span></span><br><span class="line">  <span class="keyword">if</span> (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscribeFuture.cancel(<span class="keyword">false</span>)) &#123;</span><br><span class="line">      subscribeFuture.onComplete((res, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">          unsubscribe(subscribeFuture, threadId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    acquireFailed(waitTime, unit, threadId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 之前操作经过的时间超过允许等待的时间，获取锁失败</span></span><br><span class="line">    time -= System.currentTimeMillis() - current;</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      acquireFailed(waitTime, unit, threadId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">      <span class="comment">// 尝试获取锁</span></span><br><span class="line">      ttl = tryAcquire(waitTime, leaseTime, unit, threadId);</span><br><span class="line">      <span class="comment">// 获取锁成功</span></span><br><span class="line">      <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 继续判断是否超时</span></span><br><span class="line">      time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">      <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 锁有效时间一般都是 &gt;= 0 的，则实际等待时间取决于 ttl 和允许等待时间。</span></span><br><span class="line">      <span class="comment">// 等待内部使用 Java 许可数为 0 的信号量（Semaphore）进行等待，由于没有可用的许可，等待时线程将处于休眠状态。</span></span><br><span class="line">      <span class="comment">// 在锁释放时将放出一个信号量，则等待取消，继续尝试获取锁，否则一直等到过期</span></span><br><span class="line">      currentTime = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span> &amp;&amp; ttl &lt; time) &#123;</span><br><span class="line">        subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行超时，获取锁失败</span></span><br><span class="line">      time -= System.currentTimeMillis() - currentTime;</span><br><span class="line">      <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        acquireFailed(waitTime, unit, threadId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 退出锁竞争(锁获取成功或者放弃获取锁)，则取消锁的释放订阅</span></span><br><span class="line">    unsubscribe(subscribeFuture, threadId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程如下图：</p>
<p><img src="../../images/middleware/redis/redisson-lock-lockinng.png" alt="img" /></p>
<p>这里面比较重要的是获取锁 <code>tryAcquire</code> 的操作，如下。</p>
<h3 id="获取锁"><a class="markdownIt-Anchor" href="#获取锁"></a> 获取锁</h3>
<p>在这里，它有两种处理方式，一种是带有过期时间的锁，一种是不带过期时间的锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有过期时间，就像我们调用的那样，使用 watchdog 默认的租约时间：30s</span></span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经获取了锁</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 过期时间存在，设置 watchdog 的租约时间为该过期时间</span></span><br><span class="line">                internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 过期时间不存在，如果还持有这个锁，则开启定时任务不断刷新该锁的过期时间</span></span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着往下看，<code>tryLockInnerAsync</code> 方法是真正执行获取锁的逻辑，它是一段 LUA 脚本代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="comment">// 如果锁不存在，则通过 hincrby 将锁对象的名称（RawName）key 下的该线程的锁（LockName）field 的数值递增 1</span></span><br><span class="line">            <span class="comment">// 并设置 RawName 作为 key 的过期时间为 leaseTime</span></span><br><span class="line">            <span class="comment">// 执行成功，返回 null，前面检查 为 null 代表执行成功</span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="comment">// 如果锁存在，且持有线程是当前线程，则通过 hincrby 将该锁对应的该线程的数值递增 1，并重新设置过期时间</span></span><br><span class="line">                    <span class="comment">// 执行成功，返回 null</span></span><br><span class="line">                    <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                     <span class="comment">// 如果锁已存在，且持有锁的线程不是该线程，则返回该锁的有效时间</span></span><br><span class="line">                    <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">            Collections.singletonList(getRawName()), </span><br><span class="line">            unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LUA 中的数组从 1 开始计数，KEYS 代表键数组，ARGV 代表参数数组。同时，Redis 保证以一种原子性的方式来执行脚本：当 LUA 脚本在执行的时候，不会有其他脚本和命令同时执行，这种语义类似于 MULTI/EXEC。从别的客户端的视角来看，一个 LUA 脚本要么不可见，要么已经执行完，这也因为 Redis 是单线程的原因。</p>
<h3 id="解锁"><a class="markdownIt-Anchor" href="#解锁"></a> 解锁</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 该锁不是由该线程占有的，返回 null</span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                     <span class="comment">// 该锁对应的该线程的数值 - 1，重入数 - 1</span></span><br><span class="line">                    <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                     <span class="comment">// 锁依然被占用，则续约，返回 0</span></span><br><span class="line">                    <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                     <span class="comment">// 锁无人占用，删除锁，并发布锁释放信号，这里会向之前等待的信号量释放一个许可</span></span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()), </span><br><span class="line">            LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁主要也是通过 LUA 脚本执行的，流程如下：</p>
<p><img src="../../images/middleware/redis/redisson-lock-unlock.png" alt="img" /></p>
<hr />
<p>参考链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">Distributed locks with Redis</a></li>
<li><a target="_blank" rel="noopener" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html">How to do distributed locking</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/">分布式锁的实现之 redis 篇</a></li>
<li><a target="_blank" rel="noopener" href="https://wendajiang.github.io/redis-distribute-lock/">Redis 分布式锁 [翻译]</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/14264804.html#%E5%B0%8F%E7%BB%93">冷饭新炒：理解Redisson中分布式锁的实现</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>双向关联最佳实践</title>
    <url>/persistence/%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>下面的最佳实践都是从性能角度证明双向关联的正确性。</p>
<h1 id="映射-onetomany-双向关联"><a class="markdownIt-Anchor" href="#映射-onetomany-双向关联"></a> 映射 @OneToMany 双向关联</h1>
<p><img src="../../images/jpa/one-to-many-author-book.png" alt="one-to-many-author-book" /></p>
<p>一个作者对应多本发行书，<code>Parent</code> 端 为 <code>Author</code>，<code>Child</code> 端为 <code>Book</code>。</p>
<span id="more"></span>
<p>关键点：</p>
<h2 id="总是从-parent-端到-child-端级联操作"><a class="markdownIt-Anchor" href="#总是从-parent-端到-child-端级联操作"></a> 总是从 Parent 端到 Child 端级联操作</h2>
<p>父对象都不存在的情况下操作子，显然不合理。</p>
<ul>
<li>
<p>对于<strong>新增操作</strong>，如果 Parent 和 Child 的都是瞬时状态的数据调用级联新增（<code>CascadeType.PERSIST</code>）则没有问题。</p>
<blockquote>
<p>如果传递的 Child 包含具有 ID 的分离（<code>Detached</code>）对象，persist 方法会抛出 <code>EntityExistsException</code>，因为（参见 <a target="_blank" rel="noopener" href="http://jcp.org/aboutJava/communityprocess/final/jsr220/index.html">JPA 1.0 规范</a>的第 3.2.1 节）明确指出，传入的对象不能是分离的实体。</p>
</blockquote>
<p>对于一对多关联我们一般也不会传入已有的 Child。</p>
</li>
<li>
<p>对于<strong>修改操作</strong>。</p>
<p>首先明确一点，Spring Data JPA 对有标识符的对象调用 <code>save</code> 时，其实是调用的 JPA 的 <code>EntityManager.merge</code> 合并操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">@Override</span><br><span class="line">public &lt;S extends T&gt; S save(S entity) &#123;</span><br><span class="line">    if (entityInformation.isNew(entity)) &#123;</span><br><span class="line">        em.persist(entity);</span><br><span class="line">        return entity;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return em.merge(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>merge</code> 操作会先根据分离的实体的唯一标识查询出该实体的持久态，再去合并每一个字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Author <span class="title">merge</span><span class="params">(Author detached)</span> </span>&#123;</span><br><span class="line">	Author newReference = session.byId( Author.class ).load( detached.getId() );</span><br><span class="line">	<span class="comment">// 复制所有分离的对象属性到持久化的实体中</span></span><br><span class="line">	newReference.setName( detached.getName() );</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> newReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果启用了级联合并（<code>CascadeType.MERGE</code>），则会级联合并 Child 的字段，这要求我们传入的瞬时状态的数据得是完整的（级联合并下也包括 Child），否则就会被级联修改掉。</p>
<blockquote>
<p><strong>所以尽量不要使用 merge 操作，也不要使用级联合并，除非你知道他如何工作</strong></p>
</blockquote>
<p><strong>如果我们只是想修改 Author 的信息</strong>：</p>
<p>为了更好的控制要更新的字段，最好的方法是直接使用 HQL 或 JPQL 进行更新 update 语句操作；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;UPDATE Author SET name = :name WHERE id =:authorId&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateName</span><span class="params">(String name, Long authorId)</span></span>;</span><br></pre></td></tr></table></figure>
<p>或者先查询对象，对查询出的持久化状态实体进行字段修改，在会话结束时或手动 flush 时会自动更新到数据库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authorRepository.findById(<span class="number">1L</span>).ifPresent(author -&gt; &#123;</span><br><span class="line">    author.setAge(<span class="number">38</span>);</span><br><span class="line">    author.setName(<span class="string">&quot;Zeral&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>如果需要同步数据库持久化的 Author、Children 和传入的分离的 Author、Children 的状态。这里分两种情况讨论：</strong></p>
<ol>
<li>
<p>传入的数据是完整的，不管是要修改的 Author 部分变更字段还是无需变更字段，或者 Child 的变更字段和无需变更字段，即使我们只是想同步 Child 的关联状态。</p>
<p>比如原始的数据为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Mark Janel&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;genre&quot;</span>: <span class="string">&quot;Anthology&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">&quot;books&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;A History of Ancient Prague&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;001-JN&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;A People&#x27;s History&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;002-JN&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;The Beatles Anthology&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;001-MJ&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要修改为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alicia Tom&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;genre&quot;</span>: <span class="string">&quot;Anthology&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">&quot;books&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;001-JN&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;A History of Ancient Prague&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;004-ZH&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Zeral&#x27;s Life&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们既要修改 Author 的信息，也要修改 Book ID 为 1 的信息，然后新增一个 Child，并移除缺失的 ID 为 2、3 的 Book。</p>
<p>可以直接使用 JPA <code>EntityManager.merge</code> 即可，通过级联修改（<code>CascadeType.MERGE</code>）操作，状态会正确被同步。</p>
<blockquote>
<p>在合并期间，实体的当前状态被复制到刚刚从数据库中获取的持久态实体版本上。这就是 Hibernate 会执行 SELECT 语句的原因，该语句获取 Author 实体及其子实体，和刚才描述的一样。</p>
<p>如果查询不是发起抓取 Author 及其子实体的查询，则可能发生 N+1 查询，则最好自己调用查询抓取所有。</p>
</blockquote>
</li>
<li>
<p>如果数据不完整，我们只想修改传入的变更字段。</p>
<p>如果需要同步状态，并且保留已有的关联，可以先通过 Fetch JOIN 或 EntityGraph 操作将 Author 及其子实体查询出来，再去手动同步合并变更状态，<strong>这时不需要依赖级联合并操作。</strong></p>
<p>修改 Author 的信息如之前所述，对于一对多的 Child 集合的手动合并分为三步：</p>
<p>​	detachedBooks 为传入的分离的 Author 的 Books。</p>
<ul>
<li>
<p>删除在数据库中存在但在传入的集合中已经不存在的数据行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">author.getBooks.removeIf(b -&gt; !detachedBooks.contains(b));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新数据库中和传入集合 ID 相同的数据行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Book&gt; newBooks = detachedBooks.stream()</span><br><span class="line">        .filter(b -&gt; !author.getBooks().contains(b))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他分离的实体</span></span><br><span class="line">detachedBooks.stream().filter(b -&gt; !newBooks.contains(b)).forEach((b) -&gt; &#123;</span><br><span class="line">        b.setAuthor(author);</span><br><span class="line">        Book mergedBook = bookRepository.save(b);</span><br><span class="line">        author.getBooks().set(author.getBooks().indexOf(mergedBook), mergedBook);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加传入集合新增的数据到数据库</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newBooks.forEach(b -&gt; author.addBook(b));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="在-parent-方使用-mappedby"><a class="markdownIt-Anchor" href="#在-parent-方使用-mappedby"></a> 在 Parent 方使用 <code>mappedBy</code></h2>
<p><code>mappedBy</code> 指向 Child 端的 <code>@ManyToOne</code> 对象字段的名称，它表示双向 <code>@OneToMany</code> 其实是数据库维护方 <code>@ManyToOne</code> 子端的镜像。</p>
<h2 id="在-parent-方使用-orphanremoval-以删除失去引用的-child"><a class="markdownIt-Anchor" href="#在-parent-方使用-orphanremoval-以删除失去引用的-child"></a> 在 Parent 方使用 <code>orphanRemoval</code> 以删除失去引用的 Child</h2>
<p><code>orphanRemoval</code> 表明如果将 Child 从 Parent 中移除，该 Child 将成为孤子，失去了 Parent 的引用，这时候将会被删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToMany(cascade = CascadeType.ALL, mappedBy = &quot;post&quot;, orphanRemoval = true)</span></span><br></pre></td></tr></table></figure>
<h2 id="在-parent-端使用工具方法保持两边关联同步"><a class="markdownIt-Anchor" href="#在-parent-端使用工具方法保持两边关联同步"></a> 在 Parent 端使用工具方法保持两边关联同步</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.books.add(book);</span><br><span class="line">    book.setAuthor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    book.setAuthor(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.books.remove(book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Book&gt; iterator = <span class="keyword">this</span>.books.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Book book = iterator.next();</span><br><span class="line"></span><br><span class="line">        book.setAuthor(<span class="keyword">null</span>);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止前端传过来的数据没有设置 Child 对 Parent 的关联，可以将 Setter 方法设置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(List&lt;Book&gt; books)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (books != <span class="keyword">null</span> &amp;&amp; !books.isEmpty()) &#123;</span><br><span class="line">        books.forEach(book -&gt; book.setAuthor(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.books = books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在关联的两边都使用懒加载"><a class="markdownIt-Anchor" href="#在关联的两边都使用懒加载"></a> 在关联的两边都使用懒加载</h2>
<p>Parent 端 <code>@OneToMany</code> 默认为懒加载，但是在 <code>@ManyToOne</code> 端使用懒加载可以获得比较好的性能，比如我们在获取 Parent 的 Childs 时可以防止 N+1 查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br></pre></td></tr></table></figure>
<h2 id="正确实现-equals-和-hashcode"><a class="markdownIt-Anchor" href="#正确实现-equals-和-hashcode"></a> 正确实现 <code>equals</code> 和 <code>hashcode</code></h2>
<p><code>equals</code> 和 <code>hashCode</code> 必须在所有<a target="_blank" rel="noopener" href="https://vladmihalcea.com/a-beginners-guide-to-jpa-hibernate-entity-state-transitions/">实体状态转换中</a>表现一致。所以不管是瞬时状态还是持久化状态，对象的比较总是一致的。</p>
<p>因此，我们需要通过标识符来去比较对象，标识符分两种类型：</p>
<ul>
<li>分配的标识符</li>
<li>数据库生成的标识符</li>
</ul>
<h3 id="分配的标识符"><a class="markdownIt-Anchor" href="#分配的标识符"></a> 分配的标识符</h3>
<p>在刷新 Persistence Context 之前分配分配的标识符，使用 <code>@NaturalId</code> 标识，我们可以进一步将它们分为两个子类别：</p>
<ul>
<li>
<p>自然标识符</p>
<p>比如 Book 的 ISBN。</p>
</li>
<li>
<p>与数据库无关的 UUID</p>
<p>与数据库无关的 UUID 编号是在数据库之外生成的，就像调用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html#randomUUID()"><code>java.util.UUID#randomUUID</code></a> 方法一样。</p>
</li>
</ul>
<p>自然标识符和与数据库无关的 UUID 都可以在实体被持久化前被知道。因此，在 <code>equals</code> 和 <code>hashCode</code> 实现中使用它们是安全的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Book&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Identifiable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@NaturalId</span></span><br><span class="line">    <span class="keyword">private</span> String isbn;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Book)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Book book = (Book) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(getIsbn(), book.getIsbn());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getIsbn());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库生成的标识符"><a class="markdownIt-Anchor" href="#数据库生成的标识符"></a> 数据库生成的标识符</h3>
<p>数据库生成的标识符是另一回事。因为标识符是在刷新时由数据库分配的，所以如果我们像分配标识符一样基于标识符实现 <code>equals</code> 和 <code>hashCode</code>，一致性保证就会中断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(name = &quot;Post&quot;)</span></span><br><span class="line"><span class="meta">@Table(name = &quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Post</span> <span class="keyword">implements</span> <span class="title">Identifiable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Post</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Post))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        Post other = (Post) o;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               id.equals(other.getId());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//Getters and setters omitted for brevity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正确重写-tostring"><a class="markdownIt-Anchor" href="#正确重写-tostring"></a> 正确重写 <code>toString</code></h2>
<p>如果 <code>toString()</code> 需要被覆盖，那么注意只涉及从数据库加载实体时获取的<strong>基本属性</strong>。</p>
<h2 id="移除大量-child-时使用批量操作"><a class="markdownIt-Anchor" href="#移除大量-child-时使用批量操作"></a> 移除大量 Child 时使用批量操作</h2>
<p>注意移除操作，尤其是移除子实体。 <code>CascadeType.REMOVE</code> 和 <code>orphanRemoval=true</code> 可能会产生过多的查询。在这种情况下，依赖批量操作在大多数情况下是删除的最佳方式。</p>
<h1 id="映射-manytomany-双向关联"><a class="markdownIt-Anchor" href="#映射-manytomany-双向关联"></a> 映射 @ManyToMany 双向关联</h1>
<p><img src="../../images/jpa/many-to-many.png" alt="image-005" /></p>
<h2 id="选择关系的所有者"><a class="markdownIt-Anchor" href="#选择关系的所有者"></a> 选择关系的所有者</h2>
<p>使用默认的 <code>@ManyToMany</code> 映射需要开发人员选择关系的所有者和 <code>mappedBy</code> 端（也称为反向端）。只有一侧可以是所有者，连接表在拥有方指定，并且更改仅从这一特定侧传播到数据库，则非拥有方必须使用 <code>@ManyToMany</code> 注释的 <code>mappedBy</code> 元素来指定拥有方的关系字段或属性。例如，<code>Author</code>  可以是所有者，而 <code>Book</code> 端添加了 <code>mappingBy</code> 指定拥有方 <code>Author</code> 的 <code>books</code> 字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(mappedBy = &quot;books&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;Author&gt; authors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="总是使用-set-而不是-list"><a class="markdownIt-Anchor" href="#总是使用-set-而不是-list"></a> 总是使用 Set 而不是 List</h2>
<p>特别是如果涉及删除操作，建议依赖于 Set 而不是 List，因为 Set 的性能高于 List。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Set&lt;Book&gt; books = <span class="keyword">new</span> HashSet&lt;&gt;();     <span class="comment">// in Author </span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Author&gt; authors = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// in Book</span></span><br></pre></td></tr></table></figure>
<p>Hibernate 将 @ManyToMany 操作当作两个单向的 @OneToMany 操作处理，在此语句的上下文中，实体删除（或重新排序）导致从结表中删除所有关联条目，并重新插入它们以对照内存内容（当前持久性上下文内容）。</p>
<p>如果是 Set 集合的话只会删除单个条目，因为它不保证顺序。</p>
<p>要保留顺序可以使用 <code>@OrderBy</code> 语句，例如使用多个字段排序 ：<code>@OrderBy(&quot;age DESC, name ASC&quot;)</code>。</p>
<h2 id="保持两边关联同步"><a class="markdownIt-Anchor" href="#保持两边关联同步"></a> 保持两边关联同步</h2>
<p>同样，我们可以使用之前提及的 <code>addBook</code>、<code>removeBook</code>、<code>removeBooks</code>、<code>setBooks</code> 工具方法保持两边同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.books.add(book);</span><br><span class="line">    book.getAuthors().add(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.books.remove(book);</span><br><span class="line">    book.getAuthors().remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBooks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Book&gt; iterator = <span class="keyword">this</span>.books.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Book book = iterator.next();</span><br><span class="line"></span><br><span class="line">        book.getAuthors().remove(<span class="keyword">this</span>);</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBooks</span><span class="params">(Set&lt;Book&gt; books)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(books)) &#123;</span><br><span class="line">        books.forEach(book -&gt; book.getAuthors().add(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.books = books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免-cascadetypeall-和-cascadetyperemove"><a class="markdownIt-Anchor" href="#避免-cascadetypeall-和-cascadetyperemove"></a> 避免 CascadeType.ALL 和 CascadeType.REMOVE</h2>
<p>在大多数情况下，级联删除是糟糕的想法。 例如，删除 <code>Author</code> 实体不应触发 <code>Book</code> 删除，因为这本书也可以由其他作者引用（一本书可以由几位作者编写）。所以，避免 <code>CascadeType.ALL</code> 和 <code>CascadeType.REMOVE</code> 并依赖于显式 <code>CascadeType.PERSIST</code> 和 <code>CascadeType.MERGE</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;Book&gt; books = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>对于<strong>新增操作</strong>。这里分两种情况：</p>
<ol>
<li>
<p>如果 Parent 和 Child 的都是瞬时状态的数据使用级联新增（<code>CascadeType.PERSIST</code>）则没有问题，比如下面的数据：</p>
<ol>
<li></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alicia Tom&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">38</span>,</span><br><span class="line">  <span class="attr">&quot;genre&quot;</span>: <span class="string">&quot;Anthology&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;books&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;003-OG&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;Zeral&#x27;s Life&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;isbn&quot;</span>: <span class="string">&quot;004-MJ&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;A People&#x27;s Life&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 persist 会执行如下语句，级联新增会帮我们新增 Author 和两个 Book 及其关联。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author (age, genre, name) <span class="keyword">values</span> (?, ?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (isbn, title) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (isbn, title) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果我们的 Book 已存在，我们想在新增 Author 时让它帮我们绑定关系，使用级联新增会因为有分离的对象而报错，这时则可以<strong>只使用</strong> <code>CascadeType.MERGE</code> 来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManyToMany(cascade = &#123;CascadeType.MERGE&#125;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;Book&gt; books = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>执行 <strong>persist</strong> 会执行如下语句，级联修改会帮我们新增 Author 和两个 Book 的关联。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author (age, genre, name) <span class="keyword">values</span> (?, ?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> author_book (author_id, book_id) <span class="keyword">values</span> (?, ?)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>对于<strong>修改操作</strong>：</p>
<p>对于 Parent 字段的修改和之前描述的一样，多对多的关系我们一般只修改关联，无需额外的设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">authorRepository.findById(detachedAuthor.getId()).ifPresent(author -&gt; &#123;</span><br><span class="line">    <span class="comment">// 修改 Parent 字段</span></span><br><span class="line">    author.setName(detachedAuthor.getName());</span><br><span class="line">    author.setAge(detachedAuthor.getAge());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只同步关系，不去新增修改 Book 的信息，这里传入的分离的 books 只包含 Id</span></span><br><span class="line">    author.setBooks(detachedAuthor.getBooks());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置关联表"><a class="markdownIt-Anchor" href="#设置关联表"></a> 设置关联表</h2>
<p>显式设置关联表名称和列名称允许开发人员在引用它们时避免混淆。 这可以通过 <code>@JoinTable</code> 完成，如下例所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JoinTable(name = &quot;author_book&quot;,           </span></span><br><span class="line"><span class="meta">					joinColumns = @JoinColumn(name = &quot;author_id&quot;),           </span></span><br><span class="line"><span class="meta">					inverseJoinColumns = @JoinColumn(name = &quot;book_id&quot;) </span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>
<h2 id="在关联两边都使用懒加载"><a class="markdownIt-Anchor" href="#在关联两边都使用懒加载"></a> 在关联两边都使用懒加载</h2>
<p>默认情况下，@ManyToMany 关联是惰性加载的，不要给他使用立即加载。</p>
<h2 id="正确实现-equals-和-hashcode-2"><a class="markdownIt-Anchor" href="#正确实现-equals-和-hashcode-2"></a> 正确实现 <code>equals</code> 和 <code>hashcode</code></h2>
<p>如上所述</p>
<h2 id="正确重写-tostring-2"><a class="markdownIt-Anchor" href="#正确重写-tostring-2"></a> 正确重写 <code>toString</code></h2>
<p>如上所述</p>
<h2 id="需要时使用两个双向的-onetomany"><a class="markdownIt-Anchor" href="#需要时使用两个双向的-onetomany"></a> 需要时使用两个双向的 @OneToMany</h2>
<p>如果双向 <code>@OneToMany</code> 关联在删除或更改子元素的顺序时表现更好，或者需要直接操作关联表，则没必要使用 <code>@ManyToMany</code> 关系，因为外键端不受控制。为了克服这个限制，必须直接公开关联表并将 <code>@ManyToMany</code> 关联拆分为两个双向的 <code>@OneToMany</code> 关系。</p>
<p>最自然的 <code>@ManyToMany</code> 关联遵循数据库模式采用的相同逻辑，并且关联表的关联实体控制需要联接的双方的关系。</p>
<p>在这里 Author 和 Book 都使用 @OneToMany mappedBy 到关系维护方中间表 AuthorBook，AuthorBook 使用 Author_Id 和 Book_Id 作为联合主键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String genre;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">            mappedBy = &quot;author&quot;,</span></span><br><span class="line"><span class="meta">            cascade = CascadeType.ALL,</span></span><br><span class="line"><span class="meta">            orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AuthorBook&gt; books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了简洁期间省略 Getter 和 Setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        AuthorBook AuthorBook = <span class="keyword">new</span> AuthorBook( <span class="keyword">this</span>, book );</span><br><span class="line">        books.add( AuthorBook );</span><br><span class="line">        book.getAuthors().add( AuthorBook );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        AuthorBook AuthorBook = <span class="keyword">new</span> AuthorBook( <span class="keyword">this</span>, book );</span><br><span class="line">        book.getAuthors().remove( AuthorBook );</span><br><span class="line">        books.remove( AuthorBook );</span><br><span class="line">        AuthorBook.setAuthor( <span class="keyword">null</span> );</span><br><span class="line">        AuthorBook.setBook( <span class="keyword">null</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;     </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> &amp;&amp; id.equals(((Author) obj).id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2021</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Author&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name</span><br><span class="line">                + <span class="string">&quot;, genre=&quot;</span> + genre + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorBook</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@ManyToOne</span></span><br><span class="line">	<span class="keyword">private</span> Author author;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@ManyToOne</span></span><br><span class="line">	<span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了简洁期间省略 Getter 和 Setter</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="keyword">this</span> == o ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( o == <span class="keyword">null</span> || getClass() != o.getClass() ) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		AuthorBook that = (AuthorBook) o;</span><br><span class="line">		<span class="keyword">return</span> Objects.equals(author, that.author) &amp;&amp;</span><br><span class="line">				Objects.equals(book, that.book);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Objects.hash(author, book);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JPA 不允许使用多个 Id 注解，可以使用组合 Id：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorBookId</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Column(name = &quot;author_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long authorId;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Column(name = &quot;book_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bookId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorBookId</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorBookId</span><span class="params">(Long authorId, Long bookId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorId = authorId;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了简洁省略 getter、setter、hashcode、equals...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorBook</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@EmbeddedId</span></span><br><span class="line">    <span class="keyword">private</span> AuthorBookId id;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@MapsId(&quot;authorId&quot;)</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Author author;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@MapsId(&quot;bookId&quot;)</span></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span></span><br><span class="line">    <span class="keyword">private</span> Book book;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorBook</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorBook</span><span class="params">(Author author, Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">        <span class="keyword">this</span>.book = book;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="keyword">new</span> AuthorBookId(author.getId(), book.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了简洁省略 getter、setter、hashcode、equals...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String isbn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany(</span></span><br><span class="line"><span class="meta">            mappedBy = &quot;book&quot;,</span></span><br><span class="line"><span class="meta">            cascade = CascadeType.ALL,</span></span><br><span class="line"><span class="meta">            orphanRemoval = true</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;AuthorBook&gt; authors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了简洁期间省略 Getter 和 Setter</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> id != <span class="keyword">null</span> &amp;&amp; id.equals(((Book) obj).id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2021</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> + <span class="string">&quot;id=&quot;</span> + id + <span class="string">&quot;, title=&quot;</span> + title + <span class="string">&quot;, isbn=&quot;</span> + isbn + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>ManyToMany</tag>
        <tag>OneToMany</tag>
      </tags>
  </entry>
</search>
